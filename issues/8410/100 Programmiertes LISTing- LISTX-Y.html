<!DOCTYPE html>
<html lang="de">

<head>
    <title>Programmiertes LISTing: LISTX-Y</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="XXX">
    <meta name="64er.issue" content="10/84">
    <meta name="64er.pages" content="999">
    <meta name="64er.toc_category" content="Programme zum Abtippen|Tips & Tricks">
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>Programmiertes LISTing: LISTX-Y</h1>

        <p>Bei Hilfsprogrammen, die viele Benutzeranleitungen enthalten, gibt man diese Anleitungen normalerweise über PRINT-Anweisungen auf dem Bildschirm aus. An sich würde es bei geschickter Formulierung jedoch reichen, die sowieso vorhandenen REM-Erläuterungen als Anleitungen für den Benutzer mitzuverwenden.</p>

        <p>Nur, wie bringt man diese auf den Bildschirm? Mit LIST wird das Basic-Programm jedesmal zum Direktmodus hin verlassen und, was noch schwerer wiegt, die Anfangs- und Endzeilennummern können nur als direkte Zahlen, nicht über Variablen, angegeben werden. Unser Programmvorschlag (Listing 1) simuliert den im VC 20-Basic nicht vorhandenen Befehl LISTX-Y (X=Variable, die die Anfangszeilennummer des zu listenden Programms übergibt, Y = Endzeilennummer).</p>

        <p>Man könnte sich ein solches Hilfsprogramm durch Beschreiben des Tastaturpuffers konstruieren. Dann würden sich aber die in den Puffer geschriebenen LIST-Anweisungen auf dem Bildschirm störend bemerkbar machen. Andererseits kommt aus Geschwindigkeitsgründen nur ein Maschinenprogramm in Frage. Will man ein solches Maschinenprogramm per DATA-Zeilen einlesbar gestalten, wäre der Aufwand recht hoch. Außerdem gäbe es Schwierigkeiten mit dem nur immer auf den Datenanfang zurückstellbaren DATA-Zeiger (kein RESTORE X vorhanden). Einlesen per POKE wäre noch aufwendiger. Umgekehrt muß aber ein solches Maschinenprogramm zur Simulation von LIST Y notwendigerweise viele Teile enthalten, die bereits im Betriebssystem vorkommen. Wir lösen das Problem, indem wir mit zwei einfachen FOR-NEXT-Schleifen geeignete Teile des Betriebssystems in den Kassettenpuffer kopieren und diese Kopien dann durch sechs POKE-Anweisungen so abändern, daß sie unseren Ansprüchen genügen. Listing 1 zeigt das entsprechende Unterprogramm, das beim ersten Aufruf mit »GOSUB 63000« die Maschinenroutine erzeugt. Alle weiteren Aufrufe können mit »GOSUB 6350« erfolgen, wodurch, einiges an Zeit gespart wird. In der Variablen X wird die Anfangszeile, in Y die Endzeile übergeben. Listing 3 zeigt ein Demo-Programm. In Listing 2 gebe wir ein Anwendungsbeispiel an: In einem längeren Programm mögen alle REM-Erläuterungen in den Zeilen 100<em>a bis 100</em>a+4 untergebracht sein, also in den ersten fünf Zeilen ab jeder vollen Hunderternummer. Das Beispielprogramm nach Listing 2 wird per GOSUB63100 angesprungen und listet per Cursor-Down-Taste alle oben genannten REM-Zeilen (und nur diese, eventuelle weitere REM-Zeilen werden nicht berücksichtigt). Und zwar geschieht dies in Endlosform, das heißt nach Durchgang durch die letzte zu listende REM-Erläuterung erscheint wieder die erste und so fort. Durch Drücken der Return-Taste gelangt man wieder ins Hauptprogramm.</p>

        <address class="author">(Fred Behringer/ev)</address>

    </article>

</body>

</html>
