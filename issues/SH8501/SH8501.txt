# Warum ein Sonderheft?

Mit diesem Sonderheft für Tips & Tricks-Listings wollen wir dem Anwender des Commodore 64 und des VC 20 Programme in die Hand (im wahrsten Sinne des Wortes) geben, die ihm in der täglichen Arbeit mit dem Computer sicherlich bald unentbehrlich sein werden. Beim Abtippen kann praktisch kein Fehler mehr passieren, denn jede Zeile wird nach der Eingabe automatisch geprüft.

Die Frage, die sich so mancher Leser stellen wird, nämlich wozu dieses Sonderheft für Tips & Tricks-Listings dienen soll, läßt sich relativ einfach beantworten. All diese Programme wären sicherlich irgendwann einmal im 64’er Magazin für Commodore-Fans erschienen. Doch »leider« erscheint das 64’er nur jeden Monat einmal, und der Platz für Listings ist beschränkt. Es wäre also eine nicht unerhebliche Zeit verstrichen, bis alle Programme, die hier in kompakter und zu einem Thema gehörender Form zusammengefaßt sind, für Sie zum Abtippen und Anwenden bereitgestanden hätten. Also eine Energieleistung vollbracht und ein Sonderheft gemacht.

Die 64’er-Redaktion wäre aber nicht selbige, wenn dabei nicht irgendeine Neuerung oder Verbesserung herausspringen würde. So sind alle Listings in diesem Sonderheft mit einer zeilenweisen Prüfsumme versehen. Tippen Sie also zuallererst den Checksummer ein, und speichern Sie ihn ab. Nach dem Wiedereinladen und Initialisieren können Sie das von Ihnen gewünschte Listing eintippen, und zwar ohne Fehler. Sollten Sie in einer Zeile ein verkehrtes Zeichen eingegeben haben, so macht Sie der Checksummer sofort darauf aufmerksam. Die Fehlersuche durch das gesamte Programm können Sie also in Zukunft vergessen.

Aber auch die oft schwierig zu entziffernden Grafik- und Steuerzeichen wurden durch lesbare alphanumerische ersetzt. Also keine langwierige Suche mehr auf der Frontseite der Tastenkappen und Entscheidungsqualen, ob nun dicker oder halbdicker vertikaler Strich, kein nervenzermürbendes Nachschlagen in Tabellen, welches nun das Steuerzeichen für die Funktionstaste F7 ist — alles wird in Klartext ausgeben. Die genauen Spezifikationen zur Umsetzung der Grafik- und Steuerzeichen lesen Sie bitte in dem entsprechenden Artikel nach. Den Checksummer gibt es sowohl in einer Version für den C 64 als auch für den VC 20. Sicherlich, diese Methode des sicheren Eintippens ist nicht unsere Erfindung. Amerikanische Zeitschriften praktizieren sie seit einiger Zeit, doch dieses Programm ist eine Eigenentwicklung, und wir fordern Sie auf, Vergleiche anzustellen, es ist der besten eines.

### Kommen weitere Sonderhefte?

Es wird nicht bei dieser einen Aktion bleiben, soviel können wir Ihnen versprechen. Inder 64’er-Redaktion gehen täglich dutzende von Listings ein, für deren »Verwertung« in der Stammzeitschrift einfach nicht genug Platz vorhanden ist. Die genauen Erscheinungstermine liegen noch nicht fest, doch Sie können gespannt sein, was für Sonderhefte demnächst — in noch unregelmäßigen Abständen — erscheinen werden.

In unserem ersten Sonderheft sind 28 durchweg nützliche Programme enthalten. Es würde einige Zeit in Anspruch nehmen, alle selber einzutippen. Deshalb, wie auch in der 64’er Stammzeitschrift üblich, der Diskettenservice.

### Disketten-Service

Programme, die sich auf die Floppy beziehen, also Dateiorganisation, Disksorter, ESF, Track 18, Diskettenmeister und Fileprotect, sind auf der Diskette CB 023 (Floppy-Utilities) für 29,90 Mark erhältlich.

Alle anderen auf der Diskette CB 024 (Hilfsprogramme) ebenfalls für 29,90 Mark.

Alle Listings wurden von den lauffähigen Versionen der Programme erstellt. Für das fehlerfreie Eintippen haben wir gesorgt. Dennoch kann es vorkommen, daß in einem Programm nach intensivem Ausnützen aller Funktionen und Möglichkeiten in dem einem oder anderen Teil ein logischer Denkfehler auftaucht Für Hinweise die zur Ergreifung der Täter (Fehler) führen, ist zwar keine Belohnung ausgesetzt, aber sie werden im nächsten Sonderheft oder im 64’er veröffentlicht. Ebenso dankbar ist die Redaktion für Verbesserungs- und Ergänzungsvorschläge zu den einzelnen Listings wie zur gesamten Aufmachung des Sonderheftes.

Sollten Sie zu bestimmten Bereichen bessere Programme als die hier veröffentlichten geschrieben haben, so scheuen Sie sich nicht uns dies wissen zu lassen. Das nächste Sonderheft kommt bestimmt. Es gelten dieselben Einsendekriterien wie für das 64’er-Stammheft.

(aa)


# Checksummer — keine Fehler mehr beim Abtippen von Listings

> Das Programm Checksummer 64 ist für all die Leute gedacht, die sich manchmal vor Verzweifelung »die Haare raufen« könnten. Da sitzt man mehrere Stunden, um ein gutes Programm aus dem 64’er Magazin abzutippen, und dann: ein Fehler in der DATA-Zeile oder ein falscher Buchstabe... und schon geht die Fehlersuche los. Hier soll der Checksummer 64 weiterhelfen.

Der Checksummer 64 ist ein kleines Maschinenprogramm, das, wenn es aktiviert ist, Sie sofort davon unterrichtet, ob Sie die jeweilige Programmzeile korrekt eingegeben haben.

1.	Tippen Sie den Basic-Lader sorgfältig ein. Es gibt zwei Versionen: eine für den Commodore 64 und eine für den VC 20.
2.	Bevor Sie »RUN« eingeben, speichern Sie den Basic-Lader bitte erst ab, denn wenn Sie zum Beispiel einen Fehler bei den eingetippten POKE-Anweisungen gemacht haben, ist es möglich, daß der Rechner aussteigt. Heben Sie sich den abgespeicherten Checksummer 64 auf — Sie werden ihn immer wieder brauchen, wenn Sie ein Basic-Programm aus dem 64’er Sonderheft oder in Zukunft aus dem 64’er Magazin eintippen wollen.
3.	Der Checksummer 64 überprüft sich selbst. Wenn Sie einen Fehler in den DATAs gemacht haben, listen Sie die fehlerhafte Zeile einfach, korrigieren sie und starten dann das Programm neu.
4.	Nach Initialisierung des Maschinenprogramms ist der Checksummer 64 aktiviert. Er steht innerhalb des Betriebssystems und verbraucht kein einziges Byte Speicherplatz. Es sei hier für Interessierte gesagt, daß selbst alle Sprungvektoren unverändert bleiben, das Programm also mit einer Vielzahl von anderen Programmier-Spracherweiterungen wie etwa Ex-basic Level II problemlos zusammenarbeitet. Achten Sie aber darauf, daß bestimmte Spracherweiterungen das hinter dem ROM liegende RAM für Hires-Grafiken benutzen. Wird zum Beispiel eine Hires-Grafik von Simons Basic aus angesprochen, so wird der Checksummer 64 zerstört.
5.	Wenn Sie den Checksummer 64 zwischenzeitlich nicht benutzen, können Sie ihn jederzeit mit »POKE 1, 55« desaktivieren. Auch durch Drücken der Run-Stop- und der Restore-Taste wird der Checksummer 64 desaktiviert. Wollen Sie, daß der Checksummer 64 auch noch nach Drücken dieser Tastenkombination erhalten bleibt, so geben Sie bei aktiviertem Checksummer 64 »POKE64982, 53« ein. Der Checksummer 64 ist dann nur durch »POKE 1, 55« abschaltbar.
Wollen Sie den Checksummer 64 wieder einschalten, so geben Sie bitte »POKE 1, 53« ein.
Das Maschinenprogramm bleibt solange erhalten, bis der Computer ausgeschaltet, oder wenn von anderen Programmen auf das hinter dem ROM liegende RAM zugegriffen wird.
6. Eine Checksumme wird nur dann ausgegeben, wenn der Commodore 64 (VC 20) eindeutig erkennt, daß Sie eine Zeile bestehend aus der Zeilennummer und zumindestens einem alphanumerischen Zeichen eigegeben haben. Ansonsten reagiert der Commodore 64 normal.

**Hinweis**: Wenn Sie bei aktiviertem Checksummer 64 ein Programm mit »LOAD« in den Speicher holen, wird auch eine Checksumme ausgegeben. Dies liegt jedoch an rechnerinternen Routinen und hat keine weitere Bedeutung, stellt insbesondere keine Gefahr für das geladene Programm dar, da alle Pointer richtig gesetzt werden.

Nach Eingabe von RUN wird zunächst einmal das ROM in das RAM des Commodore 64 verschoben, wonach der Basic-Interpreter modifiziert wird. Dadurch hat man den Vorteil, trotz einer zusätzlichen Routine das gesamte RAM des Rechners zur Verfügung zu haben. Nach ordnungsgemässem Ablauf des Programms können Sie sofort mit Eingaben beginnen. Für Maschinensprache-Spezialisten weise ich darauf hin, daß ich ausnutze, daß die Einschaltmeldungen des Rechners nur nach einem Reset generiert wird. Der Textbereich, in dem die Meldung steht, wird von dem erzeugten Maschinenprogramm überschrieben.

Alle veröffentlichten Listings sind mit einer Checksumme versehen, die am Ende jeder Programmzeile steht. Diese Checksumme steht zwischen &lt; und &gt;. Sie wird beim Eintippen des Programms nicht mit eingegeben. Die Zahl zwischen den beiden Zeichen stellt lediglich eine Information für Sie dar. Wenn Sie diese Checksumme dennoch mit eintippen, werden Sie schnell bemerken, daß Sie etwas falsch gemacht haben. Bei aktiviertem Checksummer 64 wird nämlich nach Eingabe einer Basic-Zeile, die mit Return beendet wird, in die linke obere Bildschirmecke die Checksumme eingeblendet, die mit der Summe aus dem veröffentlichten Listing übereinstimmen muß. Ist das nicht der Fall, haben Sie die Zeile anders eingegeben, als sie im Listing dargestellt ist. Vergessen Sie also bitte nicht, daß die am Ende einer Zeilein &lt; und &gt; stehendePrüfsumme nicht mit eingegeben werden darf.

Der Checksummer 64 ist so ausgelegt, daß er abhängig von der Zeilennummer und dem Text der Zeile eine Checksumme ausgibt. Beim Bilden dieser Checksumme werden Spaces (Leertaste) überlesen, was für Sie bedeutet, das es egal ist, wieviel Leerzeichen Sie zwischen den Worten lassen, da Sie für den Programmablauf ohnehin keine Bedeutung haben. Aber manchmal ist das richtige Setzen von Leerzeichen doch wichtig, besonders innerhalb von Strings (Zeichenketten), die gedruckt werden sollen. Seien Sie deshalb besonders genau bei Leerzeichen, die innerhalb von Anführungszeichen stehen, denn meistens ermöglichen nur die richtig gesetzten Spaces eine sinnvolle Textausgabe auf dem Bildschirm.

Beachten Sie auch, daß es durchaus erlaubt ist, Abkürzungen für die Commodore-Befehlswörter zu verwenden. So führt die Eingabe von » ? « als Kurzschreibweise für »PRINT« nicht etwa zu einem Checksummen-Fehler, sondern wird korrekt verarbeitet und dementsprechend die Checksumme generiert. Nachdem Sie ein Listing eingegeben haben, sollten Sie es aus Sicherheitsgründen vor dem Starten abspeichern. Sie brauchen hierfür jedoch nicht den Checksummer 64 zu desaktivieren.

### Hinweise zum Lesen von Listings

Die Listings haben sich ein wenig im Ausdruckformat verändert, um Ihnen das Eingeben von Programmen wesentlich zu erleichtern.

— Cursorsteuerzeichen und andere Steuerzeichen, die schwer zu lesen sind, werden von nun an in Klartext in speziellen Klammern gesetzt.
Tritt mehrmals hintereinander dasselbe Steuerzeichen auf, so wird diese Steuerzeichen-Sequenz zusammengefasst, indem zuerst das Steuerzeichen und dann die Anzahl der Wiederholungen dieses Steuerzeichens in Klartext ausgegeben wird.
— alle Commodore-Grafikzeichen, die über Shift zu erreichen sind, werden nicht mehr als Grafikzeichen, sondern als Klartextzeichen dargestellt. Dabei wird aus dem Zeichen, das Sie auf dem Bildschirm sehen, wenn Sie die Tastenkombination Shift und »A« ansprechen, wieder ein »A«. Um dieses »A« vom normalen »A« unterscheiden zu können, ist es etwas kleiner als das gewöhnliche »A« und ist außerdem mit einem Unterstreichungszeichen versehen. Diese Vereinbarung gilt auch für sämtliche andere Commodore-Grafikzeichen, die über Shift zu erreichen sind.
— entsprechendes gilt für sämtliche Commodore-Grafikzeichen, die über die Commodore-Taste zu erreichen sind. Hier wird jedoch das jeweilige Klartextzeichen nicht unterstrichen, sondern überstrichen.

## Erläuterungen zu den Cursorsteuerzeichen

Cursorsteuerzeichen werden, wie schon oben erwähnt, umdefiniert. Sie sehen hier eine Liste der möglichen Ausdrücke, die für ein Cursorsteuerzeichen im Listing auftauchen können. Gleichzeitig ersehen Sie aus der Tabelle, welche Taste beziehungsweise Tastenkombination zu drücken ist, damit dieses Steuerzeichen richtig in Ihr Programm übernommen wird. Beachten Sie, daß Sie die Steuercodes nur dann als reverses Zeichen sehen können, wenn der Rechner im »Quote-Modus« arbeitet, das heißt er sich im Gänsefüßchenmodus befindet.

## Checksummer VC 20

Der Checksummer VC 20 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremässig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.

In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC 20:

— da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.
— angeschaltet wird der Checksummer VC 20 mit »SYS 955«
— Abschaltung des Checksummer VC 20 wird mit »SYS 58459« vollzogen

ACHTUNG: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist. Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Rechner bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen.Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).

Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Rechner »aussteigt«.

Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeit aufheben, wenn man den Checksummer VC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht. Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop & Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.

— Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 20 feststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.
— bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.
— wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 63999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.

Viel Spaß beim Eintippen von Programmen mit dem neuen Checksummer!

(F. Lonczewski / gk)


# M-P-S: Multi-Programm-System – Mehr als 30 Programme gleichzeitig im Speicher

> Wer hat nicht schon den Wunsch verspürt, mehr als ein Programm gleichzeitig im Speicher zu haben. M-P-S erlaubt sogar bis zu 32 verschiedene Basic-Programme. Dafür stehen 42 KByte(!) freier Basic-Speicher zur Verfügung. Jedes Programm kann unabhängig von einem anderen aufgerufen und gestartet werden. Zu jeder Zeit behalten Sie den Überblick über die im Computer stehenden Programme. Auch Directories lassen sich permanent im Speicher halten. Eine tolle Sache.

M-P-S bietet die Möglichkeit, mehr als nur ein Basic-Programm im Speicher zu halten. Vorgesehen ist eine Verwaltung von maximal 32 Basic-Programmen, wobei die Anzahl der tatsächlich speicherbaren Programme aber auch von deren Umfang abhängt. Jedes Programm erhält eine Kennummer, die zusammen mit den Programmnamen, Anfangs- und Endadresse in einem Inhaltsverzeichnis abgelegt wird. Durch die Eingabe der Kennummer kann dann jedes einzelne Basic-Programm aufgerufen werden. Für die Basic-Programme stehen etwa 42-KByte zur Verfügung. Dies wurde dadurch erreicht, daß Tabellen und Programmspeicher teilweise in den RAM-Bereich unter dem ROM gelegt wurde.

Um die Länge von M-P-S in Grenzen zu halten, wurde die Länge der Befehlswörter auf drei Buchstaben begrenzt.

Die Befehle:
1.	OFF
2.	STO(Store)
3.	REC(Recall)
4.	DSP (Display)
5.	SPA (Space)
6.	DEL(Delete)

1. OFF
OFF bewirkt ein Abschalten von M-P-S. Möchte man anschließend M-P-S wieder aktivieren, so gibt es zwei Möglichkeiten:

a)	Die Eingabe von 8Y8 51200 bewirkt einen Kaltstart Alle Pointer werden neu gesetzt Das Inhaltsverzeichnis wird gelöscht
b)	Die Eingabe von 8YS 51297 bewirkt einen Warmstart Inhaltsverzeichnis und Pointer bleiben erhalten.

2.	STO"Programmname",X
Mit STO wird ein Basic-Programm in einen bestimmten RAM-Bereich abgespeichert (verschoben). Der Programmname darf maximal 16 Zeichen lang sein. X ist eine Zahl zwischen 0 und 31. Sie dient als Trennmarke für die einzelnen Programme. Am besten fängt man bei 0 an und erhöht X mitjedem weiteren Programm um 1.
Beispiel:
STO"Test T",0
STO"Test 2",1
STO"Test 3",2

3.	RECN
Mit REC kann ein abgespeichertes Programm aufgerufen werden. N ist hierbei die Kennummer (siehe 4. DSP). Anschließend kann man LIST oder RUN eingeben.
Beispiel:
REC0
REC1
REC2

4.	DSP
DSP gibt das Inhaltsverzeichnis der im Speicher stehenden Programme auf dem Bildschirm aus. Dabei erscheinen Kennnummer, Programmname und belegter Speicherbereich.
Beispiel:
0. »Test 1« $C7FF-$C600
Kennummer Name Anfangs- Endadresse adresse+1 TODO

5.	SPA
SPA gibt die Anfangs(immer $0801)- und Endadresse des gerade lauffähigen Basicgrogramms, sowie dessen Länge in Bytes an. Man kann so feststellen, ob das Programm noch verschoben werden kann.
Beispiel (nach NEW):
SPA
$0801-$0803/3Bytes

6.	DEL
DEL löscht das Inhaltsverzeichnis und setzt die Pointer neu. Solange man mit STO keine neuen Programme eingibt, kann man die alten noch mit REC aufrufen.

Hinweise:
Folgendes sollte bei der Benutzung von M-P-S beachtet werden:

1.	Die Basic-Programme, die abgespeichert und später auch gestartet werden sollen, dürfen keine Maschinenprogramme enthalten. Ansonsten besteht die Möglichkeit, daß das Programm M-P-S selbst, Tabellen oder Basic-Programme überschrieben werden und so nicht mehr lesbar sind.
2.	Bei REC dürfen nur tatsächlich vorhandene Kennummern eingegeben werden. Gibt man Nummern ein, zu denen kein Programm vorhanden ist, so führt dies meist zum Systemabsturz.

Adressenbelegung:
M-P-S belegt: $C800-$CC8F (1167 Bytes)
Befehl
OFF:$C8F1-$C8FD
SPA:$C930-$C97E
STO:$C97F-$CA77
DSP:$CA78-$CB4D
REC:$CB4E-$CBDD
DEL:$CC24-$CC5C
Arbeitsspeicher und Pointer:$CC90-$CC99
Speicher für Programmnamen ab:$F000
Tabelle der Anfangs- und Endadressen ab:$F800
Speicher für Basic-Programme ab:$C7FF (abnehmend)

(Kasem Mossavi / gk)


# Dateiorganisation

> Dieses Programm ist eine echte Hilfe für den C64-Benutzer, der sich einmal etwas näher mit der internen Dateiorganisation des 1541-Laufwerks beschäftigen möchte.

Die Idee zu diesem Programm kam mir, als ich nach einem »SCRATCH«-Befehl mit Bedauern feststellen mußte, ein in mühevoller Arbeit erstelltes Programm versehentlich mitgelöscht zu haben. Doch glücklicherweise hatte ich kurz zuvor erfahren, wie man ein gelöschtes File auf der 1541-Floppy regeneriert:

Filetyp im Directoryeintrag im Direktzugriff wieder setzen und anschließend ein »VALIDATE« ausführen.

Es begann also die Suche nach besagtem Byte, sowie die intensive Erkundung der Dateiorganisation und des Direktzugriffs.

Nun, nach mehreren Monaten Arbeit liegt endlich das fertige Programm vor. Es druckt eine Vielzahl von Floppy-Informationen auf einem Epson-Drucker aus. Auf eine Bildschirmausgabe wurde aus Gründen der Übersichtlichkeit verzichtet.

## Was bietet das Programm

**Ganze Dateien aufzeigen:**
Hierbei fragt das Programm nach dem gewünschten Filenamen. Bei korrekter Eingabe werden folgende Informationen ausgedruckt: Filename, Filetyp, Filelänge in Blocks, Spur, Sektor, laufende Blocknummer und natürlich der Inhalt sämtlicher von dieser Datei belegten Blöcke in ASCII-Codes und -Zeichen (je 8 Byte). Eine Seite wird mit genau 2 Blocks beschrieben, dann erfolgt automatisch ein Seitenvorschub. Bei ungerader Blockanzahl kann ein Seitenvorschub auch vom Benutzer ausgelöst werden. Bei Dateiende springt das Programm wieder ins Menü zurück.

**Einzelne Blöcke ausgeben:**
Dieser Modus unterscheidet sich vom vorigen dadurch, daß hier bestimmte Sektoren ausgewählt werden können. Und dies auf zwei verschiedene Arten:

1.	Eingabe von Spur und Sektor:
Geben Sie, durch Komma getrennt, Spur- und Sektornummer des auszudruckenden Blocks ein;
2.	Eingabe von Filename und Blocknummer: Das Programm liest aus der Directory, wieviele Blocks das angegebene File belegt und zeigt dies am Bildschirm an. Nun können Sie wählen, welchen dieser Blöcke Sie sehen möchten.

**Bytereihen ausdrucken:**

Mit diesem Menüpunkt können Sie gezielt bestimmte Bytes einer Datei oder eines Sektors herauspicken. Die Form der Eingabe von Parametern ist identisch mit der des Teilprogrammes »Einzelne Blöcke ausgeben«. Zusätzlich müssen Sie das erste und letzte auszudruckende Byte eines Sektors festlegen (0-255). Das erste Byte kann auch zugleich das letzte sein, was die Ausgabe nur eines Wertes bewirkt.

**Blockbelegung von Files:**

Von einer Datei belegte Sektoren werden ihrer Reihenfolge entsprechend, im Format: laufende Blocknummer, Spur/8ek-tor, ausgegeben. Auch eine Routine zur Berechnung der tatsächlichen Filelänge in Bytes ist in dieses Teilprogramm integriert. Das zweite Byte des letzten Blockes gibt die Anzahl der von der Datei in diesem Block benötigten Bytes an. Daraus ergibt sich folgende Formel für die Filelänge: (Gesamtzahl belegter Blocks — 1) * 254 + 2. Byte letzter Block.

Einschränkung für relative Dateien: Spur und Sektor von Side-Sektor-Blöcken werden nicht angezeigt. An ihrer Stelle erscheint das Kürzel »SSB«, so daß man wenigstens weiß, wieviel SSB das DOS zur Verwaltung der Datei benötigt.

**Directory:**
Dieser Befehl bringt Ihnen eine erweiterte und vor allem übersichtlichere Directory Ihrer Disketten zu Papier. Selbstverständlich ohne das Programm zu zerstören. Sie enthält Informationen über:

— Diskettenname und ID
— Nummer des Eintrages
— Filename
— Filelänge in Blocks
— Filelänge in Bytes = (Filelänge in Blocks — 1) * 254 + 127)

Es wird davon ausgegangen, daß der letzte Block zur Hälfte belegt ist. Die Angabe weicht also um maximal 126Bytes von der tatsächlichen Länge ab.

— 1. Datenblock des Files
— Filetyp
— Freie Einträge
— Freie Blöcke

Bei relativen Dateien finden Sie im Anschluß an den Filetyp zwei zusätzliche Angaben:

— Erster Side - Sektor - Block (Spur/Sektor)
— Recordlänge

**BAM (Block Available Map)**
Das Format des Blockbelegungsplanes ist wie folgt festgelegt: Horizontal werden die einzelen Sektoren aufgetragen, vertikal die Spuren 1—35. Ein Stern kennzeichnet einen belegten Sektor, das Minuszeichen einen freien. Mit »/« markierte Sektoren sind nicht vorhanden, da die Anzahl der Sektoren je Spur zum Diskettenmittelpunkt hin abnimmt. Dem Wert rechts neben jeder Spur können Sie entnehmen, wieviele Blöcke auf dieser noch nicht belegt sind. Die Summe der freien Sektoren finden Sie ganz unten. Sollte einmal die Gesamtzahl der freien Blöcke nicht mit der Angabe in der Directory übereinstimmen, so ist mit der Diskette ein »VALIDATE« durchzuführen, um den korrekten Zustand wieder herzustellen.

## Benötigte Hardware

Erstellt und getestet wurde das Programm auf einem C 64 mit Floppy VC 1541 und Epson RX-80 (mit Data-Becker-Interface).

**Eine Umsetzung auf andere Druckertypen** dürfte keine großen Schwierigkeiten machen, da die meisten Steuerzeichen für Druckerfunktionen in den Zeilen 4220-4370 untergebracht sind. Weitere Steuerzeichen, welche vereinzelt im Programmtext vorkommen, sind durch die Form (c$="string":c3=Zahl:gosub4030) leicht zu erkennen. Durch diese Druckparameter werden vor allem Schriftart und Zeilenabstand gesteuert.

**Ausnahme**:
Teilprogramm »Blockbelegung von Files«
Zeilen
1890—1900 : A(3) = 2 54
1930—1940
2020—2030 : A(3) = 255

In diesen Zeilen wird in den Grafikmodus des Druckers umgeschaltet und eine Punktmatrix (CHR$(254) oder CHR$(255) für die senkrechten Linien, CHR$(64) für die waagrechte Linie übermittelt.

Mit diesen Hinweisen sollte die Anpassung an andere Drucker keine Schwierigkeit mehr darstellen.

Zum Schluß möchte ich noch auf ein Buch hinweisen, das mir erst die nötigen Grundlagen zu diesem Programm vermittelte: »Das große Floppy-Buch« von Data Becker. Eine wirklich ausgiebige und informative Quelle für alle jene, die sich intensiver mit der Floppy-Programmierung befassen wollen.

Ich denke, daß Sie das Programm nun sinnvoll einsetzen können, zumal es auch Routinen enthält, die man in andere Programme übernehmen kann.

(Johann Auer / ev)


# Ein besonderer Disassembler

> Dieser Disassembler für den C64 arbeitet ausschließlich mit Dezimalzahlen

Bei vielen Hobby-Programmierern besteht der einzige Kontakt zur Maschinensprache im gelegentlichen Eingeben von Basic-Ladern. Da tut man sich insbesondere mit den Hexadezimalzahlen schon mal etwas schwer.

Hier ist nun ein Disassembler, der sowohl Adressen als auch Befehls- und Datenbytes in dezimaler Form ausgibt.

Das Programm ist sehr einfach anzuwenden und erklärt sich im übrigen von selbst, so daß eine weitergehende Beschreibung hier überflüssig ist.

Bei der Adressenabfrage gibt es drei mögliche Eingaben:

1.	Die direkte Anfangsadresse (dezimal)
2.	»W« für weiter
3.	»E« für Ende

Bei der folgenden Frage nach der Ausgabe auf Drucker kann man wählen zwischen:

1.	»J« für Ja = Druckausgabe
2.	»N» für Nein (Return reicht)

Das Programm läuft auf demC64, kann aber leicht auch für den VC 20 umgeschrieben werden (in Zeile 10 werden nur die Bildschirmfarben eingestellt).

Die verwendeten Steuerzeichen stellen nur Farben dar und können folglich frei gewählt werden.

(Stefan Heine / ev)


# Mouse 64

Das Programm Mouse 64 stellt eine Interrupt-Erweiterung des C64 dar und verträgt sich somit nicht ohne eine Anpassung mit anderen Interrupt-Erweiterungen. Das Programm erzeugt nach Aufruf eine »Maus« auf dem Bildschirm, die sich mit einem Joystick (Port II) steuern läßt. Die Abfrage erfolgt durch eine in den Interrupt eingebundene Routine, so daß die Tastatur weiterhin benutzbar bleibt.

Mouse 64 ist vollständig in 6502/10-Assembler geschrieben und benötigt keinen Basic-Speicher, da Mouse 64 im freien RAM-Bereich von 49152 ($c000) bis 53272 ($cfff) liegt. Die Sprite-Daten liegen in Block 11 (dez. 704-767). Um die Maus darzustellen, wird Sprite 7 verwendet. Das Programm liefert folgende Daten:
a)	Den Bildschirmcode des Zeichens unter der Maus
b)	Die Bildschirm-X-Koordinate
c)	Die Bildschirm-Y-Koordinate
d)	Joystick#2-Zustand
e)	Feuerknopf # 2-Zustand

Das Programm Mouse 64 ist als Eingabe- und Steuerhilfe für Anwendungsprogramme gedacht (siehe Apple-Macintosh-Software und andere), kann aber auch durch zum Beispiel Änderung des Sprites in Spiele eingebunden werden, da bis auf die Vergrößerung alle Spriteparameter veränderlich bleiben.

### Zu Listing 1

Das Listing 1 zeigt den Basic-Lader, der in zwei Schleifen die Daten für den Sprite und das Assemblerprogramm aus den DATA-Zeilen liest und in die entsprechenden Speicherstellen schreibt.

Bei einem Fehler der Daten bricht der Computer das Programm mit einer entsprechenden Meldung ab.

Nach Ablauf der beiden Schleifen wird das Assemblerprogramm direkt mit »SYS 49152« gestartet.

### Zu Listing 2

Das zweite Listing zeigt die in Assembler geschriebene Initialisierungs-Routine. Diese Routine verändert die Interrupt-Zeiger so, daß sie auf die Maus-Routine zeigen. Ferner verändert sie die zu Sprite 7 gehörenden Parameter entsprechend.

Die Initialisierungsroutine gibt den Text:

PUT JOYSTICK IN PORT 2

AND PRESS ANY KEY
aus. Wenn man diesem Folge geleistet hat erscheint eine »Maus« in der linken oberen Ecke und der Computer arbeitet normal im Programm beziehungsweise im Direktmodus weiter. Die Maus läßt sich — wie gesagt — mit dem Joystick#2 steuern.

### Zu Listing 3

Listing 3 zeigt die eigentliche Interrupt-Erweiterung. Diese beginnt mit dem Auslesen des Joystickzustandes. Dazu muß bekanntlich die Tastatur abgeschaltet werden. Das Programm schaltet also die Tastatur ab, liest das Register für den 2. JoyStick aus und schaltet die Tastatur wieder ein. So bleibt die Tastatur weiterhin benutzbar.

Daraufhin wird anhand der Joystickstellung der Sprite 7, also die Maus, bewegt. Ist dies erfolgt, werden aus den Spritekoordinaten die Bildschirmkoordinaten errechnet. Sind diese bekannt, so wird daraus das entsprechende Byte unter der Maus errechnet und ausgelesen.

Diese Werte sind folgenden Registern zu entnehmen:

1.	Der Zeichencode des unter der Maus befindlichen Zeichens: 49659 ($c1fb)
2.	Die Bildschirm-X-Koordinate : 49660 ($c1fc)
3.	Die Bildschirm-Y-Koordinate : 49661 ($c1fd)
4.	Der Feuerknopf #2 : 49662 ($c1fe) ( = 1: gedrückt / = 0 nicht gedrückt)
5.	Der Zustand des Joysticks : 49663 ($c1ff)

### Zu Listing 4

Listing 4 zeigt den Hex-Dump des Assembler-Programms. Abschließend wäre noch zu sagen, daß es keinen Sinn hat, zu versuchen, das ProgrammandererComputer, die nicht wieder C 64 in der Lage sind, frei bewegliche Sprites zu erzeugen, da ein solcher Sprite nötig ist.

(Peter Dreuw / rg)


# 17 Super-Utilities für den C64

> Wollen Sie Ihre Basic-Programme schneller und kürzer machen? Wollen Sie Betriebssystem oder Zeichensatz Ihres C64 ändern? Dieses Maschinenprogramm löst Ihre Probleme.

Das Programm entstand durch Zusammenfügen der in der praktischen Arbeit am häufigsten gebrauchten Maschinensprache-Routinen zu einem einzigen großen Utility-Paket.

Die beiden Bereiche Optimierung von Basic-Programmen und Zeichen-Definition stehen im Mittelpunkt. Nach ordnungsgemäßem Laden kann man ein Menü mit »sys 49152« aufrufen (Bild 1), in dem alle Unterprogramme mit Namen und SYS-Adresse genannt werden.

Nun zu den Programmen selbst:
**Space-Killer** (sys 49155): Hinter diesem martialisch anmuten-den Aufruf verbirgt sich nichts anderes als eine Maschinen-Routine, welche überflüssige Spaces aus einem Basic-Programm entfernt.

Nach dem »sys 49155«-Aufruf erscheint in der oberen Bildschirmecke ein farbiges Symbol als Versicherung, daß alles in Ordnung ist, denn die Routine kann durchaus bis zu 1/4 Stunde laufen, wenn viele Spaces zu entfernen sind und das Programm entsprechend lang ist.
**Space-Expander (sys 49158)**: Es erscheint auf den ersten Blick befremdend, etwas einzufügen, was man eben erst entfernt hatte. Doch die Aufgabe liegt auf der Hand: zwischen jeden Basic-Befehl ein Space einzufügen, um das Druckbild sauber und ansprechend zu gestalten.
**REM-Killer (sys49161)**: erklärt sich selbst. Erwähnenswert ist die Geschwindigkeit, mit der die Routine läuft. 20 kByte-Programme werden in etwa 10-30 Sekunden »gesäubert«.
**Zeilen löschen (sys 49164)**: Hiermit werden ganze Zeilenbereiche gelöscht. Beispiel: »sys 49164,1000,1999« entfernt alle Basic-Zeilen mit den Nummern von 1000 bis 1999 einschließlich. Mit Druck auf dieRETURN-Taste ist der Befehl schon ausgeführt.
**Text suchen (sys 49167,"Suchtext")**: Sucht eine Zeichenkette »Suchtext« im Basic-Programm und gibt die gefundenen Zeilennummern aus.
Eine Besonderheit ist das Jokerzeichen »?«: Hier wird jedes Zeichen akzeptiert, es darf allerdings nicht an erster Stelle im Suchtext stehen.
**Colon-Maker (sys 49170)**: Ersetzt jedes Space am Anfang einer Basic-Zeile durch einen Doppelpunkt»:«.
**Space-Maker (sys 49173)**: Ersetzt jeden Doppelpunkt am Anfang einer Basic-Zeile durch ein Space » «. Beide Routinen dienen als Strukturhilfen. Da alle der Zeilennummer unmittelbar folgenden Spaces überlesen werden, muß man erst einen »neutralen« Doppelpunkt setzen, diesen dann später durch ein Space ersetzen.
**Package (sys 49179)**: Hier ist die Notlösung für jeden, der einfach mehr Platz braucht und das Basic-Programm garantiert nicht mehr korrigieren muß. »Package« schmilzt nämlich benachbarte Zeilen zusammen, so daß bei jeder Verschmelzung vier Bytes freiwerden (Ein Null-Byte, Zwei Bytes der Koppeladresse plus Zwei Bytes der Zeilennummer, abzüglich ein Byte für den nun erforderlichen Doppelpunkt als Trennelement). Das braucht seine Zeit, weil einige Aspekte kontrolliert werden müssen, zum Beispiel ob die zu verschmelzende Zeile angesprungen wird, dann muß sie mit ihrer Zeilennummer präsent bleiben, sonst gibt’s Ärger mit dem Interpreter, der sich dann mit »undef’d statement« beschwert. Für die Verschmelzungstiefe gibt es leider eine unnatürliche Grenze: Mehr als 255 Bytes darf eine Zeile nicht lang sein, sonst kann der Interpreter die Zeilen nicht mehr binden und findet hinter einer solchen »Megazeile« keine Zeilennummer mehr.
Um Basic-Programme auf ein Minimum zu komprimieren, empfiehlt sich folgender Weg:

- zuerst »sys 49161« eingeben. Danach sind alle REMarks weg, und die folgenden Routinen haben weniger Prüfarbeit.
— dann »sys 49155« eingeben. Hier werden alle Zeilen gestaucht.
— zuletzt »sys 49179« eingeben, danach ist Ihr PRG redundanzfrei.

Für spätere Änderungsarbeiten wird man sich natürlich ein »augenfreundliches« Original verwahren, am besten benutzt man von allen Basic-Programmen zwei Versionen: Eine originale zur Dokumentation, Korrektur, Ausdruck und eine komprimierte mit minimalen Platzansprüchen und schneller Ausführung.
**CPU-Register ein (sys 49182)**: Zeigt fortwährend die Register des Mikroprozessors in den beiden oberen Bildschirmzeilen an.
Außerdem werden der IRQ-, NMI- und der BRK-Vektor sowie der Programmcounter angezeigt. Im Status-Register bedeutet »*« ein gesetztes Bit, ».« ein gelöschtes.
**CPU-Register aus (sys 49185)**: Schaltet die Anzeige wieder ab.
**Basic-Ende setzen (sys 49188)**: setzt das Basic-Ende genau hinter das im Speicher befindliche Programm. Normalerweise erledigt das der Interpreter; wenn aber absolut geladen wurde, zum Beispiel in den $c-Block hinein, dann steht der Programm-Ende-Zeiger ebenfalls im $c-Block, und Eingabeversuche werden mit »out of memory«-Fehlermeldungen abgewehrt.
**Dump (sys 49191)**: Gibt alle definierten Variablen unter Angabe des Namens und des aktuellen Inhalts aus.
Mit der Shift-Taste kann die Ausgabe angehalten, mit der Commodore-Taste vorzeitig abgebrochen werden.
**ROM kopieren (sys 49194)**: Kopiert Interpreter- und Kernal-ROM in das darunter liegende RAM. Es gibt zwar viele veröffentlichte Programme zu diesem Thema, doch macht die Geschwindigkeit dieser Stilblüten auf Dauer aggressiv.
**Zeichensatz RAM** Die letzten vier Routinen befassen sich mit dem Zeichensatz:
**(sys 49197)**: Verlegt den Zeichensatz nach $7000 und den Bildschirm nach $6c00. Die Absicht ist klar: im RAM kann der Zeichensatz leicht verändert werden.
**Zeichensatz ändern (sys 49200)**: Setzt voraus, daß vorher durch »sys 49197« der Zeichensatz verlegt wurde, sonst funktioniert’s nicht. Es wird eine Zeichen-Änderungsroutine aktiviert, die einfach zu bedienen ist. Man fährt einfach mit dem Cursor über das zu ändernde Zeichen, drückt RETURN, und schon guckt man wie durch eine Lupe in die Punkte-Matrix des Zeichens hinein. Auch hier kann man sich wieder frei mit dem Cursor bewegen, natürlich nur innerhalb des Zeichens. Will man einen Punkt löschen, drückt man die Space-Taste, zum Setzen gibt man ein Sternchen »*« ein. RETURN führt wieder in das Menü zurück.
**Zeichensatz speichern (sys 49203**, "filename", gerätenummer)
Speichert den aktuellen Zeichensatz unter Angabe des Filenamens (der wie bei »SAVE« dem SYS-Befehl in Anführungsstrichen folgen muß), eines Kommas und der Gerätenummer entweder auf der Floppy oder dem Kassettenrecorder ab. Damit nicht jedesmal wieder bei Null begonnen werden muß, kann man einen Zeichensatz durch den Basic-Befehl:
»load "filename", gerätenummer,1«
absolut, das heißt von $7000 bis $7fff laden.
Die verbogenen Basic-Zeigerwerden danach mit »sys 49188« wieder gerade gerichtet.
**Zeichensatz ROM (sys 49206)**: Schaltet den Zeichensatz wieder ins ROM $d000 zurück. Der Bildschirm wird wieder nach $400 verlegt.

## Grundsätzliches zur Eingabe

Maschinenprogramme sind extrem empfindlich, was Fehler anbetrifft. Einfache Prüfsummen decken sich ausgleichende Fehler nicht auf. Wird beispielsweise eine »1« und eine »2« vertauscht, so stimmt die Prüfsumme zwar, das Programm ist aber wahrscheinlich nicht lauffähig. Aus diesem Grund habe ich die Prüfsummen gespalten, »pg« für gerade Bytes und »pu« für ungerade. Zwar sind auch jetzt noch Fehlermaskierungen möglich, aber extrem unwahrscheinlich.

Noch eine Unart erregt manches Ärgernis:
Viele Autoren veröffentlichen Basic-Lader, und geben dann nach etwa 4000 harten (das heißt unformatierten) Dezimal-Bytes eine (also eine einzige) Prüfsumme an, so ziemlich weit in den Hunderttausendern, die auf Anhieb nur selten übereinstimmt. Es wollen dann 4000 Bytes überprüft werden! Ich halte es für besser, nach einem kleineren Abschnitt, etwa einer »Page« (256 Bytes) eine Zwischenprüfung zu fahren und bei Unstimmigkeiten sofort mit einem Hinweis zu unterbrechen.

In meinem Programm werden den Datenbytes die Angabe der Seite, dann die gerade und letztlich die ungerade Prüfsumme vorangestellt. Wenn Sie das berücksichtigen, können Sie nach Herzenslust ändern und erweitern, ein Maschinensprachemonitor und Assemblerkenntnisse vorausgesetzt.

## Probieren Sie mal einige Routinen aus

Wenn Sie das Programm genauso wie abgebildet im Speicher stehen haben, so können Sie durch »sys 49161« die Eliminierung aller REMs erzielen. Die Routine startet mit der Meldung »20779 Bytes PRG-Laenge« und endet nach 22 Sekunden mit »20019 Bytes PRG-Laenge«. 760 Bytes haben Sie gewonnen oder verloren, wie man’s nimmt.

Doch Vorsicht! Wenn Zeilen mit einem REM beginnen, wird die ganze Zeile entfernt. Sprünge zu dieser Zeile werden nicht berücksichtigt. Wenn das Programm mit der Fehlermeldung »undef’d statement« unterbricht, korrigieren Sie einfach den Sprungbefehl durch die Zeile, welcher der entfernten unmittelbar folgt.

Wenn Sie allerdings schon vorher überblicken, welche Zeilen »fällig« sein werden, können Sie durch zum Beispiel »sys 49167,"2000"« alle Zeilen mit dem Wortlaut "2000" ausfindig machen und korrigieren.

»sys 49155« kommt nach etwa 13 Minuten mit »17828 Bytes PRG-Laenge« zurück. Diese lange Zeit rührt davon her, daß nach jedem eliminiertem Space alle Programmzeilen wieder gekoppelt werden müssen, bei einemG ewinn von 2191 Bytes bedeutet das 2191 mal koppeln, und das Verschieben selbst braucht natürlich auch noch ein paar Millisekunden. Dann sind schnell, ehe man sich versieht, einige Minuten verflossen.

»sys 49179« als Package-Befehl bringt Ihnen nach 9 Minuten weitere 2095 Bytes Speicherplatzgewinn. Nach diesem 3-Stufen-Plan haben Sie insgesamt 5046 Bytes, die für die Funktion des Programms entbehrlich sind, entfernt. Durch den Platzgewinn werden Ihre Programme übrigens schneller, da erstens die Strings mehr Platz haben und seltener aufgeräumt werden müssen und zweitens weniger Zeilenübergänge stattfinden.

Ich möchte nochmals betonen, daß sich derartige »Rumpfpakete« ausschließlich für den RUN-Modus eignen. Listen, Korrigieren und so weiter sollte immer an einem »gesunden« Programm stattfinden.

(Johannes Mockenhaupt / ev)


# »Windows« für den C 64

> Dieses Programm für den C 64 stellt vier Speicher für Bildschirminhalte im Text/Blockgrafikmodus zur Verfügung. Da diese Speicher im RAM »unterhalb« des Betriebssystems liegen, beanspruchen sie keinen zusätzlichen Speicherplatz. Das Programm ist in Maschinensprache geschrieben und durch Verwendung eines Verschiebeladers in verschiedenen Speicherbereichen lauffähig.

Besonders in größeren Programmen ist es oft wünschenswert, zwischen mehreren Bildschirmen umschalten zu können oder aber Fenster mit Zusatzinformationen in den laufenden Bildschirm einblenden zu können, ohne jedoch seinen ursprünglichen Inhalt zu zerstören. Um dies zu ermöglichen, stellt das Programm vier Speicher zur Verfügung, in denen komplette Bildschirminhalte oder Teile daraus abgelegt werden können. Ein Speicher belegt einen Bereich von 2 KByte, jeweils ein KByte für Zeichen und Farbe. Da diese Speicher unterhalb des Betriebssystems im RAM ab Adresse $E000 untergebracht sind, beanspruchen Sie keinerlei zusätzlichen Platz.

## Anwendung

Das Programm bietet folgende Betriebsarten:

—	STORE:	SYS BA,NR,XO,YO,FB,FH	Speichern
—	RECALL:	SYSBA+3,NR	Rückholen
—	SWAP:	SYSBA+6,NR	Austauschen

Die Parameter haben folgende Bedeutung:
BA = Basisadresse des Programms (siehe unten)
NR = Nummer des angesprochenen Speichers (0...3)
X0,Y0 = Position der linken oberen Ecke des zu speichernden Bereiches (0..39,0..24)
FB = Breite des Bereiches(1...40)
FH = Hohe des Bereiches(1...25)

Die Fensterseite (Höhe) darf nur bis zum rechten (unteren) Bildrand reichen. Wenn zum Beispiel die linke obere Ecke auf die Koordinate X = 10und Y = 5 gesetzt ist, so ist die maximale Fensterbreite 30 und die maximale Fensterhöhe 20. Falsche Angaben für die Parameter erzeugen die Fehlermeldung »ILLEGAL QUANTITY ERROR«.
**STORE**: Um einen kompletten Bildschirm abzuspeichern, geben Sie folgendes ein: SYS BA,NR,0,0,40,25. Mit anderen Parametern erzeugen sie ein Bildschirmfenster, das bei RECALL auch nur den durch diese Parameter definierten Bereich überschreibt. Darum bleibt der ursprüngliche Bildschirm erhalten.
**RECALL**: Es ist nur die Angabe der Speichernummer nötig. Der gespeicherte Bereich wird an seine ursprüngliche Position zurückgeschrieben.
**SWAP**: Wenn Sie ein schon vorher vorbereitetes und im Speicher stehendes Informationsfenster in den aktuellen Bildschirm einblenden, wird dessen ursprünglicher Inhalt zerstört. Um ihn zu erhalten, müßten Sie ihn vor der Einblendung in einen noch freien Speicher retten. SWAP erleichtert die Arbeit und spart Speicherplatz, indem es die Inhalte von aktuellem Schirm und Speicher austauscht. Mit einmal SWAP rufen sie den Speicher ab, noch einmal SWAP erzeugt wieder das ursprüngliche Bild. Die Information über Position und Größe des auszutauschen Bereiches liefert das Bild im Speicher. SWAP wird daher nur mit der Speichernummer aufgerufen.

Noch ein Hinweis: Vermeiden Sie es, mit RECALL oder SWAP einen Speicher aufzurufen, in den noch nichts hineingeschrieben wurde, dies würde zum Absturz des Programms führen (siehe: Kompatibilität zu Simons-Basic). Der Basic-Lader initialisiert alle 4 Speicher, um einer Fehlbedienung vorzubeugen.

## Laden des Programmes

Die Verschieberoutine des Basic-Laders gestattet es, das Programm auf den Anfang jeder (sinnvollen) Speicherseite zu legen. Nach dem Start bietet der Lader die Optionen:
&nbsp;1 RAM-Ende normales Basic ($9E00)
&nbsp;2 RAM-EndeSimons-Basic ($7E00)
&nbsp;3 Geschützter Bereich ($C000)
&gt;7 Eingabe der Startseite

Die Optionen 1 bis 3 setzen den Programmanfang auf die angegebene Adresse, bei Eingabe einer Zahl &gt; 7 wird diese als die Nummer derjenigen Speicherseite interpretiert, wo das Programm abgelegt werden soll.

Aus der Nummer der Speicherseite erhält man durch Multiplikation mit 256 die noch fehlende Basisadresse. Das Ladeprogramm gibt sie am Schluß mit aus.

Der Vektor für die Basic-Obergrenze in (55),(56) wird entsprechend der Startadresse des Maschinenprogramms heruntergesetzt, sofern das Programm nicht im geschützten Bereich untergebracht ist. Beachten Sie, daß Sie diesen Vektor nach einem Reset beziehungsweise STOP/RESTORE korrigieren, sonst wird das Programm überschrieben.

Im Programmlisting erkennen Sie zwei Unterschiedlich umfangreiche Blocks von DATA-Zeilen. Der erste, große Block stellt das eigentliche Programm dar, der kleine ist eine Liste von Adressen, welche relativ zum Programmanfang diejenigen Bytes angeben, die bei einer Verschiebung korrigiert werden müssen. Der Korrekturwert ergibt sich aus der Differenz zwischen der Startadresse, mit der das Programm assembliert wurde ($9E00=Speicherseite 158) und der gewünschten Startseite. Die beiden Blocks besitzen eigene Checksummen und OK-/Fehlermeldungen.

## Kompatibilität zu Simons-Basic

»Bildspeicher« ist auch eine hilfreiche Erweiterung der Simons-Basic-Befehle für die Bildschirmsteuerung. Es sind jedoch folgende Punkte zu beachten:

—	Die Hires-Grafik überschreibt alle vier Speicher. Diese müssen daher vor einem Zugriff mit »RECALL« oder »SWAP« unbedingt neu beschrieben werden.
—	Der geschützte Bereich ab $C000 wird ebenfalls von Hires überschrieben, so daß »Bildspeicher« in Programmen, welche die Hires-Grafik benützen, am Basic-RAM-Ende untergebracht werden muß (Option 2).

Ob Sie jedoch nun mit oder ohne Simons-Basic arbeiten, in jedem Falle ist »Bildspeicher« eine nützliche Routine, die auch dem C 64-Besitzer das Fenster zum »Windowing« aufstößt.

(Hans-Herbert Hagedorn / ev)

# DATA-Erzeuger

> Dieses Programm dient, wie der Name schon sagt, zum automatischen Erzeugen von DATA-Zeilen. Da das Programm in Maschinensprache geschrieben ist, ist die Ausführungszeit entsprechend kurz. Der Inhalt von 10000 Speicherzellen wird in weniger als 4 Sekunden in DATA-Zeilen umgewandelt!

Es kommt immer wieder vor, daß der Inhalt von Speicherzellen in DATA-Zeilen umgewandelt werden muß. Verschiedene Lösungen habe ich aus irgendwelchen Büchern oder Zeitschriften abgetippt. Da ich keine dieser Programme als befriedigend empfand, begann ich, einen DATA-Erzeuger in Basic zu programmieren. Auch dieses Programm war zu unflexibel und vor allem zu langsam. Da ich zwischenzeitlich verstärkt in Maschinensprache programmiere, bestand ein noch größerer Bedarf an einem leistungsfähigen DATA-Erzeuger. Also beschloß ich, einen solchen in Maschinensprache zu erstellen.

## Leicht zu bedienen

Durch eine umfangreiche Fehlerprüfung ist das Programm sehr anwendungssicher. Die DATA-Zeilen können, falls gewünscht, an ein Basic-Programm angehängt werden, und das beliebig oft.

Eingabe-Format:
SYS49152,ANFADR,ENDADR,ANFZNR,SCHRITTWEITE
ANFADR:	Adresse der ersten Speicherzelle, aus deren Inhalt DATA-Zeilen erzeugt werden sollen.
ENDADR:	Adresse der letzten Speicherzelle für die DATA-Zeilen-Erzeugung.
ANFZNR:	Zeilennummer der ersten DATA-Zeile (muß größer sein als die letzte Zeilennummer im Basic-Programm, falls eines im Speicher ist).
SCHRITTWEITE: Um diese Zahl wird die Zeilennummer bei der DATA-Erzeugung jeweils erhöht.

## Fehlermeldungen

Für ANFADR, ENDADR, ANFZNR dürfen nur ganze, positive Zahlen von 0-65536 eingegeben werden. Die SCHRITTWEITE darf zwischen 1 und 255 liegen. Werden Zahlen eingegeben, die außerhalb des oben genannten Bereichs liegen, so kommt es zur Fehlermeldung »? ILLEGAL QUANTITY ER-ROR«. Weitere Fehlermeldungen sind:

— ANFANGSADRESSE GROESSER ALS ENDADRESSE.<br>FEHLER! Logischerweise muß die Anfangsadresse kleiner sein als die Endadresse.
— 0 ALS SCHRITTWEITE NICHT MOEGLICH!<br>Würde 0 als Schrittweite akzeptiert werden, so hätten alle erzeugten DATA-Zeilen die gleiche Zeilennummer.
— ZEILENNUMMEH GROESSER ALS 63999!<br>Bei der Erzeugung der DATA-Zeilen wurde eine Zeilennummer erzeugt, die größer als 63999 war. Da der C 64 nur Zeilennummern bis 63999 zuläßt, würden größere Zeilennummern Probleme der Art aufwerfen, daß sie sich nicht mehr löschen oder ändern ließen. Man sollte eine kleinere Anfangs-Zeilennummer oder Schrittweite wählen, um den Fehler zu beseitigen.
- FREIER SPEICHERPLATZ REICHT NICHT!<br>Bei der DATA-Erzeugung wurde festgestellt, daß der freie RAM-Bereich nicht ausreicht.

Beim Auftreten eines Fehlers wird die DATA-Erzeugung, falls schon begonnen, sofort abgebrochen. Die bis dahin erzeugten DATA-Zeilen werden wieder gelöscht. Die Programmzeiger werden wieder so eingestellt, wie es vor dem Aufruf des DATA-Erzeugers der Fall war.

War die DATA-Zeilen-Erzeugung erfolgreich, so erscheint die Meldung »DATA ERZEUGER FERTIG! (C) J. MATERNA«. Jetzt befinden sich die DATA-Zeilen und die Schleife zum Lesen und ZurückPOKE der DATAs im Speicher. Das Basic-Programm kann wie gewohnt gelistet, gestartet oder gespeichert werden.

Wenn man möchte, kann man noch beliebige weitere DATA-Zeilen erzeugen. Sie werden automatisch an die bereits vorhandenen angehängt. Wichtig: Die neue Anfangszeilennummer muß größer sein als die letzte im Programm verwendete. Am besten LISTet man das Programm erst auf, um die höchste Zeilennummer festzustellen. Möchte man die DATA-Blöcke als Unterprogramme aufrufen, muß natürlich noch am Ende des DATA-Blocks eine Zeilennummer mit »RETURN« eingegeben werden.

## Tips und Beispiele

Bei allen Bereichen wird vorausgesetzt, daß sich der DATA-Erzeuger lauffähig im Speicher befindet, ebenso die Daten, aus denen DATA-Zeilen erzeugt werden sollen.

### Sprite-Blöcke übernehmen

— Das Programm, das die Sprites erzeugt, laden und starten. Wenn die Sprites erzeugt sind, das Programm abbrechen und die Adressen der Sprites aufschreiben.
— Das Programm mit NEW löschen.
— Das eigene Programm, das die Sprites verwenden soll, laden und die höchste Zeilennummer feststellen.
— Beispielsweise SYS 49152, Anfangsadresse der Sprites, Endadresse der Sprites, höchste Zeilennummer des eigenen Programms plus 10, sowie beliebige Schrittweite eingeben.
— Den letzten Punkt beliebig oft wiederholen, bis alle Sprites in DATA-Zeilen umgewandelt sind. Dabei darf nicht vergessen werden, stets erneut die höchste Zeilennummer festzustellen.
— Es ist sinnvoll, am Ende der DATA-Blöcke jeweils eine Zeile mit »RETURN« einzugeben. Danach können die Sprites irgendwo vom Hauptprogramm aus mit einem GOSUB-Befehl aufgerufen werden.
— Programm testen und speichern.

Nach dem oben beschriebenen Verfahren kann man natürlich nicht nur Sprites übernehmen, sondern auch Maschinenprogramme und neue Zeichensätze. Insbesondere kann man auch sehr gut Maschinenprogramme, die von einem Assembler erzeugt wurden, an ein Basic-Programm anhängen.

### Maschinenprogramm für Datenfernübertragung vorbereiten

Da die Daten im ASCII-Format übertragen werden, müssen sie vorher umgewandelt werden.

Beispiel: Das zu übertragende Programm ist 8000 Bytes lang und wird normal ab Basic-Anfang geladen.

— Das zu übertragende Programm laden.
— POKE 44,40 : POKE 40 * 256,0 : NEW<br>Damit ist das Programm vor dem Überschreiben geschützt. Wenn das Maschinenprogramm am Speicherende liegt, dann muß natürlich der Zeiger für das Basic-Ende herabgesetzt werden.
— SYS 49152,2049,10049,100,2

Nun muß das Programm nur noch als Datei gespeichert werden und kann dann von einem Terminal-Programm gesendet werden.

### Ein Monitor-Programm ($9000 — $9FFF) in DATA-Zeilen verwandeln.

— Monitor laden.
- SYS 49152,36864,40959,100,2.
— Abspeichern<br>Das Programm kann nun normal geladen und gestartet werden. Danach kann der Monitor mit der entsprechenden SYS-Adresse aufgerufen werden.

### Bildschirminhalt in DATA-Zeilen verwandeln

SYS 49152,1024,2023,100,2
Das Programm kann sofort gestartet werden.

## Programmierte DATA-Erzeugung

Der DATA-Erzeuger läßt sich auch von Basic-Programmen aus aufrufen. Dabei dürfen die Parameter natürlich in Variablen übergeben werden. Doch Achtung: Wenn der DATA-Erzeuger fertig ist, wird ein CLR ausgeführt und zum Basic-Warmstart gesprungen. Dabei wird das Basic-Programm verlassen.

Um wieder ins Basic-Programm zurückzukommen, empfehle ich folgenden Trick, den ich am besten durch ein Beispiel demonstriere:

<pre>10 A=900:Z=100
20 A=A+100:Z=Z+20:IF Z=200 THEN END
30 PRINT CHR$(147);:PRINT CHR$(17):PRINT CHR$(17)
40 PRINT"A=";A;":Z=";Z;":GOTO 20";CHR$(19)
50 POKE 631,13:POKE 198,1
60 SYS 49152,A,A+100,Z,2:END</pre>

Dieses Programm hält in Zeile 60 an und startet sich so lange wieder automatisch, bis in Zeile 20 Z=200 ist. Dabei werden die Variablen, die in Zeile 40 auf dem Bildschirm ausgegeben werden, mit übernommen. Für den Auto-Start des Programms ist die Zeile 50 verantwortlich. Dort wird ein RETURN (POKE 631,13) in den Tastaturpuffer gePOKEt und die Länge des Tastaturpuffers (POKE 198,1) auf 1 gesetzt.

Anhand dieses Beispiels sollte jeder in der Lage sein, dieses Problem zu lösen.

Ich hoffe, daß ich durch meine Beispiele genug Anregungen für den Einsatz des DATA-Erzeugers gegeben habe.

## Die Programmeingabe

Nachdem das Programm in den C64 eingegeben ist, kann es bedenkenlos gestartet werden.

Falls dann die Meldung «DATA-FEHLER« erscheint, müssen die DATA-Zeilen noch einmal überprüft werden. Wenn die Meldung «PROGRAMM OK« erscheint, speichert man das Programm am besten ab, bevor man den DATA-Erzeuger aufruft. Vor dem Programmstart mit »SYS« löscht man am besten den Speicher mit »NEW« oder lädt das Programm, für das DATAs erzeugt werden sollen.

Möchte man den DATA-Erzeuger als Maschinenprogramm direkt speichern, so sind folgende Befehle einzugeben:
POKE 43,0:POKE 44,192:POKE 45,66:POKE 46,195:SAVE "MP-DATA-ERZEUGER",8,1

Für die Datasette muß statt der 8 natürlich eine 1 eingegeben werden.
Das so gespeicherte Programm lädt man mit »LOAD "MP-DATA-ERZEUGER",8,1«.

Nachdem man NEW eingegeben hat, ist das Programm sofort einsatzbereit.

(Jörg Materna / ev)

# Single-Step für VC 20

> »Single-Step« soll bei Maschinenprogrammen zum Aufdecken von Fehlern beitragen. Anfängern erlaubt es ein schnelleres Einfühlen in die Wirkungsweise der Maschinenbefehle.

Das Programm ist für den Commodore VC 20 mit mindestens 8 KByte Speichererweiterung geschrieben (ein entsprechendes Programm für den C64 finden Sie im 64’er Stammagazin). Es ist ein DATA-Listing einer Maschinenspracheroutine. Über Zeile 9 des Listings läßt sich die gewünschte Startadresse festlegen; die Basic-Schleife ab Zeile 300 korrigiert absolute Sprungadressen. Hierzu wurden bei der Programmerstellung die absoluten Zieladressen so eingestzt, als stünde das Programm ab Adresse 0 im Speicher. Der Basic-Teil sorgt dafür, daß die Startadresse (ss) als Offset berücksichtigt wird.

Nach einmaligem Starten läßt sich die Maschinenspracheroutine mit SYS ss starten, der Basic-Teil kann demnach gelöscht werden, sollte aber sicherheitshalber vorher abgespeichert werden.

Für die Bedienung des Programmes stehen die Funktionstasten F1, F3 und F5 zur Verfügung. Ein Beispiel soll den Ablauf verdeutlichen (Tabelle):

Zunächst startet man »Single-Step« mit SYS ss, es erscheint dann die Überschrift mit Bezeichnung der einzelnen Bildschirmspalten und der ersten, übersetzten Zeile. Nun kann man über F3 in den Editier-Modus gelangen, es lassen sich sämtliche dargestellte Register und Flags ändern. Dazu fährt man mit dem Cursor einfach an die entsprechende Stelle und tippt die gewünschten Werte ein. Im Editier-Modus wird nun der PC (Programm-Counter) so geändert, daß er auf die Startadresse der eigenen Routine zeigt (hier im Beispiel ist dies die Adresse $ 4000). Durch Betätigen der Taste F1 wird der hier abgelegte Befehl ausgeführt. Der PC zeigt dann auf die Startadresse des nächsten Befehles, PSW (Programm Status Word, auch Flag-Register genannt),A,X und Y sind entsprechend verändert. (Im Beispiel wurde der Akku mit den Daten #00 geladen). Jede weitere Betätigung der Funktionstaste F1 bringt einen weiteren Befehl zur Ausführung.

Jetzt noch eine Anmerkung zu Manipulationen im PSW (Flag-Register): Durch Ändern einzelner Flags lassen sich zum Beispiel Schleifen vorzeitig beenden oder, wie im Beispiel in Zeile 16 geschehen, auch verlängern; das Zero-Bit wurde zurückgesetzt, was die CPU durch einen weiteren relativen Sprung auf Adresse $ 4000 quittieren mußte.

Weiterhin lassen sich unter Benutzung des PSW, genauer des l-Flags, Breakpoints im Programm setzen. Es ist nicht immer nötig das Programm schrittweise von Anfang bis Ende zu untersuchen. In solchen Fällen setzt man zu Beginn des interessierenden Teiles den Befehl CLI ein. Es genügt nun im Editiermodus das l-Flag zu setzen und mit F1 den nächsten Schritt zu starten. Das Programm wird erst wieder nach Abarbeiten des.CLI- und des darauffolgenden Befehles angehalten.

Die Taste F5 dient zum Ausstieg aus der »Single-Step«-Routine. Ein Betätigen dieser Taste hat die gleiche Wirkung wie Stop/Restore, das heißt es wird eine teilweise Neuinitialisierung und ein Sprung zum Basic-Warmstart durchgeführt.

Abschließend noch eine Anmerkung zur Wirkungsweise:

Ich benutze hier den Timer 1 des VIA 6522 (versatile interface adapter) in der Betriebsart »One-Shot«. Diese läßt sich über das ACR (auxiliary control register) definieren. Der Timer erzeugt jetzt nach jedem Start einen einzelnen Interrupt. Durch geeignete Wahl des Timer-Zählerstandes kann erreicht werden, daß nach jedem Rücksprung aus der Interruptroutine mittels RTI jeweils ein Befehl des zu untersuchenden Programmes ausgeführt wird und darauffolgend die weitere Ablaufsteuerung wieder von der Interruptroutine übernommen wird. Im ersten Hauptteil der Routine »Single-Step« hole ich dann die interessierenden Daten vom Stack und stelle sie auf dem Bildschirm dar. Vor dem Rücksprung mittels RTI wird dann im zweiten Teil die eventuell geänderte Zeile wieder eingelesen und übersetzt.

(Hermann Weißenberger / ev)

# Disksorter in Vollendung

> Dieses Verwaltungs- und Sortierprogramm für Disketten läßt keine Wünsche offen. Es macht aus Ihrem Diskettendschungel eine übersichtliche Sacha So können Sie sämtliche Einträge entweder alphabetisch oder nach ID ordnen und sortieren. Auf Wunsch werden doppelte Einträge ausgesondert. Wenn Sie Ihre eigene Liste mit einer anderen Liste vergleichen wollen, wird registriert, welche Programme in Ihrer Liste nicht vorhanden sind. Aber das ist noch längst nicht alles..

In diesem Heft ist die Basic-Version abgedruckt. Das bedeutet, daß die Sortierroutine etwas langsam arbeitet. Auf der ebenfalls erhältlichen Diskette zum Heft finden 8ie eine compilierte Version, bei der auch die Sortierroutine in Maschinensprache geschrieben ist. Diese Version stellt wohl das optimalste dar. Doch nun zu den Funktionen des Programms.

### Anleitung

In den Speicher Ihres Commodore C 64 können zirka 850 Programmdaten gespeichert werden. Ein Datensatz besteht aus dem Programmnamen, der ID-Nummer und der Anzahl der belegten Blocks auf Diskette.

Achtung: Alle Eingaben die nicht mitJ/N beantwortet werden können, müssen mit RETURN abgeschlossen werden.

**F1**: Setzt den Datenzähler auf Null, das Erstellen der Liste beginnt. Daten werden von Diskette eingelesen. Sie können wählen, ob Sie alle Daten einlesen wollen, oder einzelne Daten in die Liste von Diskette aufnehmen möchten. Falls Sie mehr als eine Diskette einlesen wollen, die Anfrage des Computers mit »J« beantworten, sonst erfolgt eine Rückkehr in das Hauptmenü. Wollen Sie in diesem Fall zusätzliche Daten aufnehmen, ist die Funktion F3 zu wählen.

**F3**: F1 liest Daten zusätzlich zu vorhandenen Daten ein. Mit F3 kann ein schon vorhandenes Datenfile von Diskette zugeladen werden.

Mit F5 können alle Daten einer ID-Nummer von einer in den Computer eingelesenen Directory gelöscht werden.

Mit F7 kann der gerade im Computer befindliche Standard-Druckkopf abgespeichert werden (automatisch unter Standardkopf). Der Standardkopf wird sofort nach dem Laden des Programms eingelesen und dient dazu, Name, Adresse, Telefonnummer (oder andere Daten) in Sperrschrift über die Liste zu drucken.

**F5** erlaubt das Editieren von Daten. Daten können gelöscht, verändert, zusätzlich eingefügt und direkt auf den Drucker ausgegeben werden. Zusätzlich besteht die Möglichkeit in diesem Modus, aus einer Programmliste eine Preisliste zu machen.

**F7** sortiert alle Daten alphabetisch oder nach ID-Nummer. Danach können doppelte Daten aussortiert werden, Eingabe der Anzahl zu berücksichtigender Zeichen von links.

**F2** speichert die Daten unter dem eingegebenen Filenamen ab. Klammeraffe kann verwendet werden.

**F4** liest ein gespeichertes Datenfile in den Rechner ein, der Joker ist erlaubt.

**F6** gibt die Daten auf den Drucker aus. Entweder alle Daten in drei Spalten, oder als Liste, dann kann als ID-Code eine ID-Nummer eingegeben werden. »Directory wird ausgedruckt« auch mit Joker, dann werden zum Beispiel alle Daten deren ID-Nummer mit M beginnt nach Eingabe von »M*« ausgedruckt.

**F8** gibt die Daten auf den Bildschirm aus.

**£** Farbwechsel von Bildschirm und Schrift.

**&** alle Diskettenoperationen sind möglich.

**./.** Spezielle Listen können erstellt werden nach dem ersten Zeichen der ID-Nummer (zum Beispiel nach Eingabe von M werden alle Daten deren ID-Nummer mit M beginnt auf ein Datenfile geschrieben.

**$** Zeigt die Directory einer Diskette auf dem Bildschirm.

**!** Erlaubt das Aussortieren fremder Listen wenn die eigene Liste in den Computer geladen wurde. Es werden alle Daten, die in der fremden Liste sind, mit den eigenen nach Kriterium (Anzahl Zeichen von links) durchsucht. Ein in der eigenen Liste nicht vorhandener Datensatz wird dann auf ein Differenzfile abgelegt.

(B. Winkler / gk)

# ESF: Editieren sequentieller Dateien

> Oft kommt es vor, gerade beim Programmieren von Datei-Verwaltungen, daß sich Fehler einschleichen. Wenn sich diese Fehler innerhalb einer sequentiellen Datei befinden, hilft Ihnen dieses Programm, sie zu finden und zu verbessern.

Mit diesem Programm können Sie jede beliebige sequentielle Datei lesen, editieren, drucken und wieder neu abspeichern. Es gibt mehrere Anwendungsfälte für ESF:

1.	Sie haben auf einer Diskette ein sequentielles File und möchten wissen, was dort gespeichert steht. Mit ESF ist das kein Problem.
2.	Sie benutzen in einem Programm eine sequentielle Datei und erhalten bei der Ausgabe nicht das gewünschte Ergebnis. Um den Fehler schneller zu finden, können Sie mit ESF die Datei anschauen und drucken. So erkennen Sie zum Beispiel, ob schon beim Speichern Fehler gemacht wurden oder erst beim Lesen der Daten. Somit lassen sich Fehlerquellen eingrenzen. Auch Änderungen lassen sich einfach durchführen. Datensätze können gelöscht oder verändert, aber auch zusätzliche an beliebiger Stelle hinzugefügt werden.

### Bedienung des Programms

ESF ist ein reines Basic-Programm und wird mit LOAD "ESF*",8 geladen. Es ist vollständig menügesteuert. Nach dem Start muß der Dateiname eingegeben werden. Sie sollten also vor dem Laden von ESF wissen, welche Datei bearbeitet werden soll. Die nächste Frage entscheidet über die Art des Einlesens, entweder mit GET # oder mit INPUT #.

Mit INPUT# wird jeder Datensatz bis zum nächsten Trennungszeichen (CHR$(13)) auf einmal gelesen. Mit der Leertaste werden weitere Sätze angezeigt. Jeder Datensatz wird numeriert (nur auf dem Bildschirm oder später auf dem Drucker, nicht in der Datei selbst). Die Nummern werden revers am linken Bildschirmrand ausgegeben. Sie erleichtern des Editieren.

Da Datensätze länger als 88 Zeichen sein können, kann auch GET # benutzt werden. Mit INPUT# gäbe es ein »STRING TOO LONG ERROR«. Dann wird mit jeder Betätigung der Leertaste ein einziges Zeichen gelesen. Diese Zeichen werden solange aneinandergefügt, bis das Trennungszeichen (CHR$(13)) erscheint. Es wird durch ein »*« sichtbar gemacht. Lesen mitGET # dauert zwar länger, jedoch können sämtliche Zeichen gelesen werden, also auch Kommata.

Wenn Sie einen Drucker haben, sollten Sie sich die Datei ausdrucken lassen. Das geht mit jedem Drucker, der mit OPEN 1,4 angesprochen werden kann. Auch hier werden, wie schon erwähnt, die Datensätze numeriert. Die Nummern brauchen sie beim Einfügen, Ändern und Löschen. Mit ihnen kann jeder Satz angesprochen werden.

Beim Einfügen und Andern haben Sie ebenfalls die Möglichkeit, dies entweder mittels GET oder INPUT zu machen. GET sollte dann gewählt werden, wenn im Datensatz Kommata oder andere Zeichen vorkommen sollen, dielNPUT nichtakzeptiert, oder bei Eingaben länger als 88 Zeichen. In jedem Fall wird die Eingabe mit der RETURN-Taste abgeschlossen.

Die Datei kann erneut abgespeichert werden, unabhängig, ob sie verändert wurde oder nicht. Sie kann sowohl einen neuen Namen erhalten (die bisherige Version wird nicht gelöscht), als auch überschrieben werden. Eine Sicherheitsabfrage verhindert ein versehentliches überschreiben. Anschließend startet ESF erneut.

(G. Kluge)

# Track 18 — Das Chaos organisieren

> Nur der Dumme räumt auf, das Genie beherrscht das Chaos. Aber mal ganz ernsthaft, wem ist es noch nicht passiert, daß nach einer Kopieraktion von drei zusammengehörigen Programmen sich zwei davon auf der falschen Diskette wiederfanden, oder daß ihm die Reihenfolge seiner Programme nicht gefiel und er bei dem Versuch das zu ändern nach einigen Stunden SCRATCH & SAVE verzweifelt aufgab?

Dies muß ein Ende haben, dachte ich mir und ging daran, ein Werkzeug zu entwickeln, daß das Chaos beherrscht und Ordnung in wirre Diskettenverhältnisse bringt. Ob das Programm deswegen geniale Züge trägt, verbietet mir die Bescheidenheit zu diskutieren. Bleiben wir bei den Fakten.

Track 18 ist von der Grundkonzeption her dafür gedacht, ein Diskettendirectory umzusortieren und an geeigneter Stelle Bemerkungen anzubringen. Darüber hinaus bietet es einige nützliche und teilweise nicht alltägliche Features. So zum Beispiel die Möglichkeit, eine Bemerkung (etwa Informationen über einzelne Programme) in einen freien Bereich auf Spur 18 zu schreiben. Sollte jemand, wie ich auch, es vorziehen, Schreibschutzaufkleber zum Beschriften seiner Disketten zu verwenden, es sei ihm gewährt - Track 18 bietet auch einen Softschutz. Auch die Möglichkeit einzelne Files zu schützen, die das DOS der 1541 vorsieht, wird genutzt.

Das Programm arbeitet ausschließlich mit Spur 18 (Hex $12), wenn man von den Auswirkungen einiger Diskettenbefehle absieht.

Die Programmbedienung wird dem Anwender durch konsequente Menüführung leicht gemacht.

Der Aufbau en Detail:

**Das Hauptmenü:**
Directory einlesen
Directory bearbeiten
Neues Directory schreiben
Directory von Disk
Disk Command senden
Diskettennamen ändern
Disk-Kommentar
Files schützen/freigeben
Schreibschutz
Ende

Der aktuelle Menüpunkt ist durch reverse Schrift hervorgehoben. Die Auswahl der Positionen erfolgt über die Cursor-up/down Taste, die den reversen »Balken« verschiebt. Aus dem angewählten Programmteil kann zu jedem Zeitpunkt durch F1 ins Hauptmenü zurückgekehrt werden.

### Directory einlesen

Dieser Menüpunkt gehört zu dem auch optisch abgetrennten Komplex »Directory bearbeiten«. Das Directory muß zur Bearbeitung in den Speicher gelesen werden. Nur hier wird umgestellt, sortiert und eingefügt. Und um genau diese Dinge zu tun, bewege der geneigte Anwender den reversen Balken auf den Menüpunkt.

### Directory bearbeiten

Sofort nach Betätigen der Return-Taste (vorausgesetzt man hat vorher das Directory eingelesen) erscheint ein komplettes Inhaltsverzeichnis auf dem Bildschirm. Die bis zu 144 Files werden auf 9 Seiten dargestellt, die mit der Cursor-up/down Taste umgeblättert werden können. Komplett heißt, auch freie Plätze, die durch SCRATCH entstanden sind, werden angezeigt und können mit den Funktionen
F3 = Sortieren
F5 = Einfügen
F7 = Löschen
wie jeder andere Fileeintrag behandelt werden. So kann ein Freiplatz an eine Stelle verschoben werden, wo beim nächsten SAVE der Programmname aufgenommen werden soll.

### Sortieren

Die Routine ermöglicht das Verschieben eines Files von einer Position zu einer anderen. Nach Drücken von F3 wird erst nach der Platznummer des Files gefragt, das verschoben werden soll, dann wohin es geschoben werden soll.

### Einfügen

Hier wird nach der Platznummer gefragt, vor die eine Bemerkung gestellt werden soll. Da das System niemandem vorschreibt, welcher Art eine solche Bemerkung sein soll, — es wird unverbindlich eine Reihe Bindestriche angeboten — fragt es noch nach dem Bemerkungstext. Dieser wird dann als Programmfile getarnt in die Inhaltsliste aufgenommen. Ein Versuch diesen »blinden Passagier« durch LOAD später aufzurufen endet allerdings mit einem ERROR, da der Verweis auf den Fileanfang auf der Diskette fehlt.

### Löschen

Dieser Menüpunkt ist mit etwas Vorsicht zu genießen. Nach Angabe der gewünschten Platznummer wird dieser Platz, ob Bemerkung, ob File, schonungslos gestrichen — wohlgemerkt nur im Speicher. Erst die Rückkehr ins Hauptmenü und dann die Anwahl des Punktes.

### Neues Directory schreiben

bannt alle Veränderungen auf die Diskette. Da dieser Programmteil alle, auch ungewollte Änderungen am Directory endgültig macht, wird zur Sicherheit noch einmal eine Befehlsbestätigung verlangt. Sollte man sich seiner Sache nicht ganz sicher sein, ist es ratsam, noch einmal einzulesen.

Ein auf die Diskette zurückgeschriebenes Inhaltsverzeichnis ist natürlich ohne Einschränkungen funktionsfähig.

### Directory von Disk

Dieser Programmteil stellt das im Moment tatsächlich auf der Diskette vorhandene Directory dar, ebenfalls in Seiten zu je 16 Files. Die Routine ist nicht übermäßig schnell und kann daher zu jedem Zeitpunkt mit F1 abgebrochen werden. Man kann auf diese Weise sofort den Erfolg seiner Arbeit kontrollieren, denn die Art der Darstellung entspricht genau dem »LOAD "$"« Befehl in Basic.

Die im Folgenden beschriebenen Programmfunktionen beinhalten praktisch alles, was man braucht, wenn man die in Spur 18 enthaltenen Informationen verändert. Zunächst jedoch die einzige Routine, die etwas aus dem Rahmen fällt, weil sie nicht auf Spur 18 begrenzt ist:

### Disk-Kommando senden

Ohne OPEN-Anweisung kann jeder Befehl, den das DOS versteht, an die Diskettenstation geschickt werden. Das Format der Befehle ist dasselbe wie bei »OPEN«. Jedoch wird nur der Teil gebraucht, der normalerweise in Anführungszeichen steht. Ein Befehl darf bis zu 70 Zeichen lang sein.

### Diskettennamen ändern

Wer möchte nicht manchmal eine Diskette umbenennen, ohne sie gleich zu formatieren? Name und ID sind gemeinsam oder einzeln veränderbar, ohne die übrigen Informationen auf der Diskette zu berühren. Ein echter Leckerbissen.

### Disk-Kommentar

Hier wird brachliegender Speicherplatz sinnvoll genutzt! In 80 freie Bytes des Block 0 auf Spur 18 kann eine 80 Zeichen lange Bemerkung geschrieben werden. Nach dem Anwählen dieses Menüpunktes gelangt man in ein Untermenü mit den Positionen:

### Lesen

hier wird nur der vorhandene Text ausgelesen.

### Schreiben

Vor jedem Schreibvorgang wird der schon vorhandene Text eingelesen und im vier Zeilen langen Arbeitsfeld dargestellt. Er kann nun überschrieben oder zeilenweise editiert werden.

### Files schützen/freigeben

Das DOS bietet eine Möglichkeit, einzelne Files vor versehentlichem »exitus« zu beschützen. Ein geschütztes File kann nicht geSCRATCHt werden. Es ist höchstens noch mit der Löschen-Funktion von »Track 18« auszuradieren (außer man gibt es vorher wieder frei).

Und hier ist die vielleicht wichtigste Routine:

### Schreibschutz

Was bisher nur mit einem Klebeschild zu bewerkstelligen war, findet nun unsichtbar softmäßig auf der Diskette statt. Eine Diskette, die mit »Track 18« geschützt ist, verweigert jeglichen Schreibzugriff. Lesen ist weiterhin problemlos möglich. Als Kennzeichen steht in der Namenszeile des Directory beim Laden nicht mehr 2A, sondern zwei »Kleiner«-Zeichen.

Der Vollständigkeit halber befindet sich noch die Anweisung

### Ende

im Menü. Das Programm beendet sich nach einer Rückfrage selbst mit einem normalen END. Wer möchte, kann statt der END-Anweisung den Befehl SYS 64738 einfügen. Damit findet dann ein Reset statt, und der Computer steht für weitere Aufgaben wieder jungfräulich zur Verfügung.

Nach dieser ausführlichen Erläuterung bleibt mir nur noch ein Ratschlag: Für Probeläufe nach dem Eintippen und zum Einarbeiten auf jeden Fall eine besondere Probediskette verwenden, damit bei Eingabefehlern keine wichtigen Daten oder Programme zerstört werden.

## Tips zum Tippen

Die im Programm verwendeten REM-Zeilen dienen nur der optischen Gliederung des Listings. Sie werden von keiner Sprunganweisung angesprungen, so daß man ohne unangenehme Folgen darauf verzichten kann.
Die folgende »PRINT AT«-Maschinenroutine habe ich dem Data Becker Buch »64 Intern« entnommen. Sie ist die kürzeste, die mir bekannt ist. lm Programm wird sie mit SYS P,x,y aufgerufen, wobei P=828 (=$033C).

<pre>033C JSR $AEFD prüft auf Komma
033F JSR $B79E holt numerischen Wert ins X-Register
0342 TXA
0343 PHA
0344 JSR $AEFD
0347 JSR $AEFD
034A PLA
034B TAY
034C CLC
034D JMP $FFF0 Cursor setzen</pre>

Allen leidenschaftlichen Programmierern und Programmverbesserern sei gesagt: »Track 18« ist ausbaufähig! Für diesen Zweck habe ich mir Mühe gegeben, das Programm modular aufzubauen und zumindest die wichtigsten Routinen wasserdicht zu machen. Das heißt, vor dem Aufruf mit GOSUB werden die benötigten Werte in einige festgelegte Variablen geschrieben und die Routine gibt ihre Antwort über andere festgelegte Variablen. Jede andere von der Routine benutzte Variable wird direkt am Ort des Geschehens neu belegt (Arrays und Programmkonstanten ausgenommen). Wer diesem Prinzip treu bleibt, wird bei einem Ausbau des Programms keine Probleme haben.

(Andreas Kölbach / ev)

# Disketten-Meister

> Um leichter mit der Diskette arbeiten zu können, benötigen Sie nur diese kleine Basic-Erweiterung.

Die hier vorgestellte Basic-Erweiterung umfaßt 24 neue Befehle, die es ermöglichen, den Umgang mit dem Diskettenlaufwerk sowohl im Direktmodus als auch im Programm erheblich zu vereinfachen. Autostart, menügesteuertes Laden von Programmen sowie das Speichern von Maschinenprogrammen sind nur 3 der vielen Möglichkeiten dieses Programms.

Die Befehle im Einzelnen:

### @

Der Fehlerkanal des Laufwerks wird gelesen und auf dem Bildschirm angezeigt.

### @S

Der Fehlerkanal wird gelesen und die Nummer des Fehlers in Speicherstelle 251 abgelegt. Die Abfrage erfolgt nun mit PRINT PEEK (251). Die Bedeutung der Fehlernummern ist aus dem Floppy-Bedienungshandbuch Seite 36 bis 39 zu entnehmen.

### $

Das Inhaltsverzeichnis der Diskette wird auf dem Bildschirm seitenweise angezeigt, das heißt daß die Ausgabe nach 23 Zeilen stoppt und das Programm eine Menüzeile ausgibt. Nun hat man die Möglichkeit die folgenden Zeilen zu listen oder die Ausgabe zu beenden.

### $$

Dieser Befehl erlaubt es auf einfachste Art ein Programm zu laden ohne den Namen des Programms einzugeben. Hier wird das Inhaltsverzeichnis der Diskette gelistet, wobei jeder Zeile eine Programmnummer vorangestellt ist. Sind 20 Zeilen ausgegeben, so erscheint eine Menüzeile. Man kann nun die nächste Seite listen, die Ausgabe beenden, oder ein Programm laden. Drückt man nun die Taste für »Laden«, so ist nur die Nummer des Programms einzugeben, »RETURN« zu drücken und das jeweilige Programm wird in den Basic-Speicher geladen. Es besteht die Möglichkeit durch ein der Programmnummer nachgestelltes &-Zeichen einen Autostart durchzuführen.

### #

Die aktuelle Geräteadresse wird auf dem Bildschirm angezeigt. Sie wird beim Start des Programms automatisch auf 8 gesetzt.

### #9

Ändern der Geräteadresse. Alle folgenden Befehle beziehen sich auf Geräteadresse 9.
### #8

Alle Befehle beziehen sich wieder auf Geräteadresse 8.

### #E
Die Befehlserweiterung wird ausgeschaltet. Dies ist notwendig, wenn man ein anderes Maschinenprogramm in den Speicher ab $C000 laden will, ohne daß das System aussteigt. Alle Zeiger werden wieder in ihre Ausgangsposition gesetzt.

### £"Name"

Die Startadresse des jeweiligen Programms wird auf dem Bildschirm angezeigt. Dieser Befehl kann bei unbekannten Startadressen von Maschinenprogrammen eine nützliche Hilfe sein.

### %"Name"

Das Programm mit dem angegebenen Namen wird geladen. Dieser Befehl lädt ein Programm immer an die Adresse, die im Programm abgespeichert ist. Es lassen sich so auch Maschinenprogramme laden.

### &"Name"

Autostart-Befehl. Das Programm wird geladen und danach selbständig gestartet. Dies ist nur mit Programmen möglich, die im Basic-Speicher abgelegt sind.

### !"Name"

Das im Speicher befindliche Basic-Programm wird unter dem angegeben Namen auf Diskette gespeichert.

### !"Name",S,E

Dieser Befehl ermöglicht das Speichern von Maschinenprogrammen, wobei »S« die Startadresse und »E« die Endadresse ist. Es muß beachtet werden, daß »E« die Endadresse + 1 des abzuspeichernden Bereichs ist.

### V

Der Validate-Befehl wird ausgeführt.

### ←I

Initialisiert eine Diskette.

### ←N"Name,ID"

Formatiert eine Diskette.

### ←N"Name"

Reformatiert eine Diskette ohne Änderung der ID. Dies funktio-niertjedoch nur bei bereits formatierten Disketten.

### ←C"nf=af"

Das File »af« wird mit dem Namen »nf« kopiert.

### ←C"nf=file1,file2"

Es besteht die Möglichkeit maximal 4 sequentielle Datenfiles zu einem mit neuem Namen zusammenzufassen.

### ←R"nfn=afn"

Das File mit dem Namen »afn« wird zu »nfn« umbenannt.

### ←S"file"

Das File mit dem Namen »file« wird gelöscht.

### ←S"file1,file2,.."

Es können auch mehrere Files gleichzeitig gelöscht werden.

### ←S"fi*"

Es werden alle Files gelöscht, die mit dem Buchstaben »fi« beginnen.

### ←S"*"

Alle Files einer Diskette werden gelöscht.

Eingabe des Programms
Das Basic-Programm bildet jeweils von fünf DATA-Zeilen eine Prüfsumme. Ist diese fehlerhaft, so stoppt das Programm und zeigt die jeweilige Blocknummer auf dem Bildschirm an. Waren die Prüfsummen aller 20 Blocks fehlerfrei, stoppt das Programm mit dem Hinweis die richtige Diskette einzulegen. Nach Drücken einer Taste wird das Maschinenprogramm unter dem Namen »Disk-Master/M« auf Diskette gespeichert. Um das Laden und Starten zu erleichtern, muß der Basic-Lader eingetippt werden.

Laden des Programms mit Basic-Lader:
LOAD"Disk-Master",8. Ist die Ready-Meldung erfolgt, so ist einfach RUN einzugeben und das Maschinenprogramm wird geladen und gestartet.
direkt:
LOAD"Disk-Master/M",8,1. Ist die Ready-Meldung erfolgt, muß das Programm mit SYS 49152 gestartet werden.

Allgemeine Hinweise zur Programmbenutzung:
Will man im Rahmen eines Basic-Programmes einen Befehl hinter einer »IF...THEN« Abfrage benutzen, so ist vor dem Befehl ein Doppelpunkt zu setzen, da sonst eine Fehlermeldung ausgegeben wird.

Sollen die Befehle —N, —R, —S, —C im Programm verwendet werden, so sollten die nachfolgenden Parameter in einer String-Variablen gespeichert sein.

Will man im Anschluß an »Disk-Master« noch andere Programme abspeichern, so darf die Startadresse des folgenden Programms nicht kleiner als $C900 sein.

(Armin Haas/rg)

# Fileprotect 64

? Sicher kennen auch Sie das Problem: »OPEN1,8,15,"S:xyz*"« und schon ist es passiert! Wie leicht löscht man unbeabsichtigt ein Programm oder eine Datei von der Diskette.

Das Programm Fileproject 64 sorgt dafür, daß Ihnen so etwas nicht mehr passieren kann. Mit ihm lassen sich alle Filetypen der Floppy 1541 vorm Scratchen schützen. Natürlich kann der Schutz auch wieder entfernt werden.

Die Sprungadressen sind so angelegt, daß Sie beim Abtippen die REM-Zeichen nicht mit eingeben müssen.

Nach dem Starten des Programms erscheint das Titelbild mit dem Menü (Bild 1), von dem aus Sie in drei Unterprogramme verzweigen, oder das Programm beenden können. Drücken Sie hier die »F8-Taste«, so erzeugen Sie einen System-Reset (SYS 64738). Haben Sie Fileprotect 64 noch nicht abgespeichert, müssen Sie es mit der »STOP-Taste« beenden, sonst war die Arbeit des Abtippens umsonst...

Nehmen wir an, Sie wollen das Directory einer Diskette einlesen. Betätigen Sie dazu bitte die »F1-Taste«. Der Bildschirm wird gelöscht, es erscheint die Überschrift »DIRECTORY« und Sie werden aufgefordert eine Diskette einzulegen und eine Taste zu drücken. Sollten Sie versehentlich eine Taste drücken und es befindet sich noch keine Disk im Laufwerk, so wird die Fehlermeldung »DISK FEHLER« ausgegeben (Bild 2) und ein erneuter Tastendruck erwartet. Nach Auflisten der Einträge müssen Sie wieder eine Taste drücken (Bild 3), um zum Menü zurückzukehren. Hat das Directory mehr als 15 Einträge, so erscheint die Meldung »WEITERE EINTRAEGE BITTE TASTE DRUECKEN« und es wird eine neue Seite angelegt und angezeigt.

Möchten Sie ein Programm schützen, betätigen Sie die »F3-Taste«. Jetztwerden Sie erneut aufgefordert, eine Diskette einzulegen und eine Taste zu drücken. Haben Sie dies getan, prüft Fileprotect 64, ob eine Disk eingelegt ist und ob sie mit einem Schreibschutz versehen ist! Ist dies der Fall, wird die Fehlermeldung »SCHREIBSCHUTZ ENTFERNEN« ausgegeben (Bild 4). Haben Sie eine korrekte Disk eingelegt, durchsucht das Programm die Directory nach ungeschützten Files; wurde ein solcher Eintrag gefunden, so wird dessen Filetyp und Name ausgegeben. Danach erscheint »PROTECT (J/N)« (Bild 5) und Sie können entscheiden, ob Sie das File schützen wollen oder ob nicht. Sind keine weiteren ungeschützten Files auf der Diskette, kehrt das Programm zum Menü zurück. Drücken Siejetzt die »Fl-Taste« und lesen das Directory ein, so erkennen Sie geschützte Files an dem &gt;-Zeichen hinter dem Filetyp. Wählen Sie erneut »Protect« an, werden Sie feststellen, daß die eben geschützten Files nicht mehr abgefragt werden! Möchten Sie den Scratchschutz wieder entfernen, wählen Sie »F5 UNPROTECT«. Alles weitere läuft dann so ab, wie Sie es von »Protect« kennen.

Nun möchte ich noch einige Worte über die Funktionsweise von »Fileprotect 64« sagen.

Das Betriebssystem der Floppy 1541 kennt, wie Sie sicher wissen, fünf verschiedene Filetypen. Diese können geöffnet, geschlossen oder geschützt sein. Somit sind dann 15 verschiedene Zustände möglich. Der Filetyp wird in der Directory durch das erste Byte eines Fileeintrages gekennzeichnet. Wie Sie in Tabelle 1 sehen, unterscheidet sich ein geschützter Filetyp von einem ungeschützten durch das gesetzte sechste Bit. Das Setzen des Bits erreicht man, indem man den ungeschützten Filetyp durch die »OR«-Funktion mit der Zahl 64 verknüpft. In Tabelle 2 sehen Sie an dem Beispiel »PRG«, wie die OR-Verknüpfung arbeitet. Die beiden Operanten werden Bitfür Bit verglichen. Ist in einem der Faktoren ein Bit gesetzt, also 1, wird es auch im Ergebnisbyte gesetzt. Um das sechste Bit wieder auf 0 zu setzen, wählen wir die Verknüpfung »AND«. Jetzt ergibt sich eine 1 im Ergebnisbyte nur dann, wenn beide Faktoren den Wert 1 haben. Diese Eigenschaft können wir nutzen, um eine bestimmte Bitstelle auf 0 zu setzen. Wir verknüpfen das geschützte Byte mit dem Faktor 191 (dual 1011 1111) und erhalten wieder den ungeschützten Filetyp 130 (Tabelle 3).

Genug der grauen Theorie! Wie kann man diese Änderungen nun auf der Diskette vornehmen? Dazu müssen wir den Filetyp (1 Byte) von der Disk lesen, ihn ändern und dann wieder zurückschreiben. Das Betriebssystem der 1541 sieht hierzu die Befehle »U1« (Block lesen) und »U2« (Block schreiben) vor. Mit diesen Befehlen können Sie aber nur ganze Blöcke, also 256 Byte m den Puffer einer Direktzugriffsdatei einlesen oder aus ihm auf die Diskette schreiben. Da wir nur ein bestimmtes Byte benötigen nutzen wir die Möglichkeit, den Zeiger, der die augenblickliche Lese oder Schreibposition im Puffer angibt, auf einzelne Bytes setzen zu können. Der Befehl hierfür lautet »B-P« (Buffer Pointer). Alle Befehle, die für die Floppy bestimmt sind, werden über den Befehlskanal gesendet, der im »OPEN«-Befehl (Zeile 640) durch die Sekundäradresse 15 angesprochen wird. Mit dem PRINT #-Befehl werden jetzt die Kommandos übermittelt. Zum Beispiel lesen eines Sektors von Spur 18 (Zeile 2160). Daten können nicht direkt von der Diskette in den Computer eingelesen werden, sondern müssen in einem Datenpuffer zwischengespeichert werden. Dazu eröffnen wir eine Direktzugriffsdatei (Zeile 650), aus der wir dann mit dem GET #-Befehl die Bytes einzeln herauslesen.

Im Bild 7 sehen Sie ein kleines Beispiel für die Anwendung der genannten Befehle. Mit diesem Unterprogramm können Sie den Namen einer Diskette einlesen.

TODO

Die Funktionen der einzelnen Variablen entnehmen Sie bitte Tabelle 5. Eine wichtige Anmerkung: Damit Fileprotect 64 einwandfrei arbeitet, muß in Zeile 2499 hinter dem »(FT)« unbedingt ein Semikolon (;) gesetzt sein! Ist dies nicht der Fall, können Sie geschützte Programme nicht mehr laden. Ohne Semikolon wird ein CHR$(13) an den Wert angehängt. Es würden also zwei Byte und damit die Startadresse des Programms überschrieben!

(Jochen Fette / rg)

# P-Basic-V2: Autostart mit Rückwärtsgang

> Dieser Autostarter erzeugt nicht nur ein einfaches Lade-Programm für Basic und Assembler-Programme. Es wird zusätzlich die RUN/STOP-Taste gesperrt und ein Kopierschutz installiert. Um ein so behandeltes Programm wieder verändern zu können, kann mit einem Befehl der gesamte Vorgang rückgängig gemacht werden.

Das Programm »P-Basic-V2« läuft auf dem Commodore 64 (ohne Basic-Erweiterung) und der Floppy 1541 (nicht auf der Datasette, da das Programm beim Laden den Kassettenpuffer benutzt). Es ist zirka 260 Bytes lang und liegt im Speicher ab 49152 ($c000).

Nach dem normalen Laden und Starten des Basic-Programmes, ist das Basic-V2 um drei neue Befehle erweitert:
1. !SAVE"Name", Gerätenummer,1
2. !LOAD"Name", Gerätenummer,1
3. !NEW

Der Hauptbefehl ist !SAVE. Mit ihm kann man ein Basic-Programm oder ein Maschinenprogramm (mit Basic-Startzeile) so abspeichern, daß es nach dem Laden von allein startet. Außerdem wird die RUN/STOP/RESTORE-Taste abgestellt. Das Programm ist somit vor Änderungen gesichert. Auch das Kopieren ist nur mit besonderen Kopierprogrammen möglich. Doch durch eine Codewortabfrage in den ersten Zeilen wird es wohl keiner schaffen, das Programm zum Laufen zu bringen. Ein Programm, das mit dieser Basic-Hilfe abgespeichert wurde, muß mit dem Zusatz »,1« absolut, nicht ab Basic-Start (2049), geladen werden. Lädt man ein solches Programm ohne diesen kleinen Zusatz in den Speicher, so läßt es sich weder listen, noch starten. Weil ein normales Programm mit der Zwei-Byte-Startadresse am Anfang der Datei gespeichert wird, ist es durch ein nochmaliges anderes Abspeichern ganz verloren.

Man kann diese Routine natürlich auch nur zur Bequemlichkeit benutzen. Um die Stopp-Routine wieder zu aktivieren, hilft: POKE808,237 als erster Befehl des Programms.

Ist in dem geschützten Programm nun aber ein Fehler, oder will man es erweitern oder verbessern, so hilft der zweite Befehl. Mit !LOAD kann man alle Programme, die mit Autostart geschützt sind, knacken und nach eigener Lust bearbeiten.

Tritt bei den Arbeiten mit diesen Befehlen ein Fehler auf, den Sie oder das Betriebssystem (Floppy/Computer) verursacht haben, so können sie mit Eingabe von !NEW alle wichtigen Vektoren korrigieren und somit das gerade bearbeitete Programm wieder listen lassen.

### Erläuterungen zum Assemblerlisting

In dem Programmabschnitt »Vektorsetzung« wird die Routine zur Erkennung der Befehls-Token (Basic-Befehle) auf die erweiterte Routine (Erkennung) umgelenkt und danach der Name der Basic-Erweiterung ausgegeben.

In der Erkennungsroutine werden die Befehls-Token mit dem neuen Befehl (!) und danach mit den eigentlichen Befehlen (SAVE, LOAD, NEW) verglichen. »SAVE« hat das Basic-Token 148, »LOAD« hat 147 und »NEW« hat 162. Wird keiner dieser Befehle interpretiert, so wird Syntax Error (Jmp $afO8) angezeigt. Die DATAs werden in der Vektorsetzungsroutine ausgegeben.

Der Befehl »LOAD«, der wie der Befehl »SAVE« nur im Direktmodus verwendet werden darf, setzt zuerst das Programmodusflag, damit es keine Ausgabe wie »searching for...« und so weiter gibt. Danach werden die LOADparameter geholt ($e1d4) und nach LOAD verzweigt ($ffd5). Nachdem das Programm geladen ist, werden alle Vektoren mit der NEW-Routine wieder zurückgesetzt und dann zur END-Routine verzweigt ($a831).

Der Befehl »SAVE« gleicht am Anfang (bis Ende Zeile 166) dem LOAD-Befehl. In Zeile 168 wird die Steuerroutine in den Kassettenpuffer (Sprite 11) geladen. Dann werden die »Input«-und »Output«-Vektoren auf die Steuerroutine gesetzt und das Programm ab Byte 806 gespeichert. Die Vektoren werden dann mit der NEW-Routine normalisiert.

Die Steuerroutine arbeitet ungefähr so wie die NEW-Routine. Nur bei dieser Routine werden zusätzlich die RUN-Zeiger ($a659) gesetzt, die Run-Stop/Restore-Funktion abgeschaltet und dann zur Interpreterschleife verzweigt.

### Bemerkungen zum Programm

Das Befehlszeichen »!« kann natürlich durch fast jedes Zeichen ersetzt werden, nur wenn das Zeichen ein Token ist, muß nicht der ASCII-Wert, sondern der Tokenwert angegeben werden, da sonst der Befehl nicht erkannt wird. Wenn das Zeichen ein Buchstabe ist, kann derselben Variablen kein Wert zugewiesen werden. Denn auch dabei entsteht ein Fehler.

(Jan Kusch/gk)

# Toolkit für Programmierer

> Nicht jeder kann sich professionelle Toolkits wie zum Beispiel Ex-Basic Level II leisten. Dieses Programm hat deshalb einige der wichtigsten Funktionen, die das Programmieren sehr erleichtern.

Dieses Programm für den Commodore 64 bietet 8 leistungsfähige Befehle und 2 zusätzliche Funktionen, die bei der Programmerstellung und beim Austesten von Programmen besonders nützlich sind. Hier die Erklärung zu den einzelnen Befehlen:

### !AUTO X,Y

Dieser Befehl erspart Ihnen das Eintippen der Zeilennummern. Mit X geben Sie die Anfangszeilennummer ein. Mit Y die Schrittweite, um welcher die Zeilennummern erhöht werden sollen. X kann eine positive Integerzahl sein. Y kann im Bereich von 0-255 liegen. Wenn Sie den AUTO-Befehl eingetippt haben, erscheint nach Drücken derC= Taste zusammen mit der Taste F7 die erste Zeilennummer. Schreiben Sie nun Befehle hinter die Zeilennummer und schließen Sie mit RETURN ab. Wenn Sie nun wieder die Taste C = und F7 drücken, erscheint eine um Y erhöhte Zeilennummer. Abgeschaltet wir die AUTO-Funktion mit der C= Taste zusammen mit F1. Außerdem wird diese Funktion abgeschaltet, wenn Sie RUN/STOP und RESTORE drücken.

### !DUMP

Damit können Sie sich sämtliche Variablen mit ihrem aktuellen Inhalt ansehen. Indizierte Variablen werden nicht mit ausgegeben. Das Auflisten der Variableninhalte kann mit der CTRL-Taste verlangsamt, oder mit der STOP-Taste abgebrochen werden.

### !FIND

Hierbei muß unterschieden werden zwischen dem Suchen in Zeichenketten und dem Suchen von Befehlen und Variablen. Zum Beispiel: »!FIND "TEST"«; »!FIND GOTO1000« oder »! FIND A$«. Es werden jeweils die kompletten Zeilen gelistet in denen der Suchbegriff vorkommt. DieserVorgang kann wie bei dem DUMP -Befehl mit der CTRL - Taste verlangsamt oder mit STOP ganz abgebrochen werden.

### !KILL

Löscht statt einzelne Zeilen ganze Zeilenblöcke.
Beispiel:
!KILL 100-200 — löscht die Zeilen 100 bis einschließlich 200.
!KILL -300	— löscht die Zeilen vom Programmanfang bis einschließlich 300.
!KILL 1800-	— löscht die Zeilen ab 1800 bis zum Programmende.

Bei diesem Befehl muß folgendes beachtet werden:

Die erste Zeilennummer muß kleiner als die Endzeilennummer sein. Weiter ist notwendig, daß die Anfangszeilennummer im Programm existiert. Andernfalls kommt die Fehlermeldung ’SYNTAX ERROR’. Bei umfangreicheren Zeilenblöcken dauert die Ausführung dieses Befehls eine Weile. Mit der Taste ’F7’ kann das Löschen von Zeilenblöcken abgebrochen weden.

### !LOAD

Dieser Befehl hängt an einem im Speicher befindlichen Programm ein weiteres an. Die Syntax ist wie bei dem LOAD-Befehl. Es ist vorteilhaft, wenn das nachzuladende Programm höhere Zeilennummern hat, aber nicht unbedingt notwendig. Sie haben ja mit dem RENUM-Befehl die Möglichkeit das Programm neu zu numerieren. Nur bei gleichen Zeilennummern kann es zu Fehlern beim Umnumerieren der Sprungbefehle kommen.

### !RENUM

Hiermit numerieren sie Ihr Programm mit einer von Ihnen angegebenen Schrittweite neu durch. Sie haben bei diesem Befehl mehrere Möglichkeiten.
!RENUM — ohne weitere Parameter numeriert das komplette Programm in Zehnerschritten durch. Die erste Zeilennummer ist 10.
!RENUM X,Y — Hierbei ist X die erste neue Zeile und Y die Schrittweite. *
!RENUM X,Y,Z — Damit numerieren Sie nicht das komplette Programm neu, sondern ab der Zeile die in Z angegeben ist. Z muß dabei kleiner als X sein. Als Parameter werden jeweils positive Integerzahlen erwartet. Selbstverständlich werden sämtliche Sprungbefehle (GOTO, GOSUB, THEN, ON X GOTO (GOSUB), RUN) mit umnumeriert.

### !TRACE

Damit können Sie ein Programm schrittweise abarbeiten. Nachdem Sie !TRACE eingegeben und ein Programm mit RUN gestartet haben, wird in den oberen beiden Zeilen des Bildschirms die Zeile gelistet, die gerade bearbeitet wird. DamitSie sehen, welcher Befehl in dieser Zeile gerade ausgeführt wird, wird dieser revers dargestellt. Zur Steuerung der TRACE-Funktion stehen Ihnen die Tasten F1 und F7 zur Verfügung. Mit F1 wird ein schneller Trace ausgeführt. Mit F7 wird immer nur der nächste Befehl bearbeitet. Verlassen können Sie die TRACE-Funktion, wenn Sie beim schnellen Trace die STOP-Taste drücken.

### !OFF

schaltet die TRACE-Funktion aus.

Sämtliche Befehle können auch innerhalb eines Programms benutzt werden. Sinnvoll ist dies aber wohl nur bei ’DUMP, ’TRACE und !OFF. Zu den zwei zusätzlichen Funktionen:

1.	Trifft der Computer während des Programmlaufs auf einen Fehler, so wird automatisch die fehlerhafte Zeile gelistet. Der Cursor steht direkt unter der fehlerhaften Zeile.
2.	Beim Listen eines Programms können Sie den Listvorgang mit der Taste F7 anhalten. Sie können sich Ihr Listing nun in Ruhe betrachten. Soll der Listvorgang fortgeführt werden, so drücken Sie die SPACE-Taste. Ein mit der Taste F7 angehaltenes Listing kann mit der Taste F1 unterbrochen werden. Die STOP-Taste steht hierfür nicht zur Verfügung. Bei der Taste F1 wird BREAK und READY (wie es bei der STOP-Taste der Fall ist) nicht mit ausgegeben. Sie haben so mehr Platz für Ihr Listing. Zu dem Programm selbst. Es steht in dem Bereich ab Speicherstelle 49152. Dieser Bereich wird vom Basic nicht benutzt. Aktiviert wird das Programm mit SYS 51100. Wollen Sie ein anderes Programm in diesem Bereich nutzen, so müssen Sie das Toolkit abschalten. Dies erreichen Sie mit einem System-Reset (SYS 64738).

Nach erfolgreichem Eintippen sollten Sie das Programm (Bild 1) mit einem Maschinensprachenmonitor speichern. Die Ladezeit verringert sich dadurch erheblich. Besitzen Sie keinen solchen Monitor, so benutzen Sie das kurze Programm in Bild 2.

(Herbert Kunz / gk)

# Eigene Basic-Befehle auf dem C 64

> Bereits implementiert sind Befehle, wie Text und hochauflösende Grafik zu kombinieren oder Hintergrundfarbe ändern. Sie können bis zu 51 neue Befehle definieren.

Das Programm ermöglicht es, eigene Basic-Befehle zu definieren. Als Beispiel sind sechs Befehle definiert worden, die den hochauflösenden Grafikmodus betreffen. Alle Anweisungen, die benötigt werden, sind in REM-Zeilen gespeichert.

(Förtsch / rg)

# Basic auf Tastendruck

Beim Programm KEYS handelt es sich um ein Maschinenprogramm, das den Bereich $C000 - $C26B benötigt. Es erweitert das Basic um die beiden Befehle »KEY« und »DISPLAY«, mit denen die Funktionstasten belegt werden können beziehungsweise diese Belegung angezeigt werden kann. Zusätzlich können die wichtigsten Basic-Befehle durch gleichzeitiges Drücken von CTRL und einer Buchstabentaste »auf Knopfdruck« auf den Bildschirm geschrieben werden, was die Programmierarbeit doch sehr vereinfachen kann.

Bei der Initialisierung mit SYS 49152, die der Basic-Lader automatisch vornimmt, werden die Vektoren auf die Routine »Basic-Statement ausführen« und die Tastaturabfrage auf $C014 beziehungsweise $C11D verbogen.

Die beiden neuen Befehle werden an einem vorangestellten »!« erkannt, anschließend prüft das Programm auf die Anfangsbuchstaben K und D ($C014 - $C02D).Folgt keiner dieser Buchstaben, so wird ein »SYNTAX ERROR« ausgegeben ($C02E). Andernfalls verzweigt es nach $C031 (KEY) beziehungsweise $C0A7 (DISPLAY).

Der »KEY«-Befehl hat das Format !KEY N, »Befehl«. Hierbei muß N zwischen eins und zwölf liegen, der Befehl darf maximal neun Zeichen umfassen, wobei Anführungszeichen durch das Hochkomma zu ersetzen sind. Ein anschließendes RETURN erreicht man durch Eingabe von »£« als letztes Zeichen.

Die Funktionstasten F1 bis F8 werden wie üblich, die Tasten F9 bis F12 durch gleichzeitiges Drücken von »C=« und einer F-Taste erreicht.

Beispielsweise bewirkt !KEY 9, »RUN£«, daß nach gleichzeitigem Drücken von »C=« und »F1« ein Basic-Programm gestartet wird.

Der »DISPLAY«-Befehl hat das Format !DISPLAY und läßt sich ebenfalls auf eine Funktionstaste legen. Er bewirkt ein Löschen des Bildschirms und die Anzeige der Belegung der 12 Funktionstasten.

Die neue Tastaturabfrageroutine prüft zunächst, ob die Control-Taste gedrückt ist. Ist dies der Fall und ist die gleichzeitig gedrückte Taste belegt, so wird aus einer Tabelle ($C1A8-$C1DE) das Token des Befehls minus $7F geladen und mit dessen Hilfe der A8CII-Code der Buchstaben des Befehls aus der Tabelle der Basic-Befehlsworte geholt. Die einzelnen Buchstaben werden in den Tastaturpuffer geschrieben und ausgegeben.

Ist die Control-Taste nicht gedrückt, so wird geprüft, ob eine Funktionstaste gedrückt ist. Wenn ja, wird mit Hilfe des Tasten-Codes die Adresse der Belegung berechnet und die einzelnen Zeichen in den Tastaturpuffer geschrieben und ausgegeben.

(Klaus Russell/rg)

TODO

Die Belegung läßt sich folgendermaßen ändern: Man sucht den Code der Taste, deren Belegung man ändern will, aus obiger Tabelle und addiert 49579 dazu. Nun subtrahiert man vom Token des gewünschten Befehls 12 7 und POKEt diesen Wert in die zuerst errechnete Adresse. Will man zum Beispiel die F1-Taste mit »VERIFY« belegen, so sieht das wie folgt aus: F1 hat den Code 4 (siehe Tabelle) Das Token für VERIFY ist 149.
Nun gibt man ein: POKE 49579 + 4,(149-127)

Danach ergibt &lt;CTRL&gt; zusammen mit F1 die Ausgabe von »VERIFY« auf dem Bildschirm. Die so geänderte Belegung läßt sich dann mit einem Monitorprogramm abspeichern. Sollen auch die Belegungen der mit !KEY belegbaren F-Tasten gespeichert werden, so muß der Bereich $C000 bis $C26B geSAVEt werden.


# Automatische Zeilennumerierung

> Die lästige Arbeit, vor jeder Zeile die entsprechende Nummer einzutippen, nimmt Ihnen diese kleine Routine ab.

Die Maschinen-Routine — ganze 141 Bytes — wird vom Basic-Lader über DATAs in den Speicherbereich ab Adresse $C000 beziehungsweise 49152 Dezimal geschützt abgelegt. Dabei führt das Basic-Programm eine Checksummenprüfung durch, da sich der Basic-Lader nach Ablauf von selbst löscht.

Vom Programm aus wird eine Schrittweite von 10 eingestellt. Diese kann aber durch Verändern des Wertes in Adresse 49296 — im Bereich von 1 bis 255 — eingestellt werden. Der Wert der ersten Zeilennummer wird in die Adressen: 49294 (High-Byte) und 49295 (Low-Byte) eingepoket, wenn Sie mit einem anderen Wert als 10 beginnen soll.
Beispiel: POKE 49296,S:POKE 49294,INT(Z/256):POKE 49295,Z-(INT(Z/256) * 256)
S = Schrittweite ; Z = Wert der ersten Zeilennummer Durch Eingabe von Pfeil-links/Return kann nun eine Zeilennummer angefordert werden. Die Vorgabe einer Zeilennummer wird akustisch untermalt. Nun kann eine Basic-Zeile wie gewohnt eingegeben und mit der Return-Taste abgeschlossen werden. Die nächste Ausgabe erfolgt wieder auf Anforderung, mit der eingestellten Schrittweite.

(Thomas Schulz/rg)

# Worktool — eine Programmierhilfe

> Drei nützliche Optionen zur Programmeingabe werden durch dieses Programm realisiert. Farbwahl, aktuelle Zeitangabe und Warnton bei mehr als 80 Zeichen Eingabe auf Tastendruck.

Wie der Name schon sagt, hilft das »Worktool« dem Programmierer bei der Eingabe seiner eigenen Programme. Mehrere Optionen, die ansonsten nur bei erheblich teureren Geräten oder Hardware-Erweiterungen zu finden sind, werden ohne Basicspeicherverlust vom Toolkit übernommen.

Mittels Funktionstasten werden folgende Erweiterungen angesprochen:

— F1: Rahmen, Innenteil und Cursor erscheinen in einer vorher von Ihnen festgelegten Farbkombination.

Beim Schreiben von Programmen oder deren Test wird die Farbkombination, die Sie zur Eingabe verwenden, oft durch das Programm geändert. Haben Sie die Worktoolerweiterung eingegeben, können Sie sich jetzt, nach dem Probelauf 20 Tastendrücke ersparen um Farbkombinationen, wie zum Beispiel braun-rot-violett in Ihre Lieblingskombination zu verwandeln.

— F3: Ausgabe der aktuellen Uhrzeit, oder einer Stoppuhr. Wollen Sie wissen wieviel Uhr es ist, oder wie lange Sie schon mit dem Toolkit arbeiten, so genügt ein Druck auf F3. Wie sonst nur bei Steckmodulen der oberen Preisklasse wird vom Computer in der Mitte der 1. Zeile die Zeit in reverser Darstellung ausgegeben. Jedoch nicht permanent, sondern nur solange die Taste gedrückt ist. Das hat den Vorteil, daß keine Bildschirmzeile verloren geht.

— F5 und F7: Falls der eine oder andere von Ihnen schon einmal am CBM 4032 gearbeitet hat, wird er bestimmt bemerkt haben, daß dieser eine praktische Eingabehilfe besitzt. Er gibt, wenn der Cursor eine bestimmte Spalte erreicht, einen Piepser aus. Diese Option wurde beim Worktool noch erheblich verbessert. Im Direktmodus gibt er jetzt immer einen hellen Ton (ähnlich Tastaturklick) aus, sobald der Cursor die Spalte 35 oder 75 erreicht. Im Programmeingabemodus dagegen wird bei 35 der Klick, bei 75 ein Sägezahnton, und bei 80 ein auf- und abschwellender Ton erzeugt. Jeder kennt das ungeheuer langwierige und nervenzermürbende Editieren einer falsch eingegebenen PRINT-Zeile. Gerade im Programmierrausch schreibt man oft über die maximale Zeilenlänge hinaus, und muß später zeitaufwendig ausbessern. Ist mit F5 die Tonoption eingeschaltet, gibt der Computer rechtzeitig die oben genannten »Erinnerungstöne« aus. Mit F7 läßt sich diese Funktion ausschalten (hebt das Klima beim Mittagsschlaf Ihrer Frau).

Im Programm selbst wurde weitgehend auf Steuerzeichen verzichtet, und stattdessen der CHR$ und POKE-Befehl verwendet. Die DATAs sind der Übersicht und der Arbeitsersparnis halber in hexadezimaler Form einzugeben und werden von einer Routine automatisch umgerechnet. Das Programm gibt bei Fehleingabe einen Checksumfehler mit der Angabe des betreffenden Datenblocks aus. Die Funktionen einzelner Abschnitte sind in REM-Zeilen kurz umrissen. Das Basic-Programm benötigt 3k Speicher. Nachdem Sie Ihre Eingaben gemacht haben, löscht sich der Basic-Teil selbst und nur noch zirka 250 Bytes im abgeteilten Maschinensprachespeicher bei $C000 sind nötig. Es ist also der gesamte Basic-RAM frei verfügbar.

(Ulrich Grothaus / rg)

# Mini-GBasic für den VC 20

> Dieses Programm für VC 20 mit mindestens 16 KByte-Speichererweiterung implementiert zehn neue Befehle, die sich auf die Bildschirmdarstellung und die Grafik des VC 20 beziehen.

Mini-GBasic ist eine Befehlserweiterung, die schnelle Grafik-Routinen in Maschinensprache beinhaltet. Mini-GBasic bietet 10 neue Befehle zum Beispiel zum Setzen oder Löschen eines Punktes oder zum Verbinden zweier beliebiger Punkte. Außerdem wird ein Scrollen des Bildschirmes in alle vier Richtungen ermöglicht, was bei Spielen sehr nützlich sein kann. Mini-GBasic zeichnet sich dadurch aus, daß die neuen Befehle voll implementiert sind, so daß auch nach einem IF...THEN-Statement kein Doppelpunkt gesetzt werden muß, wenn einer der neuen Befehle folgt (dies ist bei, mir aus anderen Computerzeitschriften bekannten, ähnlichen Programmen leider nicht der Fall).

Zu erwähnen ist noch, daß man bei Mini-GBasic für die Befehle DRAW beziehungsweise CDRAW und SET beziehungsweise RESET benötigte Parameter, wie bei Basic-Funktionen, in Klammern eingeschlossen übergibt (dabei wird zur Übernahme beliebiger Ausdrücke das ROM-Unterprogramm GET-BYTE ab Adresse $ D79B verwendet).

## Zur Fehlerbehandlung

Das Programm gibt die im »normalen« Basic vorhandenen Fehlermeldungen »illegal quantity error in...« bei für die Grafik-Befehle nicht definierten Parametern und »syntax error in...« bei fehlenden Klammern und falsch eingegebenen Befehlsworten, die immer ausgeschrieben werden müssen, aus.

Zu den allgemeinen Möglichkeiten des Programmes ist noch zu sagen, daß es mit 29568 (x-Achse:0-167; y-Achse:0-175) im 16x8-Byte-Modus arbeitet.

**Wichtig**: Falls Sie das mit dem »Basic-Lader« geSAVEte Maschinenprogramm testen wollen, müssen Sie nach dem Ladevorgang erst einen System-Reset mit SYS 64802 durchführen und danach das eigentliche Maschinenprogramm mit SYS 9794 starten (das Programm setzt automatisch den Basic-Start herauf und führt den Befehl »New« aus).

## Zur Eingabe des Programms

* Vor dem Eintippen des Basic-Laders wird der Basic-Start mit den Befehlen POKE 9823,0:POKE 43,96:POKE 44,38:NEW heraufgesetzt. Dies ist notwendig, da sich der Basic-Lader sonst selber überschreiben würde.
* Nach dem Start des Basic-Laders wird das Maschinenprogramm eingePOKEt und eine Prüfsumme erstellt. Bei fehlerhafter Eingabe der DATAs wird eine Fehlermeldung ausgegeben.
* Der Basic-Lader wartet mit Ausgabe der Frage »Bereit zum Absaven?« auf Eingabe der Taste »j«. Danach wird das Maschinenprogramm abgeSAVEt.
* Das nach der eben beschriebenen Vorgehensweise geSAVEte Maschinenprogramm kann nun einfach durch Eingabe von »LOAD« an die Stelle geladen werden, an der es vor dem AbSAVEn gestanden hat. Dies wird dadurch erreicht, daß es vorher mit dem Befehl »SAVE "MINI GBASIC", 1,1« ge-SAVEt wurde.
* Nach dem Einladen des Maschinenprogrammes muß ein System-Reset durchgeführt werden (SYS64802), wonach die Befehlserweiterung mit SYS 9794 gestartet werden kann. Dieser SYS-Befehl muß auch nach eventuell durchgeführten System-Resets eingegeben werden, da dabei alle Basic-Vektoren zurückgesetzt werden. Nachdem sich die Befehlserweiterung mit »READY« gemeldet hat, können die Befehle benutzt werden.

Vor allen Befehlen muß ein Ausrufezeichen, das Erkennungsmerkmal für den Computer, daß jetzt einer der neuen Befehle folgt, stehen, da sonst eine »Syntax error«-Meldung ausgegeben wird. Nach dem Ausrufezeichen folgt der neue Befehl voll ausgeschrieben.

## Die Befehle im einzelnen

!GMODE:	Umschalten in den Grafikmodus und Löschen des Zeichensatzes.
!TMODE:	Umschalten in den Textmodus und Löschen des Bildschirmes.
!DSCROLL: Scrollt den Bildschirm (im Textmodus) um eine Zeichenposition nach unten.
!USCROLL: Scrollt den Bildschirm (im Textmodus) um eine Zeichenposition nach oben.
!LSCROLL: Scrollt den Bildschirm (im Textmodus) um eine Zeichenpostition nach links.
!RSCROLL: Scrollt den Bildschirm (im Textmodus) um eine Zeichenposition nach rechts.
!SET(x,y):	Setzt einen Punkt (im Grafikmodus) auf die Koordinate (x,y).
!RESET (x,y): Löscht einen Punkt (im Grafikmodus) auf der Koordinate (x,y,).
!DRAW (x,y): Zieht eine Linie (im Grafikmodus) von der letzten durch !SET,!RESET,!DRAW oder !CDRAW gesetzten Koordinate zur Koordinate (x,y).
!CDRAW (x,y): Löscht eine Linie (im Grafikmodus) von der letzten durch !SET,!RESET,!DRAWoder !CDRAW gesetzten Koordinate zur Koordinate (x,y)
(x,y):	x = beliebiger numerischer-oder String-Ausdruck mit dem Wert 0-167
y = beliebiger numerischer-oder String-Ausdruck mit dem Wert 0-175
!CLEAR:	Löscht den Grafik-Bildschirm

Anmerkung zu !GMODE:

Die Farbe, in der die Punkte auf den Bildschirm gebracht werden, läßt sich verändern, indem man den Inhalt der Speicherzelle 8224 (dezimal) mit dem gewünschten Farbcode belegt, bevor der Befehl !GMODE, der dann den Farbcode in den Farbspeicher bringt, ausgeführt wird.

Vorsicht ist bei der Benutzung der Grafik im Direktmodus des Computers geboten. Da der neue Zeichensatz teilweise im Bildschirm-RAM-Bereich liegt (das ist notwendig um mit der hohen Auflösung von 168 x 176 Punkten arbeiten zu können), ist es möglich, mit dem Cursor in den ersten 32 neu definierten 16 x 8 Bit Zeichen »herumzufahren«.

Für diejenigen, die selber in Maschinensprache programmieren, ist hier noch eine Liste mit den Einsprungadressen der wichtigsten Routinen und der Lage der Befehlswort-DATAs abgedruckt (Tabellen 1 und 2). Zur Benutzung der Routinen SET/RESET und DRAW/CDRAW sei noch angemerkt, daß ein Einsprung in die jeweilige Routine mit gesetztem Carry-Flag das Setzen eines Punktes beziehungsweise das Zeichnen einer Linie und der Einsprung mit gelöschtem Carry-Flag das Löschen eines Punktes oder einer Linie bewirkt.

(Jürgen Skerhut / ev)

# Delete

> Diese in Maschinensprache geschriebene Routine ermöglicht es, Basic-Programmzeilen in einem vorzugebenden Zeilennummernbereich zu löschen.

Ein ärgerlicher Nachteil des C 64-Basic und auch von Simons-Basic ist das Fehlen einer Delete-Routine zum schnellen Löschen mehrerer Programmzeilen. Das folgende Programm hilft dem ab.

Der Basic-Lader speichert das Maschinenprogramm im Kassettenpuffer ab Adresse 828 (dez.). DasProgramm kann dann auf drei verschiedene Arten aufgerufen werden:

—	SYS 828, ZN - ZN Bereich löschen
—	SYS 828, - ZN	Bis Zeile alles löschen
—	SYS 828, ZN -	Ab Zeile alles löschen

Es werden jeweils die Zeilen inklusive der angegebenen gelöscht. Da die Routine im Kassettenpuffer untergebracht ist, belegt sie keinen Basic-Speicherplatz.

(Hans-Herbert Hagedorn / ev)

# Commodore-Basic erweitert

> Mit dem hier vorgestellten Maschinenprogramm wird der Basic-Befehlssatz des VC 20 oder des C 64 um sechs Befehle erweitert.

Die 6 Befehle lauten, in die Basic-Schreibweise übersetzt, GOTO N, GOSUB N, RESTORE N, READ D,A, READ N,D,A, und POP. Einen kleinen Nachteil muß man dabei allerdings in Kauf nehmen, denn diese Routinen kann man nur dem SYS-Befehl ansprechen. Es ist also nicht möglich, eine der Routinen direkt mit einem Basic-Befehlswort aufzurufen.

Der Zugriff auf diese Befehle kann insbesondere dann von großem Nutzen sein, wenn man Programme von anderen Computern umschreiben will, die diese Befehle benutzen.

Will man einen der neuen Befehle in einem Basic-Programm benutzen, muß man nur das Basic-Wort in der oben aufgeführten Liste durch ein »SYS (Adresse)« ersetzen. Die Parameter hinter dem Befehl werden genauso hinter den SYS-Befehl geschrieben, als ob sie hinter dem Basic-Befehl stehen würden.

Bei den nun folgenden Erläuterungen wird davon ausgegangen, daß sich das Maschinenprogramm im Kassettenpuffer ab Adresse 828 befindet. Wurde eine andere Anfangsadresse gewählt, ändern sich auch die Adressen der einzelnen Routinen.

Der Befehl GOTO N sieht in der Form, wie er im Programm verwendet werden muß, so aus: SYS(828)N; also doch noch recht einfach. Dieser Befehl bewirkt, daß man direkt zu einer beliebigen Zeile springen kann, deren Zeilenummer »N« vorher berechnet wurde. Nun zur Syntax. Bei diesem, wie auch bei allen folgenden Befehlen ist darauf zu achten, daß die Startadresse der Routine nach dem SYS-Befehl, (hier 828) in Klammern steht, um Sie von der darauf folgenden Parameterliste zu trennen und so als Adresse kenntlich zu machen. »N« repräsentiert hier, wie auch bei den weiter folgenden Befehlen, eine beliebige gültige numerische Variable, eine Zahl oder einen numerischen Ausdruck. Für »N« ist also beispielsweise auch der Ausdruck »INT(RND( 1) * 20) * 10 +100« erlaubt. Der Ausdruck muß nur einen Ganzzahlenwert zum Ergebnis haben. Noch zu bemerken ist, daß zwischen der geschlossenen Klammer der Adresse und der ersten Variablen oder dem Ausdruck kein Komma stehen darf. Das Komma wirkt wie bei PRINT oder READ wie ein Trennzeichen. Da dieser Befehl aber nur eine Variable oder einen Ausdruck enthalten darf, würde das zu einem »SYNTAX ERROR« führen.Dies gilt auch bei allen folgenden Befehlen. Ist die berechnete Zeilennummer nicht im Programm enthalten, erfolg die Fehlermeldung »UNDEF’D STATEMENT ERROR«.

Für den Befehl GOSUB N gilt das gleiche, was auch zu GOTO N gesagt wurde, unter Berücksichtigung der Tatsache, daß es sich hier um einen Unterprogramm-Aufruf handelt Mit diesem Befehl kann man also zu einer vorher berechneten Unterprogramm-Adresse springen (SYS(834) N).

RESTORE N ermöglicht es, den DATA-Zeiger auf eine bestimmte Zeile zu setzen. SYS(866)100 beispielsweise setzt den DATA-Zeiger auf das erste Datum der Zeile 100. Mit einem anschließenden READ-Befehl kann man dann gezielt auf diesen Datensatz zugreifen. Ist die angegebene Zeilennummer im Programm nicht vorhanden, erfolgt ein »UNDEF’D STATEMENT ERROR«.

READ D, A (SYS(890) d, a) liest direkt den D-ten DATA-Wert in die Variable A. Anstelle von »A« kann sowohl eine numerische als auch eine Stringvariable stehen. »SYS(890) 5, A$« entspricht beispielsweise der Basic-Befehlsfolge »FOR I = 1 TO 5 : READ A$ : NEXT«. Auf etwas ist noch zu achten: Will man numerische Daten mit einer numerischen Variable lesen, darf keiner der vorhergehenden DATA-Werte ein String sein. Dies ist programmtechnisch bedingt und liegt daran, daß in Wirklichkeit die entsprechende Anzahl von READ-Befehlen durchgeführt wird. Ein direktes Lesen nur des gesuchten Datums würde das Maschinen-Programm dreimal so lang machen. Sollte es doch einmal vorkommen, daß man versucht, in eine numerische Variable einen String einzulesen, wird ein »SYNTAX ERROR« mit Angabe der entsprechenden DATA-Zeile ausgegeben. Am besten benutzt man immer Stringvariable zum Lesen.

Dann wäre da noch der Befehl »READ N,D,A« (entspricht SYS(927)N,D,A). Dieser Befehl ist eine Mischung des RESTORE- und des READ-Befehls.

SYS(927)N,D,A liest aus der Zeile N das D-te Datum dieser Zeile in die Variable »A«. Ist D größer als die Anzahl der Daten in dieser Zeile, wird in der nächsten DATA-Zeile weitergelesen.

Nun noch zu »POP« (SYS(937)). Springt man aus einem Unterprogramm anstatt mit »RETURN« mit einem direkten Sprungbefehl in die nächsthöhere Ebene (zum Beispiel ins Hauptprogramm) zurück, dann kann mit SYS(937) die letzte gespeicherte Rücksprungadresse im Stack, die dann nicht mehr gebraucht wird, gelöscht werden. Damit wird verhindert, daß der Stack überläuft, da er maximal 23 Rücksprungadressen speichern kann. Außerdem wird ein korrekter Programmablauf sichergestellt, wenn man »hart« aus einem Unterprogramm herausspringt, beispielsweise, um in eine Fehlerbehandlungsroutine zu gehen.

## Tips für die Eingabe

Als erstes sollte man nur den Basic-Lader (Listing 1 oder 2, je nach Computer) ab Zeile 10000 eintippen und dann, ohne ihn zu starten, sicherheitshalber erst mal abspeichern. Dann gibt man noch eine Testzeile ein, und zwar: »10 GOSUB 10000:PRINT"Prüfsumme=";AS:END« und startet das Ganze mit »RUN«. Ergibt sich für die Prüfsumme ein anderer Wert als 18 413 für den VC 20 oder 17 901 für den C64, dann hat man sich irgendwo vertippt und die Datazeilen sind mit dem abgedruckten Listing noch einmal zu vergleichen. Eine genaue Kontrolle sollte man sowieso vornehmen, da sich durch Zufall eine richtige Prüfsumme ergeben kann, obwohl vielleicht zwei Werte falsch sind, die sich aber gegeneinander aufheben.

Sind alle Datazeilen fehlerfrei, löscht man Zeile 10 und speichert das Programm noch einmal ab, damit man den Basic-Lader an jedes gewünschte Programm anhängen kann.

Ist dies geschehen, kann man das Umrechnungsprogramm (Listing 3) eingeben. Es dient dazu, das Maschinenprogramm aus dem Kassettenpuffer an eine andere Stelle im Speicher zu verschieben. Der Kassettenpuffer hat ja den Nachteil, daß das Maschinenprogramm bei jeder Kassettenoperation zerstört wird. Außerdem können auch andere Befehlserweiterungen diesen Bereich benutzen, um Werte zwischenzuspeichern. Dadurch würde dann das Maschinenprogramm auch zerstört. Werden in einem Programm, das den Basic-Lader enthält, noch weitere DATA-Zeilen verwendet, so ist sicherzustellen, daß deren Zeilennummern größer sind als die höchste Zeilennummer des Basic-Laders, da sonst falsche Werte eingelesen würden.

Und noch ein Tip. Um die Adressen der Befehle nicht ändern zu müssen, wenn man das Maschinenprogramm in einen anderen Speicherbereich verlegt, verwendet man am besten Variablen, denen man am Anfang des Programms die Adresse zuweist. Dies könnte zum Beispiel so aussehen: »SM% = 828«.Für die einzelnen Befehle würde dann folgendes gelten:
GOTO N = SYS(SM%)
GOSUB N = SYS(SM% + 6)
RESTORE N = SYS(SM% + 38)
READ D,A = SYS(SM% + 62)
READ N,D,A = SYS(SM% + 99)
POP = SYS(SM% + 109)

Da alle diese Routinen weitgehend in das Betriebssystem des Computers eingebunden sind, werden bei Fehlern in der Ausführung die entsprechenden Systemfehlermeldungen ausgegeben.

(Wolfgang Thauer / ev)

# Hardcopy im Superformat

> Hier ist endlich eine formatfüllende Hardcopy-Routine für den Commodore 64 mit Epson-Drucker und Simons Basic

Das Programm erzeugt eine vergrößerte Hardcopy vom Grafikbildschirm. Die in Simons Basic enthaltene Hardcopy nutzt ja leider nur das halbe Blatt aus, was in vielen Fällen sehr störend ist. Das Programm vergrößert den Ausdruck in X-und Y-Richtung, so daß eine halbe A4-Seite bedruckt wird.

Es ist für den Commodore 64 und Epson-Drucker mit VC-Interface gedacht, läßt sich aber auch an andere Nadeldrucker anpassen.

(Peter Schwabe / ev)

# Zeichen-Editor

> Bei vielen Anwendungen ist es sinnvoll mit zwei verschiedenen Zeichensätzen zu arbeiten. Dieses Programm ermöglicht Ihnen, einen eigenen Zeichensatz zu erstellen, ohne den Original-Zeichensatz zu zerstören.

Programmiert man ein Videospiel, ein Textverarbeitungsprogramm oder will man einfach nur die üblichen Bildschirmzeichen etwas interessanter gestalten, bleibt einem nichts anderes übrig, als den normalen Zeichensatz aus dem ROM herauszuholen, ins RAM zu kopieren und dann in diesem kopierten Zeichensatz »herumzuPOKEn«.

Diese Tätigkeit ist aber — ähnlich wie bei der Konstruktion von Sprites — immer wieder eine mühsame Rechnerei. Deshalb habe ich mit einen komfortablen Zeichen-Editor zusammengestellt, der jede Rechnerei abnimmt. Mit seiner Hilfe ist das Definieren eigener Grafik-Zeichen ein Kinderspiel.

Nach dem Eintippen (und Abspeichern!) läßt man das Programm mit RUN starten. Nach einer kurzen Wartezeit, während der Großbuchstaben-Zeichensatz aus dem ROM ins RAM kopiert wird (und zwar in die Speicherzellen 51200 bis 53248, der Bildschirm beginnt dann bei Adresse 50176), erscheint das Menü mit einem Zeichenfeld links unten. (Wen es interessiert: das Maschinenprogramm, das den Zeichensatz ins RAM kopiert, beginnt bei der Adresse 828, also dem Anfang des Kassettenpuffers).

In diesem Zeichenfeld kann man nun mit den Cursortasten herumwandern, Sternchen (*) malen und gegebenenfalls mit der Space-Taste wieder löschen. Ein Sternchen im Zeichenfeld bedeutet einfach, daß hier ein Bit gesetzt wird, das dann später zur Berechnung des Zeichens dient. Jedes Graphik-Zeichen besteht ja aus 8 Bytes — und genau diese 8 Bytes stellt das Zeichenfeld symbolisch dar.

### Taste 1: Berechnung des selbsterstellten Zeichens

Sobald man sein Zeichen gemalt hat, muß es berechnet werden. Hierfür ist im Menü der Programmpunkt 1 vorgesehen. Drückt man diese Taste, so wird gefragt: »Welche Taste?« Man drückt nun die Taste, der man das soeben erstellte Zeichen zuordnen möchte, und genau das Zeichen, das zu der gedrückten Taste gehört, wird nun durch das im Zeichenfeld definierte Zeichen ersetzt.

Ein Beispiel: Füllt man das Zeichenfeld ganz mit Sternchen aus, läßt das Feld berechnen und drückt dann die Taste »A«, so wird überall auf dem Bildschirm dort, wo eben noch ein »A« gestanden hat, ein reverses Quadrat erscheinen. Nette Spielchen kann man zum Beispiel mit der Space-Taste machen: dann wird nämlich überall da, wo ein Space auf dem Bildschirm ist (und das sind ja üblicherweise eine ganze Menge), das eben definierte Zeichen gedruckt. Auf diese Weise kann man den Bildschirm etwas interessanter gestalten.

### Taste 2:

Sobald das neue Zeichen berechnet und ausgedruckt ist, kann man wieder beliebig im Zeichenfeld herumhantieren. Will man jedoch ein ganz anderes Zeichen konstruieren, so drückt man einfach Taste 2, und flugs ist das Zeichenfeld wieder »sauber« — das gerade definierte Zeichen wird dabei natürlich nicht gelöscht. Zusätzlich zum reinen Konstruieren von Grafik-Zeichen gibt es jodoch auch noch andere Programmfunktionen:

### Taste 3: ROM-Zeichen auslesen

Mit Hilfe dieses Programmpunktes kann man sich ein beliebiges Zeichen aus dem ROM-Zeichensatz herholen. Hierbei wird das gewünschte Zeichen in das Zeichenfeld hineingePOKEt und die Daten dieses Zeichens rechts daneben ausgegeben. Selbst wenn Sie also den Buchstaben »A« als ein reverses Quadrat definiert haben sollten, so erscheint — sofern Sie Taste 3 und danach »A« drücken — auf dem Zeichenfeld das gute, alte »A« wieder (denn im ROM-Zeichensatz bleibt natürlich alles beim alten).

### Taste 4: Eigene Zeichen auslesen

Natürlich können Sie nicht nur Zeichen aus dem ROM holen, sondern auch aus dem kopierten Zeichensatz, in dem Sie bisher munter herummanipuliert haben. Sie haben zum Beispiel aus dem »O« ein Smiley-Gesicht gemacht und wollen er gerne in vergrößerte Form wiedersehen, um etwa Korrekturen oder ähnliches vorzunehmen — bitte sehr! Drücken Sie die Taste 4, dann ein »O« und Ihr eigenes Zeichen steht im Zeichenfeld — samt den dazugehörigen Daten rechts nebenan.

### Taste 8: Restore

Nun kann es vorkommen, daß Sie genug haben von Ihren eigenen Zeichen. Eigentlich wollten Sie jetzt ganz gern wieder die alten, »normalen« Zeichen anstelle der vielen Smiley-Gesichter und reversen Quadrate sehen.

Wenn Sie Taste 8 drücken, wird einfach der ROM-Zeichensatz wieder ins RAM kopiert; und da dieser Teil in Maschinensprache geschrieben ist, geht das ziemlich schnell vonstatten.

Will man übrigens nur ein einziges Zeichen wieder in den Ursprungszustand versetzen, so geht man am besten so vor: Man holt sich das (alte) Zeichen aus dem ROM (mit Taste 3) und läßt es mit Taste 1 wieder in den neuen Zeichensatz hineinkopieren. Mit dieser Methode kann man zum Beispiel auch einen Art Geheimcode entwickeln: Man tauscht einfach die Zeichen im ROM untereinander aus (statt eines A ein B, statt eines U ein X und so weiter). Nach einigem Umdefinieren bekommt man einen ganz eigenartigen Buchstabensalat auf dem Bildschirm.

### Taste 9: Bild zeichnen

Nehmen wir an, Sie haben aus den etwas eintönigen Grafikzeichen des C 64 interessantere Zeichen zusammengebastelt: Leitern, Mauerwerke, Treppen und ähnliches. Sie würden aber ganz gerne sehen, wie diese Zeichen im Zusammenhang wirken; wie es etwa aussieht, wenn ein Leiterstück unter dem anderen steht, daneben ein Mauerwerk und so weiter. Dazu drücken Sie Taste 9 und können jetzt mit Ihren selbsterstellten Zeichen den ganzen Bildschirm vollmalen. Wenn Sie wieder ins Menü zurückwollen, drücken Sie einfach »Cursor Home« (steht auch auf dem Bildschirm).

Ein Hinweis zu diesem Programmpunkt: Der Cursor ist beim Bildmalen aus Gründen der Programmiervereinfachung nicht immer sehr gut sichtbar, manchmal »legt« er sich sogar ab, wenn er schnell über den Bildschirm bewegt wird. Das sollte Sie aber nicht weiter stören, schließlich ist diese Programmfunktion nur als Hilfe gedacht für einen schnellen Überblick.

### Tasten 6 und 7: Abspeichern und Laden

Wenn Sie eigene Zeichen definiert haben, möchten Sie diesen Zeichensatz vielleicht abspeichern, um ihn später noch einmal verwenden zu können. Drücken Sie einfach Taste 6 und geben einen Dateinamen ein — der kopierte Zeichensatz mit Ihren selbsterstellten Zeichen wird nun auf Diskette gespeichert (nur der Großbuchstaben-Zeichensatz). Er nimmt dabei genau 44 Blöcke auf der Diskette ein. Mit Taste 7 können Sie schließlich einen abgespeicherten Zeichensatz wieder laden (der aktuelle Zeichensatz wird dabei überschrieben).

Sollten Sie einmal versehentlich 6 oder 7 gedrückt haben, so kommen Sie wieder ins Menü zurück, wenn Sie »N« + »RETURN« eingeben!

### Taste 5: Daten eingeben

Eine letzte Programmfunktion bietet die Eingabe von Daten, die ein Zeichen definieren. Dies ist eine Alternative zum Konstruieren eines Zeichens im Zeichenfeld. Zu beachten ist, daß nur Zahlen von 0 bis 255 eingegeben werden können (dies wird allerdings vom Programm sichergestellt; negative und Zahlen größer als 255 werden vom Programm nicht angenommen). Nach Eingabe des 8. Bytes erscheint dann die übliche Frage »Welche Taste!« und nach Eingabe dieser Taste das bekannte Sternchenbild auf dem Zeichenfeld.

Die Erklärung der Taste 0 (Programmende) erübrigt sich wohl. Zu erwähnen ist hierbei nur, daß der kopierte Zeichensatz auch nach Beendigung des Programms weiterhin zur Bildschirmgestaltung benutzt wird; auch der Bildschirm selbst sitzt weiterhin an der Adresse 50176 (und nicht wie üblich, bei 1024). Wollen Sie also wieder einen ganz gewöhnlichen Bildschirm mit ganz gewöhnlichen Grafik-Zeichen haben, so geht das am einfachsten nur durch Aus- und Anschalten des Computers (auch die Run/Stop-Restore-Taste wurde im Programm blockiert).

Eine kleine Bemerkung am Rande zum eigenen Programmieren: Sehr oft kommt es ja vor, daß man einen Satz von einem Programm aus mitten in dem Bildschirm hineinschreiben will. Üblicherweise geht man so vor, daß man die Cursor-Steuerzeichen in die Print-Zeile so oft einfügt, bis der gesuchte Platz gefunden ist. Für Programmlistings ist das etwas unübersichtlich. Es gibt aber noch eine andere Methode, die ich in diesem Programm benutzt habe (und zwar am Anfang fast jedes Programmpunktes): will man zum Beispiel einen Buchstaben in die 14. Zeile, 5. Spalte schreiben, so gibt man zunächst POKE 214,13
ein, danach ein PRINT-Kommando und dann PRINTTAB(4)»X«.

In Adresse 214 steht nämlich die Zeilenposition des Cursors. Um diese richtig einzusetzen, muß man allerdings noch einen PRINT-Befehl nachschicken: Cursor in Zeile 13 + PRINT-Befehl ergibt dann Zeile 14!

(Volker Bühn / gk)

# Super Line — 80 Zeichen für den C 64

> Ein kleiner Basic-Lader realisiert, wofür man sonst viel Geld ausgeben muß: 80 Zeichen pro Zeile

Es werden 4 neue Befehle definiert, die das Darstellen von 80 Zeichen möglich machen. Und das, ohne daß man lange programmieren muß.

Beginnen wir mit dem Einfachsten: dem Eingeben. Dies dürfte keine Schwierigkeiten bereiten. Bevor man das Quellenprogramm jedoch startet, sollte man es abspeichern, da es sich, vorausgesetzt, man hat keinen Fehler gemacht, selbst löscht. Anschließend kann man es mit RUN laufen lassen und wenn die Prüfsumme stimmt, erscheint nach einigen Sekunden einfach READY. Die neuen Befehle sind nun definiert und können angewendet werden.
Diese Befehle lauten:

TODO

So bewirkt zum Beispiel das kurze Programm:
10 O
20 C
30 W 0,0 "64’ER DAS MAGAZIN FÜR COMPUTER-FANS"
daß der in Anführungsstrichen stehende Satz in die linke obere Ecke geschrieben wird. Anschließend rührt sich nichts mehr und man kann durch die ’blinde’ Eingabe von ’F’ wieder zum normalen Bildschirm zurückkehren.

A$ läßt sich auch durch einzelne Stringvariable ersetzen, die mit + verknüpft werden, oder man kann auch eine normale numerische Variable verwenden. Allerdings dürfen keine Variable mit dem Namen O,C,W oder F verwendet werden. So ist zum Beispiel O$,CG,WR$ oder ähnliches verboten.

Nun einige detaillierte Angaben zum Programm selbst. Das Maschinenprogramm liegt im Bereich von $ 9000 bis $ 928F. Wer im Besitz eines Monitors ist, kann es direkt abspeichern und von der Diskette mit ,8,1 laden. Gestartet wird es dann mit SYS 36864. Wer das nicht will, der lädt einfach den Basic-Lader, der das Maschinenprogramm in den Speicher ’POKEt’. Zwischen $ 9000 und $ 902D wird zunächst der Basic-Vektor umgesetzt, und der Anfang des Basic-Speichers hochgelegt. Zwischen $ 902E und $ 9044 beginnt nun die Befehlsdekodierung. Bei Erkennen eines Befehls wird verzweigt, ansonsten in die normale Interpreterroutine gesprungen. Bei dem Befehl ’O’ wird zunächst in der Unterroutine von $ 9233 bis 928E der Zeichensatz aus dem verdeckten Bereich $ D000 in den offenen Bereich $ 0000 übertragen. Der Bereich von $ 0400 bis $ 0800 wird mit dem Code für die Hintergrundfarbe gefüllt. Außerdem wird bei $ 9057 das Register # 648 umgesetzt, damit es auf dem Bildschirm kein farbliches Durcheinander gibt. Weiterhin wird selbstverständlich der hochauflösende Grafik-Modus eingeschalten. Die Routine für den Befehl ’C’ liegt zwischen $ 9081 und $ 90A3. Der Bereich der Bit-Map wird einfach mit 00 gefüllt.

Der Befehl ’F’ wird zwischen $ 906C und $ 907E ausgeführt. Das Register 648 wird zurückgesetzt, der hochauflösende Grafik-Modus ausgeschaltet und der normale Bildschirm gelöscht.

Der Befehl, dessen Routine am längsten ist, ist der Befehl ’W’. Er wird zwischen $ 90A6 und $ 9230 bearbeitet. Zunächst werden die beiden Koordinaten x und y geholt und aus ihnen die Adresse der Bit Map berechnet, an der das erste Byte gesetzt wird. Dies geschieht zwischen $ 90A6 und 9135. Dann werden die einzelnen Zeichen des zu schreibenden Satzes geholt und ihr Code wird so umgerechnet, daß er mit der Stelle übereinstimmt, an der das jeweilige Zeichen in dem nach $ C000 verschobenen Zeichen ROM steht. Anschließend durchläuft jedes der 8 Bytes, aus denen ein Zeichen definiert ist, die gleiche Prozedur. Das Byte wird geholt, jedes zweite Bit ausgefiltert, und die verbliebenen 4 Bits zusammengeschoben. Das Zeichen ist jetzt nur noch durch 4 x 8 Punkte definiert. Jetzt müssen die entstandenen Nibbles noch in die Bytes der Bit Map gebracht werden. Dies geschieht mit einer EXOR-Verknüpfung. Dabei steuert ein Flag, das in $ 9300 steht, ob das Nibble in die linke oder die rechte Hälfte des Bytes geschrieben wird.

(Andreas Zell / rg)

# Tastaturpieps

> Bei einem Besuch in einer Bank sah ich dort einige größere Computer, die jeden Tastendruck des Bedieners mit einem Piepston quittierten. Dies wollte ich auch beim C 64 nachvollziehen.

Dies sollte unabhängig von einem anderen Programm sein. Daher meine Idee, die Interruptroutine des C 64 zu verändern, da diese 60mal in der Sekunde angesprochen wird, um die Tastatur abzufragen. Dies konnte natürlich nur in Maschinensprache geschehen, da Basic zu langsam wäre. Es ist auch möglich, schon vorhandene Programme damit zu erweitern. Denkbar sind zum Beispiel Textprogramme, Spiele, Programme zum Erlernen des Schreibmaschinenschreibens oder auch nur zur Simulation einer echten Schreibmaschine, die ja auch nicht gerade geräuschlos arbeitet.

Zu Beginn des Programms ($033C-$0348) wird der Interruptvektor verbogen. Er zeigt jetzt auf unsere Routine ($0349-$039E). Da der Computer alle 1/60-Sekunde die Tastatur abfragt, und dazu einen Interrupt auslöst, wird unsere Routine ebenfalls so häufig angesprochen. In dieser Routine wird zuerst überprüft ob überhaupt eine Taste betätigt wurde. Dazu wird der Wert der Speicherstelle $CB in den Akkumulator geladen. Enthält diese den Wert $40, so wurde keine Taste gedrückt und es wird zur normalen Interruptroutine des C 64 gesprungen. Der Wert der Speicherstelle $CB wird zwischengespeichert. Man kann damit bei einem 2. Durchlauf dieser Routine feststellen, ob eine Taste nicht kurz zuvor (t &lt;1/60 sec.) schon einmal betätigt wurde. Dies dient dazu, daß bei Tasten mit Dauerfunktion nicht unaufhörlich der Pieps ertönt. Denn dies ist erstens entnervend und zweitens verzögert dies den Ablauf der Dauerfunktion so, daß man dabei einschlafen kann. Danach werden die verschiedenen Toneinstellungen vorgenommen. Der Verzögerungsteil ($037F-$0387) dient dazu, den Ton höher zu machen. Ansonsten wäre nur ein Knacken zu hören. Sie können also selbst damit experimentieren und einen für Sie angenehmen Ton einstellen. Das Programm läßt sich durch Drücken der Run/Stop- und der Restore-Taste unterbrechen und mit SYS 49152 reaktivieren.

(Wolfgang Roth / rg)

# POKE mal wieder

### Tastatur statt Joystick

Beim Commodore 64 lassen sich alle Joystick-Funktionen auch über die Tastatur steuern. Hier eine Liste der entsprechenden Tasten:

TODO

(Gunther Knöpfle)

### Zeitlupe für den VC20

Läßt man ein Programm auf dem Bildschirm auflisten, so läuft es in Sekundenschnelle durch. Mit dem Befehl POKE 37877,0 werden nun alle Funktionen des VC20 extrem verlangsamt, und man kann sich so ein Programm in Ruhe ansehen. Durch Drücken einer beliebigen Taste wird das Listen noch weiter verlangsamt und mit der RUN/STOP-Taste so lange angehalten, wie man die Taste gedrückt hält.

Man kann den Befehl auch innerhalb eines Programms anwenden um zum Beispiel während der Testphase bestimmte Abschnitte sehr langsam und somit nachvollziehbar ablaufen zu lassen.

Mit POKE 37877,72 oder einfach durch gleichzeitiges Drücken von RUN/STOP und RESTORE wird wieder der Normalzustand hergestellt.

(Johannes Conrad)

### Kommas mit INPUT lesen

Häufig steht man vor dem Problem, einen Textstring mit INPUT zu lesen, der auch Kommas enthalten soll. Versucht man es mit einem normalen INPUT-Befehl, dann meldet der Computer nur EXTRA IGNORED. Mit dem folgenden kleinen Trick kann sowohl der C 64 als auch der VC 20 Texte mit Komma einlesen.

Unmittelbar vor dem INPUT setzt man den Tastenzähler auf 1 und POKEt ein Anführungszeichen in den Tastaturpuffer. Es ergibt sich folgende Programmzeile:
POKE 198,1 : POKE 631,34 : INPUT A$
Probieren Sie’s aus.

(Udo Stenger)

### Verstimmter C 64?

Benutzt man für ein Musikstück die im Commodore 64-Handbuch angegebenen High- und Low-Bytes, um die Töne zu POKEn, dann klingen sie häufig unrein oder »verstimmt«. Das vermeidet man, indem man die Low-Bytes neu festlegt. Man kann sie nach der folgenden Formel berechnen:

Low-Byte = Frequenz * 17 - High-Byte * 256

Ist das Ergebnis negativ, dann nimmt man ersatzweise diese Formel: Low-Byte = Frequenz * 17 - (High-Byte - 1) * 256

(Roger Limberg)

### VC 20-Tips

Umschalten des VC20 auf die Grundversion bei eingesteckter Speichererweiterung:
POKE 642,16 : POKE 644,30 : POKE 648,30 : SYS 64824

Mit POKE 55,30 : SAVE »(Name)« kann ein SAVE-Schutz umgangen werden, mit dem viele Programme geschützt sind.

Der Befehl POKE 36867,48 erzeugt eine zusätzliche Zeile unterhalb des normalen Bildschirms, die während des gesamten Programms stehen bleibt und nur über POKE-Befehle zugänglich ist.

(Frank Pachollek)

### Basic-Programme retten

Ein versehentlich mit »NEW« oder durch einen RESET gelöschtes Programm kann beim VC 20 durch Eingabe der folgenden Befehle im Direktmodus wieder zurückgeholt werden: POKE 46, PEEK(56) -1 : POKE 45, PEEK(55) + 247 : CLR »Return«
POKE PEEK(44) * 256 + PEEK(43) + 1, PEEK(44) »Return« 63999 »Return«
FOR I = PEEK(44) * 256 + PEEK(43) TO PEEK(46) * 256 + PEEK(45) : IF PEEK(I) OR PEEK(I + 1) OR PEEK(I + 2) THEN NEXT »Return«
POKE 45, (I + 3) AND 255 : POKE 46, (I + 3) / 256 : CLR »Return«

Unter Umständen erhält man jetzt eine Fehlermeldung, aber das Programm ist jedenfalls wieder da!

(Ralf Berle)

### C 64 - Bildschirm scrollen

Nach der Eingabe von SYS 59626 wird der gesamte Bildschirm um eine Zeile nach oben verschoben. Umgekehrt geht’s aber auch, nämlich mit SYS 59749. Damit werden alle Zeilen ab der aktuellen Cursorposition um eine Position nach unten geschoben. Um den ganzen Bildschirm abwärts zu scrollen, müßte man daher den Cursor in die Bildschirmzeile -1 bringen. Und auch das kann man dem Computer tatsächlich vorgaukeln, und zwar durch POKE 214, 255 : SYS 59749 : SYS 58640.

(Michael Wins)

### In C 64-Spiele gePOKEt

Hier sind einige interessante POKE-Befehle, mit denen man jeden Highscore überbieten kann. Doch Vorsicht, diese Befehle funktionieren nicht bei allen Versionen dieser Spiele.

* Fort Apocalypse: »POKE 14697,0 : POKE 14760,0 : POKE 36366,0«. Danach hat man beliebig viele Hubschrauber, einen unendlichen Treibstoffvorrat, und der Bonus wird nie erniedrigt.
*	Hunchback: »POKE 9521,234 : POKE 9522,234 : POKE 9523,234«. Hier hat man unendlich viele Helden zur Verfügung.
*	Neptune: »POKE 7870,60«. Mit diesem POKE hat man auf einen Schlag 60 Taucher.
* Jungle Hunt: »POKE 2242,234 : POKE 2243,234«. Der Held hat unendlich viele Leben.

(Frank Bastian)

### Basic-Programme retten

Die Betriebssystemroutine »Angleich von Koppeladressen» ab Adresse 42291 ermöglicht ein schnelles und einfaches »UNNEW« nach einem versehentlichen »NEW« oder Reset:
POKE 2049,1 : POKE 2050,1 : SYS 42291

Danach kann zumindest wieder geLISTet werden. Ein vollständiges »UNNEW» verlangt allerdings die Korrektur der Zeiger auf den Beginn der Variablen und Felder. Dazu wäre allerdings die Kenntnis der Programmlänge notwendig. Man kann sich aber behelfen, indem man das Programm notfalls in Teilen auf dem Bildschirm aufLISTet und die einzelnen Zeilen mit der RETURN-Taste neu übernimmt.

(Gerhard Wagner)

### Spezialeffekt

Wenn man beim C 64 in die Speicherstelle 532 70 Werte zwischen 0 und 15 schreibt (POKE 53270,x), kann man den Bildschirm um bis zu sieben Bildpunkte nach links oder rechts scrollen lassen. Ist x kleiner als 8, dann scrollt der Bildschirmausschnitt um x Bildpunkte nach links, sonst um x-8 Bildpunkte nach rechts.
POKE 53270,8 stellt den Normalzustand wieder her.

Dieser Trick läßt sich gut bei Action-Spielen als optische Untermalung beispielsweise einer Explosion einsetzen.

(Michael Keukert)

### Einige POKEs für den VC 20

Im folgenden ist X immer eine Zahl zwischen 0 und 255. POKE 36865,X: Zentriert den Bildschirm in vertikaler Richtung. Man kann dadurch den Bildschirm nach oben oder unten verschieben. Der Normalzustand wird mit X=38 erreicht. POKE 36864,X: Dieser Befehl ist für die horizontale Bildzentrierung zuständig. Er verschiebt den Bildschirm nach links oder rechts. Der Normalwert ist X=12.

POKE 37879,X: Mit diesem Befehl wird die interne Uhr des VC 20 beeinflußt. Man kann sie schneller oder langsamer laufen lassen. Die letzte Möglichkeit ist besonders beim LISTen interessant. Drückt man nämlich bei verlangsamtem Zeitgeber zusätzlich noch die CTRL-Taste, dann kann man sich einzelne Zeilen fast beliebig lange betrachten. POKE 37879,72 stellt den Normalzustand wieder her.

(Detlef Krischak)

### Miner 2049er

Ärgert es Sie auch, daß Sie beim Miner 2049er nie die letzten Bilder vor Augen bekommen? Eigentlich ist das unnötig, denn es gibt einen einfachen Weg, um in die letzten Spielstufen zu gelangen:

Sie brauchen nur entweder die Leertaste bei der Tastatur oder den Feuerknopf am Joystick einige Zeit gedrückt halten. Die augenblickliche Spielstufe wird dann übersprungen und Sie gelangen ins nächste Bild.

(Armin Robl)

### Directory ohne Programmverlust

Häufig möchte man sich das Directory einer Diskette ansehen ohne das gerade im Speicher befindliche Programm zu zerstören. Wenn man das DOS 5.1 nicht geladen hat, behilft man sich meist mit der zeitaufwendigen Zwischenspeicherung des Programms auf der Diskette. Es geht jedoch auch einfacher und schneller. Geben Sie einfach den folgenden Befehl ein: POKE 44, PEEK(46) + 1

Damit wird der Basic-Anfang auf einen freien Speicherbereich gestellt. Sie können jetzt wie gewohnt mit »LOAD "$",8« das Directory laden und anschließend auflisten.

Mit POKE 44,8 sind Sie dann wieder im eigentlichen Programm.

(Heinzpeter Oelkers)

### Commodore Joystick verbessert

Der Joystick VIC-1311 für den VC 20 benötigt eine relativ große Hebelbewegung, um die Kontakte zu schließen. Bei Spielen, die eine hohe Reaktionsgeschwindigkeit erfordern, ist diese Eigenschaft sehr ungünstig. Man kann jedoch recht einfach Abhilfe schaffen:

Man entfernt die vier Schrauben an der Unterseite des Gehäuses und hebt den oberen Teil des Joysticks mit der Platine vorsichtig ab. Nun wird die Platine an den Durchtrittsöffnungen der Schrauben mit je einer etwa 1 Millimeter dicken Unterlegscheibe verstärkt. Die vier Unterlegscheiben können mit einem Tropfen Alleskleber (Vorsicht, nicht die Kontakte verkleben !) gegen Verrutschen gesichert werden. Danach wird der Joystick wieder zusammengeschraubt. Wenn Sie alles richtig gemacht haben und insbesondere keine Teile übriggeblieben sind, dann werden die Kontakte des Joysticks nun bei erheblichen kleineren Hebelbewegungen geschlossen.

(M. Kunze)

### Tips zum C 64

Mit »POKE 808,225« wird die STOP-Taste ausgeschaltet und das Programm kann nicht mehr angehalten werden. »POKE 808,237« schaltet STOP wieder ein.

Eine Repeat-Funktion für alle Tasten wird mit »POKE 650,128« aktiviert. »POKE 650,0« schaltet wieder auf den Normalzustand zurück (Repeat-Funktion nur für die Leertaste und die Cursortasten sowie bei DEL und INST). Mit »POKE 650, 64« wird auch die Wiederholfunktion für diese Tasten abgeschaltet.

»POKE 657, 128« verhindert die Umschaltung zwischen Text- und Grafikmodus mit der Kombination von Shift- und Commodore-Taste. »POKE 657,0« hebt dies wieder auf.

Die Cursorfarbe kann mit »POKE 646,x« festgelegt werden, wobei für »x« der entsprechende Farbcode einzusetzen ist.

»PRINT PEEK(186) ergibt die Gerätenummer des zuletzt angesprochenen Peripheriegerätes.

(Thomas Lopatic)

### Zwei Tips für den C 64

Die Speicherstellen 57 und 58 enthalten die Zeilennummer der aktuellen Basic-Zeile. Die Abfrage geschieht mit PRINT PEEK(57) + 256 * PEEK(58).

Mit »PRINT PEEK(1)« kann abgefragt werden, ob eine Taste an der Datasette gedrückt ist. Es gibt drei mögliche Werte:
7: Taste gedrückt,
55: keine Taste gedrückt,
39: Taste gedrückt, aber Programmlauf unterbrochen.

Diese Abfragen sind für die benutzerfreundliche Programmierung von Kassettenoperationen recht nützlich.

(Wolfgang Meyer)

### VC 20 — Grundversion simuliert

Mit der folgenden kurzen Routine lassen sich die meisten Grundversions- oder +3 KByte-Programme auch mit einer 8 KByte-Erweiterung laden und ausführen:
POKE 648, 30 : SYS 64821
POKE 4096, 0 : POKE 44, 16 : NEW

Danach wird das Programm ganz normal geladen und gestartet. Da der Bildschirmspeicher durch die kleine Routine an der gleichen Stelle wie in der Grundversion liegt, sind die meisten Grundversions-Programme ohne weitere Änderungen direkt lauffähig.

(Sven Jensen)

### Maschinensprache »getürkt«

Es gibt eine einfache Methode, um beim VC 20 mit mindestens 8 KByte-Erweiterung aus einem ganz normalen Basic-Programm scheinbar ein Maschinensprache-Programm zu machen.

Zunächst gibt man die folgende Zeile ein:
10 SYS 4621

Danach folgt im Direktmodus:
POKE 43, 1 : POKE 44, 19 : POKE 4864, 0 : NEW

Keine Angst, die Programmzeile 10 ist nicht verloren. Jetzt • muß das folgende kleine Programm eingegeben werden.
10 FOR A = 4621 TO 4643
20 READ D : S = S + D : POKE A, D
30 NEXT
40 IF S§(2039 THEN PRINT "FEHLER IN DATAS"
50 DATA 169, 36, 133, 43, 169, 18, 133, 44
60 DATA 169, 0, 141, 34, 3, 141, 35, 3, 32
70 DATA 89, 198, 76, 174, 199, 0

Dieses Programm wird jetzt mit »RUN« gestartet. Anschließend wird im Direktmodus der Basic-Start verschoben: POKE 43, 36 : POKE 44, 18 : POKE 4643, 0 : NEW

Damit sind wir schon fast am Ziel. Jetzt kann ein beliebiges Basic-Programm geladen oder geschrieben werden. Die letzte ausführbare Zeile dieses Programms muß immer lauten:

»(Zeilennummer)« POKE 43, 1 : POKE 44, 18 : END

Um das Programm abspeichern zu können, muß man jetzt noch POKE 43, 1 : POKE 44, 18 eingeben. Gibt man nun LIST ein, so sieht man nur 10 SYS 4621. Das auf solch wundersame Art zum »Maschinenprogramm« gewordene Basic-Programm kann jetzt ganz normal gepeichert, geladen und gestartet werden. Allerdings ist jetzt ein hervorragender Listschutz realisiert, zumal im Maschinenspracheteil des Programms noch die RUN/STOP-Taste gesperrt wird. Ein Versuch, das Programm damit abzubrechen, führt stets zu einem völligen »Absturz« des Computers.

(A. Kaminski)

### »PRINT AT« einfach gemacht

Sehr oft kommt es vor, daß man eine PRINT-Ausgabe an eine bestimmte Bildschirmstelle schreiben will. Üblicherweise arbeitet man in solch einem Falle mit Cursor-Steuerzeichen, was aber einerseits recht langsam ist und andererseits auch die Übersichtlichkeit eines Programms nicht gerade erhöht. Eine Cursorsteuerung über SYS-Kommando unter Ausnutzung der entsprechenden Betriebssystem-Routine ist da schon komfortabler. Aber es geht auch viel einfacher.

Will man beispielsweise einen Text in die 14. Zeile, 5. Spalte schreiben, so geht das auch folgendermaßen:
POKE 214, 13 : PRINT : PRINT TAB(5);"Text"
Adresse 214 enthält nämlich die Zeilenposition des Cursors. Um diese allerdings richtig einsetzen zu können, muß noch ein leerer PRINT-Befehl nachgeschickt werden. Der in Adresse 214 zu POKEnde Zahlenwert ist daher nicht die gewünschte Cursorzeile, sondern der um eins verminderte Wert.

(Volker Bühn)

### Sequentielle Datei als Basic-Programm laden

Es sind eine Reihe von Anwendungen denkbar, bei denen aus einer sequentiellen Datei auf Diskette oder Kassette ein lauffähiges Basic-Programm erstellt werden soll (Datenfernübertragung, Umwandlung von Textfiles in Basic-Programme). Der folgende Einzeiler macht»s möglich:
OPEN 1, $Gerät(, $Sekundäradresse(, "$Name)" : POKE 812, 238 : POKE 781, 1 : SYS 65478

Dieses Miniprogramm öffnet das File Nummer 1 als Eingabefile (anstelle der Tastatur). Außerdem wird der CLALL-Vektor des Betriebssystems auf ein »RTS« gesetzt, so daß beim Einlesen von Programmzeilen keine Files geschlossen werden.

Deshalb werden nach Eingabe der obigen Befehlszeile von der ausgewählten Datei solange Zeilen eingelesen und sofort im Direktmodus ausgeführt, bis die Betriebssystem-Routine CLRCHN aufgerufen wird (zum Beispiel durch einen Syntaxfehler in den gelesenen Zeilen oder durch GET #1, A$).

Um in den normalen Eingabemodus zurückzukehren, muß nur »POKE 812, 239 : CLR« eingegeben werden.

Zum Ausprobieren: Laden Sie ein beliebiges Basic-Programm und geben Sie danach im Direktmodus ein:
OPEN 1,8,3,"LISTING,S,W": CMD 1 : LIST : PRINT#1 : CLOSE 1

Dadurch wird das momentan im Speicher befindliche Programm als sequentielles File auf Diskette gespeichert. Datasetten-Besitzer müssen den OPEN-Befehl abändern in »OPEN 1,1,2,"LISTING"«.

Löschen Sie jetzt den Arbeitsspeicher mit »NEW«. Wenden Sie nun unseren Einzeiler auf die sequentielle »LISTING«Datei an:

OPEN 1, 8 ,3, "LISTING,S,R" : POKE 812,238 : POKE 781,1 : SYS 65478

Bei der Datasette geben Sie stattdessen »OPEN 1,1,0, "LISTING" : ...« ein (das Zurückspulen des Bandes nicht vergessen).

Nun werden alle Zeilen des sequentiellen Listings eingelesen, und Sie haben zum Schluß wieder das fertige Programm vor sich.

Natürlich können Sie vor der Anwendung des Einzeilers auch bereits ein Programm im Speicher stehen haben. Da der Computer die Zeilen, die er aus dem sequentiellen File liest, genauso wie Direkteingaben behandelt, werden die neu gelesenen Zeilen mit dem bereits vorhandenen Programm gemischt.

Es ist sogar denkbar, sich spezielle Befehlsfiles für Stapelverarbeitung zu erstellen. Der Computer kann dann ohne weiteres Zutun die vordefinierten Aufgaben durchführen.

(Florian Matthes)

### VC 20 Tips

POKE 792, 34 : POKE 793, 3 - Nach Drücken der RESTORE-Taste führt der Computer einen Kaltstart aus.

SYS 65511 - Dieser Befehl schließt alle Dateien POKE 198, 0 : WAIT 198, 1 - Der Computer wartet, bis eine Taste gedrückt wird.
SYS 64802 - Es wird ein vollständiger Kaltstart ausgeführt
SYS 64818 - Kaltstart des VC 20, ist schneller als SYS 64802

POKE 818,34 : POKE 819,2 53 : POKE 37150,2 - Damit wird das Abspeichern von Programmen verhindert (Kopierschutz). Nach der Eingabe von »SAVE« führt der Computer einen Kaltstart durch.

(Thomas Hahn)

### Cursor abschalten

Mit dem Befehl "POKE 788,210" wird beim VC 20 der Cursor abgeschaltet. Eine Rücksetzung in den Normalzustand ist mit RUN/STOP-RESTORE möglich.

(Dietmar Roudaschl)

### Tips & Tricks

MERGE für C 64 / VC 20

Hier ist eine einfache MERGE-Routine zum Verbinden zweier Basic-Programme. Sie kann sowohl für die Floppy als auch für die Datasette (auch mit Turbo-Tape) verwendet werden. Einzige Voraussetzung: Das zweite Programm muß höhere Zeilennummern haben als das erste. Und so wird’s gemacht:

1.	Sie laden das erste Programm. Dann geben Sie im Direktmodus ein:<br>PRINT PEEK(43), PEEK(44)<br>Diese beide Zahlen schreiben Sie sich auf.
2.	Sie geben ein:<br>POKE 43, (PEEK(45) + 256 * PEEK(46) - 2) AND 255 (Return)<br>POKE 44, (PEEK(45) + 256 * PEEK(46) - 2) / 256 (Return)<br>Laden Sie nun das zweite Programm. Danach geben Sie ein:<br>POKE 43, (erste Zahl) : POKE 44, (zweite Zahl) (Return)

Nun befinden sich beide Programme hintereinander im Speicher.

(Michael Keukert)

### Funktionstastenbelegung unter Simons Basic

Simons Basic bietet ja bekanntlich die Möglichkeit, die Funktionstasten mit beliebigen Zeichenketten zu belegen. Um nun die Funktionstasten nicht jedesmal nach dem Einschalten neu belegen zu müssen, wäre es sinnvoll, die Belegung auf Floppy abspeichern zu können.

Die Funktionstastenbelegung ist bei Simons Basic in dem von Basic nicht erreichbaren Speicherbereich $C64D bis $C74B (50765 bis 51019 dezimal) abgelegt. Mit dem folgenden kleinen Programm wird dieser Speicherbereich als Maschinenprogramm abgespeichert:
10 INPUT "Filename "; X$
20 OPEN 5, 8, 5, X$ + »,P,W»
30 A = 50765 : E = 51019
40 H = INT(A / 256) : L = A AND 255
50 PRINT#5, CHR$(L); CHR$(H);
60 FOR I = A TO E
70 PRINT#5, CHR$(PEEK(I));
80 NEXT I :CLOSE 5

Mit LOAD "Name",8,1 kann die Funktionstastenbelegung nun jederzeit geladen werden, ohne ein eventuell vorhandenes Basic-Programm zu zerstören.

(Uwe Schwarz)

### Hilfe für »Turbo Tape«

Das Programm »Turbo Tape» ist ja ein Segen für alle diejenigen, die sich keine Floppy leisten können oder wollen. Es gibt allerdings einige Maschinenprogramme, die nach dem Gebrauch von »Turbo Tape» abstürzen.

Abhilfe: Nach dem Laden das Programm LISTen und den SYS-Befehl zu Anfang notieren. Nun SY8 64738 und danach den notierten SYS-Befehl eingeben — und schon läuft das Programm.

(Andreas Klofanda)

### Basic-Programme retten

Ein durch NEW oder durch einen Reset gelöschtes Basic-Programm kann durch Eingabe folgender Zeilen im Direktmodus wieder zurückgeholt werden:
POKE 46, PEEK(56) -1 : POKE 45, PEEK(55) + 247 : CLR (Return)
POKE PEEK(44) * 256 + PEEK(43) + 1, PEEK(44) (Return)
63999 (Return)
FOR I = PEEK(44) * 2 56 + PEEK(43) TO PEEK(46) * 2 56 + PEEK(45) : IF PEEK(I) OR PEEK(I + 1) OR PEEK(I + 2) THEN NEXT (Return)
POKE 45, (I + 3) AND 255 : POKE 46, (I + 3) / 256 : CLR (Return)

Diese »Rettungsmaßnahme« funktioniert sowohl beim VC 20 wie auch beim C 64.

(Ralf Berle)

### Cursor steuern

Das Betriebssystem des C 64 enthält eine Routine, die man benutzen kann, um den Cursor an eine beliebige Stelle zu setzen. Geben Sie doch mal folgendes ein:
POKE 214, (Zeile) : POKE 211, (Spalte) : SYS 58640 : PRINT "TEXT"

(Michael Keukert)

### Und noch ein Tip

Der FORMULAR TOO COMPLEX - Error ist sehr unangenehm, da sich das Programm danach oft nicht mehr listen läßt. Nach Eingabe von POKE 24,0 verhält sich der Computer aber wieder normal.

(Roger Limberg)


### Einige WAIT-Befehle

Folgende Befehle warten auf spezielle Tasten:
WAIT 198, 1 wartet auf beliebige Taste
WAIT 653, 1 Wartet auf Shift
WAIT 653, 2 Wartet auf Commodore-Taste
WAIT 653, 4 Wartet auf CNTRL

(Michael Keukert)

### Tips & Tricks

Listschutz

Möchte man ein Programm mit einem einfachen Listschutz versehen, so verfährt man folgendermaßen:

1.	Man ergänzt die Zeile, ab der der Listschutz wirksam werden soll, mit ":REM".
2.	Man fährt mit dem Cursor auf das zweite Anführungszeichen und drückt fünfmal die Taste INST.
3.	Nun wird ebenfalls fünfmal die Taste DEL gedrückt, so daß zwischen den Anführungszeichen fünf reverse T stehen. ..list
4.	Zuletzt bewegt man den Cursor hinter das zweite Anführungszeichen und drückt die Tastenkombination SHIFT und L. Anschließend RETURN nicht vergessen.

Wenn nun versucht wird, das Programm zu listen, gelangt der Computer nur bis zu der Zeile, in der der Listschutz steht und bricht dann den Vorgang mit »Syntax Error« ab.

(Thomas Lopatic)

### C64 beschleunigt
Für alle diejenigen C 64 - Besitzer, denen die Bewegung des Cursors bisher zu langsam war, gibt es einen speziellen POKE:

Mit POKE 56325,5 wird der Cursor rasend schnell und flitzt bei Betätigung der Cursortasten nur noch so über den Bildschirm. Wer’s lieber gemütlicher mag, der sollte es stattdessen einmal mit POKE 56325,255 probieren.

(Oliver Bausch)

### Text und Grafik mischen: Textomat-Tip

Bei Ihrem Software-Test des Textomat von Data-Becker (Ausgabe 9/84) wurde als gravierender Nachteil angeführt, daß bei einmal gestartetem Ausdruck keine Unterbrechung mehr möglich ist. Ich arbeite in Zusammenhang mit Textomat mit einem Epson-Drucker RX 80 F/T. Um den begonnenen Ausdruck zu unterbrechen, kann man einfach den ON-LINE-Schalter betätigen und den Drucker anschließend ausschalten. Sekunden später meldet sich der Textomat am Bildschirm mit dem zu druckenden Text zurück.

### Basic-Programme verbinden

So manch C 64-Besitzer wird es schon geärgert haben, daß sein Computer keinen MERGE-Befehl besitzt. Mit wenig Aufwand ist es aber dennoch möglich, Basic-Programme aneinanderzuhängen:

1.	Im Direktmodus »PRINT PEEK(43); PEEK(44)« eingeben und sich die Ergebnisse merken.
2.	Das erste Programm normal laden.
3.	Erscheint jetzt nach »PRINT PEEK(45)« eine Null oder eine Eins, dann geben Sie »POKE 43, 2 56 4- PEEK(45) - 2 : POKE 44, PEEK(46) - 1 : NEW« ein. Im anderen Fall wird »POKE 43, PEEK(45) - 2 : POKE 44, PEEK(46) : NEW« eingegeben.
4.	Nun wir das anzuhängende Programm geladen (Achtung! Das anzuhängende Programm muß die höheren Zeilennummern haben).
5.	Jetzt POKEn Sie in die Speicherstellen 43 und 44 die zu Anfang gemerkten Werte.

Beide Programme sind nun verbunden und können ganz normal gehandhabt werden. Wichtig bei der ganzen Prozedur ist, daß keine Variablen definiert werden, da das MERGEn sonst nicht richtig funktioniert.

(Thomas Lopatic)

### POKEs für den C 64

Mit POKE 775, 1 ist ein (fast) perfekter Listschutz aktiviert. Auch ein SAVE-8chutz ist mit wenig Aufwand möglich: POKE 801,0 : POKE 802,0 : POKE 818,165. Nach diesen drei POKE-Befehlen kann das Programm weder auf Kassette noch auf Diskette kopiert werden. Schließlich gibt es noch eine Möglichkeit, die RUN/STOP-Taste abzuschalten, und zwar mit POKE 808,225. Wiedereinschalten ist mit POKE 808,237 möglich.

(Thomas Lopatic)

### GOTO X für VC 20

Viele schätzen es, viele wünschen es sich: Einen berechneten GOTO-Befehl auf einen variablen Ausdruck anstelle einer Zeilennummer. Hier ist eine schnelle und sichere Methode, die nur 17 Bytes Speicherplatz benötigt.

Schreiben Sie als erste Programmzeile
1	REM"*********" (mindestens neun Sternchen). Anschließend geben Sie im Direktmodus ein: "PRINT PEEK(43) + PEEK(44) * 256 + 6" (RETURN).

Die daraufhin angezeigte Adresse notieren Sie sich bitte. Ohne Erweiterung müßten Sie den Wert 4103 erhalten haben, mit 3 KByte Erweiterung 1031 und ab 8 KByte Erweiterung 4615.

Jetzt POKEn Sie ab der notierten Adresse bitte folgende Werte ein: 32, 138, 205, 32, 247, 215, 76, 163, 200.

Wenn Sie nun die erste Zeile (mit dem REM) aufLISTen, sehen Sie einige Grafikzeichen. Diese stellen ein kurzes Maschinenspracheprogramm dar, das einen mathematischen Ausdruck in einen ganzzahligen Wert umrechnet. Diese Zeile muß immer die erste Programmzeile sein und darf auch nicht mehr geändert werden. Das übrige Programm kann natürlich wie gewohnt editiert werden.

8ie haben jetzt im Programm einen simulierten GOTO X -Befehl zur Verfügung, der mit SYS (Adresse) X aufgerufen wird. Für Adresse müssen Sie die anfangs notierte Adresse einsetzen (Klammern nicht vergessen). Für X kann ein beliebiger arithmetischer Ausdruck stehen wie zum Beispiel 5, A, A+2, C + D/SQR(9) oder PEEK(5).

Der neue Befehl hat im übrigen die gleichen Auswirkungen wie der normale GOTO-Befehl. Ist eine Zeilennummer nicht vorhanden, gibt es daher ebenfalls einen »UNDEF’D STATEMENT ERROR».

(Thomas Maul)

### POKEs für den 64’er

POKE 775,200 Listschutz ein
POKE 775,167 Listschutz aus
POKE 788,49 Run Stop ein
POKE 788,52 Run Stop aus
POKE 808,237 Run Stop Restore ein
POKE 808,225 Run Stop Restore aus
POKE 650,128 Dauerfunktion für alle Tasten
POKE 650,0 Dauerfunktion nur für Space und Cursortasten POKE 650,64 Dauerfunktion aus für alle Tasten

### INPUT ohne Fragezeichen

Die Ausgabe eines Fragezeichens beim INPUT-Befehl kann durch Öffnen einer Tastaturdatei unterdrückt werden:
10 OPEN 1,0 : REM Tastaturdatei eröffnen
20 INPUT#1,A$ : REM Einlesen von Tastatur ohne Fragezeichen
30 REM Nicht vergessen, die Datei mit CLOSE 1 wieder zu schließen

### Zwei Einzeiler

Zahlenkonvertierungen von Dezimal nach Hexadezimal braucht man recht häufig. Hier sind zwei Einzeiler zu diesem Thema:

— Hex $X nach dezimal X
10 x=0:fori = 1tolen(x$):x0=asc(mid$(x$,i,1)):x=16*x+x0-48 + (x0(64)*7: next
— Dezimal X nach hex $X
10 x$=":fori = 1to4:x0=x/16:x=x-int(x0)*16:x$=chr$(48+x-(x(9)*7) +x$:x=x0:next

(Volker Everts)

### Listschutz

Einen verblüffenden Listschutz für einzelne Zeilen erhält man, indem man an die eigentliche Programmzeile einen REM-Befehl anhängt und dahinter in Anführungszeichen eine Reihe reverser »T« gefolgt von einem Doppelpunkt und einem beliebigen Text schreibt.

Geben Sie doch einmal folgendes ein:
10 PRINT"BAUM":REM19reverse T:
10 PRINT"BLUME"

Wenn Sie dieses kleine Programm starten, schreibt der Computer »Baum«, listen Sie aber das Programm, so sehen Sie nur die Zeile 10 PRINT»BLUME«.

(Roger Limberg)


# Impressum

---
Herausgeber: Carl-Franz von Quadt, Otmar Weber
---
**Redaktion**: Albert Absmeier, Volker Everts, Georg Klinge, Christian Rogge.
Fremdautoren: Loucewski, Mossavi, Auer, Heine, Dreuw, Mockenhaupt, Materna, Weißenberger, Winkler, Kluge, Kölbach, Haas, Fette, Kusch, Kunz, Förtsch, Russell, Schulz, Grothaus, Sberhut, Hagedorn, Thauer, Schwabe, Bühn, Zell, Roth
---
**Layout**: Leo Eder (Ltg.)
---
**Zeichnungen**: René Nestler
---
**Auslandsrepräsentation**:
Schweiz: Markt & Technik Vertriebs AG, Alpenstraße 14, CH-6300 Zug, Tel. 042-22 31 55, Telex: 862 329
USA: M&T Publishing Inc.; 2464 Embarcadero Way, Palo Alto, CA 94303
---
**Vertriebsleitung**: Hans Hörl
---
**Anzeigen-Verkaufsleitung**: Hannelore Schmidt
---
**Anzeigenverwaltung und Disposition**: Michaela Hörl
---
**Verlagsleiter M&T-Buchverlag**: Günther Frank
---
**Druck**: R. Oldenbourg, Hürderstraße 4, 8011 Kirchheim
Auch Anschrift für Beihefter und Beilagen
---
**Preis**: Das Einzelheft kostet DM 14,—
---
**Vertrieb Handelsauflage**: Inland (Groß-, Einzel- und Bahnhofsbuchhandel) sowie Österreich und Schweiz: Pegasus Buch- und Zeitschriften-Vertriebs GmbH, Plieninger Straße 100, 7000Stuttgart80(Mohringen), Telefon (07 11) 7 20 04-0
---
**Urheberrecht**: Alle in diesem Heft erschienenen Beiträge sind urheberrechtlich geschützt Alle Rechte, auch Übersetzungen, vorbehalten. Reproduktionen gleich welcher Art, ob Fotokopie, Mikrofilm oder Erfassung in Datenverarbeitungsanlagen, nur mit schriftlicher Genehmigung des Verlages. Anfragen sind an Hans Hörl zu richten. Für die in der Übersicht gemachten Angaben können wir weder Gewähr noch irgendwelche Haftung übernehmen.
---
**© 1984 Markt & Technik Verlag Aktiengesellschaft**
---
**Verantwortlich**: Für redaktionellen Teil: Albert Absmeier
Für Anzeigen: Hannelore Schmidt
---
**Vorstand**: Carl-Franz von Quadt, Otmar Weber
---
**Anschrift für Verlag, Redaktion, Vertrieb, Anzeigenverwaltung und alle Verantwortlichen**:
Markt & Technik Verlag Aktiengesellschaft, Hans-Pinsel-Straße 2, 8013 Haar bei München, Telefon (0 89) 4613-0, Telex 5-22 052
---
Aktionäre, die mehr als 25% des Kapitals halten: Otmar Weber, Ingenieur, München; Carl-Franz von Quadt, Betriebswirt, München. Aufsichtsrat: Dr. Robert Dissmann (Vorsitzender), Karl-Heinz Fanselow, Eduard Heilmayr
---





































































<,<<
>,>>
”
“
’’
’