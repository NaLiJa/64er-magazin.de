<h1 id="steuerprobleme?">Steuerprobleme?</h1>

<p>Um eine Steuerung oder Regelung zu automatisieren, reicht in sehr vielen Fällen ein kleiner Computer. Schon die Hardware eines VC20-Grundmodells würde in vielen Fällen ausreichen, ein Commodore 64 wäre häufig gar nicht ausgelastet. Der gute alte 2001, in englischsprachigen Ländern »Pet« genannt, hinkte in puncto Leistung hinter den heutigen Heimcomputern deutlich her — wurde aber von vielen Technikern für Steuer- und Regelaufgaben eingesetzt. Manche dieser Systeme tun heute noch ihren Dienst.</p>

<p>Die Zahl der Anwendungen auf diesem Gebiet hat allerdings lange nicht so stark zugenommen, wie die Zahl der kleinen und kleinsten Computer. Das mag zu einem Teil daran liegen, daß es hier kaum vernünftige Bausätze gibt — und daß andererseits auch passionierte Bastler schnell auf Beschaffungsschwierigkeiten stoßen, wenn sie bestimmte Teile oder Baugruppen für die Realisierung der einen oder anderen Idee suchen: Wer sich mit Programmierung oder Elektronik auskennt, weiß nicht ohne weiteres, wo man welche Pumpe kaufen kann, um etwa das Blumengießen zu automatisieren.</p>

<p>Vorläufig war wohl noch ein ganz anderer Punkt hinderlich: Wer einen Computer hat, will ihn ja in der Regel für verschiedene Zwecke einsetzen und nicht nur zur Erledigung einer Aufgabe. Wenn der Computer aber beispielsweise die Heizung steuern soll, dann kann er für nichts anderes verwendet werden. Je mehr Benutzer im Laufe der Zeit jedoch »aufsteigen«, desto häufiger werden preisgünstige gebrauchte VC 20 zu haben sein, die der Commodore 64-Besitzer dann als Zweitgerät für einen speziellen Zweck reservieren kann. Damit wäre kein Problem den »Kleinen« auf Dauer als Zentrale einer Alarmanlage oder&hellip;oder&hellip;abstellen. Vielleicht bekommen damit auch die Steuer- und Regel-Anwendungen etwas Auftrieb.</p>

<p>Michael Pauly, Chefredakteur</p>

<h1 id="modem-show-im-kaufhaus">Modem-Show im Kaufhaus</h1>

<blockquote><p>Datenübertragung per Telefon ist in Amerika schon fast an der Tagesordnung, in Deutschland eine Sache von wenigen Spezialisten.<br/>
Ein Kaufhaus in München demonstrierte jetzt einen Datenaustausch zwischen einem Apple und einem C 64 über Modem und Akustikkoppler.</p></blockquote>

<p>Wir waren schon recht früh am Ort des Geschehens. Die Geschäfte hatten noch nicht lange geöffnet, dennoch herrschte bereits reger Betrieb. Unser Weg führte zu einem Kaufhaus am Stachus, einem bekannten Platz in der Münchener Innenstadt, und dort direkt in die Computerabteilung.</p>

<p>Vorbei an Farbe sprühenden Monitoren, die mit kleinen und großen Computern verbunden waren, auf denen begeisterte Jugendliche ganz weggetreten herumhackten, hielten wir Ausschau nach einem Commodore C 64. Aber nicht nach einem normalen, sondern nach einem, der an ein Modem oder auch an einen Akustikkoppler angeschlossen war. Unsere Erwartungen wurden um einiges gedämpft, als wir nichts dergleichen zu sehen bekamen. Sollte man uns falsch informiert haben? Waren wir im falschen Kaufhaus?</p>

<p>Schließlich entdeckten wir ein Gerät, von dem wir annahmen, zu Recht annahmen, daß es ein Modem war. Aber kein C 64 in der Nähe. Lediglich ein Apple, dessen Tastatur mit einer Plastikhaube verdeckt war, stand an der nächsten Regalecke (Bild 1). Dann bemerkten wir auch die Kabelverbindung zwischen diesen beiden Geräten.</p>

<p>Auch ein Bediener war nicht zu sehen. Selbst die Computer-Fans wußten mit dieser Ecke nicht viel anzufangen. Daß sich hier in Kürze erstaunliches abspielen sollte, ahnte sicherlich keiner von ihnen.</p>

<p>Wir hatten kaum Zeit, uns das Modem, dieses für Eingeweihte so interessante Gerät, genauer anzuschauen, als ein Mann auftauchte, der sich sofort daran zu schaffen machte. Nachdem wir uns vergewissert hatten, an den Richtigen gekommen zu sein,stellten wir uns vor und dann die alles einleitende Frage: »So, daß also ist das Modem ?!«</p>

<p>Im folgenden Gespräch erfuhren wir mehr über das, was wir zu sehen bekommen sollten. Es war erstens geplant, eine Verbindung zwischen einem C 64 und dem schon erwähnten Apple herzustellen. Zum anderen sollte eine Verbindung mit einem Computer in Köln geschaffen werden.</p>

<h2 id="apple-programme-mit-dem-c-64-editieren">Apple-Programme mit dem C 64 editieren</h2>

<p>Der Commodore 64, mit dem der Datenaustausch laufen sollte, stand an einem anderen Stand, etliche Meter weiter. Angeschlossen waren ein Diskettenlaufwerk VC 1541, ein Monitor und ein Akustikkoppler (Bild 2).</p>

<p>So, jetzt konnte es losgehen. Nachdem noch einmal alle Verbindungen geprüft waren, wurde zuerst die notwendige Software geladen. Sie ermöglicht es, alle Daten über die RS232-Schnittstelle über den Userport an den Akustikkoppler zu schicken, verarbeitet einkommende Daten und speichert den gesamten Dialog auf Wunsch auf Diskette.</p>

<p>Jetzt fehlte nur noch eines: Die Telefonverbindung. Also wurde die Nebenstelle angewählt, unter der das Modem angeschlossen war. Kurze Zeit später meldete sich der Apple! Natürlich vergewisserten wir uns sofort, ob das gleiche Bild auf dem Apple-Monitor zu sehen war. Und tatsächlich, alles lief synchron. Als nächstes wurde demonstriert, wie der C 64 Programme vom Apple holte. Wir ließen uns Basic-Programme aus dem Apple-Laufwerk laden und konnten sie am C 64-Monitor listen und auch ändern. Auch das Zurückspeichern verlief ohne Komplikationen.</p>

<p>Ein ungewohntes Bild war es schon. Apple Basic auf dem C 64, ohne das die VC 1541 aktiv war. Natürlich lief alles sehr langsam ab, nämlich mit 300 Baud (Bit pro Sekunde). Das ist die Geschwindigkeit, mit der die Daten per Akustikkoppler über die RS232-Schnittstelle fließen. Aber es war sehr beeindruckend.</p>

<p>Da alles über das normale Telefonnetz lief, stand auch einer weiter entfernten Verbindung nichts mehr im Weg. Aber sehen wollten wir das schon. Und so konnte eine weitere Aktion ablaufen: In Köln stand ein C 64, der darauf wartete, mit dem in München stehenden Apple zu kommunizieren.</p>

<p>Wir brauchten nur noch auf den Anruf des Kölner Gegenüber zu warten. Unser Apple stand auf Empfang. Gespannt warteten wir darauf, die ersten Zeichen auf dem Monitor zu sehen. Und auf einmal kamen sie! Wir erlebten die Versuche des Kölner mit, mit dem Apple Kontakt aufzunehmen. Jede Taste, die er in Köln drückte, war bei uns zu sehen. Er versuchte eine Meldung für ihn abzurufen. Leider hatten wir in seinen »Briefkasten« keine Nachricht hineingeschrieben. Man merkte ihm seine Enttäuschung an. Aber wir übermittelten ihm dann direkt unsere Grüße zum Gelingen dieses interessanten Versuches.</p>

<p>Mit normalen Mailboxen (Briefkästen) kann man auf drei Arten kommunizieren. Erstens ist es möglich Nachrichten einzugeben. Diese Nachrichten kann jeder, der einen Akustikkoppler besitzt, eingeben und, das ist die zweite Funktion, auch abrufen und lesen. Die dritte Möglichkeit ist die direkte Verbindung zwischen Anrufer und Empfänger. Der Empfänger ist immer der Computer, der die Mailbox unterhält. In unserem Fall war das der Apple im Münchener Kaufhaus. Manche Mailbox-Programme lassen es auch zu, persönliche Nachrichten einzugeben, die nur von einem bestimmten Teilnehmer gelesen werden können. Dieser Teilnehmer muß dazu einen persönlichen »Briefkasten« in dem Mailbox-System besitzen, für den er in der Regel einen geringen Beitrag bezahlt. Er erhält eine Geheimzahl, ein Paßwort, das nur er kennt. Somit wird sichergestellt, daß nur er die für ihn bestimmten Nachrichten lesen kann.</p>

<p>Wir »sprachen« dann noch etwas mit Köln und beendeten die Verbindung. Die Demonstration war gelungen und wir um einiges Wissen reicher. Natürlich juckte es uns in den Fingern, diese Erkenntnisse auch selbst zu verwenden. Über unsere Erfahrungen werden wir noch ausführlich berichten.</p>

<p>Als wir das Kaufhaus verließen, standen die Spiele-Freaks immer noch vor ihren Computern und hatten keine Ahnung, was ihnen entgangen war&hellip; (gk)</p>

<h1 id="tragbarer-meß--und-steuercomputer-sx-64-ads">Tragbarer Meß- und Steuercomputer SX 64 ADS</h1>

<p>Der Meß- und Steuercomputer SX 64 ADS von Datalog bietet als kompakte Einheit die preisgünstige Möglichkeit, anfallende Meßwerterfassungs-, Regel- und Steueraufgaben an wechselnden Einsatzorten ohne großen Geräteaufwand zu lösen. Das integrierte Meßdateninterface besitzt vier Analog- Eingänge mit einer Auflösung von 12 Bit, zwei Analog- Ausgänge für Regelzwecke, vier Digital-TTL- und vier Relais-Ausgänge für Steuerungsanwendungen. Die Datenrate beträgt maximal 50 Messungen pro Sekunde zum Abfragen und Setzen aller Ein- und Ausgänge. Die Programmierung des eingebauten Interfaces geschieht direkt in Commodore-Basic und sei auch von einem wenig erfahrenen Anwender mit Basic-Kenntnissen innerhalb von Minuten zu erlernen.</p>

<p>Weitere Vorzüge des Kompaktsystems sind der 5-Zoll-Farbbildschirm mit der Möglichkeit, hochauflösende Grafiken (Meßwertkurven) darzustellen, sowie die eingebaute Floppy-Station mit 170 KByte Speicherkapazität. Der Computer selbst ist mit einem RAM-Speicher von 64 KByte ausreichend bestückt. Optionell liefert Datalog ein passendes RS232C (V.24)-Interface zur Kommunikation mit anderen Systemen. Insbesondere wird darauf hingewiesen, daß das komplette Software-Angebot für den weit verbreiteten C 64-Mikrocomputer ohne Einschränkungen auf dem Meß- und Steuercomputer SX 64 ADS lauffähig ist. Somit ist das System nicht nur auf dem Einsatz im technisch-wissenschaftlichen Bereich begrenzt. Umfangreiche Demo-Software sei ini Lieferumfang enthalten.</p>

<p>Computer Journal gesucht</p>

<p>Wer hat noch Hefte der Jahrgänge 82/83 vom inzwischen eingestellten Computerjournal und kann mir diese ausleihen ? Wer besitzt eine Anleitung zum Music Composer für den VC20?</p>

<p>David Twigg-Flesner</p>

<p>CBM-Peripherie am Commodore 64?</p>

<p>Ich besitze einen CBM 3032 mit Diskettenlaufwerk und Drucker. Beim Kauf eines Commodore 64 möchte ich diese Peripherie gerne mittels eines IEC-Bus-Interfaces weiterverwenden. Hat schon jemand Erfahrungen mit solchen Interfaces gesammelt, arbeiten sie zuverlässig, und wie ist es um die mechanische Stabilität bestellt?</p>

<p>Oliver Fischer</p>

<p>Disketten beidseitig verwenden?</p>

<p>Wenn man mit einem Bürolocher auf einer einseitig beschreibbaren Diskette am linken Rand eine Stanzung in Höhe des Schreibschutzes am rechten Rand vornimmt, läßt sich die Diskette beidseitig auf einer Floppy-Disk 1541 verwenden. Ist die Datensicherheit dabei gewährleistet, oder spricht etwas gegen diese Methode?</p>

<p>Dipl.-Ing. M. Lohse</p>

<p>Die Floppy VC 1541 interessiert sich nicht für das kleine Indexloch in der Diskette. Andere Floppystationen benutzen dieses Loch zur internen Steuerung und Synchronisation. Deshalb funktioniert der Trick bei solchen Laufwerken nicht. Bei der VC 1541 gibt es jedoch keine Probleme. Allerdings ist bei einseitig beschreibbaren Disketten auch nur eine Seite durch den Hersteller geprüft. Die zweite Seite kann daher unter Umstände fehlerhafte Sektoren enthalten, die aber vom Floppy-Betriebssystem dann nicht benutzt werden. Wenn Sie nach dem Formatieren beim Listen der Directory die Meldung »664 Blocks free« sehen, sollte jedoch die Datensicherheit einigermaßen gewährleistet sein.</p>

<p>Für sehr wichtige Aufzeichnungen empfiehlt sich jedoch immer die Verwendung doppelseitig geprüfter Disketten.</p>

<p>Probleme mit Speichererweiterung</p>

<p>Neulich habe ich mir eine 16-KByte-RAM-Erweiterung für meinen VC 20 gekauft. Als ich aber versuchte, ein Spiel, das für 3 KByte-RAM und einen Joystick gedacht ist, laufen zu lassen, funktionierte es nicht, obwohl ich einen Joystick habe. Wer kann mir helfen?</p>

<p>Daniel Hüller</p>

<p>Beim VC 20 liegt der Bildschirmspeicher je nach RAM-Erweiterung in verschiedenen Adreßbereichen. Daher laufen viele Programme für die Grundversion nicht mit Speichererweiterung. Einfache Lösung für das Problem: Das Steckmodul entfernen.</p>

<p>Fragen Sie doch!</p>

<p>Selbst bei sorgfältiger Lektüre von Handbüchern und Programmbeschreibungen bleiben beim Anwender immer wieder Fragen offen. Viel mehr Fragen ergeben sich bei Computer-Interessenten, die noch keine festen Kontakte zu Händlern, Herstellern oder Computerclubs haben. Sie können der Redaktion Ihre Fragen schreiben oder Probleme schildern (arn einfachsten auf der beigehefteten Karte). Wir veranlassen, daß die Fragen von einem Fachmann beantwortet werden. Allgemein interessierende Fragen und Antworten werden veröffentlicht.</p>

<p>RESET über User-Port?</p>

<p>Um bei meinem Commodore 64 nach einem Spiel ein anderes Programm zu laden, muß in den meisten Fällen der Computer aus- und dann wieder eingeschaltet werden. Kann man das umgehen, indem man kurzzeitig Pin 1 und 3 des User-Ports miteinder verbindet, oder führt dies zu einer Beschädigung des Computers?</p>

<p>Walter Stiller</p>

<p>Pin 1 des User-Ports liegt an Masse, Pin 3 ist die RESET-Leitung. Stellt man kurzfristig eine Überbrückung her (zum Beispiel mit einer Büroklammer oder ähnlichem), dann wird ein RESET ausgelöst, wie der Computer ihn auch nach dem Einschalten durchführt. Der RESET an sich ist ungefährlich. Falls man jedoch beim Manipulieren am User-Port unabsichtlich andere Pins miteinander in Verbindung bringt, kann dies zu Beschädigungen des VIA-Bausteins führen. Es empfiehlt sich daher den Einsatz eines kleinen Tastschalters.</p>

<p>In der Ausgabe 8/84 zeigen wir übrigens verschiedene Möglichkeiten, Reset-Tasten anzubringen.</p>

<p>Nochmals DOS 5.1</p>

<p>Der Artikel über das DOS 5.1 in der Ausgabe 5/84 ist ja sehr interessant. Leider kann man bei den meisten kommerziellen Programmen aber nichts damit anfangen, da man aus diesen Programmen nur durch Abschalten des Computers wieder herauskommt. Aber dann ist auch das DOS 5.1 verloren, und es jedesmal neu einzuladen ist doch zu umständlich. Kann man da nichts dran machen?</p>

<p>Heinrich Carstensen</p>

<p>Das DOS 5.1 ist eigentlich nur bei der Programmentwicklung nützlich. Es erleichtert das Arbeiten mit der Floppy, indem es Abkürzungen verwendet. Wenn man Spiele oder andere kommerzielle Software benutzt, ist die Anwendung des DOS sowieso wenig sinnvoll.</p>

<p>64 KByte-Erweiterung für VC 20?</p>

<p>Als VC 20-Anwender möchte ich mir eventuell eine 64-KByte-RAM-Karte kaufen. Welche der angebotenen Karten ist die beste? Gibt es bei derAnwendung Probleme, zum Beispiel beim Laden von Programmen für die Grundversion? Gibt es überhaupt eine Möglichkeit, die 64 KByte voll zu nutzen, vielleicht als RAM-Disk?</p>

<p>Jens Bümmerstede</p>

<p>Wir werden in einer der nächsten Ausgaben eine 64-KByte-RAM-Karte testen. Soviel vorweg, eine Pseudo-Floppy (oder RAM-Disk) läßt sich durchaus realisieren.</p>

<p>Schachprogramme</p>

<p>Frage: Wer kennt Spielstärke Schachprogramme?</p>

<p>Ausgabe: 5/84</p>

<p>Peter Jugl</p>

<p>In einem aktuellen neutralen Vergleich in England wurden die folgenden Schachprogramme für den C 64 unter Turnierbedingungen ( = 3 min/Zug) getestet: SARGON II, CHES 7.0, COLOSSUS 2.0 und GRANDMASTER. Jedes Programm spielte dabei gegen jedes je einmal mit weiß und schwarz. Dabei wurde folgendes Endergebnis erzielt:</p>

<p>Wie Herr Wacker aber richtig schrieb, sind alle heutigen Schachprogramme für Homecomputer und selbst die neuesten Schachcomputer noch nicht in der Lage, gegen gute Vereinsspieler zu bestehen. Entscheidende Besserung dürfte erst mit modernerer Hardware (z.B. 16/32-Bit Prozessor) zu erwarten sein.</p>

<p>Fritz Schäfter, Kingsoft</p>

<p>Komma als Satzzeichen</p>

<p>Frage: Wie kann ich bei dem INPUT-Befehl das Komma als Satzzeichen verwenden?</p>

<p>Ausgabe: 5/84</p>

<p>Gerhard Giessmann</p>

<p>Kommata bei INPUT einzugeben funktioniert durchaus, vorausgesetzt die Eingabe steht in Anführungszeichen. HALLO, WIE GEHT’S? geht nicht, »HALLO, WIE GEHT’S?« aber schon. Die Anführungszeichen stehen nachher nicht in der Variablen, sie lassen den Computer lediglich das Komma als das ansehen, was es sein soll: Teil des eingegebenen Strings. Das gleiche gilt für den Strichpunkt und den Doppelpunkt. Enthält die Eingabe selbst auch Anführungszeichen heißt es aufpassen: Das erste Anführungszeichen in der Eingabe hebt das Anfangsanführungszeichen wieder auf, ein nachfolgendes Komma würde wieder als Trennzeichen interpretiert. »ICH HEISSE »WRXL«, UND DU?« ginge durchaus. Das erste Anführungszeichen ist zwar durch das zweite aufgehoben, dann folgt jedoch noch ein drittes, das dem Computer wieder sagt: es folgt ein reiner String. »NAME: »MEIER, ANDREAS«« ginge nicht. Der Doppelpunkt wird zwar nicht stören, wohl aber das Komma. Textteile, die selbst in Anführungszeichen stehen dürfen also keine Trennzeichen enthalten (,;:).</p>

<p>Metin A. Savignano</p>

<p>Zehnertastatur für C 64</p>

<p>Frage: Gibt es eine zusätzliche Zehnertastatur (Ziffernblock) zum Anschluß an den C64?</p>

<p>Ausgabe: 4/84</p>

<p>Arndt Grass</p>

<p>Die Firma Computertechnik Hartmann, Bismarckstraße 5 in 6360 Friedberg 1, Tel. 06031/ 14863, bietet für 89 Mark plus Versandkosten eine solche Tastatur an. Sie besitzt 20 Tasten, nämlich Zehnerblock, Punkt, Komma, Leer- und Return-Taste sowie die Buchstaben A bis F (zur Verwendung bei hexadezimaler Eingabe). Die Tastatur ist sowohl für den C 64 als auch für den VC 20 zu verwenden.</p>

<p>Gero Morres</p>

<p>Steckmodule abspeichern?</p>

<p>Beim VC 20 liegt der Modulbereich von $A000 bis $BFFF und läßt sich mit folgender Eingabe auf Diskette kopieren: POKE 43,0: POKE 44,160: POKE 45,0 : POKE 46,192 : SAVE »(Name)»,8.</p>

<p>Wer kann mir mitteilen, wo derModulbereich meines Commodore 64 liegt und ob es eine ähnliche Routine zum Abspeichern dieses Bereichs auf Diskette gibt?</p>

<p>Hartmut Götze</p>

<p>Der Steckmodulbereich beim Commodore 64 liegt von $8000 bis $9FFF. In der obengenannten SAVE-Routinen müssen daher der POKE-Wert 160 durch 128 und der Wert 192 durch 160 ersetzt werden. Allerdings haben die Hersteller von Steckmodulen in der Regel einige Sicherungen gegen unerlaubtes Kopieren eingebaut.</p>

<p>Sprachausgabe mit VC 20</p>

<p>Frage: Wer kennt ein Programm zurErzeugung von Sprache auf dem VC 20?</p>

<p>Ausgabe: 5/84</p>

<p>Georg Brandt</p>

<p>Die Firma Adman Electronics Ltd., Ripon Way, Harrogate N.Yorks. HG 12AU in Großbritannien bietet für den VC 20 / V 64 einen Speech-Synthesizer für englische Sprachausgabe zum Preis von 49,95 Pfund an.</p>

<p>Spiele dafür sind von Bugbyte (Twin Kingdom Valley), Voyager (Attack, Attack) und Thor Computer Software (3D Silicon Fish) schon im britischen Fachhandel erhältlich.</p>

<p>David Twigg-Flesner</p>

<p>Grafik mit VC 1515</p>

<p>Frage: Wie kann man verhindern, daß der VC 1515 Drucker von Zeit zu Zeit mit der Fehlermeldung »DEVICE NOT PRESENT ERROR« aussteigt?</p>

<p>Ausgabe: 5/84</p>

<p>Joachim Bolle</p>

<p>Das Problem läßt sich auch umgehen, wenn man alle PRINT #-Anweisungen durch normale PRINT-Befehle ersetzt. Zu diesem Zweck muß die Ausgabe mit der CMD-Anweisung auf den Druckerkanal umgelegt werden.</p>

<p>In meinen Programmen erfolgen Ausgaben auf dem Drucker also nicht mehr so:<br/>
OPEN 4,4 : PRINT#4, ”Test”: CLOSE 4,<br/>
sondern in der folgenden Form:<br/>
OPEN 4,4: CMD 4: PRINT ”Test” : PRINT#4 : CLOSE4<br/>
Durch den Wegfall der PRINT #-Anweisungen laufen meine Programme nun völlig störungsfrei.</p>

<p>Hans-Jürgen Stadelmann</p>

<p>Rechengenauigkeit</p>

<p>Frage: Wie erklärt sich der Unterschied in der Rechengenauigkeit von Taschenrechnern und Computern?</p>

<p>Ausgabe: 5/84</p>

<p>Albert Bartels</p>

<p>Ihre Antwort zur Leserfrage ist natürlich richtig. Die Rechengenauigkeit des Computers ist geringer. Allerdings wurde die Frage nur teilweise beantwortet. Das Ergebnis der Berechnung des Computers wird in Bogen maß ausgegeben. Die meisten Taschenrechnern berechnen jedoch in Gradmaß.</p>

<p>Um das Ergebnis des Computers in Grandmaß zu erhalten muß folgende Umrechnung erfolgen, wobei für x der jeweilige Winkel, für pi 3.14159265 eingesetzt werden muß:</p>

<p>Gradmaß Bogenmaß Sin x = Sin (x<em>pi/180)<br/>
Beispiel: Sin 45 = 45</em>3.141592<br/>
65/180)</p>

<p>Siegfried Dietrich</p>

<h1 id="vergleichstest-centronics-schnittstellen">Vergleichstest Centronics-Schnittstellen</h1>

<blockquote><p>Ein Interface muß die richtige Verbindung herstellen, um einen Drucker mit Centronics-Eingang am Commodore 64 zu betreiben. Mittlerweile werden einige solcher, auch Schnittstellen genannte, Erweiterungen auf dem Markt angeboten. Doch nicht alle leisten und kosten das gleiche. Welches Interface ist das beste?</p></blockquote>

<p>Die Tatsache, daß sich bisher kaum ein Hersteller von Heimcomputern zu einer Normung der Verbindungsports durchgerungen hat, ist sicher jedem C 64-Besitzer bekannt. Wer einmal versucht hat, einen anderen, als einen Commodore-Drucker an seinen Computer anzuschließen, wird fest-<br/>
gestellt haben, daß dies nicht ganz unproblematisch ist. Weder am Drucker, noch am C 64 befindet sich ein Ausgang, der dem anderen auch nur im entferntesten ähnelt. Da aber gerade die Drucker von Fremdherstellern oft mit überlegenen Leistungen aufwarten können, ist ein ständig wachsender Markt von Schnittstellen verschiedenster Konstruktionsweisen entstanden. Das Hauptunterscheidungsmerkmal bei diesen Schnittstellen ist die Art der Datenübertragung und -anpassung. Zum einen werden sogenannte Softwarelösungen angeboten, bei denen die Anpassungen der Daten mit Hilfe von ladbarer beziehungsweise auf Eproms steckbarer Software im Computer selbst vorgenommen und über den User-Port zum Drucker gesendet wird. Zum anderen gibt es die Hardwarelösungen (Bild 1), die, mit eigenem Prozessor versehen, die Datenanpassung auf einer externen Platine durchführen und ausnahmslos den seriellen Bus zur Datenübertragung verwenden.</p>

<h2 id="der-testablauf">Der Testablauf</h2>

<p>Getestet wurden natürlich sowohl Hard- als auch Softwareschnittstellen (Bild 2). Die Vertreter der Hardwareseite waren das Görlitz-Interface, zwei ungleiche Versionen von Wiesemann und das weit verbreitete Data Becker-Interface. Auf der Softwareseite traten die Eprom-Versionen von Kalawsky, Bockstaller und die Diskettenversion der in diesem Heft beschriebenen Schnittstelle unseres Lesers Helmut Eyssele, zum Test an.</p>

<p>Erstes Testkriterium waren alle in den zugehörigen Bedienungsanleitungen angegebenen Funktionen. Zusätzlich mußten die Kandidaten noch zwei Sonderprüfungen ablegen: Ihre Verträglichkeit mit einer Reihe von bekannten Textverarbeitungsprogrammen (siehe Bild 3) und ihre Fähigkeiten bei der Erstellung einer Hardcopy vom Bildschirminhalt (was noch für Überraschungen sorgte). Da die einzelnen Testteilnehmer über die verschiedensten Befehle zur Ansteuerung ihrer Funktionen verfügen, war es nicht sinnvoll, ein einheitliches Testprogramm zu schreiben. Es wurde aber trotzdem versucht, ähnliche Funktionen zu vergleichen.</p>

<h2 id="der-alleskönner">Der Alleskönner</h2>

<p>Mit zirka 340 Mark nicht gerade das billigste, stellte sich das Görlitz-Interface zum Test. Diese Hardwarelösung ist zum Einbau in einen Epson MX/RX/FX 80-Drucker vorgesehen. Der Einbau ist, auch für technische Laien, problemlos, denn die Platine (Bild 1) wird lediglich in den geöffneten Drucker eingesteckt und ist sofort betriebsbereit. Der Epson wird fortan wie ein Commodore-Drucker angesprochen. Die Commodore-eigenen Steuerzeichen werden dabei, wie gewohnt, als reverse Grafiksymbole ausgedruckt. Dies deutet darauf hin, daß auch die Grafikzeichen dem Drucker keine Schwierigkeiten bereiten. Der eingebaute Selbsttest (nicht der des Druckers) zeigt den gesamten neuen Zeichensatz. Wem das aber immer noch zu wenig ist, hat die Gelegenheit den gesamten CBM-Zeichensatz in bis zu vierzig Variationen aus doppelter Breite, doppelter Höhe und reverser Darstellung auszudrucken. Ferner verfügt das Görlitz-Interface über einen Grafik-Modus, in dem alle Zeichen, deren Code größer als 127 ist, als senkrechte Punktreihe aufgefaßt werden. Durch Aneinanderreihen vieler dieser Reihen können beliebige Zeichen gedruckt werden. Daß die Steuer- und Formatierungsbefehle, wie sie im Epson-Handbuch beschrieben sind, in jedem Modus erhalten bleiben, gefiel beim Test besonders.</p>

<p>Die letzte Station unserer Testreihe, der Bildschirmausdruck, wurde mit besonderer Spannung erwartet. Die Aufgabe lautete: Mit den in der Data Becker-Supergrafik und Simons Basic enthaltenen Hardcopyroutinen in möglichst kurzer Zeit einen genauen Abdruck des Bildschirms auf das Papier zu bringen. Nach der Vorbereitung des Interfaces durch die folgenden Basic-Zeilen:</p>

<pre>
100 OPEN 1,4 :REM Druckerkanal öffnen  
110 PRINT#1,CHR$(27)"V":REM VCEI Grafic  
120 PRINT#1,CHR$(08):REM 7-Nadel Einzelp.  
130 OPEN9,4,9,"7":REM Zeilenabst. auf 0  
140 Copy:REM Simons Basic Hardcopy  
150CLOSE1:CLOSE9:REM Druckerkan.schl.  
160 END  
</pre>


<p>konnte der Ausdruck beginnen. Ein kleines Testprogramm erstellte die auszudruckende hochauflösende Grafik und der Drucker begann seine Arbeit. Nach zirka 40 Sekunden war der Bildschirminhalt auf Papier verewigt, allerdings war der Ausdruck etwas klein. Aber auch hier bietet das Görlitz VCEI eine Veränderungsmöglichkeit an: Durch Einfügen einer zusätzlichen Zeile ist eine variable Breite des Ausdrucks möglich. Bei dieser Fülle von Anwendungsmöglichkeiten erscheint es fast schon selbstverständlich, daß auch bei der Konzeption der Platine an den Anwender gedacht wurde. So ist beispielsweise der serielle Bus am Interface doppelt vorhanden, damit der Drucker nicht das letzte angeschlossene Gerät sein muß. Die mögliche Abschaltbarkeit der Schnittstelle ist dann sinnvoll, wenn der Drucker auch noch an anderen Computern eingesetzt werden soll. Man erspart sich so den Ausbau des Interfaces. Eine Besonderheit, mit der sonst keine andere der im Test befindlichen Schnittstellen aufwarten konnte, ist der eingebaute Pufferspeicher von zwei KByte. Dies ist besonders angenehm beim Arbeiten mit Textverarbeitungsprogrammen, da bereits weitergeschrieben werden kann, während der Drucker noch arbeitet. Beim Test der Kooperation mit den Textverarbeitungsprogrammen gab es in keinem Fall Probleme beim Ausdrucken der Texte.</p>

<p>Insgesamt machte das Görlitz-Interface einen hervorragenden Eindruck. Beim ständigen Arbeiten mit dem Drucker vergißt man nach einiger Zeit vollkommen, daß der Epson FX 80 eigentlich nicht speziell für den Commodore 64 konzipiert wurde.</p>

<h2 id="die-düsseldorfer-lösung">Die Düsseldorfer Lösung</h2>

<p>Für den Einbau des VCI von Data Becker gilt das gleiche, wie für das Görlitz-Interface. Leider hat man bei Data Becker vergessen, den seriellen Bus durchzuführen, so daß der Drucker das letzte Gerät sein muß. Wie aus Bild 3 ersichtlich ist, sind Listing-Modus, Grafik- und reverse Zeichen sowie der Direkt-Modus verfügbar und über Sekundäradressen einzustellen. Auch ein spezieller Grafikmodus. Die Frage, ob diese Grafikfähigkeit aber auch für einen Bildschirmausdruck genügend war, ließ die Redaktion voller Erwartungen an den Hardcopytest herangehen. Naheliegend war es natürlich, das Hilfsprogramm aus dem gleichen Hause, die Supergrafik, zu verwenden. Getreulich den Worten der Anleitung folgend, versuchten wir mit dem Befehl für Acht-Nadel-Drucker, ein Bild zu kopieren. Das Ergebnis war ernüchternd, denn der Drucker regte sich zwar, aber das was er druckte, sah aus wie Nebel über London. Erst als wir es mit dem Sieben-Nadel-Hardcopybefehl versuchten, hatten wir Erfolg. Von diesem Erlebnis angespornt versuchten wir es auch noch mit Simons Basic. Nach dem Eingeben des folgenden kleinen Programms klappte es auf Anhieb.</p>

<pre>
100 OPEN l,4:REM Druckerkanal öffnen  
110 PRINT#1,CHR$(8):REM Grafik Modus  
120 PRINT#1,CHR$(26):REM Grafik Byte wiederh.  
130 Copy: REM Simons Basic Hardcopy  
140 CLOSEl:REM Druckerkanal schließen  
</pre>


<p>Was wir nicht erwartet hatten: Es gab bei den Zeitmessungen für die Hardcopyausdrucke enorme Unterschiede zwischen den einzelnen Schnittstellen. Für das gleiche Bild benötigte das Data Becker-Interface sechsmal länger (zirka 4 Minuten) als das Görlitz-Interface. Dies ist wahrscheinlich damit zu erklären, daß durch das VCI ein Commodore 1526 simuliert wird (ohne dabei auf die Vorzüge des Epson-Druckers zu verzichten), der aber selbst mit neuem ROM nur ein frei definierbares Zeichen besitzt. Das Zusammenspiel mit den ausgewählten Textverarbeitungsprogrammen funktionierte auch mit dem VCI einwandfrei. Wer aber lieber eigene Texte eingeben, beziehungsweise in seine Programme einbauen will, wird die Funktion »Festlegen der Druckposition« des VCI bald nicht mehr missen wollen. Durch diese Funktion ist es möglich, die Punktposition, ab der ein Text auf dem Papier gedruckt werden soll, festzulegen.</p>

<p>Bis auf die etwas langsame Hardcopy ist dem Data Becker-Interface wenig Negatives nachzusagen, wenn es auch nicht ganz die Möglichkeiten der Görlitz-Schnittstelle bietet. Dafür ist es aber mit 298 Mark auch um 40 Mark billiger als das Görlitz-Pendant. Das ist natürlich immer noch ein stolzer Preis.</p>

<h2 id="zwei-ungleiche-brüder">Zwei ungleiche Brüder</h2>

<p>Die nächsten beiden Testgeräte von Wiesemann sehen zwar äußerlich vollkommen gleich aus, in ihren Leistungsmerkmalen unterscheiden sie sich aber erheblich. Das intelligentere der beiden hat den Namen VC 20/CBM 64-Interface Typ 9200 NEC und ist für NEC und kompatible Drucker vorgesehen. Sein Bruder verzichtet auf den Zusatz NEC im Namen und auch auf so manche Fähigkeit. Er ist für die Ansteuerung eines Epson-Druckers vorgesehen. Die Installation dieser Schnittstellen ist vorbildlich einfach, denn sie werden nur in den Eingang des Druckers, beziehungsweise den seriellen Ausgang des C 64 eingesteckt. Lediglich bei der Version für Epson-Drucker ist für die notwendige Stromversorgung des Interfaces zu sorgen. Dafür eignet sich am besten das gegen Aufpreis erhältliche Netzteil. Wer aber mit Lötkolben und Meßgeräten vertraut ist, wird in der Bedienungsanleitung des Interfaces noch auf eine zweite Möglichkeit hingewiesen: die Entnahme der Versorgungsspannung von der Druckerplatine. Dieser Eingriff erfordert allerdings größte Vorsicht. Denn ein falscher Anschluß kann den »Tod« einer ganzen IC-Familie bedeuten.</p>

<p>Die Merkmale der Epson-Version sind rasch beschrieben, da sie sich lediglich auf die Ausgabe von Texten beschränken. Hierfür ist diese Schnittstelle mit Groß- und Kleinschriftmodus, sowie einigen Textformatierungsbefehlen ausgerüstet. Durch die Bauweise als Hardwareschnittstelle tauchten keine Probleme mit den zur Verfügung stehenden Textverarbeitungsprogrammen auf. Die Darstellung von Grafik- und Steuerzeichen ist leider nicht möglich. In diesem Bereich bietet das 9200 (NEC) die gleichen Funktionen wie das Data Becker VCI, kaum verwunderlich, wenn man weiß, wer der Hersteller des VCI ist: Wiesemann. Der auffallendste Unterschied vom 9200 NEC zum VCI ist die Möglichkeit, den Drucker in einen 6-Punkt-Modus zu schalten. Dadurch bleiben Programme, die für den 1515 Commodore-Drucker entwickelt wurden, weiterhin verwendbar.</p>

<p>Im wesentlichen gilt für das 9200 NEC-Interface das gleiche wie für das Data Becker-VCI. Lediglich auf den Einbau in den Drucker kann verziehet werden.</p>

<p>Die Epson-Version des 9200 eignet sich vor allem für jenen Computerbesitzer, die sich auf das problemlose Ausdrucken von Texten beschränken wollen. Allerdings liegt der Preis mit 248 ohne und 298 Mark mit Netzteil unverhältnismäßig hoch.</p>

<h2 id="der-außenseiter">Der Außenseiter</h2>

<p>Besonders gespannt waren wir auf das Abschneiden der Schnittstelle unseres Lesers H.Eyssele im Vergleich zu den professionellen. Wie die Verbindung zwischen dem Computer und dem Drucker hergestellt wird, braucht sicher nicht mehr erklärt werden, da dies genauestens in einem eigenen Bericht beschrieben ist. Ganz besonders gefallen haben uns die Möglichkeiten des Listingausdrucks. Die Umwandlung der Steuerzeichen in Klarschrift ist eine Funktion, die kein anderes Interface anbietet. Dadurch spart man sich beim Eintippen oder Korrigieren eines Listings das Nachschlagen der Steuercodes in der Vergleichstabelle. Die vorliegende Version der Schnittstelle funktionierte zwar nur in Verbindung mit Vizawrite, kann aber sicherlich ohne großen Aufwand an andere Programme angepaßt werden. Eine Hardcopy war leider noch nicht möglich. Hier geht der Aufruf an alle Programmierer, dies etwa als Teil unseres Programmierwettbewerbs »Programmbibliothek« zu ergänzen. (Die Redaktion wartet gespannt darauf).</p>

<p>Zum Preis von zirka 50 Mark (für das Kabel) bietet dieses Interface Leistungsmerkmale, wie sie eigentlich nur von professionellen Schnittstellen zu erwarten sind. Damit sicherte sich diese Lösung einen der vorderen Plätze der Bewertung.</p>

<h2 id="der-hardcopyspezialist">Der Hardcopyspezialist</h2>

<p>Die Kalawsky-Schnittstelle, deren Software nicht von Diskette, sondern durch ein Steckmodul in den C 64 eingeladen wird, überraschte durch eine komfortable Hardcopyroutine. Ein beliebiger Bildschirminhalt kann durch einfachen Tastendruck (CTRL-) auf den Drucker übertragen werden. Das Hardcopy benötigt etwa die gleiche Zeit wie das Görlitz-Interface mit Simons Basic. Ein Drücken der Tasten CTRL und x ermöglicht sogar ein großes Hardcopy auf die gesamte Blattbreite. Da manche Bilder als inverser Ausdruck besser aussehen, kann das Hardcopy auch in dieser Form ausgegeben werden. Natürlich ist auch die Textausgabe mit der Kalawsky Schnittstelle möglich. Dafür sollte man allerdings am besten ein Textverarbeitungsprogramm verwenden, da bei der direkten Ausgabe von Print-Zeilen im Groß/Kleinschriftmodus des C 64 Großbuchstaben als kursive Zeichen gedruckt werden. Dadurch leidet die Lesbarkeit doch stark. Mit 85 Mark für das Eprom, wo noch die Kosten für ein Verbindungskabel (zirka 45 Mark) hinzukommen, liegt der Preis sicher nicht in unerschwinglichen Höhen.</p>

<p>Für jeden, der sowohl Texte verarbeiten, als auch Hardcopys von beliebigen Bildern anfertigen möchte, ist dieses Interface ein nützliches Instrument.</p>

<p>Der äußeren Form des Kalawsky-Interface ähnlich präsentiert sich das Bockstaller-Interface. Die Bestandteile sind eine Epromplatine und ein Verbindungskabel. Diese Lösung macht sowohl Textausgaben von Basic aus, als auch mit dem Textverarbeitungsprogramm Vizawrite möglich. Der Groß/Kleinschriftmodus bleibt in jedem Fall erhalten. Für die Ausgabe von Grafiken und Hardcopys ist diese Schnittstelle allerdings weniger geeignet. Mit diesen Leistungen ist sie bei einem Preis von zirka 130 Mark zwar etwa gleich teuer wie das Kalawsky-Interface, besitzt aber nicht deren komfortable Hardcopyroutine.</p>

<h2 id="die-bewertung">Die Bewertung</h2>

<p>Der Test hat gezeigt, daß jede Schnittstelle mit besonderen Fähigkeiten und Vorzügen aufwarten kann. An der Spitze des Testfeldes plazierten sich unserer Meinung nach die drei Hardwarelösungen von Görlitz, Data Becker und Wiesemann (NEC). Dabei belegte das Görlitz-Interface wegen seiner universellen Anwendbarkeit und dem vorbildlichen Aufbau der Platine den ersten Platz. Zwischen den beiden Interfaces von Data Becker und Wiesemann war der Unterschied nur gering. So wurde salomonisch beschlossen, diesen beiden Schnittstellen den zweiten Platz gemeinsam anzuerkennen. Für die Überraschung sorgte der Außenseiter: Der dritte Platz konnte an die Lösung unseres Lesers vergeben werden, und das lag nicht nur an dem unübertroffenen Preis-Leistungsverhältnis. Knapp geschlagen plazierte sich das Kalawsky-Interface auf dem vierten Platz. Mit seiner Hardcopyroutine auf Tastendruck und der Möglichkeit der Textverarbeitung bietet es zu einem annehmbaren Preis eine gute Leistung. Die Schlußlichter des Testes bildeten das Wiesemann (Epson) und das Bockstaller-Interface. Obwohl sich das 9200 (Epson) zur reinen Textverarbeitung hervorragend eignet, ist es mit einem Preis von zirka 298 Mark doch etwas teuer geraten. Das Bockstaller-Interface ist eine Lösung für alle, die ohne große finanzielle Ausgabe Texte ausdrucken wollen und sich die Zeit zum Laden der Software sparen wollen.</p>

<p>Sicherlich muß jeder potentielle Käufer eines Interfaces sich über seine eigenen Anwendungszwecke im Klaren sein. Auch spielt der zur Verfügung stehende Geldbetrag eine wesentliche Rolle. Die Entscheidung für eines der getesteten Interfaces ist deshalb immer eine individuelle, bei der nicht vergessen werden sollte, daß die Ansprüche an den Drucker mit der Zeit bestimmt nicht geringer werden.</p>

<p>(Arnd Wängler)</p>

<h1 id="expansions">Expansions</h1>

<blockquote><p>Erweiterungen — das ist das Zauberwort, wenn man die durch Hardware oder Software gesetzten Grenzen eines Computers überwinden will.</p></blockquote>

<p>Ob man seinen Commodore 64 für die Meßdatenerfassung im Laboreinsatz umrüsten möchte oder ob man nur zusätzliche 16 KBytes RAM für seinen VC 20 benötigt — für fast jede denkbare Anwendung ist eine geeignete Erweiterung auf dem Markt. Das Angebot ist dabei äußerst vielfältig und selbst für den Fachmann kaum noch überschaubar, da eine Unzahl von Erweiterungen — für zum Teil sehr spezielle Zwecke — nur in kleinen Serien hergestellt und verkauft werden. Im 64'er wollen wir an dieser Stelle regelmäßig einen Überblick über Erweiterungen wie auch über interessante Neuentwicklungen für den Commodore 64 und den VC 20 geben.</p>

<p>(gk)</p>

<h1 id="der-data-kassettenrecorder">Der Data-Kassettenrecorder</h1>

<blockquote><p>In der Ausgabe 6/84 konnten wir in dem Artikel »Rund um die Datasette« wegen eines Gerätedefektes den Data-Kassettenrecorder von Nettetaler nicht berücksichtigen.</p></blockquote>

<p>Der Recorder stellt mit dem Preis von 109 Mark eine preiswerte Alternative zur Original Datasette dar. Äußerlich ist dieses Gerät nicht besonders ansprechend. Im Gegensatz zur Datasette macht der Data-Kassettenrecorder einen zerbrechlichen Eindruck.</p>

<p>Im Testbetrieb, der für Geräte bei uns in der Redaktion zur Belastungsprobe wird, stellte sich der Recorder als zuverlässig heraus. Es traten keine Lade- und Speicherfehler auf.<br/>
Auch bei den von uns benutzten Kassetten, die auf anderen Recordern oder der Orginal Datasette aufgenommen worden sind, gab es keine Probleme.</p>

<p>Nach unserer anfänglichen Enttäuschung über das defekte Testgerät stellte sich der Data-Kassettenrecorder als echte Alternative zur Original Datasette vor. Defekte an diesem Gerät sollen nach Auskunft von Nettetaler sehr selten sein: Die Rücklaufquote soll sich bei 12000 verkauften Geräten unter 0.5 % halten.</p>

<p>(rg)</p>

<h1 id="teleterm-– die-verbindung-zum-modem">Teleterm – Die Verbindung zum Modem</h1>

<blockquote><p>Um mit dem Commodore 64 über Akustikkoppler und Modem mit anderen Computern Daten austauschen zu können, benötigen Sie die entsprechende Software. Teleterm ist eine solche Treibersoftware.</p></blockquote>

<p>Um mit Ihrem C 64 in die Welt der Datenfernübertragung eintreten zu können, brauchen Sie, neben Ihrem Computer und einem Monitor (Fernseher), drei zusätzliche Werkzeuge. Als erstes wäre ein Modem oder ein Akustikkoppler für die Verbindung zum Telefon notwendig. Dann benötigen Sie ein Interface, um die Verbindung zwischen Akustikkoppler und Computer herzustellen. Das letzte, fast wichtigste Werkzeug ist die Treibersoftware. Erst dann können die Daten auch tatsächlich übertragen werden. Eines dieser Programme ist Teleterm von Software Express.</p>

<p>Am Anfang des Programms kann man die Sprache auswählen, mit der man arbeiten will. Zur Auswahl stehen Deutsch und Englisch.</p>

<p>Teleterm bietet über ein komfortables Menü vielseitige Möglichkeiten. Man kann zum Beispiel ein ständiges Protokoll auf der Diskette abspeichern. Dieses Programm lädt dabei alle Daten in einen Puffer, der dann, sobald er gefüllt ist, die Daten auf die Diskette schreibt. Der Schreibvorgang wird durch Änderung der Rahmenfarbe angezeigt. Diese Protokollierung ist oft sehr nützlich, kann aber auch zum Problem werden. Manche Mailboxen und Datenbanken haben einen Timeout. Timeout bedeutet: Wenn eine bestimmte Zeit keine Kommunikation erfolgt, wird die Verbindung als beendet angesehen. Diese Regelung ist notwendig, da sonst ein falsch aufgelegter Telefonhörer ein System über Stunden blockieren könnte.</p>

<p>Wenn dieser Timeout sehr knapp eingestellt ist, kann das Abspeichern der Kommunikation zum Abbruch der Verbindung führen.</p>

<p>Die Menüpunkte sind im einzelnen:</p>

<ul>
<li>Daten empfangen mit Telefon</li>
<li>Parameter ändern</li>
<li>Dateien anzeigen</li>
<li>Dateien ausdrucken</li>
<li>Funktionstasten belegen</li>
<li>Funktionstasten-Übersicht</li>
<li>Vorbereiten von Briefen</li>
<li>Dateien löschen</li>
<li>Ende.</li>
</ul>


<p>Bei diesem Menü fallen zwei Punkte besonders auf. Zum einen ist dies die Funktion »Parameter ändern«. Ruft man die Funktion »Parameter ändern« auf, dann können folgende Einstellungen verändert werden: die Übertragungsgeschwindigkeit (Baudrate), die Parität, die Wortlänge, die Anzahl der Stopbits, den Handshake-Betrieb und die Sendeart (Vollduplex/Halbduplex).</p>

<p>Die Bedeutung der oben erwähnten Begriffe entnehmen Sie bitte unserer Übersichtstabelle.</p>

<p>Der zweite auffällige Punkt ist die Möglichkeit, die Funktionstasten zu belegen. Besonders dieses Statement macht das Programm sehr komfortabel. Man kann die Funktionstasten zum Beispiel mit häufig vorkommenden Textstrings belegen und sich so viel Tipparbeit ersparen.</p>

<h2 id="der-testbetrieb">Der Testbetrieb</h2>

<p>Teleterm stellte sich während des mehrerer Wochen dauernden Tests in der Redaktion als zuverlässiges Werkzeug heraus. Der Test wurde mit dem RS232-Interface desselben Anbieters wie Teleterm und dem Epson CX-21 Akustikkoppler durchgeführt. Das Handbuch wurde nach kurzer Zeit beiseite gelegt. So leicht ist Teleterm zu bedienen. Betreibt man den Akustikkoppler allerdings über eine ältere Nebenstellenanlage, kann es vorkommen, daß die Abschirmung der Telefonleitungen nicht ausreicht. Dies bewirkt, daß durch andere Leitungen falsche Zeichen eingelesen werden. Dieses Manko dürfte allerdings nur sehr schwer zu beseitigen sein und tritt nicht nur bei dieser Treibersoftware auf. Auf der Nebenstellenanlage unseres Verlages traten im Testbetrieb jedoch keine Probleme dieser Art auf.</p>

<p>Das Programm Teleterm kostet 119 Mark. Zu dem selben Preis wird von Software Express auch ein RS-232-Interface angeboten. Dieses Interface ist natürlich auch unabhängig von Teleterm verwendbar.<br/>
(rg)</p>

<h1 id="electronic-mail-–-die-neue-form-der-postbeförderung">Electronic Mail – die neue Form der Postbeförderung</h1>

<blockquote><p>Hauptanwendungsgebiet für Textverarbeitungsprogramme auf Personal- und Homecomputern ist das Schreiben von Briefen. Hier haben die Computer wesentliche Leistungs-, Zeit- und Kostenvorteile ermöglicht. Die Übermittlung der schriftlichen Mitteilungen erfolgt aber immer noch auf dem traditionellen Postweg mit langen Laufzeiten und hohen Kosten.</p></blockquote>

<p>Immer deutlicher zeichnet sich ab, daß die Computer bald auch die Übermittlung von Briefen und Mitteilungen einschneidend verändern werden. Die großen Computerfirmen haben schon seit Jahren Systeme in Betrieb, mit denen sie dem teuren Briefverkehr ausweichen. Es handelt sich um Electronic-Mail-Systeme, die oft weltweit ausgelegt sind und die Mitarbeiter in die Lage versetzen, jederzeit und blitzschnell miteinander zu kommunizieren. Bildschirmterminals und Personal Computer werden über Modem oder Akustikkoppler ans Telefonnetz angeschlossen. Ebenfalls ans Telefonnetz angeschlossen ist ein Zentralcomputer, auf dem ein Mail-Box-Programm läuft. Dieses Programm richtet den Mitarbeitern elektronische Briefkästen und Editierplätze ein. Benutzerkennummern und Paßwörter ermöglichen es den Mitarbeitern, über ihre Terminals und PCs Mitteilungen abzurufen und zu senden, von jedem beliebigen kommunikationsfähigen Terminal oder PC. Die »Zustellung« beziehungsweise Verwaltung der Mitteilungen erfolgt im Zentralcomputer, der 24 Stunden am Tag ansprechbar ist.</p>

<p>Einige Computerfirmen wie Tandem haben ihr Electronic Mail System den Mitarbeitern über die rein betriebliche Anwendung hinaus geöffnet. Die Begeisterung darüber ist groß. Neben technischen Fragen und Problemlösungen werden betriebsintern auch Clubinformationen oder Gesuche und Angebote für zum Beispiel Gebrauchtwagen, Wohnungen und ähnliches allen Betriebsmitgliedern zugänglich gemacht.</p>

<p>Gegenwärtig sind Electronic-Mail-Systeme fast nur bei großen Computerfirmen im Einsatz. Terminals, PCs und Modems waren teuer. Entsprechende Zentralcomputer mit Mailbox-Programm ebenfalls. Der rasante technische Fortschritt im PC- und Homecomputerbereich hat diese Voraussetzungen im letzten Jahr einschneidend verändert. Preiswerte Personal und Homecomputer sind über oft bereits eingebaute V.24-Schnittstellen kommunikationsfähig und in großen Stückzahlen vorhanden. Neue, integrierte Modemchips haben Modems und Akustikkoppler in einen Preisbereich gebracht, in dem sie massenhaft Absatz finden können.</p>

<p>In den USA und England zeigt sich jetzt ein sehr starker Trend zur breiten Nutzung von Electronic Mail. Zunächst waren es vor allem Unternehmen, die bei Rechenzentren Kapazitäten für Electronic Mail anmieteten. Inzwischen gibt es auch mehrere Firmen, die Electronic Mail mit eindrucksvollen Erfolgen privaten Home- und Personal Computerbesitzern anbieten. Abrufsoftware und entsprechende Modems für die Home- und Personal Computer sind als preiswerte Paketangebote, oft inklusive eines Electronic-Mail-Abbonnements, in allen Computershops erhältlich. Da Mailbox-Software (für die Zentralstation) inzwischen auch für eine Reihe leistungsfähiger PCs preiswert verfügbar ist, gründen immer mehr Privatpersonen und Clubs sogenannte Bulletin Boards, kleinere Electronic-Mail-Systeme, die in der Regel auch als Informationsdatenbanken ausgelegt sind.</p>

<p>Electronic Mail wird sich auch in der Bundesrepublik durchsetzen. Dies dürfte schneller geschehen, als auf den ersten Blick zu erwarten ist. Mächtig dazu beitragen wird ein neuer Service, den die Bundespost mit ungewohnter Geschwindigkeit und Innovationsfreude demnächst einführt. Es handelt sich um die Telebox, einen bundesweiten Electronic-MaiI-Service für alle über Akustikkoppler oder Modem kommunikationsfähigen Personal Computer, portable Computer, Terminals und natürlich auch Homecomputer.</p>

<p>In Mannheim wird ein Telebox-Zentralcomputer installiert, der über das normale Telefonnetz oder über die Datex-Dienste zugänglich ist. Geboten wird ein Electronic-Mail-System mit beachtlichen Leistungsmerkmalen:</p>

<p>Jeder Nutzer des Telebox-Systems erhält eine eigene Adresse, die ihn zusammen mit dem persönlichen Paßwort als berechtigten Nutzer des Systems ausweist und ihm dadurch das Eingeben und Auslesen von Mitteilungen im System ermöglicht.</p>

<ul>
<li>Mobilität bei ständiger Erreichbarkeit. Von jedem beliebigen Ort kann sich der Benutzer über die Datexnetze oder das Telefonnetz an das System anschalten, auch mit einem transportablen, akustisch gekoppelten Datenendgerät, das in der Aktentasche mitgeführt und an jedem beliebigen Telefon benutzt werden kann. Eingegangene Mitteilungen werden ausgelesen, eine Antwort beziehungsweise eine Mitteilung abgesetzt oder eine abgelegte Mitteilung aus dem Speicher abgerufen.</li>
<li>Einfaches Abspeichern und schnelles Wiederauffinden von Mitteilungen (elektronischer Aktenschrank). Der Benutzer kann sich Ablagefächer anlegen, die er beliebig strukturiert und benennt.</li>
<li>Editieren und Formatieren von Texten. Ein umfangreicher Vorrat an Befehlen erleichtert dem Benutzer das Erstellen von Texten, die ebenfalls in wiederaufrufbare Dateien abgespeichert werden können.</li>
<li>Erleichterungen beim Absenden und Lesen von Mitteilungen.  
Mit der Angabe von Mehrfachadressen läßt sich dieselbe Mitteilung in einem Arbeitsgang an mehrere Empfänger absenden.  
Adreß-Verteiler können vom Benutzer selbst angelegt werden.  
Die Abfrage von Kopfzeilen erleichtert die Übersicht, wenn mehrere Mitteilungen eingegangen sind.  
Das Weiterleiten von eingegangenen Mitteilungen an andere Telebox-Adressen mit oder ohne Zusetzen von Kommentaren erlaubt eine rasche Bearbeitung.  
Das Beantworten von eingegangenen Mitteilungen ist in vereinfachtem Format möglich.  
Die Nutzung der Leistungen von Telebox kann zu rascherer und effizienterer Information zwischen den Partnern führen. Damit ist außerdem Zeit- und Kostenersparnis verbunden.</li>  
<li>Schwarzes Brett: Hier können Informationen im System bereitgehalten werden, auf die entweder alle Benutzer oder bestimmte Gruppen von Benutzern zugreifen können. Dabei können Sparten mit beliebigen Namen eingerichtet werden, die vom Benutzer gezielt abgefragt werden. Informationen, die rasch einen größeren Empfängerkreis erreichen sollen, lassen sich auf diese Weise einfach zugänglich machen.</li>
<li>Verzeichnisse: Sie erleichtern das Herausfinden der Adressen der Partner, denen man Mitteilungen zuleiten möchte. Es können Kurznamen und firmeninterne Bezeichnungen als Referenzadressen festgelegt werden, die vom System in die allgemeinen Adressen umgesetzt werden.</li>
</ul>


<p>Während bei Bildschirmtext die Vorbereitung Jahre in Anspruch nahm und die Testphase mit beschränkter Teilnehmerzahl drei Jahre lief, startet die Telebox praktisch aus dem Stand. Im August bis September beginnt ein Teilnehmer-Test-Betrieb. Diese Phase wird subventioniert und ist für alle Interessenten offen.</p>

<h2 id="die-telebox">Die Telebox</h2>

<p>Da preiswerte Akustikkoppler und preiswerte Kommunikationssoftware für Home- und Personal Computer zum Teil schon auf dem Markt sind oder nicht mehr lange auf sich warten lassen werden, muß die Telebox bei jedem Computerbesitzer Freude aufkommen lassen. Was allerdings bisher über die Telebox bekannt ist, trübt die Freude etwas. Zielgruppe der Bundespost der Postbeförderung sind hauptsächlich große und mittlere Unternehmen, denen die Telebox eine verbesserte und preiswertere Kommunikation zwischen Außendienst und Zentrale bringen soll. Bei den langen Laufzeiten und hohen Kosten des normalen Briefverkehrs und der Immobilität des Telex ist dieses Ziel nicht schwer zu erreichen. Mit einer nutzungszeitabhängigen Gebührenstruktur (vermutlich 0.30 Mark pro Minute) und einem monatlichen Mindestbetrag (vermutlich 80 Mark) ist der neue Service für die private Nutzung mit Home- oder Personal Computer zu teuer.</p>

<p>Trotz der für die private Nutzung unfreundlichen Gebührenstruktur sollten Besitzer von Home- und Personal Computern und speziell Besitzer des C 64 den neuen Service begrüßen. So wie die Einführung des PC durch die marktstarke IBM das Interesse und das Angebot an Personal Computern verbreiterte, wird die Telebox den Weg zu einer Vielzahl von Electronic-Mail-Systems und Bulletin Boards in der Bundesrepublik ebnen. Bereits jetzt bieten private Unternehmen wie Time Share, Digital Equipment, General Electric und andere Electronic Mail an, natürlich noch für Firmenkunden und zu Preisen, die ähnlich liegen, wie bei der Telebox. Es werden neue Unternehmen auftreten, welche preiswerte, auf große Teilnehmerzahlen ausgerichtete Electronic-Mail-Services der Vielzahl von Homecomputer- und Personal Computer-Besitzern anbieten werden. Technisch und kommerziell gesehen sind solche neuen Unternehmungen möglich und attraktiv. Hindernd wirkt sich gegenwärtig nur die Rechtsunsicherheit darüber aus, ob solche Services auf privater Basis zulässig sind.</p>

<p>Die Post wäre gut damit beraten, Wettbewerb zuzulassen. Einmal wird ihre Basis an Gebühreneinnahmen verbreitert, da die Nutzer solcher Services auf alle Fälle das Leitungsnetz der Post in Anspruch nehmen müssen. Die Nachrichtenvermittlung durch den Electronic-Mail-Service ist eine zusätzliche Dienstleistung, die sich innerhalb der Grundstücksgrenzen, sogar innerhalb des Computers des privaten Anbieters vollzieht. Das Monopol der Post auf Grundstücksgrenzen überschreitende Kommunikation wird gar nicht in Frage gestellt, und alle Erfahrungen der letzten Jahre sprechen dafür, daß private und kleinere Unternehmen bessere Chancen haben als die Post, innovative Mailbox-Software zu entwickeln und zu realisieren.</p>

<p>Im Bereich des Pakettransports konnten (nach einigen rechtlichen Schwierigkeiten) neue Unternehmen wie UPS, Deutscher Paketdienst und Ipec der Post Konkurrenz machen. Resultat ist ein wesentlich verbessertes Preis/Leistungsverhältnis im Paketdienst. Auch bei der Post, die im Wettbewerb jetzt ebenfalls neue Dienstleistungen anbietet.</p>

<p>Der Bereich der Telekommunikation ist für die zukünftige Entwicklung der Volkswirtschaft bestimmt nicht weniger wichtig als der des Pakettransports. Gerade bei der Telekommunikation hat die Bundesrepublik viel aufzuholen. Sollte man es sich ausgerechnet dann leisten, auf die Dynamik des Wettbewerbs und das heißt den Erfindungsgeist und die Initiative neuer Unternehmen zu verzichten?</p>

<p>(Hersch Fischler)</p>

<h1 id="terminalprogramm-für-den-c-64">Terminalprogramm für den C 64</h1>

<blockquote><p>Dieses Programm ermöglicht es Ihnen, über eine RS232-Schnittstelle und Akustikkoppler oder Modem mit anderen Computern in Verbindung zu treten. Der Austausch von Daten, Nachrichten und ganzen Programmen ist möglich - ebenso die Abfrage von Datenbanken. Wir haben dieses Programm mit der Software-Expreß-Schnittstelle und dem Epson CX-21-Akustikkoppler getestet und waren von Anfang an begeistert.</p></blockquote>

<p>Das Terminalprogramm bietet folgende Möglichkeiten:</p>

<ol>
<li>Die mit der Tastatur eingegebenen Zeichen werden über die RS232-Schnittstelle zur Gegenstelle gesandt.</li>
<li>Die von der Gegenstelle empfangenen Daten werden auf dem Bildschirm angezeigt.</li>
<li>Die von der Gegenstelle empfangenen Daten können zur weiteren Bearbeitung in den »Terminal-Speicher« geschrieben werden.</li>
<li>Diese gespeicherten Daten können dann wieder ausgesandt, auf den Bildschirm oder Drucker ausgegeben, beziehungsweise auf Diskette gespeichert werden.</li>
<li>Dateien können von der Diskette, zur weiteren Bearbeitung, in den »Terminal-Speicher« geladen werden.</li>
<li>Empfangene und im »Terminal-Speicher« befindliche Programme (als ASCII-Datei  
gespeichert) können über eine »Wandler«-Software aufbereitet werden. Hierbei besteht eine Kontroll- und Editiermöglichkeit der einzelnen Programmzeilen.</li>  
<li>Die Übertragungsparameter sind dem Standard entsprechend eingestellt. Durch Änderung der beiden CHR$-Befehle in den »OPEN«-Anweisungen können andere Parameter eingestellt werden. Die entsprechenden »OPEN«-Anweisungen befinden sich in Basic-Zeilennummer 10 + 50. Die Werte für das Kontroll- und Befehlsregister (1. und 2. CHR$ Befehl) sind im Commodore Programmier-Handbuch aufgeführt.</li>
</ol>


<p>Der »Terminal-Speicher« belegt den Adressenbereich Hex 5000-9FFE.</p>

<p>Der Basic-Speicher endet bei Hex 3FFF.</p>

<p>Das Terminalprogramm wird mit Load »terminal«, 8 geladen und anschließend mit Run gestartet. Nach einer kurzen Wartezeit, während der Maschinenspracheteil angelegt wird, erscheint das Menü auf dem Bildschirm.</p>

<p>Über das Menü und mit Hilfe der Funktionstasten werden alle Programmabläufe gesteuert.</p>

<p>Menüpunkt 1 erklärt die Bedeutung der Funktionstasten Fl bis F8, der TODO Taste und der RUN/Stop Taste.<br/>
Funktionstaste F1:</p>

<p>Durch Betätigung werden empfangene Daten als ASCll-Datei in den »Terminal-Speicher« geschrieben. Ein empfangenes Hex 02-Zeichen (Start of Text) bewirkt ebenfalls ein Abspeichern. Zur Erinnerung ändert sich die Rahmenfarbe des Bildschirmes in Braun.<br/>
Funktionstaste F3:</p>

<p>Die Betätigung beziehungsweise ein empfangenes Hex 03-Zeichen (End of Text) beendet das Abspeichern. Die Bildschirm-Rahmenfarbe wird wieder grün.<br/>
Funktionstaste F5:</p>

<p>Mit dieser Taste wird an den Anfang des »Terminal-Speichers« zurückgesetzt und die erste Zeile (bis zum Return-Zeichen) auf den Bildschirm übertragen.<br/>
Funktionstaste F7:</p>

<p>Ein wiederholtes Drücken dieser Taste führt schrittweise bis ans Ende des Textes. Das Textende ist durch + + + gekennzeichnet. Ein Speicherplatzende wird ebenfalls durch + + + angezeigt.<br/>
Funktionstaste F2:</p>

<p>Mit dieser Taste wird ein Vorschreiben in den »Terminal-Speicher« eingeleitet. Die Zeichen werden gleichzeitig auf dem Bildschirm angezeigt. Hierbei sind die Cursor-Tasten außer Funktion. Falsch eingegebene Zeichen können mit der Del-Taste gelöscht werden.<br/>
Funktionstaste F4:</p>

<p>Diese Taste beendet das Vorschreiben.<br/>
Funktionstaste F6:</p>

<p>Durch Betätigung dieser Taste wird wieder an den Anfang des »Terminal-Speichers« zurückgesetzt. Bis zum ersten Return-Zeichen werden die Daten über die RS232-Schnittstelle ausgegeben und gleichzeitig auf dem Bildschirm angezeigt.<br/>
Funktionstaste F8:</p>

<p>Ein wiederholtes Drücken dieser Taste setzt den Sendebetrieb schrittweise bis zum Dateiende fort. Das Ende wird wieder durch + + + angezeigt.<br/>
Die ← Taste</p>

<p>Mit dieser Taste wird der Rücksprung in das Menü eingeleitet.<br/>
Die Run/Stop Taste</p>

<p>Das Terminalprogramm kann mit Run/Stop unterbrochen werden.</p>

<p><b>Menüpunkt 2</b> startet das eigentliche Terminalprogramm. Zum Datenaustausch ist hinzuzufügen, daß einige Steuerzeichen ausgefiltert werden, um ein einwandfreies Arbeiten mit anderen Datenbanken zu ermöglichen. Weiterhin wird eine Code-Wandlung zwischen CPM und ASCII durchgeführt. Beim Betätigen der Del-Taste wird ein Backspace (ein Zeichen zurück) zur Gegenstelle gesandt. Da die Cursor-Steuertasten ihre Funktion verloren haben, wurde auf die Anzeige des Cursors verzichtet.</p>

<p><b>Menüpunkt 3</b> bewirkt die Ausgabe der im »Terminal-Speicher« befindlichen Daten auf einen angeschlossenen Drucker</p>

<p><b>Menüpunkt 4</b> verläßt das Programm und lädt das »Wandler-Programm«. Mit diesem »Wandler« ist es möglich, ein empfangenes und im »Terminal-Speicher« abgelegtes Programm (als ASCII-Datei) in ein lauffähiges Programm zu wandeln und in den Basic-Speicher zu schreiben. Es kann dann benutzt oder auf Diskette gespeichert werden. Das »Wandler-Programm« startet selbstätig und auf dem Bildschirm erscheint: ready. »   Erste Programmzeile «run 60020. Der Cursor blinkt in der ersten Programmzeile. Sind in dieser Zeile keine Fehler vorhanden, so kann diese durch Betätigen der Return-Taste in den Basic-Arbeitsspeicher übernommen werden. Jetzt steht der Cursor in der Zeile »run 60020«. Ein nochmaliges Drücken der Return-Taste bringt die nächste Programmzeile auf den Bildschirm. In gleicher Weise kann bis zum Programmende fortgefahren werden. Ist die Änderung einer Programmzeile erforderlich, so kann dieses mit den üblichen Editiermöglichkeiten geschehen. Soll eine Zeile nicht übernommen werden, so wird der Cursor manuell in die Zeile »run 60020« gesteuert und mit )Return( weitergearbeitet. Zu beachten ist, daß die Programmzeile nicht länger als 80 Zeichen ist. Der Menüpunkt 4 bietet zusätzlich eine Auswahlmöglichkeit zwischen »automatischer Wandlung« und »manueller Wandlung«. Die »manuelle Wandlung« wurde beschrieben. Bei der »automatischen Wandlung« läuft das Programm selbstätig ab. Wird aber eine fehlerhafte Zeile erkannt, so bricht das Programm ab. Nach der Editierung kann mit »run 60020« weitergearbeitet werden.</p>

<p><b>Menüpunkt 5</b> speichert alle im »Terminalspeicher« befindlichen Daten als sequentielle Datei auf eine Diskette. Vor dem Abspeichern muß der Datei-Name eingegeben werden.</p>

<p><b>Menüpunkt 6</b> lädt eine sequentielle Datei von der Diskette in den »Terminal-Speicher«.</p>

<p>Soll ein Basic-Programm zur Gegenstelle gesandt werden, so sind einige Besonderheiten zu beachten.</p>

<ol><li>Das Programm sollte nur »reine ASCII-Daten« erhalten. Bildschirm-Steuerzeichen sowie Grafikzeichen werden nicht übertragen.</li>
<li>Das Programm muß als sequentielle Datei vorliegen und nicht wie sonst üblich als Programm-Datei.</li>
</ol>


<p>Die Wandlung einer Programm-Datei in eine sequentielle Datei wird folgendermaßen durchgeführt.</p>

<ol>
<li>Das Programm wird wie üblich mit LOAD »NAME«, 8 in den Basic-Speicher des C 64 geladen.</li>
<li>Im Direktmodus wird folgende Zeile eingegeben: OPEN 1,8,2,»Name,S,W«:CMD1:LIST</li>
</ol>


<p>Jetzt wird das Programm als sequentielle Datei auf die Diskette geschrieben und kann später vom Terminalprogramm aufgerufen werden. Anschließend wird mit CLOSE 1 das eröffnete File geschlossen.</p>

<p>(Manfred Wyrwas)</p>

<p>In der nächsten Ausgabe das entsprechende Treiber-Programm für den VC 20.</p>

<h1 id="begriffe-aus-der-dfÜ">Begriffe aus der DFÜ</h1>

<blockquote><p>Wenn man über Datenfernübertragung spricht, tauchen oft Begriffe auf, deren Bedeutung nicht jedem klar ist. Deswegen werden hier einige der wichtigsten Begriffe erläutert.</p></blockquote>

<p><b>Modem</b>: Das Modem stellt die Verbindung zwischen Ihrem Computer und dem Telefonnetz her. Es wird von der Post direkt an das Telefonnetz angeschlossen. Das Modem wandelt die Ausgabesignale des Computers in elektrische Signale um, die über das Telefonnetz übertragen werden können.</p>

<p><b>Akustikkoppler</b>: Der Akustikkoppler hat dieselben Funktionen wie das Modem. Er wird aber nicht wie das Modem direkt an das Telefonnetz angeschlossen. Der Akustikkoppler verbindet den Computer mit dem Hörer eines herkömmlichen Telefonapparates. Der Akustikkoppler sendet akustische Signale, die vom Telefonapparat in elektrische Impulse umgewandelt werden, und empfängt akustische Signale, die er für den Computer in elektrische Impulse umwandelt.</p>

<p><b>Handshaking</b>: Handshaking bedeutet die Steuerung der Datenübertragung durch Stopp-, Sende- und Empfangssignale. Die Datenübertragung wird erst dann fortgesetzt, wenn der korrekte Empfang bestätigt wurde.</p>

<p><b>Vollduplex</b>: Bei dieser Art der Datenübertragung sendet der Computer, an den man die eigenen Daten übertragen hat, diese Daten zurück, damit der eigene Computer sie auf korrekte Übermittlung überprüfen kann. Stimmen diese Daten überein, so wird mit der Übertragung fortgefahren. Ist die Übereinstimmung nicht gegeben, so werden diese Daten erneut gesendet.</p>

<p><b>Halbduplex</b>: Im Halbduplex-Betrieb sendet der empfangende Computer nur eine Bestätigung des Empfangs.</p>

<p><b>Baud-Rate</b>: Mit diesem Begriff wird die maximale Übertragungsgeschwindigkeit bezeichnet. Die Baud-Rate wird in BPS (Bits pro Sekunde) angegeben.</p>

<p><b>Paritätsbit</b>: Die Paritätskontrolle ist ein Hilfsmittel zur Datensicherung. Dabei wird einer einheitlich langen Folge von Informationsbits ein zusätzliches Bit hinzugefügt. Der Wert dieses Bits wird nach Vereinbarung so gewählt, daß mit ihm die Anzahl der Bits mit dem Wert binär Eins über die gesamte Einheit hinweg stets einen geraden oder stets einen ungeraden Wert erreicht. Es wird dann von gerader oder ungerader Parität gesprochen.</p>

<p><b>Start/Stop-Bits</b>: Bei jeder Start-Stop-Übertragung wird jedem n-ten Bit jeweils ein Bit voran- und nachgesetzt. Das vorangesetzte Bit wird Start-Bit genannt, das nachgesetzte wird als Stop-Bit bezeichnet.</p>

<p><b>Treibersoftware</b>: Mit Treibersoftware wird das Programm bezeichnet, das die Kommunikation des Computers mit dem Modem steuert. Komfortable Versionen der Treibersoftware haben Zusatzfunktionen, die zum Speichern oder Drucken der gesendeten und empfangenen Daten dienen.</p>

<p><b>Mailbox</b>: Bei einer Mailbox handelt es sich um eine Datenbank, in die Nachrichten geschrieben oder aus der Nachrichten gelesen werden können.</p>

<p><b>Answer/Originate</b>: Wenn Sie mit einem Netz Verbindung aufnehmen, rufen Sie das System an. Da der Ruf von Ihnen ausgeht, muß Ihr Modem auf »Originate« gesetzt werden. Dadurch wird das »Einführungsprotokoll« in Gang gesetzt. Wenn Sie mit einem anderen Computer kommunizieren, muß einer im »Originate«- und der andere im »Answer«-Modus sein. Wenn die Verbindung aufgebaut ist, ist es nicht mehr von Bedeutung, welcher von beiden in welchem Modus ist.</p>

<p>(rg)</p>

<h1 id="wie-bedient-man-eine-mailbox?">Wie bedient man eine Mailbox?</h1>

<blockquote><p>Einen Akustikkoppler kaufen ist nicht schwierig. Doch wie geht es weiter? Wie man in eine Mailbox einsteigt und andere Fragen werden in diesem Bericht beantwortet.</p></blockquote>

<p>Vorweg die rechtliche Frage: Die Benutzung eines Akustikkopplers, um in eine Mailbox einzusteigen, ist völlig legal. Es wird sogar erwartet. Denn genau zu diesem Zweck wurden Mailboxen geschaffen. Eine Mailbox ist im Prinzip nichts anderes als eine Datenbank oder eine Datei, in die Nachrichten eingegeben und abgerufen werden können. Jeder Besitzer eines Akustikkopplers ist dazu in der Lage.</p>

<h3 id="welche-geräte-sind-notwendig?">Welche Geräte sind notwendig?</h3>

<p>Die zur Kommunikation notwendigen Geräte sind schnell zusammengestellt. Neben dem C 64/VC 20 benötigen Sie eine V.24-Schnittstelle. Sie wird in den User-Port des Computers gesteckt. Ein geeignetes Kabel verbindet den Akustikkoppler mit dem Interface. Das wäre alles. Jetzt fehlt nur noch die Software. Eine Möglichkeit ist das in diesem Heft abgedruckte Programm. Aber es gibt schon mehrere Programme, die diese Aufgabe erfüllen. Jeder Computertyp braucht seine auf ihn abgestimmte Software. Wenn Sie diese Geräte und das Programm haben, kann es losgehen.</p>

<h2 id="kein-anschluß-ohne-nummer">Kein Anschluß ohne Nummer</h2>

<p>Zwei Probleme müssen noch bewältigt werden: In der Nähe des Computers muß ein Telefonanschluß verfügbar sein. Ohne Telefon geht es nun mal nicht. Doch was nützt die beste Bedienungsanleitung des Akustikkopplers, wenn sie keine Rufnummer enthält, unter der eine Mailbox erreichbar ist. Aber ab sofort ist auch diese Schwierigkeit behoben. Ich werde Ihnen noch einige Telefonnummern geben, die Sie einmal ausprobieren sollten.</p>

<h3 id="der-erste-kontakt">Der erste Kontakt</h3>

<p>Anhand eines Beispiels möchte ich mit Ihnen eine MaiIbox anwählen. Ich habe ein geeignetes Programm in den Computer geladen. Nach dem Starten steht mir ein Menü zur Verfügung, aus dem man eine Anzahl von Funktionen wählen kann. Ich wähle die Funktion »Daten laden«. Sie stellt die Aufnahmebereitschaft her. Die jetzt folgende Frage »Sollen die Daten auf Diskette gespeichert werden?« beantworte ich mit »Ja«, denn ich möchte mir nachher alles ausdrucken lassen. Und jetzt wird es langsam spannend. Auf dem Monitor ist nichts mehr zu sehen. Aber ich weiß, was ich zu tun habe. Ich nehme den Telefonhörer in die Hand und wähle 061545 1433. Das ist die Nummer von DECATES, eine aus der langsam steigenden Anzahl von Mailboxen in Deutschland. Ein kurzer Blick auf den Akustikkoppler — die Betriebslampe leuchtet. Alles ok. Leider meldet das Telefon das Besetztzeichen. Damit muß man immer rechnen. Also noch einmal. Diesmal klappt es. Ein hoher Pfeifton sagt mir, daß die Verbindung hergestellt ist. Schnell lege ich den Hörer auf den Akustikkoppler. Gespannt warte ich auf die ersten Zeichen. Nach ein paar Sekunden tut sich etwas. Die ersten Zeichen laufen mit der für 300 Baud typischen, langsamen Geschwindigkeit über den Bildschirm. Ein erstes Bild teilt mir mit, daß ich mit DECATES verbunden bin. Gleichzeitig werde ich nach meinem Paßwort gefragt. Ich gebe es ein und sofort kommt die Bestätigung, daß ich eingetragener Benutzer bin.</p>

<p>Als Anfänger werden Sie noch kein Paßwort besitzen. Aber keine Angst. Wer noch kein Paßwort besitzt, braucht nur RETURN zu drücken.</p>

<p>Als eingetragener Benutzer bin ich in der Lage, persönliche Mitteilungen abzurufen, die nur für mich bestimmt sind. Kein anderer kann diese Infos lesen. Jeder andere Benutzer kann jedoch jedem anderen Mitteilungen zukommen lassen und auch jede öffentliche Information entgegennehmen.</p>

<p>Die dann folgende Frage von DECATES nach der Bedienungsanleitung sollten Sie ruhig mit Ja beantworten, solange Sie sich mit diesem System nicht auskennen. Laut DECATES gibt es etliche Anrufer, die am Ende nicht mehr wissen, wie sie wieder aus dem System herauskommen (nämlich indem man LOGOFF eingibt). Die meisten Bedienungsfehler werden jedoch mittlerweile abgefangen. Der Rest geht automatisch. Und wie gesagt, die Bedienungsanleitung sollten Sie am Anfang immer neben sich liegen haben. Sie können dadurch Telefonkosten sparen.</p>

<p>Viele Mailboxen lassen folgende Funktionen zu:<br/>
Informationen eingeben, Informationen anzeigen; eine Art Fundgrube für Hard- und Softwaretausch ist oft auch vorhanden. Bei einigen Mailboxen existiert zusätzlich noch ein Informationssystem für Gewerbetreibende. Dort haben »gewöhnliche« Anrufer keinen Zugriff.<br/>
Probieren Sie die Mailboxen ruhig einmal aus. Weitere Nummern finden Sie in den abgedruckten Auszügen aus einer Verbindung mit DECATES. Doch vergessen Sie nicht die Telefonrechnung.</p>

<p>(gk)</p>

<h1 id="forth-– die-etwas-andere-programmiersprache">FORTH – die etwas andere Programmiersprache</h1>

<blockquote><p>Stellen Sie sich eine Programmiersprache vor, interaktiv wie Basic, schnell wie Assembler, strukturiert wie Pascal und beliebig erweiterbar. Eine solche Sprache ist Forth.</p></blockquote>

<p>Forth wurde Anfang der siebziger Jahre von Charles H. Moore entwickelt und ursprünglich zur Steuerung von Radioteleskopen eingesetzt. Die Sprache entstand dabei ganz gezielt als Alternative zur fehleranfälligen und schlecht zu wartenden Assemblerprogrammierung auf der einen Seite und den klassischen Compilersprachen wie Fortran oder Algol auf der anderen Seite, die für Prozeßsteuerungen zu langsam und zu aufwendig waren.</p>

<p>Forth wurde übrigens damals als sogenannte »Programmiersprache der vierten Generation« entwickelt und sollte eigentlich dementsprechend den Namen »Fourth« tragen. Leider war die IBM 1130, auf der Forth zum ersten Mal implementiert wurde, noch ein Rechner der »dritten Generation« und erlaubte nur Dateinamen bis maximal fünf Zeichen. Charles Moore mußte »Fourth« daher um einen Buchstaben kürzen, und das war die Geburtsstunde von Forth. Lange Jahre fristete die Sprache ein Schattendasein in diversen Forschungsstätten, ehe sie mit dem Aufkommen der Mikrocomputer eine größere Verbreitung auch unter Privatleuten fand.</p>

<h2 id="was-ist-forth?">Was ist Forth?</h2>

<p>Forth ist interaktiv. Ähnlich wie in Basic können Programme also im Dialog mit dem Computer entwickelt und getestet werden. Das ist ein wesentlicher Unterschied zu den klassischen Compilersprachen wie zum Beispiel Pascal oder Fortran. Ein Compiler erwartet nämlich ein fertiges Programm, das er dann in einem Arbeitsgang übersetzt. Es gibt keine Möglichkeit, die Wirkung bestimmter Kommandos vor der Übersetzung zu testen. Anders bei Forth. Hier kann man im Direktmodus Rechnungen durchführen, Programmteile testen und neue Befehlsworte definieren.</p>

<p>Forth ist strukturiert. Es gibt in Forth selbst mit Gewalt keine Möglichkeit, Basic-ähnlichen Spaghetti-Code zu erzeugen. Der Grund dafür ist sehr einfach: Es gibt keine GOTO-Befehle und auch keinen Ersatz dafür. Jede Wort-Definition ist in sich abgeschlossen und am ehesten noch mit den Prozeduren in Pascal zu vergleichen.</p>

<p>Forth ist schnell. Alle Anweisungen werden zuerst compiliert und dann ausgeführt, was insbesondere bei Programmschleifen große Zeitvorteile bringt. Forth-Programme sind daher in der Regel um Größenordnungen schneller als entsprechende Basic-Programme.</p>

<p>Forth ist erweiterbar. Im Gegensatz zu den meisten anderen Programmiersprachen kann der Benutzer in Forth neue Sprachelemente definieren, ja Programmierung in Forth besteht gerade in der Definition neuer Worte zur Erweiterung des Sprachumfangs.</p>

<p>Jeder Basic-Programmierer wird erfreut zur Kenntnis nehmen, daß in Forth keine Fehlermeldung »SYNTAX ERROR« existiert — und zwar ganz einfach deswegen, weil die Forth-Syntax so einfach ist, daß keine solchen Fehler vorkommen können. Ein Wort in Forth besteht aus einer beliebigen Zeichenfolge, die allerdings kein Leerzeichen enthalten darf, weil dieses gerade zwei Worte trennt. Zum Beispiel sind gültige Forth-Worte</p>

<p>HALLO, 3FACH, %X!, + 1NOCH-UND-DANN-SCHLUSS.</p>

<p>Eine Eingabezeile besteht nun einfach aus Worten und Zahlen. Bei Zahlen ist übrigens noch eine Besonderheit zu beachten: Forth kann in beliebigen Zahlensystemen rechnen. Die Systemvariable BASE enthält die jeweils gültige Zahlenbasis. In der Regel wird man entweder im Dezimal- oder im Hexadezimalsystem arbeiten. Daher kennt Forth zwei spezielle Befehlsworte zum umschalten in das jeweilige Zahlensystem, nämlich DECIMAL und HEX.</p>

<p>Programmierung in Forth besteht nun einfach darin, mittels bereits definierter Worte wiederum neue Worte zu bilden. Ein Grundvokabular von vordefinierten Worten, das sogenannte Forth-Kernal, steht dem Benutzer dabei von Anfang an zur Verfügung.</p>

<p>Bevor wir näher auf die Programmierung eingehen, müssen wir uns zuerst noch mit einer weiteren Besonderheit von Forth auseinandersetzen, dem Stack. Forth arbeitet nämlich in umgekehrter polnischer Notation (UPN). Wesentliches Merkmal dieser Methode, die Benutzern von Hewlett-Packard-Taschenrechnern nicht unbekannt sein dürfte, ist ein Datenstack, auf dem alle Zahlenwerte gespeichert werden, bevor mit einem Operator auf sie zugegriffen wird. Um zum Beispiel den Wert des Ausdrucks 2*(3+5) zu berechnen, würde man in Basic einfach schreiben</p>

<p>PRINT 2*(3 + 5)</p>

<p>Dieselbe Berechnung in Forth lautet (Bild 1):</p>

<p> 3 5 + 2 * . (man beachte den Punkt !)</p>

<p>Die Berechnung geht also genauso vor sich, wie man auch im Kopf rechnen würde: Zunächst nimmt man die beiden Zahlen in der Klammer, weil diese zuerst berechnet werden. Dann werden die Zahlen addiert, schließlich holt man sich die »2« und multipliziert sie mit dem ersten Zwischenergebnis. Forth legt also generell erst die für einen Befehl benötigten Operanden auf den Stack, und der Befehl greift anschließend darauf zu. Das gilt nicht nur für arithmetische Operationen, sondern ist ein Kennzeichen für die gesamte Sprachstruktur von Forth. Nehmen wir etwa den Punkt am Ende der Beispielrechnung oben. Er ist das Forth-Äquivalent zum PRINT-Befehl in Basic.</p>

<p>Beachten Sie bitte, daß der PRINT-Befehl immer vor den auszudruckenden Daten steht, der Punkt in Forth jedoch immer dahinter. Mit dem Punkt-Befehl wird stets der oberste Zahlenwert auf dem Stack ausgedruckt. Der wesentliche Unterschied zu anderen Programmiersprachen, wie zum Beispiel Basic, liegt nun darin, daß der Operand zum Zeitpunkt des Erreichens des Punkt-Befehls bereits bekannt ist. Der Basic-Interpreter, der auf einen PRINT-Befehl stößt, weiß zu diesem Zeitpunkt ja noch gar nicht, was er ausdrucken soll. Also muß die Information, daß gedruckt werden soll, irgendwo abgespeichert werden. Basic und alle anderen höheren Programmiersprachen bedienen sich dazu eines internen Stacks, der ähnlich wie der Datenstack von Forth konstruiert ist.</p>

<p>Letzten Endes liegt also der Unterschied zwischen Forth und anderen Sprachen darin, daß alle anderen Sprachen den vorhandenen Stack vor dem Benutzer verheimlichen und zu diesem Zweck natürlich zusätzlichen Verwaltungsaufwand treiben müssen, was die Verarbeitung nicht gerade beschleunigt.</p>

<p>Da Forth mit einem Datenstack arbeitet, funktionieren alle eingebauten und selbstdefinierten Funktionen nach dem gleichen Schema: Die Funktion holt sich die benötigten Parameter vom Stack, führt die notwendigen Berechnungen durch und legt das Ergebnis wieder auf den Stack. Dadurch können Funktionsaufrufe beliebig geschachtelt werden. Eine Übersicht über die wichtigsten numerischen Funktionen in Forth gibt Tabelle 1.</p>

<p>Da der Stack bereits für die laufenden Rechnungen benötigt wird, ist es einigermaßen umständlich, ihn auch noch für die Speicherung von Daten zu verwenden. Forth kennt daher die beiden Befehlsworte VARIABLE und CONSTANT, die zur Definition von Variablen beziehungsweise Konstanten benutzt werden. Mit 4 CONSTANT VIER wird zum Beispiel eine Konstante mit Namen VIER und Wert 4 angelegt, auf die im weiteren Verlauf immer wieder zurückgegriffen werden kann. Wann immer Forth jetzt auf das Wort VIER stößt, wird die Zahl 4 auf den Stack gelegt.</p>

<p>Bei Variablen ist die Situation etwas komplizierter. Sei eine Variable TEST mit Anfangswert 1 definiert worden durch 1 VARIABLE TEST. Wenn jetzt wieder das Wort TEST auftaucht, wird nicht der Inhalt der Variablen, sondern deren Adresse auf den Stack gelegt. Mit zwei sehr häufig gebrauchten Befehlen kann man nun auf diese Adresse zugreifen: Es sind dies die Befehle»!« (gesprochen »Store«) und »@« (gesprochen »Fetch«). Der Befehl »!« speichert den Zahlenwert, der an zweiter Stelle auf dem Stack liegt, an die Adresse, die durch das oberste Element des Stapels (TOS = Top of Stack) gegeben ist. Beide Zahlenwerte werden dabei vom Stack entfernt. Die Wirkung ist analog zum POKE-Befehl in Basic, operiert aber mit 16-Bit-Worten statt mit einzelnen Bytes. 2 840 ! entspricht also POKE 840,2:POKE 841,0 in Basic. Ebenso ist 840 @ in Forth analog zur Basic-Funktion PEEK(840) + 256*PEEK (841). Sollen tatsächlich nur einzelne Bytes gespeichert und gelesen werden, bedient man sich der Worte »C!« und »@«. 1 840 C! entspricht POKE 840,1 in Basic und 840 C @ entspricht PEEK(840).</p>

<p>Nun sollte auch das Arbeiten mit Forth-Variablen klar sein: Bei jedem Auftreten eines Variablennamens legt Forth die Adresse dieser Variablen auf den Stack. Um zum Beispiel einer Variablen TEST den Wert 7 zuzuweisen, schreibt man in Forth</p>

<p>7 TEST !</p>

<h2 id="neue-worte-definieren">Neue Worte definieren</h2>

<p>Danach ist die Zahl 7 und auch die Adresse von TEST vom Stack verschwunden. Benötigt man die Zahl jedoch noch für weitere Rechnungen, muß sie vor der Zuweisung an die Variable zunächst dupliziert werden. Hierzu dient das Wort DUP, welches ein Duplikat des TOS erzeugt. DUP ist eine sehr häufig benutzte Funktion, da alle Forth-Befehle die Parameter vom Stack entfernen. Will man zum Beispiel das Zwischenergebnis einer längeren Rechnung mit dem Befehl ».« ausdrucken, dann muß es zunächst mit DUP dupliziert werden, da es durch ».« vom Stack gelöscht wird und somit für weitere Rechnungen nicht mehr zur Verfügung steht.</p>

<p>Forth hat die bemerkenswerte Eigenschaft, daß der Sprachumfang beliebig erweitert werden kann. Zwei Möglichkeiten zur Schaffung neuer Worte haben wir ja schon kennengelernt: CONSTANT und VARIABLE. Daneben gibt es noch eine Reihe weiterer sogenannter Definitionsworte. Zum Beispiel können mit CREATE neue Forth-Worte direkt als Maschinenspracheroutinen definiert werden (sogenannte »Primitives«). Man wird davon allerdings nur an besonders zeitkritischen Stellen Gebrauch machen und in der Regel neue Worte mittels der sogenannten »Colon-Definition« einführen. Die Syntax dieser Definitionsmethode ist die folgende:</p>

<pre><code>: NEUWORT ALTWORT1 ALTWORT2 .... ALTWORTn  ;
</code></pre>

<p>Diese Befehlssequenz erzeugt ein neues Wort, NEUWORT, welches durch die bereits vorhandenen Worte ALTWORT1 bis ALTWORTn definiert ist. Die Colon-Definition beginnt also immer mit dem Wort »:« und endet mit dem Wort »;«. Es ist wichtig, sich genau klar zu machen, daß »:« und »;« nicht irgendwelche syntaktisch notwendigen Zeichen sind, sondern daß es sich dabei tatsächlich um normale Forth-Worte handelt. Das Wort »:« ruft vereinfacht gesagt den Forth-Compiler auf, während das Wort »;« eine Anweisung zum Beenden der Compilation darstellt.<br/>
Hinsichtlich der Namensgebung für neue Worte ist der Anwender im Prinzip keinen Beschränkungen unterlegen. Benötigt man zum Beispiel des öfteren den Durchschnitt zweier Zahlen, dann kann man einfach definieren</p>

<pre><code>: MITTEL + 2 / . ;
</code></pre>

<p>Nach dieser Definition kann man jetzt einfach schreiben 4 8 MITTEL und erhält den Wert 6 angezeigt. MITTEL erwartet also zwei Zahlen auf dem Stack, die zunächst addiert werden (»+«). Das Ergebnis dieser Operation wird dann durch zwei geteilt (»2 /«) und schließlich ausgedruckt (».«). An der Definition von MITTEL ist schon zu sehen, wie kurz und effizient Forth-Programme sein können. In Basic würde ein entsprechendes Programm etwa folgendermaßen aussehen:</p>

<pre><code>10 INPUT X,Y : PRINT (X+Y)/2 : REM Mittel
</code></pre>

<p>Mit der Colon-Definition kann man auch auf einfachem Wege Forth-Worten neue Namen zuweisen. Wenn man zum Beispiel für das Ausdrucken einer Zahl lieber den Befehl »DRUCKE« hätte, kann man einfach definieren</p>

<p>: DRUCKE . ;</p>

<p>Nun kann man überall DRUCKE statt ».« schreiben. Wenn man es wieder leid ist, ständig sechs Buchstaben statt einem schreiben zu müssen, teilt man dem Forth-System einfach mit, daß es das Wort DRUCKE vergessen soll. Der dazu nötige Befehl lautet FORGET DRUCKE. Allerdings löscht dieser Befehl nicht nur die Definition von DRUCKE, sondern auch alle anderen eventuell noch danach erfolgten Definitionen. Das hängt damit zusammen, daß Forth alle Definitionen in einer verketteten Liste abspeichert, dem sogenannten Wörterbuch (Bild 2).</p>

<h2 id="strukturiert-programmieren">Strukturiert Programmieren</h2>

<p>Forth zwingt den Programmierer geradezu, seine Programme modular aufzubauen. Es gibt in Forth keinen dem GOTO in Basic vergleichbaren Befehl. Ein komplexes Forth-Programm entsteht immer zuerst auf dem Papier. Wenn die Programmstruktur festliegt, entwickelt man zunächst die benötigten Unterroutinen und testet sie aus. Diese Unterroutinen sind danach ja als völlig normale Forth-Worte zu benutzen und können dazu verwendet werden, nun eine weitere Ebene noch »mächtigerer« Worte zu definieren. Am Ende dieses Prozesses steht dann praktisch ein Wort, das das gesamte Programm repräsentiert.</p>

<p>Forth besitzt, ähnlich wie Pascal, eine ganze Reihe sogenannter Kontrollstrukturen, um strukturierte Programmierung zu unterstützen:</p>

<p><b>IF &hellip; ENDIF</b> – Die IF-Abfrage testet, ob der TOS (Top of Stack, also das oberste Element des Stacks) den Wert Null (= False) oder einen Wert ungleich Null (= True) hat. Ist das Ergebnis »True«, dann werden die Anweisungen zwischen IF und ENDIF ausgeführt, andernfalls wird das Programm nach ENDIF fortgesetzt. Einige ältere Forth-Versionen benutzen das Schlüsselwort THEN statt ENDIF.</p>

<p><b>IF&hellip; ELSE&hellip; ENDIF</b> – Arbeitet ähnlich der einfachen IF-Abfrage, führt aber im Falle TOS = 0 die Anweisungen zwischen ELSE und ENDIF aus, sonst die Anweisungen zwischen IF und ELSE.</p>

<p><b>DO &hellip; LOOP</b> – Entspricht der FOR-NEXT-Anweisung in Basic. Das Wort DO erwartet zwei Parameter auf dem Stack, nämlich die Anfangsund die Endzahl der Schleifendurchläufe. Mit LOOP wird die Schleife beendet. Falls das Wort + LOOP statt LOOP verwendet wird, erhöht sich der Schleifenindex nicht um 1, sondern um den Wert des TOS. Das Wort »I« wird innerhalb von Schleifen dazu verwendet, den Schleifenzähler auf den Stack zu kopieren.</p>

<p><b>BEGIN&hellip; UNTIL</b> – Diese Schleife wird solange durchlaufen, bis UNTIL einen Wert ungleich Null (also »True«) auf dem Stack vorfindet. Entspricht REPEAT &hellip; UNTIL in Pascal.</p>

<p><b>BEGIN &hellip; WHILE &hellip; REPEAT</b> – Der Programmteil zwischen BEGIN und REPEAT wird solange durchlaufen, bis das Wort WHILE die Bedingung TOS = 0 feststellt. Danach wird die Schleife unmittelbar hinter WHILE verlassen.</p>

<p><b>BEGIN &hellip; AGAIN</b> – Dient zum Programmieren unendlicher Schleifen und testet keinerlei Bedingungen.</p>

<p>Wer in seinen Forth-Programmen weitere Schleifen- oder Auswahlstrukturen benötigt, kann sie sich einfach selber definieren. Das gilt für praktisch alle Bereiche. Forth arbeitet zum Beispiel normalerweise nur mit Integer-Arithmetik. Wer nun für seine spezielle Anwendung Real-Zahlen benötigt, besorgt sich einfach ein REAL-Vokabular von Forth und bindet es in sein System ein. So kann sich jeder Anwender sein persönliches Forth-System zusammenstellen und nach seinen Bedürfnissen von Fall zu Fall erweitern.</p>

<p>Es ist klar, daß es sehr schwierig ist, für eine derartig flexible Sprache einen sinnvollen Standard zu finden. Die Forth Interest Group (FIG), eine nichtkommerzielle Vereinigung von Forth-Enthusiasten, bemüht sich seit Jahren mit gewissem Erfolg um eine Standardisierung von Forth. Zu diesem Zweck gibt die Forth Interest Group vollständige Assemblerlistings des sogenannten FIG-Forth mit Implementationshinweisen für alle gängigen Mikrocomputer heraus. Eine spezielle Forth-Zeitschrift, die »Forth Dimensions« kann dort ebenfalls bezogen werden. Die Adresse ist Forth Interest Group, P.O. Box 1105, San Carlos, CA 94070, USA.</p>

<p>Wer sich näher mit Forth beschäftigen will, dem seien zum Abschluß noch drei Bücher empfohlen:</p>

<p>Starting Forth von Leo Brodie, zu beziehen über die Forth Interest Group;<br/>
Das Forth Handbuch von H. Floegel, erschienen im Hofacker-Verlag;</p>

<p>Die Programmiersprache Forth von R. Zech, erschienen im Franzis-Verlag.</p>

<p>(ev)</p>

<h2 id="cpm-software-vom-apple-ii-auf-dem-commodore-64">CPM-Software vom Apple II auf dem Commodore 64</h2>

<blockquote><p>Konnten Sie bisher mit Ihrem CP/M-Modul wenig anfangen? Versuchten Sie vergeblich Programme dafür zu kaufen? Dieser Bericht zeigt Ihnen einen Weg zur Welt der CP/M-Software.</p></blockquote>

<p>Stellen Sie sich vor, Sie schalten den Commodore 64 an, laden ein Programm und Ihr Computer meldet sich mit »WORDSTAR release 3.25«. Der C 64 als Computer für Programme, die für wesentliche größere (und teurere) Systeme entwickelt wurden! Oder möchten Sie in Fortran, Cobol, PL1 oder Algol programmieren? Warum nicht? Das zur Verfügung stehende Potential an CP/M-Software ist beinahe unerschöpflich.</p>

<p>Aber woher ist diese Software zu beziehen? Diese Frage ist berechtigt. Wer einmal versucht hat, in einem Fachgeschäft, oder einem Softwarehaus CP/M-Programme im Diskettenformat der 1541-Floppys zu kaufen, wurde wahrscheinlich enttäuscht.</p>

<p>Eigentlich schade, denn eine Umfrage bei einigen Münchener Computerfachgeschäften erbrachte, daß nach dem Steckmodul häufig gefragt wurde. Erhältlich war das Modul aber nur in einem einzigen Geschäft. Dort wurde es, der eigenen Stellung wohl bewußt, nur zögernd unter dem Ladentisch hervorgezogen. Erst nach mehrmaligem Betonen der Dringlichkeit des Kaufs, konnte sich der Verkäufer zum Tausch des Moduls gegen Geld entschließen. Ein Markt, der einfach brachliegt, beziehungsweise einfallsreichen Bastlern überlassen wird (der Diplomkaufmann in mir regt sich).</p>

<p>Nutzen wir die Zeit, bis es eigene C 64-CP/M-Software gibt, mit einer gar nicht so schlechten Behelfslösung. Wir koppeln einen Apple II mit dem Commodore. Dabei geht man wie folgt vor:<br/>
Punkt 1: Sie bauen oder kaufen sich ein Verbindungskabel zwischen einem Apple II und dem Commodore 64.<br/>
Punkt 2: Sie kaufen sich die gewünschte CP/M-Software im Apple II Format.<br/>
Punkt 3: Sie suchen einen Apple-II-Besitzer, (zum Beispiel über eine Anzeige).<br/>
Punkt 4: Sie schreiben sich, oder was leichter ist, sie kaufen sich Software zur Übertragung.<br/>
Punkt 5: Sie koppeln die beiden Computer, und überspielen die gekauften Programme.</p>

<p>Dieses Verfahren ist so einfach, wie wirkungsvoll.</p>

<p>Zum Test verwendete ich das Transferpaket von Bieling und machte mich an die Arbeit. Das Kabel wird auf der Apple-Seite in den Spieleanschluß gesteckt und beim Commodore natürlich in den User-Port. Nach dem Laden der Transfersoftware kann das Übertragen beginnen. »Schon« nach 18 Minuten war eine gesamte Diskette übertragen. Mit dem DOS im Floppy 1541 lassen sich leider ohne größeren Aufwand keine höheren Transferraten erreichen. Aber immerhin, es geht.</p>

<p>Eines sei bei aller Freude über diese Quelle wirklich guter Software angefügt: Da Computer und Programme immer jenseits von Gut und Böse stehen und somit nicht fähig sind, Urheberrechten und ähnlichem Beachtung zu schenken, obliegt Ihnen diese Pflicht. Erkundigen Sie sich lieber vorher, ob es Einwände von seiten der Lizenzgeber gegen die Übertragung gibt.</p>

<p>Was passiert aber, wenn es Ihnen gelungen ist, ein Programm zu kopieren. Läuft es einwandfrei oder sind da und dort noch kleine Änderungen vorzunehmen? Das erste Hindernis, dem sie auf Ihrer Erkundungsreise durch die CP/M-Software begegnen werden, ist deren Verlangen nach einer Darstellung von 80 Zeichen auf dem Bildschirm.</p>

<p>Hier empfiehlt es sich, die Anschaffung einer 80-Zeichen-Karte in Erwägung zu ziehen. Alle mir bekannten Softwarelösungen liefern ein unbefriedigendes Ergebnis.</p>

<p>Ein wesentlich schwerwiegenderes Problem liegt im BIOS (Basic-Input/Output-System) des Commodore-CP/M. Dieses ist bekanntlich für nur ein Laufwerk konzipiert worden. Viele CP/M-Programme setzen ihrerseits aber ein Doppellaufwerk voraus. Eine Lösung ist nur durch eine Abänderung des BIOS zu erzielen. Dazu ist es notwendig, dieses näher zu betrachten. In dem Bereich $0B97 bis $0BCB befindet sich eine Routine, die zum Initialisieren des Laufwerkes, sowie zum Eröffnen einer Direktzugriffsdatei dient. Ferner wird in den Speicherstellen $0B9E und $0BB8 die Geräteadresse in das X-Register geladen. Damit liegt es nahe, diese Routine jedesmal, wenn die Laufwerksnummer (0 oder 1) gewechselt wird, anzuspringen und vorher das Argument LDX der Laufwerksnummer entsprechend auf 8 oder 9 zu setzen. Die Stelle, die die Laufwerksnummer überprüft, liegt im BIOS bei $0AF5. Dort wird die Diskettennummer ausgelesen, in ASCII-Code umgewandelt und gespeichert. Hier ersetzt man den Sprung in die ASCII-Wandelroutine durch den in eine Erweiterungsroutine zwischen $0C98 bis $0CBB. Falls die Laufwerksnummer 0 war, wird dort überprüft, ob das Argument von LDX 8 ist. Wenn ja, erfolgt ein Rücksprung. Wenn nein, wird es in 8 geändert und die Initialisierungsroutine angesprungen. Das gleiche gilt für den umgekehrten Fall.</p>

<p>Am komfortabelsten läßt sich diese Änderung mit dem Basic-Programm vornehmen (Programm laden, CP/M-Diskette in das Laufwerk einlegen, Programm starten). Vor dem Booten des CP/M-Ladeprogramms ist natürlich dafür zu sorgen, daß eines der Laufwerke die Geräteadresse 9 hat. Außerdem muß nach dem Starten des CP/M mit dem Programm Config (ist auf der Systemdiskette) die Anzahl der Laufwerke auf zwei erhöht werden. Nach dem Verlassen dieses Programms können Sie mit Ihren beiden Laufwerken wie mit einem Doppellaufwerk unter CP/M arbeiten.</p>

<p>Beispielsweise mit Wordstar, einem sehr beliebten und oft verkauften Textverarbeitungsprogramm.</p>

<p>Da ich die meisten meiner Berichte auf einem IBM-PC mit Wordstar schreibe, war ich natürlich sehr gespannt, wie das gleiche Programm auf dem Commodore 64 aussieht. Die erste Einschränkung, die ich machen mußte, war der Anspruch auf schnelle Diskettenoperationen. Viele der komfortablen Befehle des Wordstar gehen durch die langsame Ladegeschwindigkeit der Floppy verloren oder verlieren ihren Sinn.</p>

<p>Auch mit zwei Laufwerken bleibt das Laden, Speichern und Booten eine langwierige, Geduld erfordernde Angelegenheit. Zusätzlich fiel mir auf, daß eine Ausgabe auf den Drucker nur mit einem am seriellen Bus angeschlossenen Gerät möglich war. Wer aber beispielsweise einen Epson-Drucker mit einer Softwareschnittstelle betreibt, wird in den meisten Fällen keinen Buchstaben auf das Papier bekommen. Beachtet man den Preis, den man für eine Wordstar-Diskette im Apple-Format bezahlen muß, addiert dazu die Kosten für eine 80-Zeichen-Karte und das Modul, so lohnt sich fast schon die Anschaffung eines anderen Systems.</p>

<p>Die schon aus dem Handbuch zum Commodore 64 bekannte spärliche Dokumentation findet im Beipackzettel zum CP/M-Modul eine Steigerung. Mit den Hinweisen kann jeder Anwender etwa soviel anfangen, wie ein Fernsehzuschauer mit dem Pogramm der letzten Woche — nämlich nichts. Dabei werden auf der dem Modul beiliegenden Systemdiskette einige recht interessante Hilfsprogramme mitgeliefert. Außer einem lapidaren Hinweis auf etwa zur Verfügung stehende (und extra zu bezahlende) Literatur wird der frischgebackene Modulbesitzer mit einem windigen Blättchen Papier alleingelassen.</p>

<p>Obwohl es nicht die Aufgabe einer Zeitschrift ist, fehlende Handbücher nachzuliefern, sollen diese Dienstprogramme hier kurz vorgestellt werden:</p>

<p>TODO</p>

<ol>
<li><b>MOVCPM</b> Mit diesem Programm können Sie Ihr Betriebssystem ändern, zum Beispiel an einen anderen Platz im Speicher verlegen. Die Routine kann dazu verwendet werden, eine 48 KByte-Version zu erzeugen, und mit SYSGEN direkt auf die CP/M-Spuren zu schreiben. Leider funktioniert dieses Dienstprogramm nicht fehlerfrei, denn es tritt ein Synchronisationsfehler auf. Wahrscheinlich stimmen die Versionen von CP/M und MOVCPM nicht überein. Eine 48-KByte-Version sollte immer dann konstruiert werden, wenn der Drucker und die Floppy am seriellen Bus angeschlossen ist. Für das Arbeiten mit einem IEEE-Interface muß man aber eine 44-KByte-CP/M-Version benutzen.</li>
<li><b>DDT</b>. Diese sehr wichtige Routine dient der Kontrolle neuer Programme, deren sicheres »Laufen« noch ungewiß ist. Im einzelnen lassen sich damit Dateien lesen, Speicherinhalte anschauen und verändern sowie das Programmverhalten untersuchen.</li>
<li><b>SUBMIT</b> Ein Programm, das für oft wiederkehrende Aufgabenstellungen sehr nützlich sein kann. Die Formulierung der Aufgabe mit dem Editor (ED) ist ausreichend; die Abarbeitung der Befehle wird dem Computer überlassen. Eine noch höhere Automatisierung ist mit dem Programm XSUB zu erreichen. Damit ist es möglich, die aufgerufenen Programme durch die Aufgabendatei zu bedienen.</li>
<li><b>ED</b> Der Editor, ein unglaublich vielfältiges Programm, das beim Arbeiten mit CP/M oft gebraucht wird. Mit dem Editor ist es möglich, dem Computer Zeichen einzugeben, ohne daß diese als Befehl aufgefaßt und sofort ausgeführt werden. So ist beispielsweise eine einfache Textverarbeitung mit dem Editor möglich. Aber auch zur Erstellung, Veränderung und Korrektur von Programmen ist er einsetzbar.</li>
<li><b>SYSGEN</b> ist ein Dienstprogramm mit dem sich das Betriebssystem auf jede formatierte Diskette überspielen läßt.</li>
<li><b>CONFIG</b> dient der Zusammenstellung der Hardwarekonfiguration. Es kann gewählt werden zwischen den folgenden Einstellungsmöglichkeiten: Anzahl der Laufwerke, Druckertyp, Schriftmodus und Belegung der Funktionstasten.</li>
<li><b>DUMP</b> zeigt den Inhalt einer Datei in den binären Werten seiner Bytes. (Hexdump).</li>
<li><b>PIP</b> unterstützt den Datenaustausch mit den angeschlossenen Peripheriegeräten, wie dem Drucker, der Floppy und als Überbleibsel aus der Entstehungszeit von CP/M, mit Lochstreifenlesern und Fernschreibern. So können Dateien ausgedruckt oder kopiert werden; auch läßt sich aus mehreren Einzeldateien eine neue kreieren.</li>
<li><b>COPY</b> ist ein speziell für Commodore hinzugefügtes Diskettenhilfsprogramm. Mit COPY lassen sich Disketten formatieren und kopieren. Der Backup einer gesamten Diskette dauert (auch mit zwei Laufwerken) immer noch zirka 15 Minuten.</li>
<li><b>ASM</b> ist ein Assembler, mit dem sich in mnemonischer Schreibweise verfaßte Programme übersetzen lassen. Neben ASM wird hierzu auch das Programm LOAD verwendet, das die durch das Assemblieren entstandene HEX Datei in eine COM Datei umwandelt. Durch diesen Prozeß werden die Daten so aufbereitet, daß sie direkt aufrufbar sind und ausgeführt werden können.</li>
</ol>


<p>Eigentlich eine ganze Menge, was eine Systemdiskette alles ermöglicht: einfache Textverarbeitung, Programmierung und Datenübertragung, wenn auch in einer unkomfortablen Form. Würde man vergleichbare Programme für den Commodore 64 kaufen, um mit ihm in seiner eigenen Sprache zu kommunizieren, müßte man wahrscheinlich mehr ausgeben als für das CP/M-Modul. So gesehen lohnt sich die Anschaffung auf jeden Fall.</p>

<p>(Arnd Wängler)</p>

<blockquote><p>Pascal – leistungsfähiger und eleganter als Basic (Teil 1)</p>

<p>Für den Commodore 64 gibt es bereits einige Versionen der Programmiersprache Pascal. Dieser Bericht stellt wichtige Elemente der Sprache vor und vergleicht sie mit äquivalenten Basic-Lösungen.</p></blockquote>

<p>Wie lange besitzen Sie schon den Commodore 64? Wenn Sie ihn wie ich schon längere Zeit und einige Gehversuche in Basic schon hinter sich haben, die Phase der Spielsucht und des Programme-Scheffelns überstanden haben, dann werden Sie sich wohl wieder dem Programmieren in Basic zuwenden, nur diesmal ungleich intensiver. Jetzt stellt sich jedoch heraus: das eingebaute Basic hält den gewachsenen Anforderungen nicht stand.</p>

<p>Eine neue Sprache, gut, aber welche? Da gibt’s ja eine Unmenge davon, zum Beispiel Forth, Cobol, Algol, Fortran, Pascal, Modula und Assembler, die nur »ehrfürchtig« genannt wird, da Assembler angeblich nur von absoluten Spitzenkönnern beherrscht wird. Zu den Könnern zählt man sich im allgemeinen noch nicht und läßt eben die Maschinensprache beiseite (weshalb eigentlich?) und sucht sich eine sogenannte »höhere« Programmiersprache. Die Wahl dürfte wahrscheinlich auf Pascal fallen, weil Forth zu fremd, Fortran zu antiquiert, Cobol zu »geschäftig«, Algol zu wissenschaftlich und Modula zu neu ist. Nun, Pascal hat schon einiges zu bieten, was Basic nicht hat. Die Schlagwörter sind: — Strukturierte Programmierung — Blockorientierte Programmierung</p>

<ul>
<li>Operatoren auf Mengen</li>
<li>Lokale Parameter</li>
<li>Möglichkeit für Rekursionen</li>
<li>eigene Typendefinitionen</li>
<li>Records etc.</li>
</ul>


<p>Über Schlagworte läßt sich bekanntlich streiten, aber ich möchte beweisen, daß sie für Pascal wirklich zutreffen.</p>

<p>Niklaus Wirth, der diese Sprache aus den beiden Hauptlinien Algol 68 und Fortran beziehungsweise PL/1 1971 an der ETH Zürich entwickelte, hat sie Pascal genannt, zu Ehren des französischen Mathematikers und Philosophen Blaise Pascal (zirka 1650). Man kann deshalb von einem Wirth-Standard im Gegensatz zum UCSD-Pascal sprechen. Das UCSD-Pascal entstand in Kalifornien und enthält nun auch den Typ »STRING« sowie Operatoren auf diesen Typ wie man es von Basic her gewöhnt ist. Ansonsten ist der Unterschied nicht annähernd so groß, wie derjenige zwischen Basicdialekten.</p>

<p>Pascal ist wegen seiner Klarheit im Aufbau und seiner enormen Leistungsfähigkeit zur wichtigsten, wissenschaftlichen Programmiersprache geworden.</p>

<p>Ein äußerlicher Unterschied gegenüber Basic besteht darin, daß Pascal vollkommen formatfrei ist, das heißt es gibt keine Zeilennummerierung. Man darf daher eine Befehlssequenz (statements) über eine Bildschirmzeile hinaus auf der nächsten fortsetzen, denn, als gültigen Statementstrenner gibt es nur das Semikolon (;). Pascal kennt daher den Befehl »GOTO/GOSUB Zeilennummer« nicht. Aber dafür ist Pascal sehr stark blockorientiert. Ein Block ist im einfachsten Fall entweder ein Befehl oder eine mit »BEGIN« und »END« umschlossene Befehlssequenz. Andere Blocks sind »PROCEDURE«, eine Art Unterprogramm, und »FUNCTION«, auch eine Art Unterprogramm, aber mit dem Unterschied, daß man einer »FUNCTION« einen Wert zuweisen kann. Darauf komme ich später zurück. Ein Beispiel dazu:<br/>
FOR i := 10 DOWNTO 3 DO statement</p>

<p>Diesem Statement entspricht in Basic die folgende Sequenz:<br/>
FOR i = 10 TO 3 STEP -1: befehle: NEXT</p>

<p>Diese ganze Schleife ist ein Statement. Obwohl sie mehrere Befehlswörter enthält, muß man sie nicht mit »BEGIN« und »END« umklammern. Ebenfalls als ein Statement gilt eine Wertzuweisung der Form:<br/>
i := i + 1;</p>

<p>Der Operator &lsquo;:=’ weist der links davon stehenden Variablen den Wert des rechten Ausdrucks (expression) zu. Er ersetzt nicht den Vergleichsoperator ’=’. Diesen braucht man in Pascal korrekterweise nur für Vergleiche wie »IF i = 5 THEN&hellip;.«</p>

<p>Wenn ich schon bei Vergleichsstatements bin, kann ich die drei ebenfalls »mehrwortigen« Statements besprechen, die Pascal für bedingte Abarbeitung eines Blocks besitzt, wobei eine Bedingung (condition) von der Form ist »variable = , &l;&gt;, &lt;=, =&gt;, &lt;, &gt; expression«:</p>

<ul>
<li>IF condition THEN statements ELSE statements</li>
<li>WHILE condition DO statement</li>
<li>REPEAT statements UNTIL condition</li>
</ul>


<p>Das erste Statement existiert fast in identischer Form in Basic, außer der Tatsache, daß »ELSE« im Basic des Commodore 64 natürlich fehlt. Die unteren beiden haben einen Schleifencharakter. Wofür nun aber zwei Schleifen, die sich doch fast nicht unterscheiden? Nun, bei näherer Betrachtung finden Sie sehr wohl einen interessanten Unterschied: Die »WHILE«-Schleife testet eine Bedingung bevor eine Befehlssequenz ausgeführt wird (Solange wie&hellip;wiederhole&hellip;), die »REPEAT«-Schleife hingegen testet erst nach der Ausführung (Wiederhole&hellip;bis&hellip;). Sie werden vielleicht sagen, das sei doch nun wirklich nur Haarspalterei. Mitnichten! In den folgenden zwei Beispielen sehen Sie, wie man damit elegant iterative Probleme mit Bedingungen programmieren kann. Kümmern Sie sich vorerst nicht um die anderen Statements, die in den beiden Progrämmchen sonst noch vorkommen, sondern konzentrieren Sie sich bitte nur auf die Schleifen.</p>

<p>Beide Programme (Listing 1 und Listing 2) berechnen die Quadratwurzel einer Zahl:</p>

<p>Die unterstrichenen Worte sind reservierte »Steuerworte« in Pascal, die nicht anders gebraucht werden dürfen. Die übrigen Worte sind Standardprozeduren. Man erkennt sie auch daran, daß sie ein oder mehrere Argumente in Klammern annehmen können. Ein Statement kann aus Steuerworten und Prozeduren bestehen, was man leicht erkennen kann, weil nach &lsquo;WHILE-&rsquo;..&lsquo;DO&rsquo; bekanntlich nur ein Statement folgen darf, denn sonst müßte man ein Ende der »WHILE«-Schleife definieren. »PROGRAM«&hellip; sind die Programmköpfe, »VAR«&hellip; die Deklarationsteile, auf die ich bald eingehen werde und innerhalb »BEGIN« und »END.« befindet sich das eigentliche Programm. »WRITE« beziehungsweise »WRITELN« entsprechen im Commodore-Basic »PRINT;« beziehungsweise »PRINT«, »READLN« dem »INPUT«. »SORT« entspricht »SQR« und berechnet die Quadratwurzel.</p>

<p>Nun zur Routine selbst: Wie Sie wissen, kann man nur aus Zahlen > = 0 reelle Quadratwurzeln ziehen, deshalb muß man vor der Berechnung jeweils testen, ob die mit »READLN« gelesene Zahl > = 0 ist. Dies geht natürlich sehr elegant mit der »WHILE«-Schleife, die ja vor der Ausführung den Test durchführt. In der »REPEAT«-Schleife muß hingegen unbedingt ein Test mit »IF« gemacht werden. Weshalb wird aber die Eingabe zweimal geschrieben? Nun, erstens enthalten Variablen in Pascal, nachdem sie ins Leben gerufen wurden, keinen bestimmten Wert und zweitens muß der erstmalige Test in der »WHILE«-Schleife etwas »Wohldefiniertes« zum Testen haben. Man sieht auch gleich, daß der ganze Inhalt der »WHILE«-Schleife übersprungen wird, falls die erste Eingabe &lt; 0 ist. Hätte man nun in der »WHILE«-Schleife keine Gelegenheit mehr, »z« zu verändern, käme man niemals mehr aus ihr heraus. In der »REPEAT«-Schleife verhält es sich diesbezüglich ähnlich. Nun noch schnell das äquivalente Basicprogramm:</p>

<p>In dem äquivalenten Basic-Programm (Listing 3) entsprechen der kleinen Standardprozedur »READLN« die Zeilen 30 und 40. Es ist sehr schön zu sehen, daß man in Basic nicht ohne das »GOTO« auskommt und daß das Programm jetzt schon schlechter ist, als dasjenige in Pascal. Stellen Sie sich schon jetzt mal vor, wie es sich erst mit längeren bis sehr langen Programmen verhält, bei denen man nicht so schnell sieht, was alles wiederholt wird, weil zwischen der angesprungenen Zeile und dem entsprechenden »GOTO« eventuell mehr als 100 Zeilen liegen.</p>

<p>Ein weiteres Pascal-Statement, von dem man sagen könnte, daß es irgend etwas teste, ist das »CASE«-Statement. Es lautet:</p>

<pre>
CASE selektor OF  
  marke 1 : STATEMENT;  
  marke 2 : STATEMENT;  
  marke 3 : STATEMENT;  
  ....... : .........  
  ....... : .........  
  marke n : STATEMENT  
END:  
</pre>


<p>Mit ihm kann man eine aus mehreren Möglichkeiten auswählen, je nachdem welcher Marke der Selektor entspricht. Es entspricht den »ON x GOTO« und »ON x GOSUB«-Verteilern. Aber »CASE« ist dagegen ungleich vielseitiger. Bekanntlich darf »x« in Basic weder ein Ausdruck noch ein alphanumerisches Zeichen sein. In Pascal darf der Selektor ein beliebiges Zeichen sein. Listing 4 zeigt dies.</p>

<p>Je nachdem, welchen Wert »tagnr« hat, werden der Variablen »tag« die entsprechenden 3 Buchstaben zugewiesen. Stimmt der Selektor mit keiner der Marken überein, so ist im Standardpascal nicht definiert, was dann geschieht. In UCSD-Pascal hingegen wird einfach beim nächsten Statement fortgefahren. Hier folgt nun noch das kleine äquivalente Basicprogramm dazu (Listing 5). Da im Basic des Commodore 64 dem »IF&hellip;THEN«-Befehl das »ELSE« fehlt und weil eine Basiczeile nicht mehr als 80 Zeichen zuläßt, muß man auf die Konstruktion verschachtelter »IF&hellip;THEN&hellip;ELSE IF&hellip;THEN&hellip; ELSE IF&hellip;’s zur Emulation von »CASE« verzichten. Man sieht, daß man zur Emulation dieses Statements in Basic sehr redundant programmieren muß.</p>

<p>Es ist dies sicher nicht die einzige und schon gar nicht die eleganteste Lösung, aber wahrscheinlich diejenige, die einem zuerst in den Sinn kommt. Eine weitere bevorzugte Verwendung von »CASE« ist die Menüsteuerung, wie Listing 6 zeigt.</p>

<p>Zu Listing 6 ist nicht viel zu sagen, außer daß man sieht, daß der Selektor (Variable »w«) auch ein alphanumerisches Zeichen sein kann und daß den Marken (»A«, »B«, »C«) mehrere Statements folgen können. Hier also Zuweisungen und Prozeduren. Hinzu kommt noch eine neue Standardprozedur genannt »PAGE«. Sie produziert einen Seitenvorschub auf einer Text-Ausgabedatei, weshalb dieser Prozedur ein Dateiname folgen muß. »PAGE (OUTPUT)« produziert also einen Seitenvorschub auf dem Bildschirm, der sich als Löschen des Schirms äußert.</p>

<h2 id="blockstruktur,-lokale-und-globale-variablen">Blockstruktur, lokale und globale Variablen</h2>

<p>Nun komme ich endlich zu demjenigen Punkt, welchen ich bisher immer vor mir herschob, Ihnen aber schon vier mal in den Programmen vorgesetzt habe: Es ist dies der Programmkopf mit dem wichtigen Deklarationsteil. Die Blockstruktur ist ein Hauptmerkmal von Pascal. Man kann sich eine Ebene vorstellen, die bezeichnet wird mit »PROGRAM name«. In ihr sind überall und jederzeit alle Konstanten und Variablen verfügbar und änderbar, die in dem zu dieser Ebene gehörigen Deklarationsteil angegeben werden müssen. Ein Programm, das völlig ohne Prozeduren und Funktionen auskommt, liegt in dieser Ebene, und somit leben alle Variablen in ihm (das heißt sie sind gültig), eben weil sie im Deklarationsteil dieser Ebene stehen. Im Deklarationsteil, der zu dieser Ebene gehört, wird nun gesagt, ob und welche Konstanten, Typen und Variablen in dieser Ebene gebraucht werden. Man muß also alle in dieser Ebene verwendeten Variablen deklarieren. Wenn man nun ein Unterprogramm, genannt Prozedur, einführt, so bildet man eine neue Ebene, die jetzt auf derjenigen liegt, die »PROGRAM« genannt wurde (es entsteht mit der Zeit eine Art Relief, indem Ebene auf Ebene zu liegen kommt). Will man die Variablen aus der Hauptebene (»PROGRAM«) benützen, so kann man das bedenkenlos tun.</p>

<p>Man kann aber auch Konstanten, Typen und Variablen definieren, die nur in dieser und jeder daraufliegenden Ebene leben, das heißt man kann von der Hauptebene diese Variablen nicht ansprechen, weil sie für die Hauptebene nicht existieren, da sie nicht in deren Deklarationsteil verzeichnet sind. Daraus ergibt sich, daß man die gleichen Variablennamen verwenden darf, die eigentlich schon in der Hauptebene verteilt worden sind. Obwohl, gleich benannt, beeinflussen sie einander in keiner Weise. Beide Inhalte bleiben erhalten. Je nachdem, in welchem Block man sich befindet, sind gerade die Variablen von dessen Deklarationsteil aktiv. Man kann also, indem man in der Prozedur einen Deklarationsteil hat, eine Sperre aufbauen, die ein Verändern einer gleichlautenden Variable aus einer tieferliegenden Ebene verhindern kann. Aus dieser Tatsache entstand der Begriff der »Lokalen Variablen«. Ein typisches Anwendungsbeispiel dazu ist das »FOR i: = x TO y DO«-Statement. Da man mit diesem Statement oft Indices verändert, heißt die Laufvariable meistens »i« für Index, und so hat es sich eingebürgert, daß man sie wenn möglich immer »i« nennt. Damit nun niemals irgendwelche Komplikationen auftreten können, deklariert man diese Variable »i« meistens in jeder Ebene und zwar vom Typ »INTEGER«. Ich hoffe, daß dies am nächsten Beispiel (Listing 7) ein bißchen klarer wird:</p>

<p>In Listing 7 gibt es zum ersten Mal einen fast ausgelasteten Deklarationsteil. Er ist strikt gegliedert und die Teile der Deklaration müssen immer in derselben Reihenfolge auftreten. Im Standardpascal lautet die Abfolge folgendermaßen:</p>

<p>TODO</p>

<p>In UCSD-PascaI gibt es zwar den LabelteiI, aber das »GOTO«-Statement nur bedingt. Man darf daher nicht ein Label anspringen, welches außerhalb des aktuellen Blockes liegt. Ein Aussteigen aus dem gerade bearbeiteten Block ist nur mit »EXIT procedure p« möglich. Der aktuelle Block wird verlassen und die Prozedur »p« wird ausgeführt. Eine Labeldeklaration geschähe dann wie folgt:<br/>
LABEL 0,27,56,876,9999<br/>
Damit hätte ich 5 Labels deklariert, die irgendwo im betreffenden Block stehen können. Die Zahlen haben nichts mit irgendwelchen Zeilennummern zu tun (man kann sie natürlich so verwenden).</p>

<p>Die Konstantendeklaration:<br/>
CONST name = wert;<br/>
Die Typendeklaration:<br/>
TYPE name = Definition des Typs;<br/>
Die Variablendeklaration:<br/>
VAR name : Typenzugehörigkeit;<br/>
Die Prozeduren- und Funktionendeklaration:<br/>
PROCEDURE name (Übergabeparameter);<br/>
Definition der Prozedur<br/>
FUNCTION name (Übergabeparameter);<br/>
Definition der Funktion</p>

<p>Nun ist zwar endlich klar, was ein Deklarationsteil ist, aber die Typenarten, von denen ich schon zwei in den Beispielprogrämmchen benutzt habe, sind noch immer nicht klar. Nun, es gibt einmal vordefinierte Typen, diese sind:</p>

<p>TODO</p>

<p>Eine ebenfalls vordefinierte Abänderung der Standardtypen erhält man, indem man schreibt: »FILE OF standard typ«. So deklariert man eine sequentielle Datei, deren Elemente einem der Standardtypen angehören. Eine ungeheure Flexibilität erreicht Pascal nun, indem man eigene Typen definieren kann. Im letzten Beispiel habe ich auch einen eigenen Typen definiert, nämlich den Typ »matrix«. Er ist definiert als ein zweidimensionales Feld der Größe »m« * »n« Elemente des Standardtyps »INTEGER«. In der Typendeklaration hat man fast unbeschränkte Möglichkeiten der Typengenerierung. Da nun der Typ definiert ist, darf ich ihn im Variablendeklarationsteil verwenden. Auch das habe ich gemacht: Es sei »a« vom Typ »matrix«. Im Konstantenteil hat man nur die Standardtypen zur Auswahl, da die Typendeklaration erst später folgt. Einen großen Nachteil hat die Sache mit dem Deklarationsteil: Da man nur Variablen benutzen darf, die man deklariert hat, kann man die Reservation von Speicherplatz für die Variablen nicht optimieren. Man sieht das sehr deutlich an der Variablen »a«. Die Größe der Matrix ist bestimmt durch die Konstanten »m« und »n«, die ich aber schon vorher deklarieren mußte. Ob ich nun wirklich die ganze Größe voll ausnutze oder nicht, ich muß die Array-Grenzen angeben. Unter Umständen verschleudere ich sehr viel Speicherplatz, eventuell reicht er aber nicht einmal. In Basic dagegen kann man schreiben:<br/>
10 INPUT &ldquo;WIEVIELE ZEILEN, SPALTEN&rdquo;;m,n<br/>
20 DIM matrix(m,n)</p>

<p>In Pascal geht es nicht so bequem, aber es ist möglich. Es werden noch einige Beispiele folgen, in denen andere Typen gebraucht werden. Das Beispiel (Listing 7) zeigt, daß neben- und nacheinander zwei Variablen »i« leben können, die einander nicht zerstören. Die eine ist global, weil sie im Programmkopf deklariert worden ist, die andere ist lokal, da sie erst in der Prozedur deklariert wird. Man muß aber klar erkennen, daß man zu keinem Zeitpunkt die Werte beider Variablen zugleich ausgeben kann. Zu den Prozeduren ist zu sagen: Jede Prozedur hat einen Namen. Man kann ihr Werte übergeben, indem man hinter dem Namen eine Klammer öffnet und die Variablennamen sowie deren Typenzugehörigkeit eingibt. Man kann nun aber auf zwei Arten Werte übergeben. Dies soll am Beispiel zweier Prozeduren (Listing 8) gezeigt werden:</p>

<p>Man erkennt sofort, daß an die Prozedur »IN« zwei Werte übergeben werden, fragt sich nur, wo der Unterschied der zwei Übergabearten liegt. Dies ist schnell geklärt:</p>

<p>Die Parameter in Klammern bei der Prozedur »IN (i: INTEGER; VAR j: INTEGER)« sind sogenannte »formale Parameter«, diejenigen aber im Prozedurenaufruf »IN(a,b)« nennt man »aktuelle Parameter«. Die formalen Parameter zeigen an, daß (hier zwei) Parameter übergeben werden, die in der betreffenden Prozedur »i« und »j« heißen werden. Die aktuellen Parameter dagegen beinhalten die Werte, die tatsächlich übergeben werden. In unserem Beispiel heißt das, daß die aktuellen Parameter »a« beziehungsweise »b« den formalen Parametern »i« beziehungsweise »j« entsprechen. Nun, einen kleinen Unterschied gibt es aber doch, wie die Notation der formalen Parameter vermuten läßt:</p>

<p>Dem formalen Parameter »j« wird der Inhalt des aktuellen Parameters »a« übergeben.</p>

<p>Dem formalen Parameter »j« jedoch wird die Speicherplatzadresse des aktuellen Parameters »b« übergeben. Ein kleiner aber wichtiger Unterschied.</p>

<p>Wenn nämlich die Prozedur »IN (i: INTEGER; VARj: INTEGER)« ausgeführt wird, wird der Inhalt von »a« in die Variable »i« kopiert. Der Inhalt von »a« wird in dieser Prozedur nicht verändert. Dagegen wird beim Aufruf von »IN(i: INTEGER; VARj: INTEGER)« nicht der Inhalt von »b« nach »j«, sondern deren Adresse zur Adresse von »j« kopiert. Das hat eine konsequenzenreiche Auswirkung: Alle Veränderungen von »j« in der Prozedur »IN« beeinflussen auch den Inhalt der globalen Variablen »b«, weil »j« nun ja einfach nur ein anderer Name für die Variable »b« ist. Die erste Methode der Parameterübergabe nennt man daher »call by value«, die zweite hingegen »call by reference«. Die Variablen sind nun in der betreffenden Prozedur sowie jeder weiteren darin verschachtelten Prozedur lokal bekannt. Man hat nur darauf zu achten, daß man bei der Übergabe keinen Typenkonflikt verursacht und daß beim Aufruf ebenso viele Parameter stehen wie beim Prozedurenkopf.</p>

<p>Diese Art der Parameterübergabe eignet sich besonders dazu, eigene Programmodule für eine Programmroutinenbibliothek bereitzustellen. Ein weiteres Beispiel dazu mit einer »FUNKTION«, für eine ganz bestimmte Anwendung, nämlich einer Vergleichsfunktion: Gegeben sei folgende Deklaration:<br/>
CONST max = 10000;<br/>
TYPE zahlenmenge = ARRAY (1..max) OF BOOLEAN;</p>

<p>Eine Variable vom Typ »zahlenmenge« kann man auffassen als die Darstellung einer Menge von Zahlen zwischen »1« und »max«, wobei für jede solche Zahl der entsprechende Boolean-Wert im Array angibt, ob sie Element der Menge ist oder nicht (das heißt ob der korrespondierende Wert im Array »1« oder »0« ist).</p>

<p>Gesucht ist nun eine Pascal Funktion, die das Enthaltensein einer Menge »ml« in einer Menge »m2« (beide vom obigen Typ) prüft. Eine mögliche Lösung zeigt Listing 9.</p>

<p>Diese Funktion übernimmt nun aus dem Umfeld der Funktion zwei Variablen vom Typ »zahlenmenge« und weist sie den formalen Parametern »ml« und »m2« mittels der »call by value«-Methode zu. Neu bei der Funktion ist nun, daß hinter der Klammer noch deklariert werden muß, welchen Typs das Resultat der Funktion sein wird. Die Funktion ist ein wichtiger Bestandteil von Pascal. Ihr entspricht in Basic teilweise der Befehl »DEF FN name (variable) = expression«, außer daß er in Basic nur eine mathematische Formel definieren und nur eine numerische Variable übernehmen kann. Man kann mit ihm keinerlei Operationen definieren, die als Resultat einen String oder einen Charakter ausgeben.</p>

<p>Der zweite Teil erscheint in der nächsten Ausgabe und beschreibt die Programmierung mit Funktionen, dem Mengentyp, Aufzählungs- und Auszähltyp sowie die Definition von Datensätzen und den Einsatz von Zeigern (POINTER). Kurz erläutert werden Befehle zur Dateibearbeitung. Den Abschluß bildet eine kritische Auseinandersetzung mit vier Pascal-Versionen, die alle auf dem Commodore 64 lauffähig sind.</p>

<p>(Martin Baur)</p>

<h1 id="debugging---fehlersuche-in-basic-programmen">Debugging - Fehlersuche in Basic-Programmen</h1>

<blockquote><p>Diese Situation kennt wohl jeder Besitzer eines Homecomputers zur Genüge: Da tippt man in stundenlanger Arbeit ein ellenlanges Listing ein, lehnt sich nach dem letzten »RETURN« einen Augenblick erleichtert zurück, gibt das magische Wort »RUN« ein — und natürlich läuft das Programm in keiner Weise so, wie es eigentlich sollte. Das Spektrum der möglichen Ereignisse reicht dabei vom simplen »SYNTAX ERROR« bis zum völligen Absturz des Programms.</p></blockquote>

<p>Solange der Computer noch brav seine Fehlermeldungen ausgibt, hat man ja noch Glück gehabt. Kritisch wird die Situation dann, wenn auf dem Bildschirm ein eigenartiges Gemisch undefinierbarer Zeichen erscheint und sich der Computer weder durch Betätigen aller erreichbaren Tasten, noch durch gutes Zureden wieder auf den Boden der Tatsachen zurückholen läßt. Wenn man beim Eintippen eines Programms einmal an diesem Punkt angelangt ist, wird es Zeit, sich die erste Regel gut einzuprägen: Jedes Programm sollte vor dem Start unbedingt mit SAVE gesichert werden.</p>

<p>Mit dem SAVEn allein ist es allerdings noch nicht getan, es muß effektiv noch etwas gegen die im Programm enthaltenen Fehler unternommen werden. Diesen Vorgang bezeichnet man auch als »Debugging«. Das Wort ist von der englischen Bezeichnung »Bug« abgeleitet und bedeutet eigentlich »entwanzen«, wobei mit den »Wanzen« die Fehler gemeint sind, die sich überall im Programm verstecken. In der amerikanischen Umgangssprache hat sich das Wort ganz allgemein für das Suchen versteckter Fehler eingebürgert.</p>

<p>Ganz grob kann man zwischen zwei Arten von Fehlern unterscheiden. Einerseits gibt es die logischen Fehler, die mit schöner Regelmäßigkeit in der Entwicklungsphase eines Programms auftauchen, weil man dem Computer noch nicht genau genug gesagt hat, was er denn nun eigentlich machen soll. Diese Art von Fehlern erkennt man zumeist daran, daß das Programm anstandslos läuft, aber nicht immer die gewünschten Ergebnisse produziert. Die zweite Art von Fehlern ist wesentlich profanerer Natur und tritt praktisch jedesmal dann auf, wenn man ein Programm von einem fremden Listing oder auch von den eigenen Aufzeichnungen abtippt: Es handelt sich dann zumeist um schlichte Tippfehler oder um Fehler, die auf schlechter Lesbarkeit der Vorlage beruhen. Wir wollen uns im folgenden nur mit der zweiten Art von Fehlern beschäftigen.</p>

<h2 id="der-computer-hilft-bei-der-fehlersuche">Der Computer hilft bei der Fehlersuche</h2>

<p>Wie geht man nun zweckmäßig vor, um alle Fehler zu finden, ohne das gesamte Programm von Anfang bis Ende mit der Vorlage vergleichen zu müssen? Nun, eine allgemeingültige Methode, die für alle Arten von Programmen anwendbar wäre, gibt es leider nicht. Dennoch erscheint ein gewisses systematisches Vorgehen durchaus angebracht.</p>

<p>Zunächst sollten wir uns darüber klarwerden, inwieweit uns der Computer selbst bei der Suche nach Fehlern helfen kann. Als erstes kommen einem dabei natürlich die Fehlermeldungen in den Sinn, die beim Commodore-Basic ja erfreulicherweise im Klartext erfolgen und recht vielfältig sind. Wer mit den englischen Bezeichnungen nicht sofort etwas anfangen kann, hat die Möglichkeit, die deutschen Erläuterungen dazu im Handbuch nachzuschlagen.</p>

<p>Was aber soll man tun, wenn der Computer gar keine Fehlermeldung ausgibt, sondern sich nach »RUN« einfach sang- und klanglos verabschiedet und auf keine Tasten mehr reagiert?</p>

<p>Nun, für solche Fälle gibt es im Basic des C 64 beziehungsweise des VC 20 zwei spezielle Befehle, die man immer dann in nicht zu geringem Umfang einsetzen sollte, wenn man nicht genau weiß, wo denn nun der Fehler steckt. Gemeint sind die Basic-Befehle STOP und CONT. Wenn der Computer beim Abarbeiten des Programms auf den Befehl STOP stößt, unterbricht er die Programmausführung und gibt eine Meldung »BREAK IN nnn« aus, wobei nnn die Zeilennummer ist, in der er die STOP-Anweisung gefunden hat. Alle Variablen und auch der Stackpointer bleiben dabei erhalten, so daß die STOP-Anweisung auch in Unterprogrammen und innerhalb von FOR-NEXT-Schleifen auftreten kann.</p>

<p>Nach einem solchermaßen erzwungenen Programmstop kann man sich im Direktmodus mit dem PRINT-Befehl über die Werte wichtiger Variablen informieren und sogar mit LIST einzelne Programmteile anschauen. Danach gibt man den CONT-Befehl, und das Programm wird ganz normal fortgesetzt. Wenn es zu Testzwecken notwendig erscheint, kann man während eines Stops auch im Direktmodus Variablenwerte verändern oder FOR-NEXT-Schleifen verwenden. Allerdings dürfen weder neue Programmzeilen eingegeben noch alte gelöscht oder verändert werden, da dadurch gleichzeitig alle Variablen gelöscht werden und CONT danach nicht mehr möglich ist.</p>

<p>Es ist empfehlenswert, an kritischen Stellen im Programm STOP-Befehle einzufügen, um dadurch den Programmlauf verfolgen zu können und den Fehler immer mehr einzugrenzen. Kritische Stellen sind generell und ohne Ausnahme alle SYS- und USR-Aufrufe, desgleichen alle POKE-Befehle, über deren Bedeutung man sich nicht hundertprozentig im klaren ist. Im Zweifelsfalle sollte man auch nach jedem GOSUB im Programm zunächst einen STOP-Befehl einbauen, um sicherzugehen, daß das Unterprogramm auch wieder auf normalem Wege verlassen wird.</p>

<h2 id="fehlersuche-mit-stop-und-print">Fehlersuche mit STOP und PRINT</h2>

<p>Jedesmal, wenn man die Harmlosigkeit, zum Beispiel eines SYS-Befehls, durch davor und danach plazierte STOP-Befehle festgestellt hat, kann man die STOPs natürlich wieder entfernen, um einen flüssigeren Programmablauf zu erreichen. Es empfiehlt sich, alle eingefügten STOP-Befehle auf einem Zettel zu notieren, um die Übersicht zu behalten. Schließlich dienen diese Befehle nur der Fehlersuche und müssen irgendwann einmal alle wieder entfernt werden.</p>

<p>In vielen Fällen kann man STOP-Befehle durch einfache PRINT-Anweisungen ersetzen. Das hat den Vorteil, daß keine Programmunterbrechung stattfindet und man nicht jedesmal CONT eintippen muß. Außerdem kann man in PRINT-Anweisungen auch zusätzliche Informationen geben, zum Beispiel Variablenwerte ausdrucken oder direkt auf ein spezielles Problem aufmerksam machen. Diese PRINT-Anweisungen sollten aber in irgendeiner Weise von den normalen Bildschirmausgaben unterschieden sein. Zum Beispiel kann man jede PRINT-Anweisung zur Fehlersuche mit fünf Sternchen oder fünf Pluszeichen beginnen lassen.</p>

<p>Will man sich mehrere Variable während des Programmlaufs ausdrucken lassen, sind kleine Unterprogramme recht hilfreich, die in einen freien Zeilenbereich geschrieben werden und die alle benötigten Ausgaben durchführen. Am Ende solcher Unterprogramme sollte eine GET-Schleife stehen, die das Programm auf Tastendruck weiterlaufen läßt. Statt langer PRINT-Listen braucht man so nur einen GOSUB-Aufruf überall dort im Programm einzufügen, wo dies sinnvoll erscheint.</p>

<h2 id="komfortables-debugging-mit-basic-erweiterungen">Komfortables Debugging mit Basic-Erweiterungen</h2>

<p>Das Arbeiten mit STOP und CONT mag manchem Computerneuling etwas ungewohnt erscheinen, aber es ist jedenfalls ein recht sicheres Mittel, einem immer wieder abstürzenden Programm auf die Schliche zu kommen.</p>

<p>Leider sind STOP und CONT auch schon die einzigen speziellen Debug-Befehle im Commodore-Basic. Viele Spracherweiterungen, wie zum Beispiel das bekannte Simons Basic oder Exbasic Level II, stellen zusätzliche Funktionen zur schnellen Fehlersuche zur Verfügung. Wichtige derartige Befehle sind zum Beispiel</p>

<ul>
<li><b>TRACE</b> – listet während des Programmlaufs die gerade bearbeiteten Programmzeilen oder zumindest die Zeilennummern auf.</li>
<li><b>DUMP</b> – gibt eine Liste aller Variablen mit ihren derzeitigen Werten aus.</li>
<li><b>FIND</b> – sucht im Direktmodus eine Zeichenfolge im Programm.</li>
<li><b>ON ERROR GOTO &hellip;</b> – ermöglicht die Fehlerbehandlung im Programm selbst (ohne Abbruch).</li>
</ul>


<p>Wenn der Computer jedoch noch in manierlicher Weise seine Fehlermeldungen ausgibt, sind aufwendige Verfahren zumeist nicht nötig, denn zusammen mit der Meldung über die Art des Fehlers erfährt man ja auch die Zeilennummer des Auftretens.</p>

<h2 id="syntax-error:-wenn-der-computer-nur-noch-»bahnhof«-versteht">Syntax Error: Wenn der Computer nur noch »Bahnhof« versteht</h2>

<p>Die häufigste Fehlermeldung ist sicherlich der ungeliebte »SYNTAX ERROR«. Böse Zungen behaupten allerdings, beim VC 20 wäre es der »OUT OF MEMORY ERROR«. Wie dem auch sei, solange der Computer nur Syntax-Fehler meldet, kann man noch von Glück reden. Es handelt sich dabei meistens um einfache Tippfehler, die nach auflisten der entsprechenden Zeile leicht zu finden und zu korrigieren sind. Beliebte Fehler sind zum Beispiel fehlende oder überzählige Klammern und die Verwechselung ähnlicher Zeichen, wie zum Beispiel »0« und »O«, »1« und »I« oder »8« und »B«. Sehr häufig ist auch die Verwechslung von Punkt und Komma, was sich besonders in DATA-Zeilen verhängnisvoll auswirken kann, wie wir nachher noch sehen werden. Wenn Sie also irgendwo einen »SYNTAX ERROR« gemeldet bekommen und in der fraglichen Zeile auf Anhieb keinen Fehler finden, dann gehen Sie zuerst die vorhin genannten Punkte durch.</p>

<p>Eine gute Hilfe ist es, mit dem Cursor die fehlerhafte Zeile Zeichen für Zeichen abzufahren und dabei mit der Vorlage zu vergleichen. Kommen in der Fehlerzeile viele Klammern vor, dann empfiehlt sich häufig das Anlegen zweier Strichlisten für öffnende und schließende Klammern. Die Anzahlen müssen innerhalb jeder Basic-Anweisung übereinstimmen. Aber bitte keine Klammern mitzählen, die in Anführungszeichen stehen; diese haben mit der Syntax nichts zu tun.</p>

<h2 id="syntax-fehler,-die-man-nicht-sehen-kann">Syntax-Fehler, die man nicht sehen kann</h2>

<p>Ab und zu kann es vorkommen, daß man bei aller Sorgfalt einen Syntaxfehler nicht findet, wie zum Beispiel in der folgenden Basic-Zeile:<br/>
10 OPEN 1,4:PRINT#1,”HALLO”: CLOSE 1</p>

<p>Wenn der Computer hier dennoch einen Syntaxfehler meldet, dann kann das nur eine Ursache haben: Bei der Eingabe dieser Zeile wurden die Basic-Befehle in der bekannten Art und Weise abgekürzt. Der zweite Befehl wurde also als »?#1« eingegeben, was beim Auflisten wieder zu »PRINT # 1« wird. Leider sind PRINT und PRINT# zwei völlig verschiedene Befehle, genauso wie INPUT und INPUT# oder GET und GET#. Alle diese #-Befehle darf man daher nie abkürzen. Die normalen PRINT-, INPUT- und GET-Routinen wissen nämlich mit dem nachfolgenden »#« nichts anzufangen und es kommt zu einer Fehlermeldung.</p>

<p>Eine ähnliche Situation kann sehr leicht bei Verwendung langer Variablennamen auftreten. In einem Spielprogramm »Schiffe versenken« kann zum Beispiel die folgende Zeile auftreten:<br/>
10 ANZAHLSCHIFFE = 12</p>

<p>In dieser Zeile wird unweigerlich ein »SYNTAX ERROR« auftreten, weil der Computer innerhalb des Variablennamens »ANZAHLSCHIFFE« das Basic-Schlüsselwort »IF« entdeckt und sich bei aller Anstrengung nicht erklären kann, was eine IF-Abfrage an dieser Stelle soll. Trotz aller Vorteile für die Übersichtlichkeit eines Programms sei daher an dieser Stelle von der Benutzung langer Variablennamen abgeraten.</p>

<h2 id="was-tun-bei-»out-of-data«?">Was tun bei »OUT OF DATA«?</h2>

<p>Eine andere häufig auftretende Fehlermeldung ist vor allem bei Anfängern gefürchtet, nämlich der »OUT OF DATA ERROR«. Gefürchtet ist dieser Fehler vor allem deswegen, weil die Zeilennummer, die der Computer zu dieser Fehlermeldung ausgibt, in den allermeisten Fällen keinen Hinweis darauf gibt, an welcher Stelle denn nun ein Fehler vorliegt. Listet man nämlich die fehlerhafte Zeile am Bildschirm auf, so findet man dort nur den READ-Befehl, für den keine DATAs mehr vorhanden waren. In der Regel steht dieser READ-Befehl innerhalb einer FOR-NEXT-Schleife. Ein typisches, wenn auch stark vereinfachtes Beispiel für das Auftreten von Fehlern im Zusammenhang mit DATA-Anweisungen ist in Listing 1 auf Seite 50 gegeben. In den Zeilen 100 bis 170wird eine Prüfsumme über den ersten DATA-Block gebildet, und nur dann, wenn diese Prüfsumme in Ordnung ist, wird in den nächsten Programmteil verzweigt, wo aus dem zweiten DATA-Block Zahlen gelesen und an den Anfang des Bildschirms gePOKEt werden und dort das Wort »COMMODORE« bilden sollen.</p>

<p>Das Programm enthält nun einige Fehler in den DATA-Zeilen, die wir gemeinsam herausfinden wollen. Stellen wir uns einfach vor, wir hätten das Programm in Listing 1 aus einer Zeitschrift abgetippt und dabei einige Fehler in den DATA-Zeilen fabriziert. In Listing 2 sind zum Vergleich noch einmal die entsprechenden DATA-Zeilen des »Original«-Listings abgedruckt. Die Fehlersuche scheint somit recht einfach: Man vergleicht die paar DATAs in beiden Listings und wird dann schon den Fehler finden. Bei diesem kurzen Testprogramm stimmt das natürlich auch. Aber stellen wir uns doch einmal vor, daß die beiden DATA-Blöcke insgesamt vielleicht über drei volle Listing-Seiten gehen und nicht nur über drei Zeilen wie in unserem Beispiel. Dann lohnt es sich nämlich mit Sicherheit schon, wenn man etwas systematischer an die Fehlersuche herangeht.</p>

<p>Zuerst starten wir unser Programm nach Listing 1 einmal ganz arglos mit RUN, nachdem wir es vorher aufKassette oder Diskette abgespeichert hatten. Der Programmverlauf ist zu Anfang ganz wie erwartet: Der Bildschirm wird gelöscht, es erscheint die Meldung »S = 270« und darunter »OK«, dann jedoch erscheinen am oberen Bildschirmrand statt eines längeren Wortes nur die beiden Zeichen »@« und »C« und das Programm bricht mit der Meldung »? ILLEGAL QUANTITY ERROR IN 230« ab. Was ist hier geschehen?</p>

<p>Wenn wir uns Zeile 230 einmal auflisten lassen, dann sehen wir</p>

<p>230 POKEB + I,X</p>

<p>Da wir wissen, daß nur Zahlen zwischen 0 und 255 gePOKEt werden können, vermuten wir den Fehler beim Wert der Variablen X. Um unsere Vermutung zu bestätigen, fragen wir den Computer doch einmal ganz einfach nach dem Wert von X, indem wir eintippen</p>

<p>PRINT X<br/>
und danach die RETURN-Taste betätigen. Wir erhalten als Antwort den Wert 1513, der tatsächlich zu groß ist, um in eine Speicherzelle zu passen. Wir vergleichen den zweiten DATA-Block mit dem Original (Listing 2) und stellen fest, daß wir bei der Eingabe das Komma zwischen den beiden Zahlen 15 und 13 in Zeile 360 vergessen haben. Das ändern wir, indem wir das Komma nachträglich einfügen. Dank dieses schnellen Erfolges bessert sich unsere Stimmung um einiges, was sich jedoch nach dem nächsten RUN sehr schnell wieder ändert. Zwar erscheint am Bildschirm zunächst ganz ordentlich die Prüfsumme des ersten DATA-Blocks und das dazugehörige »OK«, aber am oberen Bildschirmrand stimmt einiges noch nicht: Man liest dort die Zeichenfolge »@COMMOORE« statt »COMMODORE«.</p>

<p>Auf den ersten Blick würde man vielleicht vermuten, daß der Fehler nur im zweiten DATA-Block stehen kann, weil das Lesen des ersten Blocks keine Fehlermeldung erzeugt und sogar die Prüfsummenbildung stimmt. Diese Überlegung ist aber nicht ganz schlüssig. Denn durch Bildung einer einfachen Prüfsumme werden Vertauschungsfehler und überflüssige oder fehlende Nullen nicht erkannt. Die fünf DATA-Zeilen in Listing 3 ergeben zum Beispiel alle die gleiche Prüfsumme.</p>

<p>Man sollte sich also nie blindlings auf Prüfsummen verlassen. Sie sind zwar oft nützlich, um Fehler in DATA-Zeilen festzustellen, man darf aber aus der Richtigkeit der Prüfsummenprobe niemals auf die Abwesenheit von Fehlern schließen. Außerdem taucht eine weitere Schwierigkeit auf: Wenn man nur eine globale Prüfsumme über alle DATAs bildet, dann kann man zwar unter Umständen einen Fehler nachweisen, weiß aber immer noch nicht, wo er steckt. Da muß man dann schon zu anderen Mitteln greifen.</p>

<h2 id="mit-listing,-lupe-und-logik«-dem-fehler-auf-der-spur">Mit Listing, Lupe und Logik« Dem Fehler auf der Spur</h2>

<p>Um den Fehler aufzuspüren, können wir dem Computer einen großen Teil der Arbeit überlassen. Als erstes wollen wir feststellen, in welchem der beiden DATA-Blöcke der Fehler liegen könnte. Dazu veranlassen wir den Computer einfach, nur den ersten DATA-Block zu lesen, indem wir eine STOP-Anweisung hinter die erste FOR-NEXT-Schleife plazieren. Wir fügen also folgende Zeile ins Programm ein:<br/>
145 STOP</p>

<p>Wenn wir das Programm jetzt starten, erhalten wir die Meldung »BREAK IN 145«, die von unserem STOP-Befehl herrührt. Da aber das Programm bis Zeile 145 durchlaufen wurde, muß der erste DATA-Block an dieser Stelle vollständig gelesen worden sein. Die Variable X enthält natürlich immer noch den zuletzt gelesenen DATA-Wert. Wenn dieser Programmteil richtig gearbeitet hat, dann müßte X jetzt den Wert Null haben, denn dies ist ja gerade der letzte DATA-Wert aus Block 1, wie man anhand von Listing 1 oder 2 unschwer erkennen kann. Das können wir einfach nachprüfen, indem wir den Computer nach dem Wert von X fragen:<br/>
PRINT X</p>

<p>Zu unserem Erstaunen ist die Antwort aber nicht 0, sondern 12. Wir werfen wieder einen Blick auf Listing 1 und stellen fest, daß die Zahl 12 die vorletzte Zahl im ersten DATA-Block ist. Offenbar wurde eine Zahl zuwenig gelesen! Es ist nun verlockend, einfach den Endwert der ersten FOR-NEXT-Schleife um eins zu erhöhen, um alle Werte des ersten Blocks zu lesen. Doch halt, hier ist Vorsicht geboten. Viel wahrscheinlicher als ein Fehler in einer FOR-NEXT-Schleife ist ein Fehler innerhalb der DATA-Zeilen. Bei so vielen Zahleneingaben kann man sich schließlich leicht mal vertippen. Betrachten wir das Problem also einmal von der anderen Seite. Wenn die Anzahl der gelesenen X-Werte stimmt, das Programm aber trotzdem nur bis zum vorletzten DATA-Wert kommt, dann enthält Block 1 vielleicht einen DATA-Wert zuviel. Wir wollen also die DATAs in Block 1 ganz gezielt überprüfen. Dazu schreiben wir in einen freien Zeilenbereich, zum Beispiel ab Zeile 1000, das folgende kleine Unterprogramm:</p>

<pre>
1000 PRINT ”I=" ; I, ”X = ” ; X  
1010 GET A$ : IF A$ &lt;&gt; CHR$(32) THEN 1010  
1020 RETURN  
</pre>


<p>In die erste FOR-NEXT-Schleife fügen wir direkt hinter die READ-Anweisung einen Aufruf dieses Unterprogramms ein:<br/>
125 GOSUB 1000</p>

<p>Wenn wir das Programm nun laufenlassen, geschieht folgendes: Der Computer gelangt mit Zeile 110 in die Leseschleife. In Zeile 120 wird jeweils ein DATA-Element gelesen. Dann erfolgt mit der eingefügten Zeile 125 ein Sprung in das vorhin geschriebene Unterprogramm. Dieses Unterprogramm druckt den Wert der Zählvariablen I und den soeben gelesenen DATA-Wert X aus und wartet dann, bis die Leertaste betätigt wird. Dann kehrt das Unterprogramm zurück und die Schleife wird nach dem NEXT in Zeile 140 erneut durchlaufen. Auf diese Art und Weise erhält man am Bildschirm eine übersichtliche Darstellung der gelesenen DATA-Werte, die man leicht mit der Vorlage vergleichen kann. Wenn wir das Programm jetzt starten, erhalten wir jeweils nach Drücken der Leertaste eine Bildschirmanzeige, etwa in der folgenden Art:</p>

<pre>
I = 1   X = 12  
I = 2   X = 33  
I = 3   X = 11  
</pre>


<p>und so weiter bis schließlich das Ende von DATA-Zeile 310 erreicht wird:</p>

<pre>
I = 9   X = 18  
I = 10   X = 0  
</pre>


<p>Nanu? Das hatten wir eigentlich nicht erwartet. X = 18 ist der letzte Wert in Zeile 310, und danach sollte eigenlich der erste Wert aus der nächsten DATA-Zeile gelesen werden, nämlich X = 11. Woher also kommt dieser Wert Null bei 1 = 10? Ein Vergleich von Zeile 310 in Listing 1 (abgetippt) mit Listing 2 (Original) führt uns auf des Rätsels Lösung. Offenbar haben wir beim Abtippen am Ende von Zeile 310 noch ein Komma gesetzt, was da nicht hingehört. Ein Komma in einer DATA-Anweisung trennt für unseren Commodore-Computer aber immer zwei Werte voneinander, und da er hinter dem letzten Komma nichts mehr findet, setzt er kurzerhand den Wert Null dafür an.</p>

<p>Damit haben wir den überzähligen DATA-Wert im ersten Block gefunden. Wir entfernen das Komma in Zeile 310, löschen die Zeile 125 mit dem GOSUB-Befehl und ebenso die Zeile 145 mit dem nun nicht mehr benötigten STOP-Befehl.</p>

<p>Ein erneuter Probelauf des Programms schreibt die Zeichenfolge »COMMOORE« links oben in den Bildschirm — und bringt die Fehlermeldung »OUT OF DATA ERROR IN 220«. Nach Auflisten der Zeile 220 sehen wir leider nur<br/>
220 READ X</p>

<p>Das bringt uns nicht viel weiter. Die Fehlermeldung und das verstümmelte Wort »COMMOORE« am oberen Bildschirmrand deuten aber auf einen fehlenden DATA-Wert in Block 2 hin. Untersuchen wir also Block 2 einmal genauer. Das Unterprogramm zum Ausdrucken der Werte von I und X am Bildschirm befindet sich ja ab Zeile 1000 noch im Speicher. Wir brauchen daher nur einen entsprechenden GOSUB-Befehl in die zweite Leseschleife einzufügen, am besten gleich nach dem READ-Befehl, also etwa in Zeile 225:<br/>
225 GOSUB 1000</p>

<p>Wir erhalten wieder eine leicht zu überprüfende Liste aller DATA-Werte, diesmal aus Block 2. BeiI = 4 fällt uns sofort etwas auf. Am Bildschirm erscheint nämlich<br/>
I = 4   X = 15.4</p>

<p>Das ist die einzige Zahl mit Nachkommastellen, was bei dieser Art der Bildschirmausgabe sofort ins Auge sticht. Wir vergleichen den Wert mit der Eintragung im Originallisting und sehen sofort den Fehler: Wir haben beim Abtippen irrtümlich einen Punkt statt eines Kommas eingegeben. Die Korrektur ist leicht ausgeführt.</p>

<p>Danach löschen wir Zeile 225 mit dem GOSUB 1000 wieder und überzeugen uns durch einen abschließenden Probelauf vom einwandfreien Funktionieren des Programms.</p>

<p>Natürlich kann man nicht erwarten, daß sich alle Fehler so reibungslos lokalisieren lassen wie in unserem kleinen Beispiel. Gerade bei Fehlern in DATA-Zeilen kann die Suche sich namentlich bei längeren DATA-Blöcken um einiges schwieriger gestalten. Aber bei Programmen mit vielen DATA-Zeilen sind die hier beschriebenen Methoden zum Auffinden von versteckten Fehlern einfach unentbehrlich, wenn man einigermaßen schnell und sicher zum Ziel gelangen will.</p>

<p>(ev)</p>

<h1 id="der-volkscomputer-und-der-große-bruder:-adressenvergleich-vc-20---c-64">Der Volkscomputer und der große Bruder: Adressenvergleich VC 20 - C 64</h1>

<blockquote><p>Der Commodore 64 wird oft als der »große Bruder» des VC 20 bezeichnet. Tatsächlich sind zum Beispiel Betriebssystem, Basicinterpreter und Schnittstellen weitgehend identisch. Daher können Basicprogramme, in denen keine Befehle und Funktionen wie POKE, PEEK, SYS und USR vorkommen, praktisch unverändert übertragen werden.</p></blockquote>

<p>Leider wird man derartige Programme nur sehr selten finden, da beide Computer Grundlegendes gemeinsam haben: Die Hardwareeigenschaften werden von der Software — sprich vom Basic — kaum unterstützt. Immer dann, wenn die grafischen oder musikalischen Fähigkeiten von C 64 und VC 20 angesprochen werden, geschieht dies durch POKE-Befehle, auch wenn es nur darum geht, zum Beispiel die Farbe des Bildschirmrahmens einzustellen.</p>

<p>Das allein wäre ja noch nicht so schlimm. Nun ist aber die entsprechende Hardware, also Video- und Soundchip, bei beiden Computern grundlegend verschieden aufgebaut und belegt zudem noch völlig unterschiedliche Adressen im Speicher. So ist es kein Wunder, wenn das Umschreiben von C 64-Programmen auf den VC 20 (und umgekehrt) in der Regel mit erheblichen Schwierigkeiten verbunden ist. Wir wollen im folgenden versuchen, eine ganze Reihe dieser Schwierigkeiten aus dem Weg zu räumen. Als erste grobe Übersicht soll dabei die Tabelle 1 dienen. Auf weitere Einzelheiten wird im folgenden näher eingegangen.</p>

<p>Bevor man daran gehen kann, für den jeweils anderen Computer geschriebene Software an den eigenen C 64 oder VC 20 anzupassen, müssen die Programme erst einmal in den Speicher gebracht werden. Ein Blick auf die Modulschächte beider Computer verrät sofort, daß es mit dem Austausch von Steckmodulen nicht allzu weit her sein kann: Das Modulformat ist völlig unterschiedlich.</p>

<p>Leider ist auch der Softwareaustausch per Programmkassette nur über einen Umweg zu realisieren. Zwar ist das Aufzeichnungsformat auf Cassette bei beiden Computern gleich, dennoch kann der eine Computer die Aufzeichnungen des anderen in den meisten Fällen nicht lesen. Der Grund hierfür liegt darin, daß der VC 20 eine höhere Taktfrequenz als der C 64 hat (VC 20-Programme sind um einiges schneller als entsprechende C 64-Programme). Dadurch gerät beim Lesen einer fremden Kassette die Synchronisation völlig aus den Fugen. Den einzigen Ausweg in dieser Situation bietet die Verwendung eines »großen« CBM der Serien 30xx oder 40xx als Vermittler. Die Taktfrequenz dieser CBM-Rechner liegt zwischen der des C 64 und der des VC 20, wodurch es zum Beispiel möglich ist, VC 20 Programme zunächst mit dem CBM zu laden, dann wieder abzuspeichern und nun wiederum mit dem C 64 zu laden.</p>

<p>Beim Programmaustausch per Floppy-Disk treten solche Probleme nicht auf. Hier kann man nach Herzenslust VC 20-Software in den C 64 laden oder auch umgekehrt. Hat man allerdings keine Floppy oder liegt das interessierende Programm nicht auf Diskette vor, dann bleibt in der Regel nur noch eins zu tun: Die Zähne zusammenbeißen und das Programm vom Listing abtippen. Dabei kann man dann auch gleich alle nötigen Programmänderungen vornehmen.</p>

<p>Leider gibt es viele Programme sowohl für den VC 20 als auch für den C 64, die man nicht durch Ändern einiger POKE-Adressen und kleinen Korrekturen am Bildschirmlayout an den jeweils anderen Computer anpassen kann.</p>

<p>Dazu gehören generell alle Programme, die hochauflösende Grafik verwenden. Die Prinzipien, nach dem die hochauflösende Grafik auf den beiden Computern realisiert ist, sind völlig unterschiedlich. Außerdem ist es natürlich von vorne herein völlig aussichtslos, ein C 64-Programm, das Sprites und Synthesizereffekte einsetzt, für den VC 20 umschreiben zu wollen. Umgekehrt gibt es eine solche Einschränkung allerdings nicht — der VC 20 kennt keine Sprites und sein Tongenerator läßt sich mit dem Synthesizer des C 64 allemal simulieren.</p>

<p>Sehr viel Vorsicht ist geboten, wenn das Programm längere Abschnitte in Maschinensprache enthält. Oftmals müssen diese Maschinenspracheroutinen in andere Speicherbereiche verschoben werden, um gemeinsam mit dem Basic-Programm laufen zu können. Wir wollen uns an dieser Stelle aber nur mit den Anpassungen bei Basic-Programmen beschäftigen.</p>

<h2 id="poke-befehle-für-farbe-und-bildschirm">POKE-Befehle für Farbe und Bildschirm</h2>

<p>Selbst die einfachsten Programme enthalten in der Regel Befehle, um Rahmen- und Hintergrundfarbe des Bildschirms einzustellen. Beim VC 20 werden beide Einstellungen gleichzeitig mit einem einzigen POKE-Befehl in Register 36879 durchgeführt (Tabelle 2). Der C 64 verwendet zwei getrennte Register, nämlich 53280 für die Rahmenfarbe und 53281 für die Hintergrundfarbe. Jeweils 16 Farben sind möglich (Tabelle 3). Zum Beispiel erzeugt der Befehl POKE 36879,95 beim VC 20 einen gelben Bildschirmrahmen und einen grünen Hintergrund. Mit POKE 53280,7 : POKE 53281,5 wird dasselbe am C 64 erreicht.</p>

<p>Beim C 64 enthält der Bildschirm 25 Zeilen zu je 40 Zeichen; der Bildschirmspeicher belegt die Adressen 1024 bis 2023. Der zugehörige Farbspeicher geht von 55296 bis 56295. Mit POKE 1024, 1 : POKE 55296, 2 erscheint zum Beispiel ein rotes »A« in der linken oberen Bildschirmecke. Der für den Anwender verfügbare RAM-Bereich beginnt bei Adresse 2048 (Bild 1).</p>

<p>Beim VC 20 wird die Angelegenheit etwas komplizierter. Die Anfangsadressen von Bildschirm- und Farbspeicher sind nämlich je nach Speicherausbau unterschiedlich (Bild 2). In der Grundversion und mit der 3-KByte-Erweiterung beginnt das Video-RAM bei Adresse 7680 und geht bis Adresse 8185. Das Farb-RAM belegt dann den Bereich von 38400 bis 38905. In dieser Konfiguration liegt der Bildschirmspeicher oberhalb des für den Anwender verfügbaren RAM-Bereiches, der ab Adresse 4096 (Grundversion) beziehungsweise 1024 (3-KByte-Erweiterung) beginnt. Sobald jedoch eine Speichererweiterung von mindestens 8 KBytes eingesteckt ist, wandert das Video-RAM nach »unten» und beginnt dann ab Adresse 4096. Dies geschieht, um für Basic-Programme einen zusammenhängenden Speicherbereich von der Adresse 4608 an aufwärts zu schaffen. Eine eventuell zusätzlich vorhandene 3-KByte-Erweiterung kann in diesem Fall nicht für Basic-Programme genutzt werden. Schließlich verändert auch noch das Farb-RAM seine Lage und startet jetzt bei Adresse 37888.</p>

<p>Der Bildschirm des VC 20 ist aufgeteilt in 23 Zeilen zu je 22 Zeichen. Insgesamt sind also 506 Bildschirmstellen vorhanden, das sind etwa halb soviele wie beim C 64. Eine Anpassung des Bildschirmlayouts ist also in fast allen Fällen erforderlich. In der Regel dürfte das kein Problem darstellen. Bei der Anpassung von VC 20-Programmen an den C 64 wird man des öfteren PRINT-Anweisungen zusammenfassen, da eine Bildschirmzeile beim C 64 fast doppelt soviele Zeichen wie eine entsprechende VC 20-Zeile aufnehmen kann. Im umgekehrten Fall ist das Einfügen von PRINT-Befehlen sinnvoll, um eine übersichtliche Bildschirmdarstellung zu erhalten. Ernste Schwierigkeiten kann es nur bei der Ausgabe von Tabellen auf dem Bildschirm geben. Eine sechsspaltige Zahlentabelle zum Beispiel läßt sich auf dem C 64 ganz gut darstellen, beim VC 20 wird man bei derartigen Versuchen unangenehm an die arg begrenzte Zeilenbreite erinnert. In solchen Fällen kann man versuchen, weniger interessante Spalten der Tabelle einfach fortzulassen. Wenn das nicht erwünscht oder möglich ist, hilft nur noch der CMD-Befehl, um die Ausgabe der entsprechenden Tabelle auf den Drucker umzuleiten.</p>

<p>Das Betriebssystem von C 64 und VC 20 ist weitgehend identisch. Natürlich gibt es einige Unterschiede bei den Ein-/Ausgabeoperationen, bedingt schon alleine durch das unterschiedliche Bildschirmformat. Fast alle nutzbaren Adressen in der Zeropage oder in den anderen vom Betriebssystem benutzten Speicherbereichen haben jedoch die gleiche Bedeutung. So befindet sich zum Beispiel bei beiden Computern der Kassettenpuffer zwischen den Adressen 828 und 1019 und mit »? PEEK(43) + 256 * PEEK(44)« erhält man beidesmal die Anfangsadresse des Basic-Programms.</p>

<p>Eine wichtige Ausnahme von dieser Regel ist der USR-Vektor. Beim VC 20 befindet er sich in den Speicherstellen 1 und 2 am Anfang der Zeropage, in Adresse 0 steht immer ein »JMP«-Befehl. Jedesmal bei der Ausführung der USR-Funktion verzweigt das Basic zur Adresse 0 und aufgrund des dort stehenden »JMP« sofort weiter zur Adresse, die in sich in den Speicherzellen 1 und 2 befindet. Beim C 64 befinden sich dagegen am Anfang der Zeropage zwei Register des 6510-Mikroprozessors, so daß der USR-Vektor hier in die Adressen 785 und 786 verlegt wurde. Bei Programmen, welche die USR-Funktion verwenden, müssen diese unterschiedlichen Adressen unbedingt beachtet werden.</p>

<p>Wie aus den Bildern 1 und 2 hervorgeht, liegt der Basic-Interpreter beim C 64 in einem anderen Adreßbereich als beim VC 20. Da die Routinen aber bis auf Ausnahmen (USR-Funktion) völlig gleich sind, kann man die Adressen sehr einfach umrechnen: VC 20-Adressen zwischen $C000 und $DFFC entsprechen den C 64 Adressen zwischen $A000 und $BFFC, die Differenz ist also gerade $2000 oder dezimal 8192. In Adresse $BFFD steht beim C 64 ein Sprung nach $E000, um den RAM-und I/O-Bereich zwischen $C000 und $DFFF zu überbrücken. Durch diesen Sprungbefehl entsteht im folgenden eine Adressendifferenz um drei Bytes. Von allen C 64-Adressen zwischen $E000 und $E37A müssen daher diese drei Bytes abgezogen werden, um die entsprechenden VC 20-Adressen zu erhalten.</p>

<p>Einige häufig vorkommende POKE-Adressen wurden bisher noch nicht erwähnt. Gemeint sind die zur Programmierung von Musik und Geräuscheffekten benutzten Register. Leider ist die Art und Weise der Tonerzeugung bei beiden Computern völlig unterschiedlich, so daß sich keine äquivalenten POKE-Befehle angeben lassen.</p>

<p>Der C 64 verfügt nämlich über einen vollwertigen Synthesizer-Baustein, während der VC 20 nur »normale« Tongeneratoren besitzt. Tabelle 4 enthält für alle VC 20 Besitzer eine Übersicht über die beim C 64 zur Tonerzeugung benutzten Register. Diese Tabelle dient allerdings wirklich nur zur Orientierung, welche POKE-Befehle beim C 64 zur Tonerzeugung dienen. Eine Simulation des C 64-Synthesizers ist mit dem VC 20 nicht möglich. Es empfiehlt sich daher, bei der Programmanpassung zunächst einmal alle derartigen POKE-Befehle fortzulassen und später eigene Sound-Routinen einzufügen.</p>

<p>C 64-Besitzer haben es hier etwas besser: Mit etwas Geschick und einem guten Handbuch zur Musikprogrammierung können sie dem C 64 auch alle VC 20-Töne entlocken. Als Referenz hierzu kann Tabelle 5 mit den Daten zu den Tongeneratoren des VC 20 dienen. Im Zweifelsfalle sollte man aber auch hier eher auf originalgetreue Tonuntermalung verzichten und sich damit eine ganze Menge Arbeit sparen.</p>

<p>Und noch ein Punkt, wo der VC 20 hardwäremäßig benachteiligt ist: Der C 64 verfügt nämlich gleich über zwei Joystickports (mit den Adressen 56320 und 56321), während der VC 20 sich mit einem Anschluß zufrieden geben muß, der zu allem Überfluß auch noch ein recht kompliziertes Abfrageprogramm erfordert. Der Feuerknopf und die Schalter 0, 1 und 2 desJoysticks werden nämlich beim VC 20 über VIA #1 gelesen, während der Zustand von Schalter 3 über VIA # 2 abgefragt wird. Normalerweise sind Joystickabfragen in Programmen leicht zu finden. Halten Sie beim VC 20 nach PEEKs in die Speicherstellen 37137 und 37152 Ausschau und beim C 64 nach entsprechenden Abfragen der Adressen 56320 und 56321. Anschließend muß die gesamte Joystickroutine für den jeweiligen Rechner neu geschrieben werden, da die Art der Abfrage einfach zu unterschiedlich ist.</p>

<p>Bei der Steuerung mittels Drehreglern (sogenannten Paddles) ist die Anpassung wesentlich einfacher zu realisieren. Die Paddle-Werte werden beim C 64 aus den Registern 54297 und 54298 ausgelesen. Beim VC 20 sind es die Register 36872 und 36873. Das Umschreiben besteht hier also lediglich im Einsetzen der entsprechenden Adressen in die PEEK-Befehle.</p>

<h2 id="wo-sich-das-umschreiben-lohnt">Wo sich das Umschreiben lohnt</h2>

<p>An dieser Stelle muß noch einmal deutlich darauf hingewiesen werden, daß die Zahl derjenigen Programme, die mit vertretbarem Aufwand vom C 64 zum VC 20 oder umgekehrt übertragen werden können, doch verhältnismäßig gering ist. Bei Spielprogrammen ist in der Regel äußerste Vorsicht geboten, da hier aus Geschwindigkeitsgründen zumeist mit Routinen in Maschinensprache gearbeitet wird. Außerdem ist bei Spielen in der Regel das Bildschirmlayout fest vorgegeben, so daß wegen der unterschiedlichen Bildschirmkapazität beider Computer sehr wahrscheinlich größere Probleme auftreten werden. Von Sprites und hochauflösender Grafik einmal ganz zu schweigen.</p>

<p>Dagegen gibt es viele Anwendungsprogramme, welche den Computer nicht zu einer hochspezialisierten Spielmaschine machen, sondern ganz einfach Problemlösungen in Basic anbieten. Dabei kann es sich beispielsweise um ein Textverarbeitungsprogramm, eine Lagerverwaltung oder ganz einfach um ein Programm zum Ausdrucken einesJahreskalendershandeln. Für fast alle derartigen Programme sollte es möglich sein, eine Anpassung mit Hilfe der hier abgedruckten Tabellen und Adressenvergleiche vorzunehmen.</p>

<p>(ev)</p>

<h1 id="daten-im-(relativen)-direktzugriff">Daten im (relativen) Direktzugriff</h1>

<blockquote><p>In diesem Bericht werden die Unterschiede zwischen der relativen und der sequentiellen Datei aufgezeigt und anhand eines Beispielprogramms die Programmierung einer relativen Datei erklärt.</p></blockquote>

<p>Kommen wir gleich zu den Vor- und Nachteilen. Der Hauptvorteil der relativen Datei ist der schnelle Zugriff auf Daten. Ein weiterer Vorteil ist, daß eigentlich nur wenig Speicherplatz des Computers notwendig ist, nämlich nur so viel, wie das Programm selbst benötigt. Deshalb ist eine sinnvolle Anwendung dieser Dateiform auch mit dem VC 20 in der Grundversion möglich. Allerdings ist ein Diskettenlaufwerk unbedingt notwendig. Die sequentielle Datei hingegen benötigt viel Speicherplatz im Computer, und ein schneller Zugriff auf Daten ist nicht einfach zu realisieren, zumindest muß die gesamte Datei erst in den Speicher des Computers geladen werden, bevor man sinnvoll mit ihr arbeiten kann. Jedoch ist nicht unbedingt ein Diskettenlaufwerk notwendig, die Datasette tut&rsquo;s auch, wenn auch erheblich langsamer. Der Nachteil der relativen Datei ist die Art des Zugriffs auf bestimmte Daten. Er ist nämlich nur über die Datensatznummer möglich. Das heißt: Angenommen, wir haben uns eine Adressendatei aufgebaut und auch schon eine Anzahl Adressen eingegeben. Wenn wir uns jetzt die Adresse von Anton Huber ausgeben lassen wollen, so ist das nicht möglich, indem wir den Namen »Huber« eingeben und dann das Ergebnis, seine Adresse, auf einen Schlag vor uns haben. Dazu müßten wir seine Satznummer kennen. Vereinfacht kann man sagen, daß die Satznummer angibt, die wievielte Adresse gemeint ist. Satznummer 14 bedeutet also die 14. Adresse. Diese Adresse findet der Computer, weil er vom Dateianfang ausgeht, den er sich merkt, und dann 13 Datensätze überspringt (auf den nächsten Datensatz positioniert), umdirektden 14. Datensatzzu lesen (daher der Name relative Datei: relativ zum Dateianfang).</p>

<p>Dazu ist eine Voraussetzung notwendig: Die Datensätze müssen alle die gleiche Länge haben. Wie das realisiert wird, erkläre ich noch.</p>

<p>Um einer möglichen Frustration vorzubeugen, sei gesagt, daß auch eine direkte Suche über einen Namen möglich ist, indem man die Vorteile der relativen Datei mit der der sequentiellen Datei verknüpft.</p>

<p>Eine relative Datei besteht im Prinzip aus 3 Teilen:</p>

<pre><code>1. Einrichten einer Datei  
2. Speichern (Schreiben) eines Datensatzes  
3. Lesen eines Datensatzes
</code></pre>

<p>Gehen wir diese Teile Schritt für Schritt durch. Anhand des Listings können Sie diese Schritte mitverfolgen.</p>

<p><b>1. Einrichten einer relativen Datei</b></p>

<p>Um mit einer relativen Datei arbeiten zu können, müssen 2 Kanäle zur Floppy geöffnet werden. Zum ersten ist das der Kommandokanal (Kanal 15) und zweitens ein beliebiger anderer Kanal. Der Kommandokanal ist notwendig um den Positionierbefehl zu übertragen. Mit dem anderen Kanal wird die Datei eröffnet und bearbeitet.</p>

<p><b>1.a) Öffnen des Kommandokanals<br>130 CLOSE 15:0PEN 15,8,15</b></p>

<p>Sicherheitshalber sollte man vor jedem OPEN ein CLOSE setzen, um eine eventuelle Fehlermeldung »FILE OPEN ERROR» zu verhindern.</p>

<p><b>1.b) Eröffnen der Datei und Festsetzen der Datensatzlänge</b></p>

<p>Wie schon erwähnt, ist ein Merkmal der relativen Datei, daß jeder Datensatz die gleiche Länge besitzen muß. Diese Angabe muß beim Einrichten der Datei angegeben werden. Das geschieht mit folgendem Befehl:<br/>
<b>OPEN lfn,ga,kanal,”dateiname,L,” + CHR$(datensatzlänge)</b>
(im Listing Zeile 140 und 11120)<br/>
lfn = logische filenummer<br/>
ga = Geräteadresse (normalerweise 8)<br/>
kanal (2-14)<br/>
dateiname = Name der Datei, wird so im Directory abgelegt, im Beispiel »ADR.REL«.<br/>
L = Kennzeichen für eine relative Datei<br/>
datensatzlänge = Summe aller Feldlängen (1-254)</p>

<p>Der Buchstabe »L« sagt dem DOS, daß eine relative Datei eröffnet wird. Diesem Buchstaben muß die Angabe der Datensatzlänge folgen. Sie wird mit dem CHR$ gesandt. Im Beispiel setzt sich ein Datensatz folgendermaßen zusammen:</p>

<p>TODO<br/>
NAME    = 15 Buchstaben<br/>
VORNAME = 15Buchstaben<br/>
STRASSE =   20 Buchstaben<br/>
POSTLZ  =   4   Buchstaben<br/>
ORT =   15  Buchstaben<br/>
TELEFON =   12 Buchstaben</p>

<p>Das ergibt insgesamt 81 Buchstaben pro Datensatz, Da jeder Datensatz (auch RECORD genannt) mit einem RETURN abgeschlossen wird, erhöht sich die Datensatzlänge auf insgesamt 82 Zeichen.</p>

<p><b>1.c) Positionieren</b></p>

<p>Der Computer findet einen bestimmten Datensatz über die Datensatznummer, indem er sich den Dateianfang merkt und die entsprechende Anzahl Datensätze überspringt. Genauer gesagt, er positioniert auf diesen Datensatz. Und das wird mit dem Positionierbefehl erledigt. Dieses Kommando wird über den Kommandokanal (15) der Diskette gesandt. Seine Form ist:<br/>
<b>PRINT #lfn,&ldquo;P&rdquo;+CHR$(kanal+ CHR$(low)+CHR$(high)+CHR$(byte)</b>
(siehe dazu Zeile 11130 - 11190)</p>

<p>Die Parameter »low« und »high« geben die Datensatz(=Record)nummer an. Da ein Byte maximal den Wert 255 annehmen kann, die Recordnummer aber höher sein darf, muß sie aufgeteilt werden in ein Low-Byte und ein High-Byte. Das geschieht einfach mit den Anweisungen<br/>
<b>HB=INT(RN/256)<br>LB=RN-HB*256</b>
RN = Recordnummer<br/>
HB = Höherwertiges Byte<br/>
LB = Niederwertiges Byte</p>

<p>Der letzte Parameter (Byte) positioniert auf eine bestimmte Stelle innerhalb eines Records. Beispiel:<br/>
<b>PRINT#</b>15,&ldquo;P&rdquo; + CHR$(2) + CHR$(12) + CHR$(l) + CHR$(8)</p>

<p>Hier wird auf das 8. Byte des 268. Records positioniert. Die 268 ist die Recordnummer und wird aufgeteilt in ein Low-Byte(12) und ein High-Byte(1). (HighByte*256 + Low-Byte = Recordnummer). Beim Schreiben eines Records muß jedoch immer auf das erste Byte positioniert werden.</p>

<p>Zum Schluß wird die Datei freigegeben.</p>

<p><b>1.d) Freigeben der Datei<br>PRINT#15,CHR$(255)</b></p>

<p>Diese Anweisung bewirkt, daß alle Records, die unter der angegebenen Recordnummer liegen, mit CHR$(255) beschrieben werden, sofern sie noch nicht anders belegt wurden. Das dauert seine Zeit. Je mehr Datensätze eingerichtet (freigegeben) werden, desto mehr Zeit beansprucht diese Arbeit. Aber erst diese Prozedur erlaubt ein fehlerfreies Lesen und schnelles Schreiben von Datensätzen. Wollen Sie einen Record beschreiben, der oberhalb des zuletzt freigegebenen Records liegt, so werden automatisch alle Records, die zwischen dem letzten und dem gerade beschriebenen Record liegen, freigegeben, das heißt, mit CHR$(255) beschrieben. Um diese Prozedur zu vermeiden, sollten Sie nur das erste Mal, beim Einrichten der Datei, die maximal zu erwartende Anzahl Records freigeben. Die Fehlermeldung »RECORD NOT PRESENT«, die dann im Floppy-Fehlerkanal erscheint, kann ignoriert werden, da dieser Record nur beschrieben (freigegeben) wird.</p>

<p><b>2. Speichern (Schreiben) eines Datensatzes</b></p>

<p>Zum Speichern eines Datensatzes sind folgende Funktionen durchzuführen:</p>

<p><b>2.a) Eingabe der Recordnummer</b> und Aufteilung in Low- und High-Byte (siehe oben).</p>

<p><b>2.b) Eingabe der Daten</b> (zum Beispiel über Input). Hier wird auch sichergestellt, daß die einzelnen Felder nicht länger werden, als vorher geplant wurde.</p>

<p><b>2.c) maximale Datensatzlänge bilden.</b></p>

<p>Das wird im Beispiel (siehe Listing) in Zeile 7000 bis 7999 durchgeführt. Es wird ein String mit der maximalen Länge (im Beispiel 81) gebildet. Dazu wird vorher eine Variable (im Listing BL$) definiert, mit der Anzahl Leerstellen, die das längste Feld unseres Datensatzes besitzt (im Beispiel das Feld »STRASSE« mit 20 Zeichen, also enthält BL$ 20 Leerstellen). Jedes Feld unseres Datensatzes wird entsprechend seiner vorher festgelegten Länge und abhängig von der wirklichen Länge bei der Eingabe mit den notwendigen Leerstellen aufgefüllt. Im Beispiel hat die Variable RC$ dann die Länge von 81 Zeichen und sie enthält den vollständigen Datensatz.</p>

<p><b>2.d) Speichern</b></p>

<p>Das Speichern dieses Datensatzes ist dann schnell geschehen: Es wird auf die vorher (in 2.a) angegebene Recordnummer positioniert und danach mit PRINT#1,RC$ gespeichert.<br/>
Mit PRINT # kann man jedoch nur Datensätze abspeichern, die nicht länger als 88 Zeichen sind. Sonst muß man die Daten Zeichen für Zeichen mittels einer GET# -Schleife schreiben und lesen.</p>

<p><b>3. Lesen eines Datensatzes</b></p>

<p>Hier erfolgt die Reihenfolge fast umgekehrt wie beim Schreiben. Zuerst muß jedoch auch hier die Nummer des gesuchten Datensatzes eingegeben werden. Nach entsprechender Aufteilung in Low- und High-Byte wird auf den Record positioniert und anschließend mit INPUT#1, RC$ von der Disk gelesen.</p>

<p><b>3.a) Eingabe Recordnummer</b> und Aufteilung in Low- und High-Byte.</p>

<p><b>3.b) Lesen des Datensatzes</b></p>

<p><b>3.c) Aufteilen des Datensatzes</b></p>

<p>Dieser Vorgang muß umgekehrt dem Verketten (2.c) geschehen. Es wird ja lediglich der komplette Datensatz in die Variable RC$ gelesen. In Zeile 5000 bis 5999 werden wieder die einzelnen Felder gebildet. Danach fehlt nur noch die</p>

<p><b>3.d) Anzeige des Datensatzes</b></p>

<p>Das wars auch schon. Wenn Sie sich einmal alles gut durch den Kopf gehen lassen und die Problematik am Beispiel durchgehen und ausprobieren, können Sie in Zukunft Ihre eigene relative Datei programmieren.</p>

<p>Es ist gar nicht so schwierig, wie es auf den ersten Blick aussehen mag. Sie können auch Teile dieses Programms in Ihre eigenen einbauen. Schließlich ist das der Vorteil eines strukturierten Programmablaufs.</p>

<p>Zum Schluß möchte ich Sie noch auf einige Besonderheiten im Listing hinweisen.</p>

<p>Zeile 11110: Löschen einer eventuell bestehenden relativen Datei.</p>

<p>Zeile 11200-11220: Lesen des Fehlerkanals. Wenn der Fehler 52 gemeldet wird, bedeutet dies, daß die Anzahl Datensätze, die Sie angegeben haben, die Speicherkapazität der Diskette sprengen würde. Der Fehler 50 (RECORD NOT PRESENT, siehe auch Zeile 9050) bedeutet, daß Sie einen Datensatz lesen wollen, der nicht freigegeben wurde. Beim Schreiben braucht diese Fehlermeldung nicht beachtet werden (siehe 1.d).</p>

<p>Zeile 3060: Wenn ein gelesener Datensatz den Wert CHR$(255) besitzt, wird davon ausgegangen, daß er noch nicht beschrieben wurde. Deshalb wäre es auch sinnlos, Ihn anzeigen zu wollen. Dieser Vergleich wird in Zeile 9120-9130 nocheinmal in anderer Form durchgeführt, kann dort jedoch weggelassen werden.</p>

<p>Zeile 1170: Wenn das Programm beendet werden soll, muß der zur Positionierung notwendige Kanal 15 wieder geschlossen werden.</p>

<p>Anzumerken ist noch, daß nicht mehr als eine relative Datei gleichzeitig geöffnet werden kann. Es ist lediglich möglich, noch eine zusätzliche sequentielle Datei zur gleichen Zeit zu nutzen. Und diese Möglichkeit erlaubt uns, auch komfortablere Suchkriterien als über die Recordnummer einzusetzen. Doch darüber mehr in der übernächsten Ausgabe des 64'er Magazins.</p>

<p>(gk)</p>

<h1 id="magic-desk-i">Magic Desk I</h1>

<blockquote><p>Magic Desk, der »magische Schreibtisch«, ist ein völlig neuartig konzipiertes Datenverwaltungsprogramm für den Commodore 64. Man kann es verwenden zum Schreiben, Ablegen, Vervielfältigen von Schriftstücken jeder Art, zum Führen von Adreßkarteien, Inhaltsverzeichnissen oder einfach als elektronischen Notizblock – und das alles, ohne von Arbeitsweise und Programmierung eines Computers etwas verstehen zu müssen.</p></blockquote>

<p>Es ist völlig ausreichend, wenn man mit Schreibmaschine und Karteikasten umgehen kann und außerdem weiß, wozu ein Papierkorb gut ist. Denn eben diese Gegenstände werden auf dem Bildschirm mittels Farbgrafik in natürlicher Weise um einen Schreibtisch gruppiert dargestellt und können mit einem Joystick in einfacher Weise angewählt und aktiviert werden.</p>

<p>Um mit Magic Desk, das als Steckmodul geliefert wird, arbeiten zu können, benötigt man neben einem Commodore 64 (oder Executive 64) in jedem Falle ein Floppy-Laufwerk sowie Joystick und Drucker. Modul einstecken, Joystick an Control Port 2 anschließen und eine leere Diskette ins Laufwerk einlegen — und schon kann&rsquo;s losgehen. Der Bildschirm zeigt zunächst ziemlich formatfüllend einen Schreibtisch, daneben aufeinandergetürmt drei große Karteikästen (Bild 1). Auf der Schreibtischplatte befinden sich ein Telefon, ein Taschenrechner, eine Schreibmaschine, ein Finanzjournal und ein Satz Karteikarten. Ein Papierkorb und eine Digitaluhr sind ebenso vorhanden. Von diesen Gegenständen kann man mit Magic Desk I jedoch nur Schreibmaschine, Papierkorb, Digitaluhr sowie die drei Karteikästen benutzen. Die anderen Utensilien sind für spätere Magic Desk — Versionen vorgesehen.</p>

<p>Ebenfalls auf dem Bildschirm erscheint eine Hand mit ausgestrecktem Zeigefinger. Diese Hand kann mit dem Joystick beliebig über den Bildschirm bewegt werden. Um eine Funktion zu aktivieren, positioniert man die Hand so, daß der ausgestreckte Zeigefinger auf das entsprechende Gerät deutet und drückt den Feuerknopf am Joystick. Das ausgewählte Gerät erscheint daraufhin weiß eingerahmt und das Schirmbild wechselt in den meisten Fällen. Nun kann man weitere Unterfunktionen aufrufen, indem man den Handzeiger auf andere grafisch dargestellte Gegenstände deuten läßt oder die Tastatur benutzt. Das Arbeiten gestaltet sich so sehr komfortabel und übersichtlich, ohne daß man sich darum zu kümmern hat, welche Schritte der Computer machen muß, um eine Aufgabe zu erledigen.</p>

<h2 id="briefeschreiben-leichtgemacht">Briefeschreiben leichtgemacht</h2>

<p>Nehmen wir zum Beispiel das Briefeschreiben mit anschließender Archivierung einer Kopie. Mit Magic Desk geht das mindestens genauso problemlos wie an einem realen Schreibtisch. Mittels Joystick läßt man den Handzeiger auf die auf dem Bildschirm abgebildete Schreibmaschine fahren und drückt den Feuerknopf. Sofort wechselt das Schirmbild und zeigt im unteren Drittel die grafischen Darstellungen von fünf Objekten: Schreibtisch, Tabulatoren (der Schreibmaschine), die Schreibmaschine selbst, Drucker und Papierkorb.</p>

<p>Die Schreibmaschine ist weiß umrahmt und der bekannte Handzeiger deutet darauf. Solange der weiße Rahmen um die Schreibmaschine existiert, läßt sich der Handzeiger nicht bewegen. Dafür kann man nun die Schreibmaschine benutzen, deren Wagen ungefähr in der Bildschirmmitte sehr realistisch dargestellt ist (Bild 2). Die Computertastatur wird nun als normale Schreibmaschinentastatur mit Groß- und Kleinschreibung benutzt. Die Simulation einer Schreibmaschine ist nahezu perfekt. Der Wagen rückt mit jedem Anschlag eine Stelle nach links, wobei maximal 80 Zeichen in einer Zeile möglich sind, von denen aber immer nur 40 Zeichen im Bild sind (horizontales Scrolling).</p>

<p>Einige Stellen vor Erreichen des Zeilenendes ertönt eine Warnklingel, bei Betätigen der RETURN-Taste wird ein Wagenrücklauf mittels Grafik und entsprechendem Geräusch simuliert. Mit den Funktionstasten F5 und F7 können Tabulatoren gesetzt oder gelöscht werden, mit F3 erfolgt ein schneller Wagenvorlauf auf die nächste Tabulatorposition. Mittels Joystick oder Cursortasten kann man sich auf dem dargestellten Papierbogen in alle vier Richtungen bewegen und mit der DEL-Taste beliebige Textbereiche löschen.</p>

<p>Vorsicht ist geboten beim Umgang mit der DEL- und der SPACE-Taste. DEL löscht das Zeichen, auf das die Maschine gerade positioniert ist und hinterläßt einen Freiraum, zieht den Text also anders als beim normalen Basic-Betrieb nicht zusammen. Die SPACE-Taste wirkt dagegen genauso wie ein »Cursor rechts», verändert also keine Zeichen. Das ist beim Überschreiben von Textstellen des öfteren sehr störend, da unerwünschte Zeichen explizit mit DEL gelöscht werden müssen.</p>

<p>Bis auf das Überschreiben von Texten und das Löschen von Zeichen gibt es keine weiteren Editiermöglichkeiten, insbesondere ist es unmöglich, zusätzlichen Text einzufügen oder Textstellen zu kürzen. Diese fehlenden Editiermöglichkeiten sind sicherlich ein Schwachpunkt des Programms, auch wenn man berücksichtigt, daß Magic Desk kein hochspezialisierter Texteditor ist und auch keiner sein soll.</p>

<h2 id="druckerausgabe-auf-knopfdruck">Druckerausgabe auf Knopfdruck</h2>

<p>Doch nun weiter in unserem Beispiel ! Hat man den Text fertig geschrieben oder ist man am Ende einer Seite angelangt (jede Seite hat 66 Zeilen), dann kann man den Text auf dem Drucker ausgeben und/oder in einem der drei Karteikästen archivieren. Das Ausdrucken einer Seite gestaltet sich dabei denkbar einfach: Man drückt den Feuerknopf amJoystick, worauf die weiße Umrandung um das Schreibmaschinensymbol verschwindet. Nun lenkt man den Handzeiger etwas nach rechts, so daß er auf die kleine Abbildung eines Druckers zeigt. Nun nochmals den Feuerknopf betätigen und schon bekommt das Druckersymbol einen weißen Rahmen und der Drucker rattert los und druckt den — symbolisch gesprochen — in die Schreibmaschine eingespannten Bogen aus.</p>

<p>Eine Kopie gefällig? Einmal Feuerknopf drücken — Drucker aus, wieder Feuerknopf drücken — die Textseite wird nochmals ausgedruckt. Das läßt sich beliebig fortsetzen, denn die Textseite in der Schreibmaschine bleibt solange erhalten, bis man sie entweder in einer Kartei ablegt oder sie in den Papierkorb wirft.</p>

<p>Letzteres ist genauso einfach wie das Ausdrucken. Mit dem Joystick den Handzeiger auf das Papierkorbsymbol setzen, Feuerknopf betätigen und die Textseite erscheint verkleinert über dem Papierkorb. Falls man es sich anders überlegt hat, kann man jetzt einfach ein anderes Objektsymbol ansteuern, die Textseite landet dann wieder in der Schreibmaschine. Drückt man allerdings ein zweites Mal den Feuerknopf, dann wandert die Textseite — mit einer an »Space Invader« erinnernden Geräuschuntermalung — in den Papierkorb und ist damit endgültig verloren.</p>

<h2 id="die-floppy-ersetzt-den-karteikasten">Die Floppy ersetzt den Karteikasten</h2>

<p>Alle mit der Schreibmaschine erzeugten Textblätter können jedoch auch in einer Kartei archiviert werden. Die Kartei wird vom Hauptmenü — also von der Bildschirmdarstellung des gesamten Schreibtisches her — angewählt. Zur Verfügung stehen drei Karteikästen. Jeder dieser Karteikästen enthält zehn gelbe Indexkarten, deren oberer Rand beliebig beschriftet werden kann und die mit dem Joystick in natürlicher Weise durchgeblättert werden können (Bild 3). Zu jeder gelben Indexkarte wiederum gehören zehn weiße Textkarten, die ebenso wie die gelben Indexkarten beschriftet und durchgeblättert werden.</p>

<p>Das Ablegen einer mit der Schreibmaschine erstellten Textseite geschieht nun sehr einfach und genauso wie in einer realen (Papier-) Kartei. Zunächst wird einer der drei Karteikästen angewählt. Auf dem Bildschirm erscheinen nun die zehn gelben Indexkarten, die man bis zur gewünschten Karte durchblättert und eventuell mit einem Stichwort beschriftet. Mit dem Joystick werden die zur Indexkarte gehörigen weißen Textkarten auf den Bildschirm gebracht und bis zur gewünschten Stelle durchgeblättert. Nun den Feuerknopf drücken und die kleine Abbildung einer Diskette anwählen — und schon wird der Text aus der Schreibmaschine an der ausgewählten Stelle in der Kartei abgelegt.</p>

<p>Um sich einen Textbogen aus der Kartei anzusehen, geht man wie zuvor beschrieben zur gewünschten Stelle in der Kartei, wählt aber dann statt des Diskettensymbols einen kleinen weißen Zettel an. Das entsprechende Karteiblatt wird dadurch in großformatiger Darstellung auf den Schirm gebracht und kann eingesehen oder auch in die Schreibmaschine eingespannt werden.</p>

<p>Da sowohl die gelben Indexkarten als auch die weißen Karteikarten beliebig beschriftet werden können, bietet sich das System für Adressenlisten, Inhaltsverzeichnisse, Terminplanungen oder ähnliche Anwendungen geradezu an.</p>

<p>Eine Diskette kann den Inhalt dreier Karteikästen speichern; das sind immerhin 300 Textbögen, die allerdings nicht alle vollständig beschrieben sein dürfen. Durch Verwendung mehrerer Disketten kann das Speichervermögen der Kartei praktisch beliebig gesteigert werden.</p>

<p>Bei der praktischen Arbeit mit Magic Desk machten sich die doch recht langen Disketten-Zugriffszeiten unangenehm bemerkbar:</p>

<p>Zwischen fünf und zehn Sekunden zum Anwählen eines Karteikastens (nur der reine Diskettenzugriff!) ist noch akzeptabel, aber eine runde Minute zum Abspeichern eines Fünf-Zeilen-Textes zerrt mitunter schon sehr an den Nerven des Benutzers. Allerdings sind diese langen Zugriffszeiten in erster Linie wohl auf den seriellen Datentransport zwischen dem C 64 und dem verwendetem 1541-Laufwerk zurückzuführen.</p>

<h2 id="magic-desk-gibt-hilfestellung">Magic Desk gibt Hilfestellung</h2>

<p>Ein Glanzpunkt des Magic Desk wurde bisher noch nicht erwähnt: Wenn man sich über die Funktion eines Gegenstandes im unklaren ist oder sich sonstwie nicht zu helfen weiß, genügt ein Druck auf die »Commodore«-Taste des C 64 um ein Hilfsmenü aufzurufen. Je nach angewählter Funktion erscheint dabei ein anderes Hilfsmenü, das eine Anzahl von Gegenständen auf den Schirm zeichnet, mit denen es der Benutzer gerade zu tun haben könnte (Bild 4).</p>

<p>In der schon bekannten Art und Weise kann man nun eine dieser Abbildungen mit dem Joystick ansteuern und erhält dann nähere Informationen über den Umgang mit dem entsprechenden Gegenstand. Durch Ansteuerung eines Schildes mit der Aufschrift »EXIT« gelangt man wieder zur gerade aktuellen Funktion zurück.</p>

<p>Insgesamt betrachtet ist das Arbeiten mit dem Magic Desk recht erfreulich, alle Funktionen lassen sich perJoystick leicht und sicher ausführen. Die Einarbeitungszeit ist wesentlich kürzer als bei entsprechenden konventionellen Programmen.</p>

<p>Wer von Magic Desk allerdings einen ausgefeilten Texteditor oder ein komfortables Datenbanksystem erwartet, der wird einigermaßen enttäuscht sein. Magic Desk ist weder das eine noch das andere und soll es auch gar nicht sein. Es ist halt nur ein Schreibtisch — allderdings einer mit recht magischen Zügen.</p>

<p>(ev)</p>

<p>BASIC BÄR (The last one) – Ein Programmgenerator</p>

<blockquote><p>Sie haben die Idee für ein Programm, Ihnen fehlt aber die Zeit oder die Geduld, sie zu verwirklichen. Hier hilft Ihnen Basic Bär.</p></blockquote>

<p>Angenommen Sie möchten mit Ihrem C 64 ein komplettes Datenverwaltungssystem einrichten. Wie gehen Sie vor? Programmieren Sie selbst, vielleicht in Basic? Oder kaufen Sie sich ein fertiges Programm? Beide Möglichkeiten haben ihre Vor- und Nachteile. Es gibt aber noch eine dritte Möglichkeit. Sie benutzen einen Programmgenerator.</p>

<p>Ein Programmgenerator ist ein Programm, das nach Ihren Angaben ein Programm erstellt. Dabei müssen Sie selbst kaum programmieren können. Sie geben nur ein sehr allgemeines Ablaufschema des zu erstellenden Programmes ein. Das von Ihnen eingegebene Schema wird nun Schritt für Schritt verfeinert. Nach Ablauf der Generierung steht das erzeugte Programm unabhängig von dem Programmgenerator zu Ihrer Verfügung.</p>

<p>Das gut lesbare Handbuch hat das Format eines Taschenbuches. Die Einarbeitungszeit ist recht kurz, und für einfache Problemlösungen benötigen Sie nicht einmal Basic-Kenntnisse.</p>

<p>Dieser Programmgenerator ist menüorientiert, was bedeutet, daß mit baumartig organisierten Bildschirmmasken alle Möglichkeiten zur Auswahl angeboten werden und Sie Ihre Auswahl nur in Form einer Zahl eingeben brauchen. Diese Dialogform ist recht fehlersicher und hat den Vorteil, daß Sie nach wenigen Stunden kaum noch in das Handbuch sehen müssen.</p>

<p>Die Menütechnik wird überall voll unterstützt, so daß auch das zu erstellende Programm auf diese Weise mit fehlersicheren Eingaberoutinen ausgestattet werden kann.</p>

<p>Die Generierung eines Programmes erfolgt in zwei Schritten. Zuerst geben Sie einen Ablaufplan ein. In einer Frage-Antwortsitzung müssen Sie dann alle Detailfragen, die der Programmgenerator noch benötigt, beantworten.</p>

<p>Der Ablaufplan ist eines der wenigen Dinge, die Sie vorab selbst planen müssen. Ein Ablaufplan im Sinne vom Basic Bär ist eine logische Aufeinanderfolge von Arbeitsschritten, die Sie benötigen, um Ihr geplantes Programm zu verwirklichen. Der Programmgenerator nutzt die Tatsache, daß die einzelnen Verarbeitungsschritte in den meisten Programmen ähnlich sind. Die Ausgabe einer Bildschirmmaske und das anschließende Einlesen von Daten ist ein solcher Arbeitsschritt. Soll zum Beispiel in eine Datei mit dem Namen »Telefonliste« eingelesen werden, so wird dies mit folgendem Befehl umschrieben:</p>

<p>KEYBORD INPUT USING TELEFONLISTE FIELDS</p>

<p>Wenn Sie im Programm eine Abfrage einbauen, und abhängig davon an eine bestimmte Stelle im Ablaufplan verzweigen wollen, müssen Sie etwa folgendes schreiben:</p>

<p>ASK USER »FERTIG ?«: BRANCH IF YES TO LINE X</p>

<p>Wie die Bildschirmmaske und die Datei überhaupt aufgebaut sein soll, und welche Datenfelder denn eingelesen werden sollen, wird wie die Sprungadresse erst in der Codegenerierung abgefragt.</p>

<h2 id="das-generierte-basic-programm">Das generierte Basic-Programm</h2>

<p>Wenn der Ablaufplan vollständig eingegeben worden ist, wird Zeile um Zeile der Basic-Code generiert. Das Floppy-Laufwerk kommt dabei kaum zur Ruhe. In dieser Phase beantworten Sie die Fragen nach dem Aufbau von Bildschirmmasken, nach dem Druckbild von Listen, nach Sortierkriterien oder nach den Sprungzielen bei Verzweigungen. Den Aufbau von Bildschirmmasken, Listen und den Ablaufplan können Sie abspeichern, um später auf diese wieder zurückgreifen zu können.</p>

<p>Anschließend werden Ihre gesamten Angaben in Basic übersetzt, ähnlich wie ein Makroassembler Makroanweisungen in Maschinensprache übersetzt.</p>

<p>Ein so erzeugtes Programm ist nicht sehr übersichtlich. Will man später Änderungen vornehmen, muß man sehr viel Zeit aufwenden, um sich in dem Programm zurecht zu finden. Wie zu erwarten war, ist ein mit Basic Bär erstelltes Programm erheblich länger als ein selbst erstelltes. Der Unterschied wird aber erheblich geringer, je komplexer die Anforderungen an das Programm sind. Das Zeitverhalten ist für ein Basic-Programm recht gut. Jedem ernsthaften Anwender sei allerdings ein Basic-Compiler empfohlen, um so das generierte Programm zu beschleunigen.</p>

<h2 id="dateibearbeitung-und-andere-funktionen">Dateibearbeitung und andere Funktionen</h2>

<p>Alle Routinen zur Dateibearbeitung sind in Basic Bär fest eingebaut. Sie arbeiten allerdings nur mit relativen Dateien. Wer also eine andere Dateiform wünscht, muß die Routinen wie Dateiöffnen, Satzlesen, Positionieren auf einen bestimmten Satz oder Satzschreiben selbst programmieren. Dies ist jedoch ohne weiteres möglich, da innerhalb des Programmgenerators auch sämtliche Basic-Befehle zugänglich sind. Sehr positiv ist zu erwähnen, daß mit einem SORT-Kommando gearbeitet werden kann, mit dem nach bis zu drei Schlüsseln sortiert wird.</p>

<p>Durch eine automatische Ausrichtung und Überprüfung von numerischen Feldern in den Bildschirmmasken und einer automatischen Dokumentation der gesamten Eingaben bei der Generierung werden die von Basic Bär erstellten Programme sehr fehlersicher und wartungsfreundlich.</p>

<p>Basic Bär gehört in die Klasse der guten und durchdachten Dienstprogramme. Der Preis von 425 Mark wird den Anwenderkreis sicherlich einschränken. Aber trotzdem ist dieser Programmgenerator für jene interessant, die sowohl mit dem aufwendigen Selbstprogrammieren als auch mit den starren Programmen aus der Dose unzufrieden sind.</p>

<p>(rg)</p>

<h1 id="hes-64-forth-–-komfortabler-als-basic">HES 64 FORTH – komfortabler als Basic</h1>

<blockquote><p>Die Programmiersprache Forth ist für immer mehr Mikrocomputer erhältlich, und das nicht ohne Grund. Forth ist eine sehr mächtige Sprache, die in einem gewissen Sinne die positiven Seiten von Basic, Pascal und Assembler in sich vereint. Für den Commodore 64 ist jetzt eine der leistungsfähigsten Forth-Versionen als Steckmodul erhältlich: Das 64 Forth von Human Engineered Software.</p></blockquote>

<p>Bei dieser Forth-Version für den C 64 handelt es sich um ein im Sprachumfang stark erweitertes FIG-Forth. Die Abkürzung FIG steht dabei für Forth Interest Group und bezeichnet eine unabhängige Gruppe von Forth-Enthusiasten, die sich die Standardisierung und Verbreitung von Forth zum Ziel gesetzt hat. Bei einer Sprache wie Forth, die vom Anwender praktisch beliebig erweiterbar und veränderbar ist, erscheint ein solcher Standard auch dringend notwendig, weil sonst der Softwareaustausch zwischen den Anwendern fast unmöglich würde. Das 64 Forth hält sich sehr eng an den FIG-Standard, was dem Benutzer unmittelbar zugute kommt: Die meisten für andere Computer entwickelten Forth-Programme sind, solange nicht spezielle Hardware-Eigenschaften ausgenutzt werden, mit minimalen Änderungen sofort auf dem C 64 lauffähig.</p>

<p>Forth zeichnet sich ja generell schon durch einen großen Befehlsvorrat aus. Im 64 Forth wurde jedoch der Grundwortschatz des FIG-Standards nochmals stark erweitert. Über 500 Befehle stehen zur Verfügung. Damit man hier noch den Überblick behält, sind diese Befehle auf vier Vokabulare aufgeteilt: FORTH, EDITOR, SYSTEM und ASSEMBLER. Ein Vokabular wird einfach durch Angabe seines Namens aufgerufen oder aktiviert.</p>

<p>Zu Anfang ist nur das normale Forth-Vokabular zugänglich. Will man längere Forth-Programme oder Texte eingeben, dann ruft man einfach das Editor-Vokabular auf und kann nun alle vorhandenen Befehle zum Editieren von Texten nutzen. Das System-Vokabular enthält Befehle zum Zugriff auf die Betriebssystemebene.</p>

<p>Obwohl Forth-Programme in der Regel um Größenordnungen schneller als Basic-Programme laufen, können doch ab und zu zeitkritische Situationen eintreten. In diesem Fall ruft man das Assembler-Vokabular auf und hat sofort einen 6502-Macro-Assembler zur Verfügung.</p>

<p>Schon bei einem ersten Blick ins Inhaltsverzeichnis des (leider nur englischen) Handbuchs fällt es auf: Das 64 Forth verfügt in Addition zum FIG-Forth-Standard über eine ganze Reihe von Befehlen, um spezielle C 64 — Eigenschaften zu unterstützen.</p>

<p>Mit BGROUND und BORDER werden zum Beispiel die Hintergrund- und die Rahmenfarbe gewählt. Mit NEWSPRITE kann man innerhalb einer Bildschirmmaske sehr komfortabel neue Sprites entwerfen. Spritedaten können in spezielle Sprite-Dateien geschrieben oder daraus gelesen werden. Mit dem Befehl SHOW werden Sprites sichtbar gemacht, mit HIDE verschwinden sie wieder vom Bildschirm. Mit weiteren Befehlen kann man Sprites über den Bildschirm bewegen, einfärben und vergrößern. Natürlich ist auch der Mehrfarbenmodus möglich.</p>

<p>Wer sich schon einmal mit den diversen POKE-Befehlen in Basic abgemüht hat, um ein paar Sprites über den Bildschinn zu bewegen, der wird diese Möglichkeiten des 64 Forth sehr zu schätzen wissen.</p>

<p>Ganz ähnlich verhält es sich auch bei den Toneffekten: Wo man in Basic viele Zeilen mit POKE-Befehlen braucht, um ein paar Noten zu spielen, geht das mit 64 Forth im Klartext und wesentlich übersichtlicher. Der Befehl VOICE1 wählt zum Beispiel den Tongenerator 1 an, mit TRIANGLE, SAWTOOTH, SQUARE oder NOISE wird die Wellenform ausgewählt. Weitere Befehle steuern Frequenz, Hüllkurve, Lautstärke und andere Faktoren. Insgesamt gibt es 40 (!) Befehle zur Steuerung des Synthezisers.</p>

<p>Auch die Ansteuerung externer Geräte macht mit 64 Forth keine Schwierigkeiten. Im SYSTEM-Vokabular gibt es diverse Befehle zur Datenkommunikation mit Drucker, Floppy oder Kassette. Der Befehl PRON ersetzt beispielsweise die Basic-Befehlsfolge »OPEN 1,4:CMD 1«. Um Befehle an die Floppy zu schicken, braucht nicht umständlich ein Kommandokanal eröffnet werden, sondern es reicht der CMD-Befehl. Um zum Beispiel eine Diskette zu formatieren, schreibt man in 64 Forth: CMD N:Name,ID.</p>

<p>Außerdem können die meisten Kernal-Routinen des Betriebssystems einfach mit ihrem Namen aufgerufen werden, wodurch sich eine hohe Flexibilität beim Datenaustausch über den seriellen Bus ergibt.</p>

<p>Bemerkenswert sind die recht komfortablen Testhilfen, die 64 Forth zur Verfügung stellt. Mit den Befehlen TRACE, STEP, EMULATE und CONT kann die Ausführung von Forth-Befehlen überwacht werden. Zusätzlich ist ein Decompiler vorhanden, der mit SOURCE aufgerufen wird und compilierte Forth-Worte wieder zurückübersetzen kann (Bild 1). Derartig umfangreiche Debug-Funktionen sucht man bei anderen Forth-Compilern in der Regel vergeblich.</p>

<p>Im Gegensatz zu der recht einfachen Speicherverwaltung von Basic benutzt Forth das Konzept des virtuellen Speichers. Vereinfacht gesagt bedeutet das die Aufteilung des verfügbaren Speichers in kleine Abschnitte, sogenannte Screens oder Textfelder, auf die über eine Nummer zugegriffen wird. Dabei ist es nicht nötig, daß sich alle Screens zur gleichen Zeit im Hauptspeicher befinden. Die meisten Screens sind daher als relative Datei auf einer Diskette angelegt und werden nur bei Bedarf geladen.</p>

<p>64 Forth bietet dabei noch die Besonderheit, daß eine solche virtuelle Speicherverwaltung auch ohne Floppy ermöglicht wird. Die einzelnen Textfelder werden dabei in der Reihenfolge ihrer Numerierung mit der Datasette wie normale Programme aufgezeichnet. Ein Pufferspeicher von 16 Textfeldern im RAM, begrenzt die Anzahl der nötigen Kassettenoperationen.</p>

<p>Jedes Textfeld kann nun für sich mit dem Texteditor bearbeitet werden. Bei fast allen Forth-Versionen ist zu diesem Zweck nur ein einfacher zeilenorientierter Editor vorhanden. 64 Forth stellt seine Kompatibilität dadurch unter Beweis, daß es ebenfalls über einen solchen umständlich zu bedienenden Zeileneditor verfügt, der ganz normal mit n EDIT aufgerufen wird, wobei n die Nummer des zu editierenden Textfeldes ist.</p>

<h2 id="der-full-screen-editor">Der Full-Screen-Editor</h2>

<p>Daneben aber gibt es in 64 Forth auch einen »Full-Screen-Editor«, wie er vom Basic her bekannt ist. Man drückt im Edit-Modus die Tastenkombination »Shift« und »INST/DEL«, und es erscheint augenblicklich das gesamte zu editierende Textfeld. Wie von Basic her gewohnt, kann man nun mit Hilfe der Cursourtasten über den gesamten Bildschirm fahren und fehlerhafte Textstellen löschen oder einfach überschreiben.</p>

<p>Die Funktionstasten sind dabei mit diversen hilfreichen Funktionen belegt, zum Beispiel Vorwärts- und Rückwärtstabulator und Suchfunktionen. AufTastendruck kann man in das vorhergehende oder nachfolgende Textfeld wechseln.</p>

<p>Als weitere Besonderheit versteht der Editor eine Reihe von »Wordstar«-kompatiblen Control-Funktionen. Statt mit der »CTRL«-Taste werden diese Funktionen jedoch durch gleichzeitiges Drücken der »Commodore«-Taste und eines Buchstabens ausgelöst. Wer also an das Arbeiten mit »Wordstar« gewöhnt ist, wird sich mit diesem Editor ebenfalls gut zurechtfinden.</p>

<p>Ganz hartgesottene Forth-Programmierer, denen soviel Bedienungskomfort schon dekadent erscheint, haben ja noch die Möglichkeit, stattdessen mit dem zeilenorientierten Editor zu arbeiten.</p>

<p>Das zu magere Handbuch ist in Englisch geschrieben, eine deutsche Übersetzung ist zur Zeit nicht geplant.</p>

<p>Auf 155 kleinformatigen Seiten wird eine kurze Einführung in Forth gegeben, die aber dem Anfänger vermutlich nicht allzuviel sagen wird. In kurzen Kapiteln werden dann der Texteditor und die wichtigsten Forth-Befehle erläutert. Es folgen Abschnitte über die Speicherbelegung von Forth, über die I/O-Organisation und über den integrierten 6502-Macro-Assembler. Listings einer Anzahl von Forth-Utilitys und eine Kurzbeschreibung aller Befehle runden das Handbuch ab.</p>

<p>Durchweg alle Kapitel sind aber recht kurz und knapp ausgefallen, so daß man häufig gezwungen ist, entweder in anderen Büchern nachzuschlagen oder einfach herumzuexperimentieren. Immerhin, man findet die wichtigsten Informationen. Dennoch wäre ein deutsches, etwas ausführlicheres Handbuch sicherlich wünschenswert.</p>

<p>Insgesamt gesehen ist das 64 Forth sicherlich eine der besten Forth-Versionen, die derzeit überhaupt für Mikrocomputer erhältlich sind. Deutliche Pluspunkte sind der hervorragende Editor und der umfangreiche Befehlssatz, insbesondere die vielen Befehle für Spritegrafik und Sounderzeugung, die man im Commodore-Basic manchmal schmerzlich vermißt. Der integrierte Assembler ist eine wertvolle Hilfe bei der Lösung zeitkritischer Probleme.</p>

<p>Das 64 Forth kann in Deutschland als Steckmodul (Bild 2) für den C 64 über »Die Forth-Quelle« in 7820 Titisee-Neustadt zum Preis von 198 Mark bezogen werden. Eine Version für den VC 20 ist ebenfalls erhältlich. Leider ist das Modul nach Auskunft der Anbieter auf dem tragbaren SX 64 aufgrund doch vorhandener geringer Hardwareunterschiede nicht lauffähig.</p>

<p>(ev)</p>

<h1 id="lode-runner">Lode Runner</h1>

<blockquote><p>Wer auf seinem Heimcomputer sein Reaktionsvermögen testen will, dem sei Lode Runner empfohlen, ein Spiel mit 150 (!) verschiedenen Spielfeldern.</p></blockquote>

<p>Das Spiel Lode Runner ist ein Actionspiel aber dennoch kein Schießspiel und wird für Apple<br/>
II, II+ und IIe, Atari 400/800/XL, VC 20, Commodore 64 sowie IBM PC angeboten.<br/>
»Du bist ein gut trainierter Commander im unendlichen Weltraum&hellip;« — so verheißungsvoll beginnt die Spielanleitung (natürlich in Englisch abgefaßt). Man muß auch wirklich gut trainiert sein, um alle 150 Spielfelder zu durchlaufen. Ich selbst habe allein sechs Stunden benötigt, um bis zum siebten Spielfeld vorzudringen. Man hat die Möglichkeit, sich ganze 255 eigene Spielfelder zu erstellen und diese auf Kassette oder Diskette abzuspeichern.</p>

<p>Dies ist mit dem im Spiel integrierten Game Generator möglich. Der Generator ist sehr einfach zu bedienen. Obwohl die Bedienung sehr einfach ist, wäre es angebracht, in der Spielanleitung zu erwähnen wie man den Game Generator startet. Ich wollte die Suche nach dem Generator schon aufgeben, als ich zufällig nach dem Start des Spieles die »E«-Taste drückte und sogleich mein eigenes Spielfeld entwerfen konnte.</p>

<p>Doch nun noch einmal zum Spiel selbst.</p>

<p>Der Spieler muß in jedem Feld alle Goldklumpen sammeln. Doch das Einsammeln der Punkte in dem Labyrinth aus Mauern, Leitern und Stangen ist nicht so einfach, da man hierbei von einigen Feinden verfolgt wird. So braucht man schon einiges Geschick und Reaktionsvermögen, um alle Goldklumpen zu sammeln und nicht gefangen zu werden.</p>

<p>Die grafischen und musikalischen Fähigkeiten des VC 20 werden nicht gerade voll ausgeschöpft. Der Spieler bewegt sich zwar fließend aber die Verfolger »hüpfen« nur ruckartig von Kästchen zu Kästchen.</p>

<p>Fazit:</p>

<p>Wer Abwechslung und Spannung liebt, dem sei dieses Spiel empfohlen, da wegen der großen Variationsberichte und der Möglichkeit, selbst kreativ zu werden, die Spielmotivation bestimmt nicht nachläßt.</p>

<p>(Christian Spitzner)</p>

<h1 id="zaxxon---zu-große-erwartung?">Zaxxon - Zu große Erwartung?</h1>

<p>Allen Arcade-Spiel-Freunden ist er sicherlich bekannt&hellip;Zaxxon. Der gefährliche Kampfroboter treibt nun schon seit Anfang ’84 sein Unwesen auf dem Home-Computer-Markt. Allerdings hört man schon einige Seufzer&hellip;ist der Riesenhit doch kleiner als man erwartet hatte? Nun, zur Handlung: Man fliegt mit einem Raumkreuzer über einen Asteroidengürtel, versucht möglichst viel »Feindliches« abzuschießen und steht dann nach einigen Prüfungen vor »Zaxxon«, einem gefährlichen Kampfroboter. Dieser erscheint zwar nur kurz, trotzdem muß man sich mit ihm ein heißes Gefecht liefern. Nach dieser Konfrontation beginnt alles wieder von vorne. — Nur etwas schwerer. Die starke pseudo-3D-Grafik wertet das Spiel zwar auf, jedoch hilft selbst die beste Grafik nicht, über Schwächen hinwegzutäuschen, die nach einigen Spielen deutlich werden: So wird es dem Spieler leicht langweilig, wenn er 5 bis 6 mal immer wieder dieselbe Szene überfliegt und sich nichts ändert, außer dem Schwierigkeitsgrad. Generell ist zu sagen, daß a) die Erwartungen der Käufer zu hoch gesteckt waren und b) daß Zaxxon diese hohen Ansprüche nicht erfüllen kann — und das schon gar nicht auf Dauer! Alles in allem, Zaxxon ist nicht das, was man so hört, wird aber sicher bei den Weltraumabenteuern einen gehobenen Rang einnehmen, den er sich trotz alledem verdient hat.</p>

<p>(Oliver v. Quadt)</p>

<h1 id="flight-ii-–-fast-wie-richtiges-fliegen">Flight II – Fast wie richtiges Fliegen</h1>

<blockquote><p>Wenn Sie auch zu den Zeitgenossen gehören, denen das Fliegen nur auf dem Passagiersitz eines Linienflugzeugs vergönnt ist, dann gibt es etwas Neues für Sie und Ihren Commodore 64.</p></blockquote>

<p>Der Flight-Simulator II von Sublogic im Vertrieb der Lucius Computer-Programme (190 Mark) stellt ohne Übertreibung alle bekannten Flug-Programme in den Schatten.</p>

<p>Das Fluggerät ist eine Piper Pa 28-181 Archer II. Ihre Instrumente und Flugeigenschaften werden täuschend echt simuliert. Über 80 Flughäfen kann der Computer-Pilot in den USA ansteuern. Ein riesiges Terrain, das nur die wenigsten überfliegen werden. Die relativ realistische Abbildung des Geländes ist allein schon ein Genuß für das Auge.</p>

<p>Nun zum Fluggeschehen. Je nach Können und vor allem Mut ist es möglich, zwischen drei verschiedenen Schwierigkeitsgraden zu wählen: Dem »realistic«, dem »easy« und dem »slew« Modus. Die höchsten Ansprüche an die Fähigkeiten des Piloten stellt der Realflug. Hier ist vom Starten des Motors über den Kampf mit den verschiedensten Handicaps und Defekten bis zum sensiblen Flugverhalten alles vorhanden. In den vollen Genuß der Landschaft und der Flugumgebung kommt man am besten durch Anwählen des »slew« Modus. Das Flugzeug fliegt dann wie ein Hubschrauber.</p>

<p>Zu Beginn der fliegerischen Laufbahn ist es sinnvoll, der ausgezeichneten (noch englischen) Anleitung zu folgen. Dadurch erspart man sich so machen unfreiwilligen »Crash«.</p>

<p>Der Horizont und die Landschaftsmerkmale bewegen sich beim Fliegen naturgetreu, entsprechend der jeweiligen Flugposition über den Bildschirm. Aber Vorsicht; nicht die Instrumente vergessen! Schnell kann es geschehen, daß man übersteuert oder zu niedrig fliegt.</p>

<p>Starten möchte ich in New York. Dazu sind die Koordinaten des Abflugortes im Editmodus einzugeben; in diesem Fall ist das 17070/20990. Nach kurzen Diskettenmanövern, die leider im ganzen Spiel immer wieder notwendig werden, erscheint New York auf dem Bildschirm. Vorsichtig die Geschwindigkeit erhöhen, leicht nach oben ziehen, sanft eine Rechtskurve einleiten, nur nicht übersteuern und immer den Höhenmesser im Auge behalten — ein Kommando folgt auf das nächste. Vor mir erscheint das World Trade Center mit seinen beiden Türmen. Der Abenteurer in mir wird wach. Etwas tiefer noch, und da sind sie auch schon, immer größer und bedrohlicher werdend. Als ich zwischen den Türmen durchfliege, wage ich einen Blick nach unten und was ich sehe läßt meinen Atem stocken: Ich bin zu tief! Dies waren meine letzten Gedanken. Als ich »aufwachte«, stand nur noch »crash« auf dem Bildschirm.</p>

<p>Nicht unerwähnt soll auch das auswählbare Actionspiel im Flight II bleiben. Nicht etwa, daß Flight II ohne das Luftkampfspiel »World War I Ace« kein vollständiges Programm wäre. Im Gegenteil, beide Programme könnten auch separat verkauft werden. Die Aufgabe des Piloten besteht beim »World War I Ace« darin, feindliche Stellungen, Depots und Fabriken zu beschießen. Das Flugzeug ist dazu mit Maschinenkanonen und Bomben bewaffnet. Damit der Angriff realistischer wird, wehrt sich der Feind mit sechs äußerst aufdringlichen Jagdfliegern. Diese sind nur durch waghalsige Flugmanöver und intensiven Einsatz der Bordkanone abzuschütteln.</p>

<p>Es ist unbestreitbar, auch dieses Spiel begeistert, mich persönlich mehr durch die gelungene Grafik und Animation, als durch die Spielidee. Wer aber gerne als »Richthofen« durch die Lüfte jagen möchte, wird sicher einige seiner bisherigen »Actionspiele« zumindest vorläufig beiseitelegen.</p>

<p>Insgesamt, wobei der Flugsimulator der wichtigere Teil ist, kenne ich kein Programm, das den Flight II in bezug auf Spielmotivation, Grafik, Beeinflußbarkeit der Handlung und Abwechslungsreichtum erreichen könnte. Am besten gefällt mir aber, daß mit Flight II ein Unterhaltungsprogramm geschaffen wurde, das sicher nicht nur die jüngere Generation begeistert.</p>

<p>(Arnd Wängler)</p>

<h1 id="der-softwarekatalog-für-ihre-programme">Der Softwarekatalog für Ihre Programme</h1>

<blockquote><p>Wie finden Sie Ihre auf Disketten gespeicherten Programme ohne langes Suchen? Abhilfe in diesem Punkt schafft dieses Programm, mit dem Sie Ihren eigenen Softwarekatalog erstellen können.</p></blockquote>

<p>Das Programm für den Commodore 64 mit Diskettenlaufwerk und Epson-Drucker RX-80 mit Data-Becker Interface (simuliert einen Commodore-Drucker auf dem RX-80) erlaubt die Verwaltung der auf Diskette gespeicherten Programme. Man legt nur eine Diskette ein, dann lädt der Computer das Inhaltsverzeichnis der Diskette und druckt es auf dem Bildschirm aus. Nun tippt man nur noch »J« für Ja oder »N« für Nein ein, ob der Computer den Programmnamen in seine Liste aufnehmen soll oder nicht. Danach gibt man ein, unter welcher Kategorie das Programm eingeordnet werden soll. Zur Auswahl stehen allgemeine, Spiel-, Hilfs- und Sprachprogramme.</p>

<p>Im Menü kann man zwischen dem alphabetischen Sortieren der Liste, Speichern der Liste und dem Auflisten und Löschen von Programmen wählen. Beim alphabetischen Sortieren werden zunächst alle Namen, die zweimal gespeichert sind, gelöscht. Dann wird die Liste nach ASCII-Wertigkeit geordnet. Das Abspeichern der Liste erfolgt in eine sequentielle Datei. Auf ein »Random-File« wurde verzichtet, da sonst das Programm um einiges länger und langsamer geworden wäre. Bei »Programme löschen« kann man Programmfiles löschen und umbenennen. Will man umbenennen, so gibt man zuerst den alten, noch gespeicherten Namen, dann den neuen Namen des Programmes ein.</p>

<p>Beim Auflisten von Files kann man die Programme entweder auf dem Bildschirm oder dem Drucker ausgeben. Dabei kann man alle oder nur einzelne Kriterien auflisten.</p>

<p>Zur besseren Übersicht und zum schöneren Aussehen werden die Farben Rot, Gelb, Blau, Schwarz und Weiß benutzt. Diese werden in Control-Strings abgespeichert, da sonst das Programmlisting sehr unübersichtlich und beim Eintippen schwierig zu lesen wäre.</p>

<p>(Michael Börner)</p>

<h2 id="leserservice:-die-alternative-zum-mühsamen-abtippen">Leserservice: Die Alternative zum mühsamen Abtippen</h2>

<blockquote><p>Alle Listings, die im 64’er-Magazin veröffentlicht werden, gibt es künftig auch auf Datenträgern. Zusätzlich bieten wir auch Autoren besonders langer Basic- oder Maschinenprogramme eine neue Möglichkeit an, ihre Arbeiten zu veröffentlichen. Solche Programme werden künftig ebenfalls über den Leserservice angeboten.</p></blockquote>

<p>Viele Leser haben uns gefragt, ob die veröffentlichten Listings auch auf Datenträgern angeboten werden. Mit dem Leserservice kommen wir diesem Wunsch nach. Es werden, nach VC 20 und C 64 getrennt, jeweils alle in einer 64’er-Ausgabe enthaltenen Listings aufKassette angeboten.</p>

<p>Eine Diskettenversion dieser Programme ist in Vorbereitung und wird in einer der nächsten Ausgaben angeboten. Mit Erscheinen dieses Heftes sind die Kassetten mit den Programmen der Ausgaben 4 und 5 des 64’er-Magazins verfügbar. Diese Kassetten können mit der beigehefteten »Buchladen-Software-Bestellkarte unter folgenden Nummern bestellt werden.<br/>
Ausgabe 4,<br/>
C 64-Programme: CB 007<br/>
Ausgabe 4,<br/>
VC 20-Programme: VC 006<br/>
Ausgabe 5,<br/>
C 64-Programme: CB 008<br/>
Ausgabe 5,<br/>
CV 20-Programme: VC 007</p>

<p>Diese Kassetten kosten pro Stück 29,90 Mark. Kassetten mit den Listings der Ausgaben 6 und 7 werden ab Erscheinen von Heft 8 angeboten.</p>

<h2 id="der-extra-service">Der Extra-Service</h2>

<p>Oft erreichen die Redaktion interessante Programme, die leider zu lang sind, um sie im Heft als Listing zu veröffentlichen. Oder sie sind in Assembler geschrieben. Viele dieser Programme brauchen den Vergleich mit teuren kommerziellen Produkten nicht zu scheuen.</p>

<p>Solche Programme veröffentlichen wir zusätzlich zu unserem bisherigen Listingangebot in einer neuen Form: Sie werden im Heft vorgestellt. Darin finden Sie die Programmbeschreibung, die Bedienungsanleitung, kurz alles, was Sie für eine komplette Dokumentation benötigen. Das Programm selbst wird auf Kassette angeboten. Auch für diesen Service sind die Diskettenversionen in Vorbereitung. Auf den folgenden Leserservice-Seiten finden Sie die ersten drei Programme: ein Lernprogramm für russische Vokabeln, eine Superversion des Spiels »Space Invaders« und ein Programm, das einen Geldspielautomaten simuliert und über ausgezeichnete Grafik verfügt.</p>

<p>Auch diese Programme sind über die »Buchladen-Software-Bestellkarte« erhältlich. Die Bestellnummer ist jeweils am Ende der Dokumentation aufgeführt. Der Preis für diese Programme beträgt 29,90 Mark.</p>

<p>Die Preise für die Leserservice-Kassetten und -Disketten müssen die Kosten decken — wir sind aber bemüht, sie so niedrig zu halten, daß der Leserservice auch wirklich ein Service ist.</p>

<p>Ihre 64’er-Redaktion</p>

<h1 id="russische-vokabeln---das-lernprogramm-mit-den-zwei-zeichensatzen">Russische Vokabeln - das Lernprogramm mit den zwei Zeichensatzen</h1>

<blockquote><p>Beim Eriernen einer Fremdsprache ist das Lernen von Vokabeln, Redewendungen und Satzkonstruktionen eine ziemlich unangenehme Aufgabe.</p></blockquote>

<p>Ein Computer mit einem Vokabellernprogramm kann einem das Lernen selbst nicht abnehmen. Er kann aber ohne große Mühe ein »elektronisches« Vokabelheft führen, verwalten, ausdrucken, zum Abfragen verwenden, das Lernen durch gezieltes Wiederholen noch nicht beherrschter Wortpaarungen verbessern helfen und das Lernen durch den Umgang mit dem Computer interessanter erscheinen lassen.</p>

<p>Viele Vokabellernprogramme wurden schon veröffentlicht. Das im folgenden vorgestellte Programm für den Commodore 64 zum Lernen russischer Vokabeln hat jedoch die folgenden herausstechenden Merkmale:</p>

<ol>
<li>Erweiterung des Zeichensatzes auf Bildschirm und Drucker, um die kyrillischen Buchstaben darstellen zu können</li>
<li>ein hoher Bedienungskomfort, denn Auswahl, Eingabe, Abfragen und so weiter erfolgen menü- beziehungsweise maskengesteuert.</li>
</ol>


<p>Für diejenigen, die an der russischen Sprache nicht interessiert sind, kann das Programm vielleicht als Anregung dienen, denn viele Sprachen haben ja in ihrer Schrift Buchstaben, die nicht im normalen Zeichensatz der Computer enthalten sind (zum Beispiel Griechisch, Französisch).</p>

<p>Das Programm »Russische Vokabeln« kann maximal fünfzig Vokabeln im Speicher des Computers aufnehmen und zum Abfragen, Drucken, Ändern und so weiter verwenden. Eine Vokabel besteht aus fünf Blöcken:</p>

<ul>
<li>Russisches Wort, eventuell mit grammatikalischen Erläuterungen,</li>
<li>deutsche Übersetzung (en),</li>
<li>Bemerkungen,</li>
<li>ein oder mehrere russische Satzbeispiele und</li>
<li>die deutsche Übersetzung der Satzbeispiele.</li>
</ul>


<p>Jeder der fünf Blöcke kann maximal drei Zeilen mit maximal 39 Zeichen fassen. Die Mindesteingabe ist eine russische Vokabel mit deutscher Übersetzung. Da das Lernen von »nackten« Wortpaaren später oft zu einer fehlerhaften Anwendung des Wortes im Satz führt, ist es zweckmäßig, auch ein kleines Satzbeispiel mit Übersetzung zu lernen. Dies ist mit der in diesem Programm vorhandenen Vokabelstruktur möglich. Der Block »Bemerkungen« kann beliebige Informationen enthalten. Sie werden beim Abfragen der Vokabeln immer angezeigt, ganz egal in welcher Richtung abgefragt wird. Man kann hier zum Beispiel die Wortart eingeben.</p>

<p>Die maximal 50 Vokabeln im Speicher des Computers können auf einer Diskette unter einer Nummer (zwischen 0 und 999) abgespeichert werden. Die Abspeicherung erfolgt als sequentielle Datei mit dem Namen »RUSS.VOK. nnn« mit nnn als Dateinummer am Ende der Eingabe beziehungsweise Änderung von Vokabeln.</p>

<p>Das Programm läuft unter Simons Basic und folgender Hardware-Konfiguration: Commodore-64, Floppy 1541 und Drucker 1525 oder Seikosha GP-100 VC.</p>

<p>Nach dem Laden und Starten von Simons Basic kann das Programm geladen und gestartet werden. Durch Drücken irgendeiner Taste gelangt man in das Auswahlmenü. Nach Eingabe des Auswahlcodes (1 bis 8, eine detaillierte Beschreibung erfolgt später) und Drücken von »RETURN« wird, falls bereits Vokabeln im Speicher des Computers sind, gefragt: »DATEI nnn IM SPEICHER, NEU (J/N) ?«. Wenn man die vorhandenen Vokabeln verwenden will, gibt man »N«, sonst »J«, gefolgt von »RETURN«, ein. Wenn noch keine Vokabeln geladen oder eingegeben wurden oder wenn man eine andere Vokabeldatei laden will (Antwort »J«), wird nach der Datei-Nummer (0 bis 999) gefragt. Nach der Eingabe der Nummer und »RETURN« wird die Datei (wenn sie auf der Diskette vorhanden ist) in den Speicher geladen. Vorsicht! Wenn keine Datei mit der eingegebenen Nummer vorhanden ist, wird der Vokabelspeicher im Computer gelöscht.</p>

<p>Die folgenden Funktionen können im Auswahlmenü gewählt werden:</p>

<h3 id="abfragen-von-vokabeln">Abfragen von Vokabeln</h3>

<p>Folgende Möglichkeiten gibt es: Abfragen Russisch-Deutsch, Abfragen Deutsch-Russisch und Abfragen mit zufälliger Abfragerichtung. Das zu übersetzende Wort und das Beispiel werden angezeigt, wobei in den Blöcken der Zielsprache Fragezeichen erscheinen. Die Bemerkungen werden immer angezeigt. Man übersetzt nun die angezeigte Vokabel und das Beispiel (im Geist oder auf einem Stück Papier) und drückt dann irgendeine Taste. Daraufhin wird die gesamte Vokabel angezeigt. Man muß nun seine Übersetzung mit der angezeigten vergleichen und entscheiden, ob die Vokabel gewußt (Eingabe »R«) oder nicht gewußt (»F«) wurde. Außerdem ist das Beenden des Abfragens durch die Eingabe »E« möglich. Das Abfragen geht zufallsmäßig so lange weiter, bis alle Vokabeln »sitzen«.</p>

<h3 id="ausdruck-der-vokabeln-(4)">Ausdruck der Vokabeln (4)</h3>

<p>Der gesamte Vokabelbestand im Speicher wird ausgedruckt (links Russisch, rechts Deutsch, sowie die mit Stern markierten Bemerkungen). Der Ausdruck ist auf 72zeiliges Papier abgestimmt.</p>

<h3 id="eingabe,-Ändern,-ergänzen,-speichern,-ansehen-von-vokabeln-(5)">Eingabe, Ändern, Ergänzen, Speichern, Ansehen von Vokabeln (5)</h3>

<p>Zu Beginn wird die erste Vokabel angezeigt und steht zur Änderung oder Eingabe zur Verfügung. Die folgenden Tasten dienen zum Positionieren des Cursors beziehungsweise zum Blättern innerhalb des Vokabelspeichers:</p>

<ul>
<li>RETURN/SHIFT-RETURN: Zeilenwechsel vorwärts und rückwärts innerhalb eines Blocks.</li>
<li>f1/f2 (= Shift-f1): Wechsel in den nächsten oder vorherigen Block (also zum Beispiel Wechsel von Russisch nach Deutsch und so weiter).</li>
<li>f3/f4 (= Shift-f3): Vokabelwechsel, vorwärts oder rückwärts.</li>
<li>f5/f6 ( = Shift-f5): Vokabelwechsel, je fünf Vokabeln vorwärts oder rückwärts.</li>
</ul>


<p>Wenn sich in einer Zeile bereits Text befindet, steht der Cursor immer am Ende des Textes. Durch Drücken von »DEL« kann man Text löschen. Die deutsche Eingabe erfolgt wie gewohnt (nur Großbuchstaben); die russische Eingabe erfolgt gemäß der beigefügten Tabelle (die auf der Tastatur fehlenden kyrillischen Zeichen sind über Shift-Taste einzugeben).</p>

<p>Nach dem Eingeben beziehungsweise Ändern drückt man zum Abspeichern der Vokabeln auf Diskette die Taste »f7«. Eine eventuell vorhandene Vokabeldatei mit derselben Nummer wird dabei überschrieben. Soll keine Abspeicherung erfolgen, so kommt man durch »f8 ( = Shift-f7)« wieder in das Auswahlmenü.</p>

<h3 id="löschen-einer-vokabeldatei-(6)">Löschen einer Vokabeldatei (6)</h3>

<p>Mit dieser Option kann man eine Vokabeldatei von der Diskette entfernen.</p>

<h3 id="liste-der-vokabeldateien-anzeigen-(7)">Liste der Vokabeldateien anzeigen (7)</h3>

<p>Es wird eine Liste aller Dateien auf der Diskette angezeigt, die »RUSS.VOK.nnn« heißen.</p>

<h3 id="programmende-(8)">Programmende (8)</h3>

<p>Diese Option schließlich beendet das Vokabellernprogramm »RUSSVOK — Russische Vokabeln«.</p>

<p>(Hans Peter Postel)</p>

<p>Dieses Programm ist auf Kassette im Rahmen des Leserservice (s.S.75) unter der Bestellnummer CB 011 erhältlich.</p>

<h1 id="crown-no.-1-–-der-c-64-als-spielautomat">Crown No. 1 – der C 64 als Spielautomat</h1>

<blockquote><p>Dieses Programm wurde für alle diejenigen geschrieben, die sich auch einmal an einem Geldspielautomaten versuchen wollen, ohne großes Kapital zu investieren.</p></blockquote>

<p>Crown No. I simuliert den gleichnamigen Automaten in den Gasthäusern und Spielhallen. Durch Sprites und selbstdefinierte Zeichen wurde eine entsprechende Grafik erzielt.</p>

<p>Wichtig!! Vor dem Einladen muß der Speicher hochgePOKEd werden:<br/>
POKE 44,64 : POKE 16384,0 : NEW<br/>
Technische Daten:</p>

<p>Das Programm selber benötigt 15068 Byte im Speicher<br/>
Die Dimensionierungen verbrauchten 811 Byte<br/>
Crown No. 1 enthält 5 Sprites<br/>
Die Maschinenroutine liegt bei Adresse 49152<br/>
Es wurden 79 Zeichen umdefiniert.</p>

<h2 id="spielanleitung">Spielanleitung</h2>

<p>Crown No. 1 fragt Sie nach dem Start, wieviel Kapital Sie investieren möchten. Sie können bis zu 30 Mark einsetzen. Danach müssen sie eine Weile warten, die Zeichen werden umdefiniert.</p>

<p>Sinn des Spiels ist es, drei gleiche Symbole in den fünf Fenstern zu bekommen. Ist dies erreicht, so gibt es mehrere Möglichkeiten. Drei Kronen ergeben Sonderspiele. Bei Sonderspielen wird jeder Gewinn auf drei Mark erhöht, jedes goldene Feld in der Mitte wird als Gewinn (drei Mark) gewertet. Die Anzahl der Sonderspiele wird durch Drücken einer Taste bei laufender Auswahl bestimmt. Alles wird optisch dargestellt. Bei leuchtendem Starter kann die Auswahl während einer bestimmten Zeit nachgestartet werden. Der Starter erlischt dann. Wenn dreimal der gleiche Geldbetrag in den Fenstern erscheint, dann ist der Gewinn gleich dem angegebenen Wert. Die Krone im mittleren Fenster gilt als Joker für jeden Betrag. Eine Krone allein gewinnt 30 Pfennig. Jeder Gewinn kann durch Drücken der Risikotaste (eine beliebige Taste) verdoppelt oder genullt werden. Dies wird optisch an den äußeren beiden Leitern dargestellt.</p>

<p>Zwei gleiche Wappen erhöhen die dazugehörige Gewinnstufe um eins. Es können bei jeder Risikoleiter höchstfalls zwei Gewinnstufen zustandekommen. Eine Gewinnstufe verdoppelt einen Gewinn auf der Risikoleiter automatisch. Bei drei gleichen Wappen wird der Starter eingeschaltet. Sie können die erste Scheibe nachstarten, wenn das Wort »Start« leuchtet. Bei leuchtendem »Stop« können alle Scheiben gestoppt werden. Kapital und Sonderspiele werden in den oberen Fenstern angezeigt.</p>

<p>(C. Vigelius)</p>

<p>Bestellnummer CB009</p>

<h1 id="space-invaders">Space Invaders</h1>

<blockquote><p>Das Programm ist so konstruiert, daß selbst ein unerfahrener Computerbesitzer Variationen des Spielablaufsdurch einfaches Ändern der Variablen vornehmen kann.</p></blockquote>

<p>Diese Space-Invader-Version ist den gleichnamigen Telespielen nachempfunden, und zeichnet sich durch die Möglichkeit, leicht anpaßbar zu sein, aus.</p>

<p>Außerdem sind natürlich jede Menge Extras, zum Beispiel sichtbeeinflussende Wolken, ein intelligenter Außerirdischer und ein UFO, das Alien aussetzt, vorhanden.</p>

<p>Nach dem Kampf erwartet der Spieler dann eine Highscore-Tabelle. Das Programm läuft auf dem Commodore 64.</p>

<p>Nachdem das Programm mit »RUN« gestartet wurde, springt der Basic-Interpreter nach Zeile 250, wo er die Maschinenprogramme einliest, und den Zeichengenerator in das Basic-RAM verlegt. Hierzu muß gesagt werden, daß man nach dem ersten »RUN« keine Veränderungen am Basic-Programm mehr vornehmen sollte.</p>

<p>Der Interpreter würde die Programmzeilen neu ordnen und dabei den Zeichengenerator durcheinanderbringen. Änderungen am Spielablauf kann man ohne weiteres vornehmen. Zu diesem Zweck unterbricht man das Programm und stellt dann die Variablen entsprechend ein. Das Programm wird dann durch »GOTO 10« fortgesetzt.</p>

<p>Bei Unterbrechung mit der »RUNSTOP/RESTORE«-Taste kann man den Zeichengenerator mit »POKE 53272, 29« wieder einschalten.</p>

<p>Nachdem das Einladen beendet ist, erfolgt ein Rücksprung aus dem Unterprogramm und die Register werden gestellt.</p>

<p>In Zeile 80 erfolgt der Aufruf des Maschinen-Programmes und die Auswertung. Sind alle Alien der ersten Zone vernichtet, so kommt man in die zweite Hälfte des Basic-Programmes, die im Prinzip der ersten Hälfte entspricht.</p>

<p>Das Programm ist auf den Joystick an Port 1 abgestimmt, kann aber auch über »CONTROL«, »2« und »SPACE« gesteuert werden. Dies trifft übrigens für alle Spiele mit Joystick an Port 1 zu.</p>

<p>(Gunther Knöpfle)</p>

<p>Bestellnummer CB010</p>

<h1 id="vollautomatisches-blumengießen">Vollautomatisches Blumengießen</h1>

<blockquote><p>Sie kennen sicher auch das leidige Problem: Der Urlaub steht vor der Tür und keiner der Nachbarn will die Blumen versorgen, da sie just in der gleichen Zeit Urlaubsgefühle verspüren. Der Computer schafft Abhilfe.</p></blockquote>

<p>Die Idee war, mit einer kleinen Tauchpumpe (Campingartikelbedarf) und einem verzweigten Schlauchsystem die Blumen täglich mit dem kostbaren Naß zu versorgen (Bild 1). Diese kleinen Pumpen haben eine Förderleistung von etwa 14 l/min., was für die minimalen Ein- und Ausschaltzeiten mechanischer Schaltuhren von 30 Minuten viel zu viel ist. Elektronische Schaltuhren, die individuelle Schaltzyklen zulassen, waren wiederum viel zu teuer.</p>

<p>Die Idee, meinen 64er zum Blumengießen herzunehmen, reifte. Denn schließlich besitzt er einen User-Port, der für solche Aufgaben wie geschaffen ist.</p>

<h2 id="der-user-port,-eine-verbindung-zur-außenwelt">Der User-Port, eine Verbindung zur Außenwelt</h2>

<p>Der User-Port ist eine Schnittstelle, mit der der Anwender auf einfache Art und Weise Kontakt zwischen dem Commodore und der Außenwelt herstellen kann. Mit ihm ist es unter anderem möglich, Geräte an- und auszuschalten. Da der User-Port eine 8 Bit breite Datenleitung besitzt (PB0-PB7, siehe Bild 2), können ohne weiteres Klimmzüge bis zu 8 Verbraucher geschaltet werden. Dazu ist jedoch etwas zusätzliche Hardware nötig. Um einen Stromverbraucher zu steuern (in unserem Fall eine kleine Pumpe), benötigt man ein Schaltinterface. Denn die Pumpe braucht mehr Strom als der User-Port zur Verfügung stellt. In meinem Fall baute ich mir ein Interface, das direkt an das normale 220-Volt-Netz angeschlossen werden kann. Mit ihm lassen sich grundsätzlich alle Elektrogeräte schalten. Den Aufbau dieses einfachen Schaltinterfaces zeigt Bild 3. Zusätzlich benötigt man noch eine Verbindung vom Interface zum User-Port. Ein geeigneter Stecker zum Anschluß an den User-Port ist der Cardcon-Stecker von TRW (Nr. 251-12-50-170) (Bild 4).</p>

<p>Zur Absicherung des User-Ports wurde zwischen der eigentlichen Schaltung und dem Port ein 6fach-Inverter eingefügt.</p>

<h3 id="das-programm:-eine-uhr">Das Programm: eine Uhr</h3>

<p>Das Gießprogramm besteht im wesentlichen aus der Programmierung der Echtzeituhr im CIA 1. Dieses Programm entstammt dem Data Becker-Buch 64-intern.</p>

<p>In Zeile 100 bis 270 wird die Uhr gestellt, in Zeile 280 bis 480 die laufende Uhr programmiert. In Zeile 440 wird abgefragt, ob der Zeitpunkt zum Gießen erreicht ist. Wenn dies der Fall ist, wird in die Subroutine 1000 verzweigt. In diesem Unterprogramm wird das Datenrichtungsregister auf Ausgang geschaltet und mit POKE 56577,1 die PB0-Leitung auf High gelegt. In Zeile 1030 schließlich wartet das Programm 20 Sekunden und schaltet in Zeile 1050 die Pumpe wieder aus. Die Warteschleife in Zeile 1030 kann dem jeweiligen Anwendungsfall angepaßt werden.</p>

<p>Das Programm läßt sich natürlich für beliebige Schaltzyklen und Schaltzeiten abändern.</p>

<p>(Klaus Michael)</p>

<h1 id="das-erste-»strubs«-listing">Das erste »Strubs«-Listing</h1>

<blockquote><p>Unser Kurs über den Precompiler »Strubs« ist erst in dieser Ausgabe beendet worden. Und doch hat uns schon jetzt das erste mit »Strubs« erstellte Listing erreicht.</p></blockquote>

<p>Ich war so begeistert, daß ich mich gleich hingesetzt und ein Programm geschrieben hatte, um die Fähigkeiten von Strubs zu testen, und ich muß sagen, Strubs ist ein Programm, das hält, was es verspricht.</p>

<p>Das von mir mit Strubs entwickelte Programm »Menü« liegt als Quell- und Objektprogramm vor. Der Benutzer kann damit seine Programme nur mit Hilfe der Funktionstasten und der Returntaste auswählen und starten, so daß die umständliche Ladeprozedur per Hand entfällt.</p>

<p>Will man mit »Menü« arbeiten, trägt man zunächst in Data-Zeilen ab Zeilennummer 10 den Text, der auf dem Bildschirm erscheinen soll (maximal 34 Zeichen ein und dann in der gleichen Zeile — durch Komma getrennt — den genauen Namen des Programms, das geladen werden soll. Die Verwendung desJokers (*) zur Abkürzung ist dabei auch möglich. Anschließend speichert man Menü ab und kann es starten.</p>

<p>»Menü« faßt immer 10 Programme auf einer Bildschirmseite zusammen und blättert — je nachdem man mit dem Pfeil, der auf die Programme zeigt, nach unten oder nach oben aus dem Bildschirm heraus will — weiter oder zurück.</p>

<p>Bei Programmen, die größer sind als »Menü« ist darauf zu achten, daß in der ersten bearbeiteten Programmzeile eine Routine steht, die die Pointer auf das Basic-Ende ausrichtet (siehe dazu Zeile 1 von »Menü«).</p>

<p>Ersetzt man in den Programmen, die durch »Menü« geladen werden sollen noch die END-Anweisung — oder das Programmende, falls keine END vorhanden — durch LOAD”MENUE”,8, so wird nach Beendigung des gewählten Programms automatisch wieder »Menü« geladen.</p>

<p>Vorsicht ist geboten bei Programmen, die den BASIC-Anfang oder das RAM-Ende verschieben, da diese Programme zum Systemabsturz führen, wenn man die entsprechenden Vektoren nicht zurücksetzt.</p>

<p>»Menü« müßte auch auf dem C 64 laufen, ich konnte es aber leider nicht testen.</p>

<p>(Gerd Sombetzki)</p>

<aside>
Folgende Änderungen nahm ich für meinen VC 20 mit 40/80 Zeichenkarte, 32 K-RAM, Floppy 1541 und VC 1526 vor. Zunächst verlegte ich die Maschinenroutine in den Kassettenpuffer. Zeile: 45610 POKE 828 + i, w: ...usw.  
Der Sprung zur Interpreterroutine $A7E7 = #167 liegt beim VC 20 bei $C7E7 = #199. Außerdem fehlte das im Assemblerlisting vorhandene PLP = $28 = #40.  
D.h.:Zeile 45620 DATA32, 115,0,8,201,33,240,4,40,76,231, <u>199,40</u>  
45630 DATA169,<u>18</u>,133,44,169,138,76,231,<u>199</u>,999  
Verschieben der Initialisierungsroutine:  
45650 FORI = 0TO10:READW:POKE<u>850</u> + I,W  
45670 SYS<u>850</u>  
45680 DATA169,<u>60</u>,141,8,3,169,3,141,9,3,96

Die Änderung des Wertes 8 in 18 in der Zeile 45630 ist notwendig, da der Basic-Anfang beim VC-20 mit Erweiterung ) = 8K bei $1200 beginnt, also Highbyte $12 = #18.  
</aside>


<h1 id="hardcopy-mit-dem-vc-1520">Hardcopy mit dem VC 1520</h1>

<blockquote><p>Wer sich den Commodore VC 1520 kauft, ist sich meist auch dem Nachteil dieses VC 1520-Druckers/Plotters bewußt. Einer dieser Nachteile ist die fehlende Möglichkeit, Hardcopys mit den gängigen Basic-Erweiterungen (Simons Basic, Extended Basic und so weiter) erstellen zu können.</p></blockquote>

<p>Das abgebildete Programm bietet nun die Möglichkeit, jedes Bild in High Resolution Byte für Byte auszudrucken, wenn es sich im Bereich $2000 = Dez.8192 bis $3FFF = Dez.16383 befindet. Steht das Bild in einem anderen Bereich, ist lediglich die Variable C in Zeile 257 in die gewünschte Anfangsadresse zu ändern.</p>

<p>Um ein High Resolution-Bild auszudrucken, ist zunächst die Zeile:<br/>
POKE44,64:POKE64 + 256,0: NEW einzugeben. Anschließend wird das auszudruckende Bild absolut (LOAD”Bild”,8,l) geladen. Jetzt erst wird nach vorherigem NEW das Hardcopy-Programm geladen und mit RUN gestartet.<br/>
Der Ausdruck dauert dann, je nach Bild, immer noch eine ganze Weile. Dies ließ sich, ausgehend von der Hardware, leider nicht ändern.</p>

<p>(J. Wichmann)</p>

<h1 id="komfortables-treiberprogramm-für-centronics-drucker">Komfortables Treiberprogramm für Centronics-Drucker</h1>

<blockquote><p>Viele Anwender des Commodore 64 möchten anstelle eines Commodore-Druckers lieber den Drucker eines anderen Herstellers erwerben. Um diesen an ihren Computer anzuschließen, müssen sie entweder ein Hardwareinterface oder eine Softwarelösung kaufen. Dieser Artikel stellt die Softwarelösung für den Anschluß von Druckern am Userport des C 64 vor.</p></blockquote>

<p>Es handelt sich hierbei um ein Maschinenspracheprogramm mit 726 Byte Länge, das den Adreßbereich CB57-CBD1 (dezimal: 51456 bis 52182) belegt. Damit kann zum Beispiel das DOS 5.1 auf der Demodiskette ohne Probleme zusätzlich geladen werden.</p>

<p>Das Programm ist ohne Einschränkung für alle Centronics-kompatiblen Drucker anwendbar, die über einen Bitmustermodus verfügen. Dieser Modus wird für die Ausgabe der Commodore-eigenen Grafikzeichen benötigt. Das Programm besteht aus mehreren Programmteilen, von denen die meisten Erweiterungen bestehender Ein-/Ausgaberoutinen des Betriebssystems sind und bei der Initialisierung in diese eingebunden werden. Dadurch können schon bestehende Basicbefehle wie OPEN und PRINT# zum Drucken benutzt, und Programme müssen nicht umgeschrieben werden. Zur Ansteuerung verschiedener Druckmodi wurden jedoch zusätzliche Gerätenummern definiert, deren Bedeutungen in Bild 1 erklärt sind. Gerätenummer 16 realisiert einen sogenannten Direktmodus, mit dem die internen Commodorezeichencodes ohne Wandlung an den Drucker gelangen. Der Direktmodus ist zur Ausgabe von Steuerzeichen oder bei der Verwendung des Druckers als Plotter zur Einzelnadelsteuerung beziehungsweise zur Ausgabe von Bitmustern geeignet. Der Textmodus (Groß- und Kleinschreibung) ist unter Gerätenummer 18 und, weil er wohl am häufigsten bei bereits bestehenden Programmen benutzt ist, unter Gerätenummer 4 ansprechbar. Die Gerätenummer 19 realisiert den Großschrift/Grafik-Modus, wie er beim C 64 gleich nach dem Einschalten voreingestellt ist. Der wichtige Modus zum Listen von Programmen wurde mit Gerätenummer 17 realisiert. Es läßt sich über die Sekundäradresse, wie in dem Musterlisting (Bild 4) gezeigt, noch zwischen vier Fällen unterscheiden. Einmal kann ausgewählt werden, ob das Listing, wie vom Bildschirm her gewohnt, mit Großbuchstaben und Grafikzeichen oder im Textmodus mit großen und kleinen Buchstaben gedruckt wird. Zum anderen kann man auswählen, ob die Steuerzeichen wie bei der Bildschirmausgabe als inverse Zeichen oder durch Abkürzungen wie (CRD) (Cursor down) im Klartext gedruckt werden. Durch all diese Möglichkeiten kann der Anwender zum einen auf seinem Drucker Ausgaben erzeugen, wie man sie von Commodore-Druckern her gewohnt ist, zum anderen auch alle Möglichkeiten seines Druckers voll nutzen.</p>

<h2 id="commodore-eigene-grafikzeichen">Commodore-eigene Grafikzeichen</h2>

<p>Die Ausgabe von Grafikzeichen erfolgt in der Routine OUTGEN ab Adresse $CAC4. Zu diesem Zweck wird der Zeichengenerator des C 64 ausgelesen. Die Zeichen, die aus einer 8 x 8 Punktmatrix bestehen, sind dort in je 8 Byte abgelegt. Jedes Byte repräsentiert das Punktmuster einer Zeile der Matrix. Ein Matrixdrucker druckt die Zeichen, indem er sie ebenso als Muster von matrixartig angeordneten Punkten zu Papier bringt. Jedoch gibt er die Punktmatrix nicht wie der Bildschirm zeilenweise sondern spaltenweise aus. Deshalb wird in OUTGEN die im Zeichengenerator in 8 Zeilenbyte gespeicherte Zeichenmatrix zunächst in 8 Spaltenbyte umorganisiert. Nach Umschalten des Druckers in den sogenannten Bitmustermodus, in dem er jedes ankommende Datenbyte nicht mehr als ASCII-Zeichen sondern als Musterbyte für eine Matrixspalte interpretiert, gibt OUTGEN die acht geänderten Zeichenbyte an den Drucker aus. Dieser fügt sie wieder zu einem 8 x 8 Punktmatrixzeichen zusammen. So ist es möglich, auf einem Matrixdrucker exakte Kopien der C 64-Bildschirmzeichen herzustellen, obwohl dieser nicht über den entsprechenden Zeichensatz verfügt.</p>

<h2 id="handhabung-des-programms">Handhabung des Programms</h2>

<p>Die etwas Konzentration fordernde Methode der Programmeingabe besteht im Eintippen des abgebildeten Basicprogramms (Bild 2), in dem das Treiberprogramm in DATA-Zeilen steht. Ein eingebauter Quersummentest deckt hoffentlich Eingabefehler auf.</p>

<p>Zur Herstellung des Verbindungskabels zwischen Userport und Drucker ist in Bild 3 eine Verbindungstabelle angegeben. Das Kabel sollte für eine störungsfreie Funktion nicht länger als ein Meter lang sein und aus einem abgeschirmten, mehradrigen Steuerkabel bestehen, das man in (fast) jedem Elektronik-Bastelgeschäft findet. Dort sind auch meist der Centronicsstecker und der Stecker für den Userport erhältlich.</p>

<p>Initialisiert wird die geladene Treiberroutine mit<br/>
SYS 12<em>4096 + 9</em>256 beziehungsweise SYS 51456</p>

<p>Hierbei wird die Routine in das Betriebssystem eingebunden. Jedoch Vorsicht: Nach einem Break, zum Beispiel durch die Betätigung der Tasten RUN/STOP und RESTORE ausgelöst, muß die Routine erneut initialisiert werden, da die I/O-Vektoren vom Betriebssystem zurückgesetzt wurden. Die einzelnen Druckmodi spricht man mit den üblichen Basicbefehlen an. Geöffnet wird der Ausgabekanal mit:<br/>
OPEN log. Dateinummer, Geräteadr. [,Sekundäradr.]<br/>
Die eckigen Klammern kennzeichnen optionale Angaben. So dann kann auf den geöffneten Kanal mit PRINT # log. Dateinummer ausgegeben werden. Ein Programmlisting wird zum Beispiel erzeugt mit (Bild 4) den Befehlen<br/>
OPEN 17,17 [Sekundäradr.]:CMD17: LIST<br/>
PRINT#17 : CLOSE 17</p>

<p>Der PRINT-Befehl vor dem CLOSE ist notwendig, damit der CMD-Modus aufgehoben wird.</p>

<h2 id="umstellen-auf-beliebige-drucker-mit-centronics-schnittstelle">Umstellen auf beliebige Drucker mit Centronics-Schnittstelle</h2>

<p>Das Programm wurde für einen Epson-Drucker geschrieben. Unverändert ist es für jeden anderen Drucker verwendbar, sofern auf die Ausgabe von commodoreeigenen Grafikzeichen verzichtet wird. Für diese Funktion muß der Drucker jedoch vorübergehend in den Bitmustermodus umgeschaltet werden, was während einer normalen Textausgabe möglich sein muß. Diese Umschaltung erfolgt im Programm in der Schleife ab Adresse $CB10. Die Anzahl der auszugebenden Steuerzeichen ist unter Adresse $CB18 gespeichert und die Steuerzeichen selbst stehen ab Adresse $CBD2 am Ende des Programms. Für einen Epson-Drucker wird die Folge:<br/>
ESC »*« 4 8 0<br/>
ausgegeben, wobei mit vier der Bitmustermodus »CRT-Grafik« ausgewählt wird, 8 das niederwertige Byte und 0 das höherwertige Byte der Anzahl auszugebender Punktmatrixspalten darstellt. Der Epson-Drucker kehrt nach der Ausgabe der spezifizierten Anzahl Musterbytes wieder in den Textmodus zurück.</p>

<p>(H.Eyssele)</p>

<h1 id="kurvendiskussion-hires-grafik-mit-hardcopy-funktion">Kurvendiskussion Hires-Grafik mit Hardcopy-Funktion</h1>

<blockquote><p>Mit dem Programm »Kurvendiskussion« besitzen Sie die Möglichkeit, eine komplette Funktionsanalyse durchzuführen. Sie können die Funktion auf dem Bildschirm und auf dem Drucker 1526 (neues ROM) plotten lassen. Zusätzlich wird die X- und Y-Achse, mit Einheitsstrichen versehen, geplottet.</p></blockquote>

<p>Zusätzlich können Sie folgende wichtige grafische Daten abrufen: Nullstellen, relative Minima und Maxima, das absolute Minimum und Maximum, die Fläche unter dem Graphen, das Volumen des Rotationskörpers und Sie können einzelne Funktionswerte abfragen. Diese grafischen Daten werden auf einige Stellen hinter dem Komma genau berechnet. In seltenen Fällen können diese auch falsch berechnet werden. Dies ist teilweise auf Fehler im Betriebssystem und auf Fehler bei der Approximation (Näherung) zurückzuführen.</p>

<h3 id="eingabe-der-funktionsdaten">Eingabe der Funktionsdaten</h3>

<p>a) Eingabe der Funktion Dies geschieht in der normalen Commodore-Schreibweise, wie sie in dem Handbuch auf den Seiten 23 bis 29 beschrieben ist. Beispiel: normale Darstellung:<br/>
F(X) = COSX + COS2X + COS5X<br/>
Eingabe in den Computer:<br/>
COS(X) + COS(2<em>X) + COS (5</em>X)</p>

<p>Mit dieser Schreibweise können Sie jede Funktion eingeben, die im Commodore-Basic implementiert ist: (ABS(X), ATN(X), COS(X), EXP(X), INT(X), LOG(X), SIN(X), SQR(X) und TAN(X)). b) Eingabe des Intervalls, in der die Funktion geplottet werden soll.</p>

<p>Zuerst wird die linke Grenze des Intervalls eingegeben, danach die rechte durch ein Komma getrennt. Die grafischen Daten werden später nur für dieses von Ihnen angegebene Intervall berechnet. Beispiel: normale Darstellung:<br/>
[-10,10]<br/>
Eingabe in den Computer:<br/>
-10,10</p>

<p>Natürlich dürfen die Funktionen nur in definierten Intervallen eingegeben werden. Die Wurzelfunktion ist zum Beispiel nur im positiven Bereich definiert. Sie darf also nicht im Intervall von —5 bis 7 eingegeben werden.</p>

<p>c) Eingabe der Einheiten</p>

<p>Hier wird eine positive Zahl sowohl bei der X-Achse als auch bei der Y-Achse angegeben. Es können nur bis zu 30 Einheitenstriche auf der X-Achse und Y-Achse geplottet werden. Falls Sie keine Einheitenstriche benötigen, drücken Sie einfach »RETURN«.</p>

<p>d) Ausdruck auf dem 1526-Drucker (mit neuen ROMs)</p>

<p>Sie haben die Möglichkeit, die Funktion in verschiedenen Maßstäben zu drucken<br/>
(1:1, 1:2, 1:4). Je nach Eingabe der Vergrößerung wird die Kurve entsprechend groß geplottet. Anschließend werden noch wichtige Angaben zur Funktion gedruckt. Falls Sie später noch grafische Datenabrufen werden, -werden diese automatisch auch noch gedruckt, Wenn Sie keinen Ausdruck auf. dem Drucker benötigen oder wenn Sie keinen 1526-Drucker besitzen, drücken Sie einfach »RETURN«.</p>

<p>e) Höchster Y-Wert</p>

<p>Das Programm ist so konzipiert, daß die Funktion immer den gesamten Grafikbildschirm voll ausnutzt. Wenn jetzt in dem angegebenen Intervall eine Unendlichkeitsstelle auftritt, wird die Funktion im Bereich der X-Achse sehr gestaucht. Dies soll durch die Angabe des höchsten Y-Werts verhindert werden. Wenn Sie zum Beispiel die Funktion l/X im Intervall —5,5 plotten lassen und Sie geben als höchsten Y-Wert 10 an, dann werden alle Werte, die größer als 10 sind, weggelassen. Jetzt liegt der Wert F(X) = 10 am oberen Ende des Grafikbildschirms und F(X) = —10 am unteren Ende. Dadurch wird die Funktion im Bereich der X-Achse nicht gestaucht. Falls der angegebene Y-Wert größer als der höchste Funktionswert ist, hat dieser keinen Einfluß auf den Ausdruck. Wenn Sie nur »RETURN« drücken, beträgt der höchste Y-Wert automatisch 1000.</p>

<h3 id="abruf-der-grafischen-daten">Abruf der grafischen Daten</h3>

<p>Nachdem die Funktion korrekt eingegeben wurde, braucht der Computer zirka 2 bis 3 Minuten, bis er mit dem Plotten fertig ist. Danach drücken Sie bitte eine beliebige Taste. Es erscheinen einige wichtige Informationen und ein Menü. Auf Druck der entsprechenden Zahl wird das Erwünschte ausgeführt. Wir wollen uns jetzt nur der zweiten Möglichkeit zuwenden, da sich die anderen wohl selbst erklären. Auf Druck der Taste. 2 erscheint ein weiteres Menü. Jetzt können Sie alle grafischen Daten errechnen lassen. Diese werden, wie unter Punkt 2.b erwähnt, nur in dem angegebenen Intervall, mit Ausnahme der speziellen Funktionswerte, errechnet. Folgende Sonderfälle sind zu beschten.</p>

<ol>
<li>Absolute Extremwerte</li>
</ol>


<p>Diese können nur korrekt berechnet werden, wenn der höchste YWert größer ist als der größte Funktionswert.</p>

<ol>
<li>Fläche unter dem Graphen</li>
</ol>


<p>Der Computer gibt nicht wie bei der Integralrechnung die Differenz der Fläche zwischen dem Graphen und der X-Achse an, sondern den tatsächlichen absoluten Wert der Fläche.</p>

<ol>
<li>Spezielle Funktionswerte</li>
</ol>


<p>Falls Sie beim Abfragen eines Funktionswertes genau eine Unendlichkeitsstelle oder eine nicht definierte Stelle erwischt haben sollten, gibt der Computer eine Null als Funktionswert an.</p>

<p>(Jan Schaefer)</p>

<h1 id="rätsel---ein-knobelprogramm">Rätsel - ein Knobelprogramm</h1>

<blockquote><p>Sicher kennen Sie die Rätsel, bei denen man aus einem Buchstabensalat bestimmte Wörter heraussuchen muß. Dies ist nicht immer einfach, zumal die Wörter auch rückwärts oder diagonal angeordnet sein können. Solche Rätsel können Sie nun mit dem VC 20 selbst erstellen.</p></blockquote>

<p>Das Programm Rätsel bringt 440 Buchstaben bunt durcheinander auf den Bildschirm. In diesem Buchstabensalat sind Wörter versteckt, deren Anzahl zuvor bestimmt werden kann (Zeile 35).</p>

<p>Die Suche ist nicht einfach, weil die Wörter zufällig verteilt (Zeile 130) kreuz und quer, diagonal und zum Teil auch rückwärts geschrieben werden (Zeilen 100 bis 120 drehen dafür etwa jedes vierte Wort herum).</p>

<p>Richtig gefundene Wörter werden im Buchstabensalat schwarz gedruckt. Wer vor der Aufgabe kapituliert, kann sich mit der Taste x die Lösung zeigen lassen.</p>

<p>Das Programm schreibt die zu versteckenden Wörter zuerst in das Feld F$ (22,20). Zugleich wird im Feld FF$ (22,20) registriert, welche Zeichen belegt sind.</p>

<p>Der Programmlauf wird im übrigen aus den eingefügten REM-Zeilen verständlich.</p>

<p>(Jürgen Curdt)</p>

<h1 id="croussaider-– ein-action-spiel-für-den-vc20">Croussaider – Ein Action-Spiel für den VC20</h1>

<blockquote><p>Dieses Spiel zeigt die Möglichkeiten, die bereits in der Grundversion des VC 20 stecken. Obwohl von den Farbgrafik- und Soundmöglichkeiten ausgiebig Gebrauch gemacht wird, benötigt das Programm nur knapp 3 KByte RAM.</p></blockquote>

<p>Feindliche Weltraumschiffe greifen die Erde an! Sie haben in diesem Spiel die Aufgabe, die Invasion abzuwehren. Dazu besitzen Sie ein Raumschiff, den »Croussaider«, das über der Erde schwebt. Unter ihm liegt eine moderne Stadt mit Hochhäusern, Fabriken und einem Atomkraftwerk. Am oberen Rand des Bildschirms erscheinen die Angreifer, deren Ziel es ist, in der Stadt zu landen und sie zu zerstören.</p>

<p>Sie bewegen sich rasch auf die Stadt zu, so daß schnelle Reaktionen erforderlich sind, um eine Landung zu verhindern.</p>

<p>Hat man es geschafft, den Angreifern eine bestimmte Zeit zu widerstehen, erscheint eine neue, gefährlichere Welle von Invasoren mit anderem Aussehen.</p>

<p>Wenn man fünf verschiedene Angriffswellen übersteht, erscheint wieder die erste, mit dem Unterschied, daß die Angreiferzahl steigt. So ist immer für Abwechslung und Spannung gesorgt.</p>

<p>Der fortgeschrittene Spieler, dem das Spiel zu einfach ist, kann den Wert der Variablen Y in Zeile 10 vermindern.</p>

<p>Um das Spiel zu beschleunigen, wurden einige Routinen in Maschinensprache geschrieben. Die erreichte Punktzahl wird ständig angezeigt, und eine »High-Score»-Funktion hält das jeweils beste Ergebnis fest.</p>

<p>Doch damit genug der Vorrede. Tippen Sie doch jetzt einfach das Listing ab und versuchen Sie, die Invasion zu verhindern&hellip;</p>

<p>(Eberhard Aust)</p>

<h1 id="mehr-über-sys">Mehr über SYS</h1>

<blockquote><p>Der SYS-Befehl beim C 64 und VC 20 leistet wesentlich mehr, als das Commodore-Handbuch zugeben will. Er bietet zum Beispiel eine einfache Möglichkeit, Parameter an Maschinenprogramme zu übergeben.</p></blockquote>

<p>Der SYS-Befehl hat folgendes Format:<br/>
SYS &lt;Adreßausdruck&gt; [, &lt; Parameterausdrücke &gt; ]</p>

<p>SYS ruft das Maschinensprachprogramm auf, das bei »Adreßausdruck« logisch beginnt. »Adreßausdruck« steht für eine RAM-Adresse im Bereich von 0 bis 65535.</p>

<p>Die wahlweise anzugebenden Übergabeparameter werden nicht von SYS bearbeitet, vielmehr müssen diese Angaben in geeigneter Weise vom aufgerufenen Maschinenprogramm ausgewertet werden. Hierzu sind natürlich genauere Kenntnisse in Assembler-Programmierung erforderlich.</p>

<p>Es kann jedoch eine andere Übergabeform gewählt werden, auch wenn dies im VC 20-Programmierhandbuch verschwiegen und im Handbuch das Gegenteil behauptet wird.</p>

<p>Diese Form der Parameter-Übergabe besteht darin, Akkumulator, X- und Y-Register sowie den Prozessorstatus vorzugeben.</p>

<p>Wie soll das vom Basic aus geschehen? Wenn nicht direkt, dann eben über die Speicherstellen, die SYS als oben genannte Register aufnimmt, bevor ins Maschinenprogramm verzweigt wird, und in die SYS nach Rückkehr (RTS) aus dem Maschinenprogramm die aktuellen Registerinhalte ablegt.</p>

<p>Es gibt also eine Kommunikationsmöglichkeit mit dem Maschinenprogramm vor und nach der Abarbeitung, sie muß nur genutzt werden.</p>

<p>Die vier Speicherbytes nach Bild 1 sind die Schnittstellen zu den Prozessor-Registern.</p>

<p>Der Prozessor-Status wird dabei durch das Flag-Register dargestellt. Die Bedeutung der einzelnen Bits im Flag-Register geht aus Bild 2 hervor.</p>

<p>Hier nun eine Anwendung der Kommunikation mit Maschinen-Unterprogrammen.</p>

<p>Die Betriebssystem-Routine »Plot« soll genutzt werden, um den Cursor auf eine bestimmte Position zu setzen, ab der dann eine Ein-/Ausgabe erfolgen kann, beziehungsweise es soll abgefragt werden, wo sich der Cursor gerade befindet, wo also die nächste Ein-/Ausgabe erfolgen würde.</p>

<p>Bild 3 zeigt das kleine Beispiel-Listing. In den Zeilen 100 bis 150 wird der Cursor auf Zeile 10, Spalte 5 gesetzt. Anschließend wird zur Demonstration ein kleiner Text ausgedruckt und in den Zeilen 200 bis 260 die aktuelle Cursorposition gelesen.</p>

<p>(Rolf Zweifel)</p>

<h1 id="kopierprogramm-für-relative-files">Kopierprogramm für relative Files</h1>

<blockquote><p>Nicht jedes Kopierprogramm ist in der Lage, relative Dateien zu kopieren. Diese Arbeit übernimmt das folgende Programm. Aus Geschwindigkeitsgründen wurde es vollständig in Maschinensprache geschrieben.</p></blockquote>

<p>Nach dem Starten des Programms erfolgen zunächst einige Abfragen:</p>

<ol>
<li><p>Sind alle Erweiterungen ausgeschaltet? Damit ist zum Beispiel DOS 5,1 oder Simons Basic gemeint. Wird die Frage mit ja beantwortet, so steht der gesamte freie RAM (zirka 60 KByte) als Puffer zum Kopieren zur Verfügung. Andernfalls wird die Pufferobergrenze auf $ 8000 (32768) gesetzt, so daß zirka 28 KByte zur Verfügung stehen. In beiden Fällen können jedoch beliebig große Files kopiert werden.</p></li>
<li><p>Angabe der Gerätenummer und der Drivenummer von Ausgangslaufwerk und Ziellaufwerk. Zulässig sind die Gerätenummern 8 und 9 sowie die Drivenummern 0 und 1, bei anderen Nummern erscheint eine Fehlermeldung. Es wird die Gerätenummer 8 und die Drivenummer 0 auf dem Bildschirm vorgegeben, so daß bei Verwendung eines VC-1541-Laufwerks nur vier mal RETURN gedrückt werden muß.</p></li>
<li><p>Angabe des Filenamen der zu kopierenden relativen Datei. Beim Filenamen für das neue File wird der alte Filenamen vorgegeben, er kann natürlich mit den üblichen Tasten geändert werden.</p></li>
<li><p>Eingabe der maximalen Satzlänge des neuen Files. (Zulässig ist 1 bis 254). Sie muß nicht notwendigerweise mit der Satzlänge des alten Files übereinstimmen, sollte aber so lang sein wie der längste Satz im alten File. Andernfalls kommt es zu Datenverlust. Aus Geschwindigkeitsgründen wird übrigens der Fehlerkanal während des Kopierens nicht abgefragt, so daß der Fehler »overflow in record« nicht erkannt wird!</p></li>
</ol>


<p>Nachdem alle Eingaben erledigt sind, beginnt das Kopieren. Das Programm gibt jeweils auf dem Bild-&lsquo; schirm an, welche Diskette einzulegen ist, bei Diskettenwechsel und am Programmende wird zusätzlich ein Tonsignal erzeugt. Ist der Diskettenwechsel durchgeführt, so muß die SHIFT-Taste gedrückt werden, damit es weitergeht. Beim Arbeiten mit zwei Laufwerken oder einem Doppellaufwerk sowie beim Kopieren auf die gleiche Diskette kann die SHIFT-LOCK-Taste eingerastet werden, sobald alle benötigten Disketten im richtigen Laufwerk liegen. Es wird dann ohne Pause kopiert.</p>

<p>Ist das Kopieren beendet, startet das Programm von vorn. Es kann abgebrochen werden, indem als Gerätenummer »q« eingegeben wird. Der Rechner meldet sich dann wieder mit »READY« im Basic-Modus. Übrigens ist während des gesamten Kopierens (ab Eingabe der ersten Gerätenummer) die Stoptaste funktionsfähig. Wird sie gedrückt, so werden die offenen Files geschlossen und das Programm startet von vorn. Da während des Kopierens der augenblicklich kopierte Satz auf dem Bildschirm angezeigt wird, ist es damit auch möglich, ein File nur teilweise zu kopieren. Es ist normal, daß beim Schreiben die erste Satznummer erst nach längerer Zeit erscheint, da die Floppy das File zuerst einmal einrichten muß.</p>

<p>Folgende Fehlermeldungen werden vom Programm ausgegeben: ?? falsches Laufwerk oder Drive ??: Gerätenummer ungleich 8 oder 9 beziehungsweise Drivenummer ungleich 0 oder 1 ?? Unzulässige Satzlänge ??: Satzlänge größer 254 oder kleiner 1<br/>
?? Gerät nicht bereit ??: Das angesprochene Laufwerk ist nicht eingeschaltet oder angeschlossen.<br/>
Abbruch !: Die Stoptaste wurde gedrückt.<br/>
Zusätzlich werden Fehlermeldungen der Floppy ausgegeben, falls sie auftreten (Außer RECORD NOT PRESENT). FILE TOO LARGE bedeutet, daß kein Platz mehr auf der Diskette ist.</p>

<h3 id="arbeitsweise-des-programms:">Arbeitsweise des Programms:</h3>

<p>Die Abfrage der Stoptaste geschieht mit Hilfe der Interruptroutine des Rechners, die 60 mal pro Sekunde durchlaufen wird und automatisch die Tastatur abfragt. In diese Interruptroutine wird eine zusätzliche Routine eingebunden, welche die Stoptaste abfragt. Ist die Stoptaste gedrückt, so wird zuerst ein eventuelles Tonsignal ausgeschaltet und alle Files werden geschlossen. Außerdem wird der Stackpointer zurückgesetzt, da der Abbruch ja in jeder Unterprogrammebene erfolgen kann. Danach erfolgt ein Neustart. Als Zwischenspeicher für die Filenamen wird der Kassettenpuffer, als Arbeitsbereich der Speicher für Sprite 11 (ab Adresse 704) verwendet. Die Sätze des Files werden in kompakter, sequentieller Form im RAM des Rechners untergebracht. Es wird zunächst die aktuelle Satzlänge +1 gespeichert und danach die Bytes des Satzes. Dadurch nehmen kurze Sätze auch nur wenig Platz im RAM ein während sie auf der Diskette den gesamten Platz entsprechend der maximalen Satzlänge des Files belegen).</p>

<h3 id="eingabe-des-programms:">Eingabe des Programms:</h3>

<p>Der Basic-Lader bildet nach jeweils fünf DATA-Zeilen eine Prüfsumme, so daß nahezu alle Eingabefehler erkannt werden. Nicht erkannt werden vergessene Nullen und überschüssige Kommata. Wenn alle Prüfsummen korrekt sind, fordert der Lader zum Einlegen einer Diskette auf. Das Programmfile »rel kopierer« wird dann direkt auf Diskette erzeugt. Das erzeugte Programm kann dann wie ein Basicprogramm geladen, kopiert und mit RUN gestartet werden.</p>

<p>(Bernward Bretthauer)</p>

<h1 id="tips-&amp;-tricks">Tips &amp; Tricks</h1>

<h2 id="listschutz">Listschutz</h2>

<p>Einen verblüffenden Listschutz für einzelne Zeilen erhält man, indem man an die eigentliche Programmzeile einen REM-Befehl anhängt und dahinter in Anführungszeichen eine Reihe reverser »T« gefolgt von einem Doppelpunkt und einem beliebigen Text schreibt.</p>

<p>Geben Sie doch einmal folgendes ein:<br/>
10 PRINT”BAUM”:REM”{19 reverse T}&ldquo;:10 PRINT ”BLUME”</p>

<p>Wenn Sie dieses kleine Programm starten, schreibt der Computer »Baum«, listen Sie aber das Programm, so sehen Sie nur die Zeile 10 PRINT”BLUME”.</p>

<p>(Roger Limberg)</p>

<h2 id="input-ohne-fragezeichen">INPUT ohne Fragezeichen</h2>

<p>Die Ausgabe eines Fragezeichens beim INPUT-Befehl kann durch Öffnen einer Tastaturdatei unterdrückt werden:<br/>
10 OPEN 1,0 : REM Tastaturdatei eröffnen<br/>
20 INPUT#1,a$ : REM Einlesen von Tastatur ohne Fragezeichen<br/>
30 REM Nicht vergessen, die Datei mit CLOSE 1 wieder zu schließen</p>

<h2 id="pokes-für-den-64er-und-den-vc-20">POKEs für den 64er und den VC 20</h2>

<p>TODO</p>

<h2 id="zwei-einzeiler">Zwei Einzeiler</h2>

<p>Zahlenkonvertierungen von Dezimal nach Hexadezimal braucht man recht häufig. Hier sind zwei Einzeiler zu diesem Thema:</p>

<ul>
<li>Hex X$ nach dezimal X:<br>10 x = 0:fori=1tolen(x$): x0 = asc(mid$(x$,i,1)):x=16<em>x + x0-48+(x0>64)</em>7: next</li>
<li>Dezimal X nach hex X$:<br>10 x$=””:fori=1to4:x0=x/16: x = x-int(xO)<em>16:x$ = chr$ (48 + x-(x > 9)</em>7 + x$:x = x0:next</li>
</ul>


<h2 id="tastatur-statt-joystick">Tastatur statt Joystick</h2>

<p>Beim Commodore 64 lassen sich alle Joystick-Funktionen auch über die Tastatur steuern. Hier eine Liste der entsprechenden Tasten:</p>

<h3 id="joystick-port-1">Joystick Port 1</h3>

<p>Feuer = SPACE<br/>
Links = CTRL<br/>
Rechts = »2«<br/>
Oben = »1«<br/>
Unten = »&lt;«</p>

<h3 id="joystick-port-2">Joystick Port 2</h3>

<p>Feuer   =   CTRL    +   »J«<br/>
Links   =   CTRL    +   »D«<br/>
Rechts  =   CTRL    +   »G«<br/>
Oben    =   CTRL    +   CRSR RIGHT<br/>
Unten = CTRL + »A«</p>

<p>(Gunther Knöpfle)</p>

<h2 id="zeitlupe-für-den-vc-20">Zeitlupe für den VC 20</h2>

<p>Läßt man ein Programm auf dem Bildschirm auflisten, so läuft es in Sekundenschnelle durch. Mit dem Befehl POKE 37877,0 werden nun alle Funktionen des VC 20 extrem verlangsamt, und man kann sich so ein Programm in Ruhe ansehen. Durch Drücken einer beliebigen Taste wird das Listen noch weiter verlangsamt und mit der RUN/STOP-Taste so lange angehalten, wie man die Taste gedrückt hält.</p>

<p>Man kann den Befehl auch innerhalb eines Programms anwenden um, zum Beispiel während der Testphase, bestimmte Abschnitte sehr langsam und somit nachvollziehbar ablaufen zu lassen.<br/>
Mit POKE 37877,72 oder einfach durch gleichzeitiges Drücken von RUN/STOP und RESTORE wird wieder der Normalzustand hergestellt.</p>

<p>(Johannes Conrad)</p>

<h2 id="vom-bildschirm-auf-kassette/diskette">Vom Bildschirm auf Kassette/Diskette</h2>

<p>Das kurze Maschinenprogramm dient dazu, den Bildschirminhalt beim Commodore 64 abzuspeichern und auch wieder einzuladen. Dies kann mit einem Recorder oder Diskettenlaufwerk geschehen. Dabei werden außer dem eigentlichen Bildschirmspeicher (der an eine beliebige Stelle verschoben sein kann und nicht ab Adresse 1024 liegen muß) auch das Color-RAM und die Tabelle der Doppelzeilenkennzeichnungen mitberücksichtigt. Das Abspeichern und Einladen erfolgt über einen Pufferbereich im »versteckten« RAM ab 40960, da die drei verschiedenen Speicherbereiche in einem Stück abgespeichert und außerdem die 1000 Farbnibbles zu 500 Bytes zusammengeschoben werden. Das erspart beim Arbeiten mit dem Recorder wertvolle Zeit.</p>

<p>Nach dem Eintippen des Basic-Loaders kann durch »RUN 16« geprüft werden, ob es richtig eingegeben wurde. Trotzdem sollte es vor dem Start abgespeichert werden, da auch durch Prüfsummen nicht alle Fehler erkannt werden können. Ausgegeben werden zwei Adressen für das Laden und Speichern. Das Programm kann an jede Stelle des Arbeitsspeichers geladen werden, in der vorliegenden Version lädt es sich an das Ende des Basic-Arbeitsspeichers. Es ist davon auszugehen, daß das Programm direkt nach dem Einschalten ohne andere Erweiterungen eingeladen und gestartet wird.</p>

<p>Soll ein Bildschirminhalt auf Diskette abgespeichert werden, so erfolgt dies durch<br/>
SYS 40738 »FILENAME«, 8</p>

<p>Beim Arbeiten mit Recorder kann (auch beim Einladen) die Gerätenummer entfallen; die Angabe einer Sekundäradresse ist nicht erlaubt. Durch das Abspeichern bedingte Betriebssystemmeldungen wie »PRESS RECORD &amp; PLAY« sowie das Scrolling des Bildschirms sind unbedeutend und werden nicht berücksichtigt. Alle Bildschirmdaten werden zuvor in einen Zwischenspeicher übertragen.</p>

<p>Das Einladen solcherart abgespeicherter Bildschirminhalte geschieht mit<br/>
SYS 40833 »FILENAME«, 8</p>

<p>Zunächst werden die Daten in den Puffer von Adresse 40960 bis 42483 geladen und dann in MSB-Tabelle, Farbspeicher und die momentan gewählte Videomatrix übertragen.</p>

<p>(Ralph Babel)</p>

<h1 id="synthetische-steuerzeichen-(teil-2)">Synthetische Steuerzeichen (Teil 2)</h1>

<blockquote><p>Benutzen Sie die synthetischen Steuerzeichen, um Ihre Druckerlistings übersichtlicher zu machen. Es gibt interessante Möglichkeiten.</p></blockquote>

<p>Nachdem ich in der Ausgabe 5/84 des 64’er-Magazins die Erzeugung synthetischer Steuerzeichen und ihre Wirkung bei Bildschirmbetrieb dargestellt habe, soll jetzt von neuen Möglichkeiten für Druckeranwender die Rede sein. Dabei beziehe ich mich auf den Drucker VC 1515, mit dem die Steuerzeichen ausgetestet wurden. Es ist nicht auszuschließen, daß der eine oder andere Druckertyp unterschiedlich reagieren wird. Die wichtigsten Steuerfunktionen dürften jedoch auf allen Geräten die gleichen Reaktionen hervorrufen.</p>

<p>Bevor es nun zur Sache geht, sei mir — vor allem für neu hinzugekommene Leser — ein kurzer Abriß des vorangegangenen Artikels erlaubt:</p>

<p>Zur Cursor-Steuerung, für RVS ON/OFF oder zum Beispiel für Farbumschaltungen stehen dem VC 20- beziehungsweise C 64-Anwender zwei Möglichkeiten zur Verfügung. Erstens kann die CHR$-Funktion genutzt werden (Beispiel ?CHR$(19) bewirkt HOME) und zweitens erlauben reverse Steuerzeichen eine direkte und kurze Eingabe der Steuerbefehle (Beispiel: das reverse S veranlaßt ebenfalls HOME). Nun existieren jedoch einige CHR$-Codes, für die äquivalente Steuerzeichen nicht über zugehörige Tasten abgerufen werden können. So schaltet CHR$(14) beispielsweise auf Kleinbuchstaben um. Mit Hilfe der ASC-Funktion zeigt sich, daß das reverse N den CHR$-Code 14 trägt. Damit kann dieses Zeichen ebenfalls zur Steuerung herangezogen werden. Da außer den konventionellen Steuerzeichen keinerlei reverse Symbole in Strings vorkommen können, muß das reverse N quasi künstlich erzeugt werden (daher der Name »Synthetische Steuerzeichen«). Aber das ist kein Problem! Wir haben bereits ein Eingabeverfahren kennengelernt, das ich aber jetzt nicht wiederholen möchte. Statt dessen möchte ich Ihnen ein anderes Verfahren zeigen, das vielleicht ein wenig übersichtlicher ist, als das im vorigen Heft beschriebene.</p>

<p>Geben Sie die Programmzeile, die ein im String stehendes Steuerzeichen erhalten soll, wie gewohnt ein. Reservieren Sie dabei jedoch mittels Space die Stelle im Textstring, wo später das synthetische Steuerzeichen stehen wird. Schließen Sie die Eingabe der Zeile mit Betätigung der Return-Taste ab. Nun können sie ohne Schwierigkeiten den Cursor auf die bewußte Stelle bewegen, durch gleichzeitiges Drücken von CTRL und RVS ON in den Revers-Mode schalten (es erscheint kein reverses R!) und schließlich den freigehaltenen Platz mit dem entsprechenden Reversezeichen belegen (in unserem Beispiel also mit dem reversen N). Die so ergänzte Programmzeile wird jetzt durch erneutes Drücken der Return-Taste verlassen. Fertig. Auf diese Weise lassen sich sowohl die altbekannten als auch die neuen Steuerzeichen leicht erzeugen und entsprechend ins Programm einfügen. In den weiteren Ausführungen werde ich die synthetischen Steuerzeichen vereinfachend in geschweiften Klammern darstellen (zum Beispiel reverses N = {N}).</p>

<h2 id="die-drucker-»synthies«">Die Drucker-»Synthies«</h2>

<p>Nun zum eigentlichen Thema: Ich könnte fast wetten, daß einige Druckerbesitzer unter unseren Lesern inzwischen beim Experimentieren mit synthetischen Steuerzeichen nicht schlecht gestaunt haben. Denn auch hier eröffnen sich neue Möglichkeiten, an die bislang nicht zu denken war. So sind zwar keine spektakulären Effekte in laufenden Programmen zu erzielen, dafür jedoch hat man erstmals die Möglichkeit, Druckerlistings zu manipulieren. Zuvor möchte ich Ihnen jedoch eine Liste der Steuerzeichen geben. Es ist zu beachten, daß die mit *) gekennzeichneten Steuerzeichen nicht zu den synthetischen zählen, da sich diese direkt über Tasten eingeben lassen. Sie wurden nur der Vollständigkeit halber mit in die Tabelle aufgenommen.</p>

<p>Nun zu den Erläuterungen derjenigen Zeichen, die sinnvolle Anwendungen erlauben.</p>

<h2 id="grafik-im-listing">Grafik im Listing</h2>

<p>Das reverse H gestattet die Umschaltung des Druckers in den Grafik-Modus. Alle nachfolgenden Zeichen im String werden — sofern ihr jeweiliger CHR$-Code größer als 127 ist — als Grafikinformationen interpretiert. In diesem Modus bleibt der Drucker so lange, bis er mit {N} oder [0] auf Schriftbetrieb zurückgeschaltet wird. Betrachten Sie bitte das Beispiel 1.</p>

<p>Zwischen »TEST« und »LAUF« befindet sich ein selbstdefiniertes Grafikzeichen, das sowohl im Programmlauf als auch im Listing ausgegeben wird. Auch wenn Sie es zunächst nicht glauben — Sie sehen ein Original-Listing und nicht etwa gePRINTete Textzeilen. Ich will Ihnen den Trick verraten. In einer Vergrößerung sieht das Grafiksymbol aus wie im Bild 1 gezeigt.</p>

<p>Die Umrechnung des dualen Bitmusters in Dezimalzahlen liefert diejenigen CHR$-Codes, durch die das Zeichen spaltenweise beim Drucken entsteht. Man muß also nur wiederum synthetische Zeichen finden, die die gesuchten CHR$-Codes tragen. Bei diesem Beispiel ergibt sich:</p>

<p>Mit dieser Folge von reversen Zeichen erzielen Sie also den Ausdruck, der im Beispiel 1 abgebildet ist.</p>

<p>Folgt dem {H} keine Grafikinformation, das heißt ist der CHR$-Code kleiner als 128, so kommt es zum Abbruch des Listings. Diese Tatsache kann man sich bewußt zunutze machen, wenn man ohne größeren Programmieraufwand einen Drucker-Listschutz in sein Programm einbauen will. Der Bildschirmbetrieb leidet darunter nicht, da {H} dort nur eine Verriegelung der Umschaltung zwischen Groß- und Kleinschrift bewirkt.</p>

<h2 id="zeitenvorschub">Zeitenvorschub</h2>

<p>Die Beispiele 2.1 und 2.2 zeigen daß {J} einen Zeilenvorschub mit Rückwagenlauf verursacht. In 2.1 befindet sich das reverse J zwischen »TEST« und »LAUF«, bei 2.2 am Schluß des Strings. Da man das zweite Anführungszeichen eines Strings weglassen kann, sofern keine weiteren Basic-Befehle mehr in dieser Zeile folgen sollen, ergibt sich so die Möglichkeit, echte Leerzeilen mit {J} im Listing zu erzeugen</p>

<h2 id="breitschrift-–-schmalschrift">Breitschrift – Schmalschrift</h2>

<p>Während {N} beim Bildschirmbetrieb auf Kleinbuchstaben umschaltet, zeigt der Drucker eine andere Wirkung. Er wird veranlaßt, alle nachfolgenden Zeichen in doppelt breiter Schrift auszugeben. Es ist also bei der Anwendung von {N} Vorsicht geboten, da ein für den Bildschirm konzipiertes Programm beim Druckerlisting unerwünschte Steuerungen zur Folge haben kann. In diesen Fällen sollte man {N} wieder durch den konventionellen Befehl CHR$ ersetzen.</p>

<p>Wollen Sie jedoch die Breitschrift zur übersichtlichen Gestaltung eines Listings nutzen, so können Sie ruhig das {N} hier und da im Programm verstecken. Es bleibt demjenigen, der das Programm lesen soll, sowieso verborgen. Wenn nur eine Hervorhebung einzelner Worte, Befehle oder Zeilen gewünscht wird, muß die Breitschriftphase entsprechend mit {O} beendet werden. Im Beispiel 3 sehen Sie dieses Vorhaben realisiert. Hier bewirkt das {N} vor dem Wort »Test« die Umschaltung auf Breitschrift, während ein {O} vor »Lauf« diesen Modus beendet.</p>

<h2 id="druckstartposition">Druckstartposition</h2>

<p>Die Druckstartpositionierung — vergleichbar mit TAB — wird normalerweise mit CHR$(16) und nachgestellter Startadresse vorgenommen. Also etwa:<br/>
PRINT#4,CHR$(16) &ldquo;10TEST’</p>

<p>Diese Zeile druckt beginnend in Spalte 10 nur das Wort »TEST« aus. Die im String vorangestellte Zahl dient dabei als Startadresse. Das kürzere Äquivalent sieht nun wie folgt aus:<br/>
PRINT #4,&ldquo;{P}10 TEST”</p>

<p>Doch Vorsicht! Obwohl diese Anweisung während des Programmlaufs korrekt ausgeführt wird, verschluckt sie der Drucker im Listing vollständig. Das 4. Beispiel zeigt, daß von {P}10 zwischen »TEST« und »LAUF« nicht mehr zu bemerken ist.</p>

<p>Damit verbietet sich die Anwendung des synthetischen {P} bei Programmen, die zum Beispiel zur Veröffentlichung vom Drucker dokumentiert werden sollen.</p>

<p>Für die Zeichen {Z}Zeichenwiederholung und }[} (Punktadresse für Druckerstart) haben sich bislang noch keine sinnvollen Einsatzmöglichkeiten ergeben. Sie sollen daher jetzt nicht weiter diskutiert werden. Auch auf die Beschreibung von {Q}, {R}, {SHIFT Q} und {SHIFT R} möchte ich verzichten, da sie keine synthetischen Zeichen sind und sich damit «ganz normal« verhalten.</p>

<p>Ich persönlich benutze die synthetischen Steuerzeichen gern zur Gestaltung von Listings. Wie so etwas aussehen kann, habe ich Ihnen im abschließenden Beispiel 5 zusammengestellt.</p>

<p>Vielleicht versuchen Sie einmal, die versteckten und unsichtbaren Steuerzeichen herauszufinden.</p>

<p>(Jürgen Wagner)</p>

<h1 id="autostart-in-theorie-und-praxis">Autostart in Theorie und Praxis</h1>

<blockquote><p>Welcher Anwender hat sich nicht schon immer gewünscht, seine Programme »so einfach wie möglich« in den Computer zu bringen. Geräte der oberen Preis-/Leistungsklasse sind zu diesem Zweck mit einem Autostart-Mechanismus ausgerüstet. Dabei wird das Programm ohne weiteres Zutun nach dem Anschalten des Gerätes vom Massenspeicher (Floppy) in den Computer geladen. Hier soll jetzt dieRealisierung eines solchen Autostarts auf einem C 64, beginnend mit der dazu nötigen Theorie, beschrieben werden.</p></blockquote>

<p>Es gibt beim C 64 mehrere Möglichkeiten, einen Autostart herbeizuführen. Ich will Ihnen hier eine weniger bekannte Methode vorstellen:</p>

<p>Die Stack-Manipulation.</p>

<p>Der Stack belegt beim C 64 den Bereich $0100 bis $01ff (256 bis 511). Er wird unter anderem zum Ablegen von Rücksprungadressen benutzt. Nach Beendigung einer Routine sucht sich der Prozessor vom Stack zwei Bytes (nämlich die Rücksprungadresse in das Hauptprogramm) und springt die Adresse, die sich aus diesen beiden Bytes ergibt, an. Eigentlich ist daraus schon zu ersehen, was zu tun ist: Man müßte diese Rücksprungadresse so ändern, daß das Programm nicht an die eigentliche Rücksprungstelle springt, sondern auf eine eigene Routine. Jetzt jedoch tauchen schon die ersten Probleme auf; Wie soll der Stack geändert werden, ohne daß man dafür ein Extra-Programm braucht? Wie soll sich das Programm nach dem Ladevorgang automatisch starten?</p>

<h2 id="die-theorie">Die Theorie</h2>

<p>Auf beide Fragen gibt es eine Antwort: Da sich der Stack beim Ladevorgang ändern soll, ist es das einfachste, den (manipulierten) Stack einfach mit abzuspeichern! Damit hätten wir dann auch den von uns gewünschten Inhalt des Stacks geladen. Dann aber tauchen schon die nächsten Fragen auf: Woher wissen wir, aus welchem Stack-Bereich der Prozessor seine Rücksprungadresse holt? Die Antwort ist: Wir wissen es nicht! Unsere einzige Möglichkeit ist, den ganzen Stack mit der von uns gewünschten Rücksprungadresse zu belegen. Das Programm, auf das unsere Adresse zeigt (ein Maschinenprogramm), hängen wir direkt an den Stack an. Von dieser Startroutine wird nun das eigentliche Hauptprogramm, das wiederum hinter der Routine liegt, angesprungen. Die Reihenfolge der Programmteile und des benötigten Speichers ist in Bild 1 zusammengefaßt:</p>

<p>Der Ladevorgang unseres Autostart-Programms muß mit »LOAD ”xxx”,8,l« erfolgen, damit das Programm nicht ab der Adresse $0801 (normaler Basic-Speicher), sondern ab $0100 geladen wird. Schauen wir uns nun noch einmal an, was im einzelnen beim Ladevorgang passiert:</p>

<ol>
<li>Laden des Programms von Diskette oder Kassette mit »LOAD ”xxx”,8,l«.</li>
<li>Nach Beendigung des Ladevorgangs will sich der Prozessor vom Stack die Rücksprungadresse ins Basic holen, findet aber die (soeben geladene) Adresse auf unser eigenes Startprogramm und springt dies an.</li>
<li>Unser Startprogramm springt jetzt das eigentliche Hauptprogramm an, das irgendwo ab $0801 stehen sollte.</li>
</ol>


<p>Nachdem also das Programm mit »LOAD ”xxx”,8,l« geladen wurde, startet es sich selbst sofort.</p>

<p>Zum Abschluß sei noch gesagt, daß einige Vorgänge zur besseren Verständlichkeit vereinfacht werden mußten. Bei eigenen Experimenten sei geraten, das abgedruckte Demo-Programm zu modifizieren. Außer einigen saftigen Abstürzen kann eigentlich nichts passieren.</p>

<h2 id="die-praxis">Die Praxis</h2>

<p>Das abgedruckte Demo-Programm läuft ohne Änderungen auf einem C 64 mit einer 1541-Floppy (Gerätenummer 8). Die Anpassung an andere Gerätenummern dürfte keine Schwierigkeit darstellen. Lediglich in den Zeilen 110, 112, 120 und 180 ist die 8 durch eine 9 zu ersetzen. Die Beschreibung der einzelnen Programmteile ist in Bild 2 zusammengefaßt.</p>

<p>Nun zum Programm selbst: Das Programm Autostart-Maker gibt dem Benutzer die Möglichkeit, ein beliebiges Programm mit einem Autostart zu versehen. Dabei muß folgende Bedingung erfüllt werden: Das Programm muß mindestens eine Basic-Zeile enthalten. Dies ist notwendig, da der vom Autostart-Maker generierte Autostart das Hauptprogramm mit dem RUN-Befehl startet. Zu diesem Zweck prüft der Autostart-Maker die Startadresse des gewünschten Programms und wirft eine Fehlermeldung aus, falls diese ungleich $0801 (Basic-Start) ist.</p>

<p>Wenn aber alles in Ordnung ist, so arbeitet das Programm eine Weile mit der Diskette, bis es eine Ende-Meldung ausgibt. Sollte ein Diskettenfehler auftreten, so macht sich das Programm optisch und akustisch bemerkbar. Danach hat der Benutzer die Wahl: das Programm zu beenden oder einen neuen Start zu versuchen.</p>

<p>Im Programm sind folgende Unterroutinen enthalten:<br/>
10000 Fehlerkanal lesen und auswerten<br/>
20000 Gong ausgeben (wird von Fehler-Routine aufgerufen)</p>

<p>In den Zeilen 30000- stehen die DATAs für das Startprogramm, das das eigentliche Hauptprogramm anspringen soll. Die Bedeutung einzelner Zeilen läßt sich auch den REM-Statements des Programms entnehmen.</p>

<p>Ein mit diesem Autostart versehenes Programm ist auch in gewissem Sinne geschützt. Es läßt sich weder mit RUN/STOP noch mit RESTORE abbrechen. Wird extern ein RESET-Impuls erzeugt, so wird der ganze Speicher gelöscht, bevor in die normale RESET-Routine verzweigt wird. Diese Eigenschaften gehen auf den Aufbau unseres Startprogramms zurück.</p>

<p>Geladen wird das neue Programm mit »LOAD ”name”,8,l«. Der Name entspricht dem des Ursprungprogramms mit dem Zusatz »/a«. Noch ein Tip: Wenn Sie im Besitz eines Basic-Compilers sind, so sollten Sie den Autostart-Maker compilieren. Und nun viel Spaß mit dem Autostart-Maker. Wenden Sie ihn doch am besten gleich mal bei Ihrem Programm an.</p>

<p>(Andreas Wurf)</p>

<h1 id="bücher">Bücher</h1>

<h2 id="spiele-mit-computer-grafik">Spiele mit Computer-Grafik</h2>

<p>Hier handelt es sich um ein Bilderbuch ganz besonderer Art. Auf 128 Seiten findet man genau 111 Grafikprogramme für den Commodore 64 und zu jedem dieser Programme auch das dazugehörige Listing sowie eine Hardcopy des Bildschirminhalts. Eine Reihe besonders beeindruckender Grafiken sind als farbige Bildschirmfotos abgedruckt, jedoch ist auch der größte Teil der schwarzweiß wiedergegebenen Grafiken wirklich sehenswert.</p>

<p>Auf den ersten Blick recht erstaunlich ist der sehr geringe Umfang der Programmlistings. Auf den zweiten Blick stellt man allerdings fest — und kann es auch im Vorwort lesen — daß alle Programme mit Simons Basic geschrieben wurden und somit leider auf einem »normalen« C 64 nicht ohne weiteres übernommen werden können. Wer noch kein Simons Basic besitzt, wird aber wohl spätestens nach der Lektüre dieses Buches an eine Anschaffung denken, so überzeugend sind die dargestellten grafischen Möglichkeiten dieses erweiterten Basic. Auch sehr beeindruckende Grafiken werden in der Regel mit einem sehr geringen Aufwand von nur vier bis zwölf Programmzeilen erzeugt.</p>

<p>Das Buch behandelt in den einzelnen Kapiteln ein weites Spektrum der grafischen Darstellungsmöglichkeiten. Es beginnt mit der Darstellung und Überlagerung geometrischer Figuren wie Rechteck, Ellipse und Gerade. Dabei ist es wirklich erstaunlich, welche Vielfalt an grafischen Ausdrucksmöglichkeiten bereits durch Kombination und Überlagerung dieser einfachen Figuren entsteht.</p>

<p>Weitere Kapitel behandeln die Darstellung spezieller Funktionen und Raumkurven. Die einzigen längeren Programme in diesem Buch dienen der Erstellung von Erdkarten im Multicolor-Modus. Dabei kann zwischen verschiedenen Projektionsmodellen gewählt werden. Besonders interessant erscheint die Möglichkeit, den Erdball als Globusdarstellung auf den Bildschirm zu bringen, wobei die Neigung der Erdachse und die Drehung per INPUT gewählt werden können.</p>

<p>Sehr interessant sind auch die Abschnitte über optische Täuschungen, Trugbilder und Moire-Effekt. Ein Metamorphose-Programm, das zwei beliebig vorgegebene grafische Darstellung schrittweise ineinander überführt, regt zu weiteren Experimenten in dieser Hinsicht an, ebenso die Kapitel über die Erzeugung von Zufallsgrafik.</p>

<h2 id="viele-programme-und-denkanstöße">Viele Programme und Denkanstöße</h2>

<p>Das Buch bietet also neben einer Fülle von guten Grafikprogrammen auch Denkanstöße für die eigene Beschäftigung mit den vielfältigen Möglichkeiten der grafischen Darstellung am Commodore 64. Leider fehlen Hinweise auf das Format der Grafikbefehle von Simons Basic, so daß die Anpassung an andere Computersysteme zumindest recht schwierig sein dürfte. Dennoch mag das Buch auch für Besitzer anderer Computersysteme interessant sein, da es einfach zur näheren Beschäftigung mit den Grafikmöglichkeiten von Computern allgemein anregt.</p>

<p>Wer das Abtippen der 111 Programme scheut, kann gegen Einsendung für 42,75 Mark eine Programmkassette beim Buch-Verlag anfordern.</p>

<p>(ev)</p>

<p>Dr. Norbert Treitz: Spiele mit Computergrafik, 128 Seiten, Lehrmittelverlag Wilhelm Hagemann, Düsseldorf 1984, ISBN 3-544-53003-1, Preis 28,50 Mark.</p>

<h2 id="das-maschinensprachebuch-zum-commodore-64">Das Maschinensprachebuch zum Commodore 64</h2>

<p>Dieses Buch verspricht eine leicht verständliche Einführung in die Maschinenspracheprogrammierung zu sein. Es wendet sich damit an Programmierer, die Basic mehr oder weniger gekonnt beherrschen und die nun beginnen möchten, kleinere Routinen ihrer Basic-Programme aus Geschwindigkeitsgründen in Maschinensprache zu formulieren. Dazu werden dem Programmierer erst der 6510-Mikroprozessor des Commodore 64 und dann die Befehle und Adressierungsarten dieses Prozessors auf gut 60 Seiten nähergebracht. Danach erfolgt die Beschreibung und das Listing eines in Basic geschriebenen Assemblers. Wer sich die Mühe macht, die zehn Buchseiten abzutippen, wird bald erkennen, wie wertvoll ein guter Assembler für einen Maschinenspracheprogrammierer ist. Und der abgedruckte Assembler ist schon aus Geschwindigkeitsgründen (er ist ja in Basic geschrieben) nur für die ersten Gehversuche auf diesem neuen Programmiergebiet geeignet.</p>

<p>Deshalb wird wohl auch auf den letzten 20 Seiten des Buches das Data-Becker-Produkt Profi-Ass beschrieben. Eine solche ausführliche Werbung in einem Buch, welches nicht billig zu nennen ist, ist nicht sehr kundenfreundlich, zumal der Besitzer von Profi-Ass das Beschriebene auch in einem Handbuch nachlesen können sollte.</p>

<p>Besser hätte ich es persönlich gefunden, wenn zu Beginn des Buches darauf hingewiesen würde, daß zum vollständigen Erarbeiten des Buches ein professionelles Assemblerprogramm (wie es Profi-Mon ohne Zweifel ist) sehr nützen kann. Damit hätte man sich den abgebildeten Assembler, einen weiter hinten im Buch abgedruckten Disassembler und die Beschreibung von Profi-Ass sparen können und die so gewonnenen zirka 50 Seiten mehr zu dem eigentlichen Zweck des Buches, der Einführung in die Maschinenspracheprogrammierung, nutzen können.</p>

<p>Gefallen hat mir an dem Buch die schrittweise Erarbeitung der hochauflösenden Grafikprogrammierung, der abgedruckte Einzelschrittsimulator und die ausführliche Beschreibung einiger Betriebssystemroutinen.</p>

<p>Zusammenfassend möchte ich sagen, daß das Buch dem Anfänger in der Maschinenspracheprogrammierung zwar einige wertvolle Hinweise bietet, daß aber auch gerade für den Anfänger wichtige Kapitel zugunsten anderer, unwichtigerer Abschnitte nicht ausführlich genug behandelt werden. 39 Mark sind allerdings für die verwendbaren Beispiele ein stolzer Preis!</p>

<p>(Wolfgang Willing)</p>

<p>Lothar Englisch: Das Maschinensprachebuch zum Commodore 64, 202 Seiten, Data Becker GmbH, ISBN 3-89011-008-8, 39 Mark</p>

<h1 id="listing-des-monats:-q-bernd">Listing des Monats: Q-Bernd</h1>

<blockquote><p>Listing des Monats sollen nicht nur sehr lange Programme werden. Auch kleinere Programme haben eine Chance. Q-Bernd ist eine sehr hübsche Version eines bekannten Spielhallenhits.</p></blockquote>

<p>An seinem Foto können Sie schon erkennen, daß der Autor Bernd Pape eine Menge Witz und Phantasie besitzt. Auch in seinem »Lebenslauf« und seiner Spielbeschreibung kommt das ganz klar zum Ausdruck. Dochlesen sie selbst:</p>

<p>Anleitung für das Spielprogramm »Q Bernd«.</p>

<p>Was Sie hier erleben, ist der ebenso heldenhafte wie qualvolle Untergang des letzten Menschen der Erde: Q Bernd. Auf einem hyperwasserstoffbombenfesten Teil des Verwaltungsgebäudes der Antiwurgkommission ist es ihm gelungen, die Explosion zu überleben, die ein jähzorniger Erdkundelehrer in einem Wutausbruch durch seine übermächtigen Gehirnwellen erzeugt hat. Q Bernd hat sich auf dem folgenden langen Flug durch den Weltraum auf den leider nur sehr spärlich vorhandenen Sauerstoff einstellen können, was allerdings nicht ohne bleibende Schäden abgegangen ist, wie man an seiner dunklen Hautfarbe und seinen O-Beinen erkennen kann. Aber leider schwebt Q-Bernd mit seinem hyperwasserstoffbombenfesten Fetzen nicht allein durch die unendlichen Weiten des Weltraums. Als er ungefähr 765.854.863.654. 392 Q-Berndsche Lichtmonate hinter sich gelegt hat, was nur dadurch möglich war, daß er sich jegliche Ernährung seines schon damals O-beinigen und sehr dunklen Körpers abgewöhnt hatte, näherte sich ihm ein Wesen, das einen derartigen Hunger entwickeln kann, daß es sogar Scheusale wie Q-Bernd frißt. Sie haben mit Ihrem Commodore 64 nun die Möglichkeit, das Leben Q-Bernds durch schnelle Reaktion und gute Taktik um wertvolle Sekunden zu verlängern. Sagen Sie ihm wahlweise per Tastendruck oder Joystickbewegung, wie er diesem Scheusal ausweichen kann. Jeder Sprung auf eine Stelle des hyperwasserstoffbombenfesten Fetzens, den er auf seiner langen Reise noch nicht erreicht hat, dankt er Ihnen in seiner Todesangst durch Punkte.</p>

<p>Wenn er auf diese Weise den ganzen Fetzen erforscht hat, hat ihr Commodore 64 durch die Punkte genügend Kraft, um Q Bernd einen neuen noch hyperwasserstoffbombenfesteren Fetzen zu geben, was Ihnen Q Bernd durch Zusatzpunkte dankt. Doch — Oh Schreck! — mit jedem Fetzen erhöht sich die Anzahl der gefräßigen Wesen. Erst wenn ihre Anzahl auf die runde Zahl 10 gestiegen ist, hört diese erschreckende Fortpflanzung auf (die Wesen haben Angst vor Überbevölkerung). Doch der Untergang Q Bernds läßt sich nur hinauszögern — nicht verhindern. Irgendwann werden ihn die Wesen packen und Sie können in Ihrem Mitleid nur noch die Geräusche der gestörten Verdauung der widerlichen Scheusale wahrnehmen, ehe Sie das Spiel wieder mit einem Druck auf die Taste »F1« neu starten.</p>

<p>Und nun das Gleiche für Praktiker:</p>

<p>Steuern Sie ihr Männchen wahlweise mit Joystick oder Tastatur so, daß alle 49 Felder gefärbt werden, um in die nächste Phase zu gelangen. In jeder Phase bis zur Phase 10 erhöht sich die Anzahl der Figuren, deren Berührung mit Ihrem Männchen tödlich ist. Danach wird das Spiel nicht mehr schwieriger. Mit Druck auf die Taste »fl« können Sie das Spiel neu starten. (Bernd Pape)</p>

<p><aside></p>

<h2 id="lebenslauf">Lebenslauf</h2>

<p>Am 6.12.1968 wurde ich als angeblich gewolltes Kind meiner Eltern versehentlich im Ruhrgebiet geboren und wenig später in Stade, einer sehr schönen Stadt zwischen Hamburg und Cuxhaven auf den Namen Bernd getauft. Bernd Pape war also der Name, der von nun an meine Umwelt in Schrecken versetzen sollte. Ungefähr 6½Jahre später gelang meinen Eltern ein kaltblütiges Attentat: Sie schulten mich in Bochum, wo ich auch jetzt noch meine Residenz habe, gegen meine schärfsten Proteste ein. Als ich nach 4 Jahren meinte, dieses Übel überstanden zu haben und ich gerade das Wort »arbeiten« aus meinem Vokabular streichen wollte, gelang es der Bürokratie, einen entscheidenden Sieg über mich zu erlangen: Ich wurde zum Gymnasiasten erklärt. All diese Mißhandlungen konnten mich aber nicht davon abhalten, meinem Protest durch ausgiebige Freizeitnutzung Nachdruck zu verleihen. Zunächst hatte ich nur die Möglichkeit, meine Eltern und die Nachbarschaft durch falsches, aber lautes Akkordeonspielen zu ärgern. Mit meinen ersten Elektronikkästen konnte ich dann aber mein Waffenlager erweitern: Ich erging mich in den herrlichsten und lautesten Sirenenschaltungen des 19. Jahrhunderts — oder des zwanzigsten? Geldgeschenke zur Konfirmation (weitere Spenden nehme ich gerne entgegen!) ermöglichten es mir, alle Leser dieser Zeitung aufzufordern, den Kampf um möglichst viel Freizeit nicht aufzugeben! Denn von diesem Geld holte ich mir den Commodore 64, auf dem ich den »Q Bernd« unter besonders, erschwerten Bedingungen geschrieben habe. Nach einer Lateinarbeit, deren Zensur nicht genau den Vorstellungen meiner Eltern entsprach, erhielt ich »Computer-Verbot«. Gott sei Dank sah ich dies schon beim Schreiben der Arbeit voraus, was dazu führte, daß ich meine Diskette mit dem schon angefangenen Programm vor der liebenden Umsicht meiner Eltern retten konnte. So entstand der Rest des Programms durch mein heimliches Programmieren in verschiedenen Computerläden Bochums. Hier ist es nun, das Programm, für das Bernd Pape seinen Hausfrieden geopfert hat: Q Bernd!</p>

<p>(Bernd Pape)</p>

<h1 id="druckfehlerteufelchen">Druckfehlerteufelchen</h1>

<blockquote><p>Die Redaktion hatte mir ausdrücklich den Kampf erklärt. Dennoch konnte ich wieder zweimal zuschlagen und Verwirrung stiften.</p></blockquote>

<h3 id="schatzsucher,-seite-91-ausgabe-5/84">Schatzsucher, Seite 91 Ausgabe 5/84</h3>

<p>»Nein, die Zeile 440 im Listing »Schatzsucher« fehlt nicht« wurde zur Standardantwort. Der Autor dieses Listings hatte anscheinend, bevor er den Beitrag einsandte, ein Renumber durchgeführt. Nachträglich wurde dann von ihm die Zeile 440 entfernt. Was in dieser Zeile stand, wird wohl immer ein Rätsel bleiben. Auf den Programmablauf hatte sie auf jeden Fall keinen Einfluß. Trotzdem bedanken wir uns bei den zirka eintausend Lesern, die uns im letzten Monat diesen »Fehler« meldeten.</p>

<p>Nun zu einigen wirklichen Fehlern. Wir möchten uns auch hier noch bei unseren Mitstreitern im Kampf gegen den Fehlerteufel bedanken.</p>

<h3 id="supergrafik-ohne-erweiterungsmodul,-seite-81,-ausgabe-5/84">Supergrafik ohne Erweiterungsmodul, Seite 81, Ausgabe 5/84</h3>

<p>In Zeile 4030 muß »BC +1« durch »BC = BC +1« ersetzt werden, sowie in Zeile 4050 P = PEEK(P): durch P = PEEK(B):</p>

<h3 id="adreß--und-telefonregister,-seite-67,-ausgabe-5/84">Adreß- und Telefonregister, Seite 67, Ausgabe 5/84</h3>

<p>Zeile 1060 muß lauten:<br/>
1060 FORI = 0TOAN</p>

<h1 id="alle-tasten-,-zeichen--und-steuercodes">Alle Tasten-, Zeichen- und Steuercodes</h1>

<p>Das ist der dritte Teil einer Serie über die Abfragemethoden für Tasten und ihre verschiedenen Codes. Alle Angaben gelten für den VC 20 und den C 64 gleichermaßen. Wo Unterschiede auftreten, sind die Werte für den Commodore 64 in Klammern gesetzt.</p>

<p>Ich habe im zweiten Teil dieser Reihe versucht, Sie zum Experimentieren mit den ASCII-Codes anzuregen. Heute habe ich für Sie die vollständige Liste aller 255 Codewerte vorbereitet und zwar in einer Art, die sicher einiger Erklärungen bedarf.</p>

<h2 id="ascii-codes,-die-von-commodore-verschwiegen-werden">ASCII-Codes, die von Commodore verschwiegen werden</h2>

<p>Ich habe nämlich noch ein paar zusätzliche Überraschungen parat, auf die man nur durch Zufall kommt oder durch Studium des Betriebssystems oder aber, wenn man den Aufsatz von G. Urbanczyk in Computer persönlich vom 19.10.1983, Seite 76, gelesen hat.</p>

<p>Tippen Sie bitte das Programm Nummer 3 aus dem 64’er Mai-Heft, Seite 107, ein, nämlich eine der drei Versionen zur Tastaturpuffer-Abfrage. (Ich verwende unten die GET-Version).<br/>
310 PRINT CHR$(147)<br/>
320 GET A$<br/>
330IFA$= ” &ldquo;THEN320<br/>
340 PRINT ASC(A$)<br/>
350 GOTO 320</p>

<p>Auf beiden, VC 20 und C 64 erhalten Sie nach RUN 310 und Drücken der RETURN-Taste (natürlich) den ASCII-Code 82. Wenn Sie zuerst die CTRL-Taste drücken und halten und dann erst das R drücken, dürfte eigentlich nichts passieren, denn die CTRL-Taste gilt ja angeblich nur für die Farben. Ja, denkste! Wir erhalten nämlich die Zahl 18. Ein Blick in die ASCII-Tabelle zeigt uns für 18 die Funktion »REVERSE-ON«.</p>

<p>Versuchen Sie dasselbe mit CTRL und der TODO-Taste. Wir erhalten die 6, und nicht 95, wie es eigentlich sein sollte.</p>

<p>Für den VC 20 ist das alles. Aber immerhin, wir haben sozusagen noch zwei zusätzliche Funktionstasten gefunden.</p>

<p>Beim C 64 aber geht es erst richtig los:</p>

<p>Der Versuch wird Ihnen zeigen, daß alle Buchstaben, von A bis Z, zusammen mit CTRL gedrückt, einen anderen ASCII-Wert, nämlich 1 bis 26, ergeben, als allein gedrückt.</p>

<p>Desweiteren biete ich Ihnen noch:<br/>
CTRL - t = 30<br/>
CTRL - = = 31<br/>
CTRL - £ = 28<br/>
CTRL - : = 27<br/>
CTRL - ; = 29</p>

<p>Das heißt aber, daß einige ASCII-Codezahlen zwei Bedeutungen haben. Oder umgekehrt, zwei verschiedene Tasten (kombiniert) haben denselben ASCII-Code.</p>

<p>Schwierigkeiten dadurch, daß einige ASCII-Werte zwei Bedeutungen haben, gibt es deswegen nicht, weil die Kombination mit CTRL nicht PRINT-bar ist (PRINT CHR$(19) schickt immer den Cursor »home«, mit dem »S« passiert gar nichts).</p>

<p>Andersherum kann es allerdings vorkommen, daß eine Tastenabfrage, zum Beispiel<br/>
GET A$:IF A$ = CHR$(19) THEN &hellip;&hellip;<br/>
sowohl auf die Taste »HOME« als auch auf »CTRL-S« reagiert. Da ist sicher etwas Vorsicht angebracht. Aber ein Blick in meine ASCII-Tabelle zeigt Ihnen ja die Doppeldeutigkeiten.</p>

<p>An dieser Stelle erwarte ich eigentlich einige Einsprüche, wie: »Wozu das alles, die acht Funktionstasten, oder gar erweitert auf 32, reichen doch völlig aus!« Für den Hausbeziehungsweise Spielgebrauch ist das sicher richtig. Aber bei professioneller Software, welche benutzerfreundlich aufgebaut ist, kann es oft gar nicht genügend Funktionstasten — besonders solche, die eine optische Buchstabenbeziehung zu der Abfrage haben sollen — geben. Wenn in einem Programm gefragt wird, ob Sie »LOADen« oder »SAVEn« wollen, ist CTRL-L oder CTRL-S halt klarer, als f-1 oder f-3.</p>

<p>Ich finde es schade, daß diese großartige Möglichkeit nur auf dem C 64 gegeben ist. Hier zeigt sich deutlich, daß dieser Computer doch professioneller ist als der VC 20.</p>

<h2 id="die-vollständige-ascii-tabelle">Die vollständige ASCII-Tabelle</h2>

<p>So, jetzt können Sie meine ASCII-Tabelle erst richtig interpretieren (Tabelle 1).</p>

<p>Leere Kästchen haben keine Bedeutung für die betreffende Codezahl.</p>

<p>Jeweils zwei Zeichen nebeneinander mit derselben Codezahl stellen die beiden Zeichensätze dar, in die mit C = SHIFT (Commodore-Taste) umgeschaltet werden kann. Wo nur ein Zeichen steht, ist es in beiden Zeichensätzen identisch.</p>

<p>Die Funktionen der Codezahlen 129 und 149 bis 155 gelten nur für den C 64. Interessant ist übrigens, daß die 4. und 7. Spalte identisch ist, ebenso die 6. und 8. Spalte (außer dem Zeichen für 255).</p>

<p>Ich möchte jetzt gern die Szene wechseln, ohne aber den ASCII-Code aus den Augen zu verlieren. Wir haben den ASCII-Code bisher verwendet, um Tasten abzufragen oder Funktionen auszuführen. PRINT CHR$(66) druckt zum Beispiel den Buchstaben B auf den Bildschirm.</p>

<p>Welche Methoden kennen Sie noch, mit denen das gleiche erzielt werden kann?</p>

<p>Die erste, die jeder aus dem Handbuch lernt, ist PRINT ”B”.<br/>
Die komplizierteste ist:<br/>
POKE 7680,2: POKE 38400,7<br/>
(POKE 1024,2: POKE 55296,7)</p>

<p>Diese beiden Vorgehensweisen wollen wir uns näher anschauen und prüfen, ob wir sie in Analogie zu dem ASCII-Code für Tastenabfragen einsetzen können.</p>

<p>Es ist sicher viel bequemer, längere Buchstabenreihen oder gar Texte zwischen Gänsefüße gestellt einzutippen, als eine Serie von CHR$-Werten, ganz abgesehen vom erforderlichen Speicherplatz.</p>

<p>Nicht ganz so bequem ist der Gänsefuß-Modus bei Steuerzeichen, wie zum Beispiel Cursor-Bewegungen, besonders, wenn man diese herbeiführen will, aber statt dessen die reversen Darstellungen auf dem Bildschirm erzeugt.</p>

<h2 id="der-gänsefuß-modus">Der Gänsefuß-Modus</h2>

<p>Geben Sie es zu. Sie haben deswegen auch schon herzhaft geflucht. Auch jeder Redakteur bittet um Listings mit CHR$-Darstellung anstelle der reversen Zeichen, die bei der Druckwiedergabe oft zu Schwierigkeiten führen.</p>

<p>Jetzt wissen Sie, warum ich bei meinen Progrämmchen immer PRINT CHR$(147) statt PRINT” verwende.</p>

<p>Genauso austauschbar wie bei PRINT ist der ASCII-Code mit dem Gänsefuß-Modus bei der Tastenabfrage.<br/>
Statt:<br/>
10 GET A$<br/>
20 IF A$&lt;&gt;CHR$(65) THEN 10<br/>
30 PRINT CHR$(88)<br/>
können wir schreiben:<br/>
10 GET A$<br/>
20 IF A$&lt;&gt;”A” THEN 10<br/>
30 PRINT ”X”</p>

<p>Beide Programme sind gleichwertig. Nach RUN rührt sich gar nichts. Erst, wenn die A-Taste gedrückt wird (Zeile 20), druckt Zeile 30 den Buchstaben X.</p>

<p>In Zeile 20 können wir natürlich statt des A jeden beliebigen Buchstaben, Zahl oder Zeichen nehmen.</p>

<p>LISTen Sie einfach die 2. Version der drei Zeilen, fahren mit dem Cursor auf das A und verändern Sie es Ihren Wünschen entsprechend. Wie ich Sie einschätze, machen Sie das sicher auch mit den Funktionstasten.</p>

<p>Nein? Dann machen Sie es mal. Sie haben nämlich Pech, so geht es nicht. Aber es geht, wenn Sie sich mit Absicht in die Lage begeben, die wie vorhin beschrieben, Flüche auslöst. Fahren Sie mit dem Cursor auf den 1. Gänsefuß, tippen Sie ihn noch einmal ein und drücken Sie dann eine Funktionstaste. Siehe da, es erscheint ein reverses Zeichen. Mit RETURN wird es »fixiert«, nach RUN wird das X erst mit der verwendeten Funktionstaste ausgelöst.</p>

<p>Der Trick besteht also darin, durch eine ungerade Anzahl von Gänsefuß-Eingaben diesen Modus herbeizuführen. Es geht ebenso durch Drücken der INSERT(INST)-Taste, allerdings nur für soviele Zeichen, wie oft sie gedrückt worden ist.</p>

<h2 id="im-gänsefuß-modus-erscheinen-alle-steuer--und-funktionstasten-in-reverser-darstellung">Im Gänsefuß-Modus erscheinen alle Steuer- und Funktionstasten in reverser Darstellung</h2>

<p>Sie haben oben ein reverses Zeichen für die Funktionstasten erhalten. Die Zeichen für die Farben und Cursorbewegungen, also alle »gängigen« Funktionen, kennen Sie inzwischen sicher schon. Aber alle Steuer- und Funktionstasten?</p>

<p>Es gibt zwei Möglichkeiten, diese Zeichen zu finden:</p>

<p>Die 1. Methode verwendet entweder ganz primitiv im Direkt-Modus den Befehl: PRINT ” mit nachfolgendem Drücken der Steuer- oder Funktionstaste oder sehr elegant den Dreizeiler<br/>
10 GET A$: IF A$ = &ldquo;"THEN 10<br/>
20 PRINT CHR$(34) A$ CHR$(34) ASC(A$)<br/>
30 GOTO 10<br/>
Auch hier ist ein kleiner Pfiff drin. In Zeile 20 wird zuerst ein Gänsefuß (34) gedrückt, wodurch wir in dem danach benannten Modus sind. Das nachfolgende A$ erscheint im Fall einer Steuertaste als reverses Zeichen, nach dem abschließenden 2. Gänsefuß gibt uns die ASC- Funktion noch den ASCII-Code der gedrückten Taste.</p>

<p>Mit Gänsefüßen statt CHR$ hätten wir lediglich die beiden Zeichen A und $ auf den Bildschirm gedruckt. Mit dieser Methode erhalten Sie zum Beispiel für:<br/>
ASCII-Code 17 = Cursor Down &hellip;. TODO<br/>
ASCII-Code 147 = CLR &hellip;. TODO</p>

<p>Die 2. Methode ist viel einfacher. Schauen Sie in meine ASCII-Tabelle (Tabelle 1). Sie ist in Spalten zu je 32 Zeichen angeordnet. Die Steuerzeichen und die Farben stehen alle in Spalte 1 und 5.</p>

<p>Da finden Sie zum Beispiel über der Codezahl 17 die Funktion »Cursor-Down«. Wenn Sie jetzt in die 3. Spalte waagrecht rübergehen — also den Wert um 64 erhöhen — steht da das TODO . Oder: In Spalte 5 ist der Taste CLR die Codezahl 147 zugeordnet. Zwei Spalten weiter (64 höher) steht das TODO.</p>

<p>Wenn Sie die Ergebnisse der 1. Methode oben mit den durch Spaltenhüpfen gefundenen Zeichen vergleichen, sehen Sie, daß es dieselben Zeichen sind, halt nur reversiert.<br/>
Machen wir die Probe:</p>

<p>Mit Methode 1 erhalten wir für »Rot« das reverse Pfund-Zeichen Q TODO . In der ASCII-Tabelle finden wir »Rot« unter 28. Zwei Spalten weiter, unter 28 + 64 = 92, steht dasselbe Zeichen.</p>

<p>Das gilt auch für alle CTRL-Kombinationen, nicht nur für die der Farben. Bei beiden Computern entspricht dem CTRL-TODO das TODO, beim C 64 erzeugt CTRL-TODO ein TODO. Alle Kombinationen der Buchstaben mit CTRL erzeugen diese Buchstaben in reverser Darstellung.</p>

<p>Um das in einer kleinen praktischen Anwendung zu verdeutlichen, schlage ich vor, dieselbe Aufgabenstellung, die in Heft 5/84 sowohl mit Tastencode-Abfrage (Programm Nummer 1 auf Seite 104/105) als auch mit Tastaturpuffer-Abfrage (Programm Nummer 4 auf Seite 135) gelöst wurde, noch einmal zu verwenden, jetzt aber die Gänsefuß-Methode einzusetzen.</p>

<p>Um beim Eintippen des Programms unten sicherzustellen, daß alles klappt, habe ich statt der reversen Zeichen die Tasten angegeben beziehungsweise umrahmt, die nach dem 1. Gänsefuß gedrückt werden müssen.</p>

<p>Das Programm schaltet, wie die beiden anderen Versionen auch, die Bildschirm-Farben mit f-1, f-2, f-3 und @ um.</p>

<h3 id="programm-1.-abfrage-mit-gänsefuß">Programm 1. Abfrage mit Gänsefuß</h3>

<p><pre>
410 PRINT &ldquo;SHIFT und CLR/HOME &rdquo;<br/>
420 GET A$ 430IFA$= ’"’THEN 420<br/>
440 IF A$= ” f-1 &ldquo; THEN POKE 36879,126<br/>
450 IF A$= ” f-2 ” THEN POKE 36879,45<br/>
460 IF A$= ” f-3 ” THEN POKE 36879,25<br/>
470 IF A$= ” TODO ” THEN POKE 36879,27<br/>
480 GOTO 420<br/>
</pre></p>

<p>Für den C 64 gelten in den Zeilen 440 bis 470 andere POKE-Adressen:<br/>
440     POKE 53280,6:POKE 53281,7<br/>
450     POKE 53280,5:POKE 53281,2<br/>
460     POKE 53280,l:POKE 53281,1<br/>
470     POKE 53280,3:POKE 53281,1</p>

<p>Ein letztes Problem bleibt uns noch. Wie schaffen wir es, daß wir im Gänsefuß-Modus auch Funktionen einsetzen können, die entweder keine eigene Taste haben (zum Beispiel 14 = Text, 8 = Lock) oder die beim Eintippen sofort die Funktion auslösen (zum Beispiel 13 = RETURN, 20 = DELete)?</p>

<p>Hier müssen wir eine Methode anwenden, die meine Kinder und ich »finkeln« getauft haben und zwar deswegen, weil wir sie zum ersten und einzigen Mal vom Commodore-Software-Spezialisten Andy Finkel im amerikanischen Handbuch gefunden haben.</p>

<p>Sein Trick besteht darin, daß er in einer ASCII-Tabelle das entsprechende Zeichen für die Funktion heraussucht und es in mehreren Schritten an seinen vorgesehenen Platz bringt.</p>

<p>Ich will Ihnen zeigen, was ich damit meine:</p>

<p>Bitte, versuchen Sie mit der Gänsefuß-Methode die DELete-Taste in eine PRINT-Anweisung zu bringen<br/>
10 PRINT ” INST/DEL ”</p>

<p>Sie werden es nicht schaffen, da die DEL-Taste, statt ein reverses Zeichen zu drucken, ihrer Funktion nachgeht und das vorherige Zeichen löscht.</p>

<p>Jetzt »finkeln« wir:</p>

<h3 id="1.schritt:">1.Schritt:</h3>

<p>10 PRINT ” &ldquo; (mit RETURN abschließen)</p>

<h3 id="2.-schritt:">2. Schritt:</h3>

<p>Mit dem Cursor auf die Leerstelle zwischen den Gänsefüßen fahren.</p>

<h3 id="3.-schritt:">3. Schritt:</h3>

<p>Aus der ASCII-Tabelle das Zeichen der DEL-Taste holen (T).</p>

<h3 id="4.-schritt:">4. Schritt:</h3>

<p>Die reverse Darstellung mit CTRL-REV.ON einschalten (der Cursor bleibt auf seiner Stelle) und das T drücken, mit RETURN abschließen. Jetzt steht das Zeichen drin und das Programm läuft.</p>

<p>Um Ihnen den Schritt 3 für alle widerborstigen Funktionen zu erleichtern, habe ich sie alle in der Tabelle 2 zusammengefaßt.</p>

<p>Da ich hoffe, daß Sie in Zukunft fleißig finkeln werden, muß ich Sie noch über einen lästigen Nebeneffekt aufklären, der bei ein paar Finkeleien auftritt. Einige der Funktionen, nämlich RETURN, DELete (schon wieder) und das SHIFT-RETURN wirken nicht nur im Programmablauf wie vorgesehen, sondern auch beim LISTen, was lästig sein kann. (Allerdings ergeben sich dadurch auch ungeahnte Möglichkeiten — siehe Artikel »Synthetische Steuerzeichen«. Das geSHIFTete RETURN (ASCII-Code 14) ist sehr nützlich bei Platz- und Speichermangel. Sie können nämlich mit ” 0 &ldquo; in einer langen Programmzeile den Cursor mit nur drei Zeichen auf den Anfang der nächsten Zeile bringen, mit CHR$(141) bräuchten Sie schon neun Zeichen, mit SPC(&hellip;) müssen Sie sehr genau die Cursorposition berechnen, mit einer entsprechenden Anzahl von »Cursor-Rechts«-Zeichen geht es auch nur mühsam. Also, nützlich ist SHIFT-RETURN durchaus!</p>

<p>Nur: Beim LISTen wird es auch ausgeführt und die Zeile, in der es steht, sieht recht blöd aus. Zusätzlich kann eine derart geLISTete Zeile nicht mehr geändert werden, sondern muß bei Verbesserungen völlig neu geschrieben und gefinkelt werden. Alles Gute hat seinen Preis!</p>

<p>Soviel sei zur Methode gesagt. Jetzt wollen wir zur Erholung und zur Übung ein kleines Spiel programmieren, in dem wir (fast) alles Gelernte auch anwenden.</p>

<p>Eine kleine Seltenheit ist bemerkenswert: Das Programm ist für VC 20 und C 64 identisch!</p>

<p>Die Spielaufgabe soll darin bestehen, die ersten sieben Buchstaben des Alphabets möglichst in der richtigen Reihenfolge auf den Bildschirm zu bringen.</p>

<h2 id="das-finkel-system">Das Finkel-System</h2>

<p>Klingt einfach, aber die Buchstaben sollen in zufälliger Reihenfolge auftauchen. Zusätzlich hat der Spieler, falls der Buchstabe nicht der Reihenfolge entspricht, lediglich die Möglichkeit, ihn mit der DEL-Taste zurückzuweisen, wenn er schnell genug ist. Das Programm zählt die Felder und zeigt am Schluß das Ergebnis an.</p>

<p>Wir brauchen dazu:</p>

<ul>
<li>Einen Zufalls-Buchstaben-Erzeuger von A bis G (ASCII-Code 65 bis 71)</li>
<li>einen Buchstaben-Drucker</li>
<li>einen Buchstaben-Reihenfolgezähler</li>
<li>eine Möglichkeit, die DEL-Taste zu drücken und damit den gedruckten Buchstaben rückgängig zu machen</li>
<li>einen Fehlerzähler</li>
<li>eine Prüfung, ob der letzte Buchstabe (71) erreicht ist.</li>
</ul>


<p>Normalerweise müßte ich jetzt ein Flußdiagramm zeichnen und »strukturiert« vorgehen, so wie die ausgezeichnete Serie in diesem Heft lehrt. Man möge mir aber verzeihen, daß ich aus Erklärungsgründen in einzelnen Schritten vorgehe, welche uns erlauben, jederzeit Zwischenresultate mit Probeläufen zu überprüfen (Programm 2, siehe Listing). Auf geht’s!</p>

<p>Den Buchstaben-Erzeuger und -drucker erhalten wir durch Zeile 50, welche für eine Variable A zufällige ASCII-Codes zwischen 65 und 71 erzeugt, sowie durch Zeile 70, die das Zeichen für den ASCII-Code ausdruckt.<br/>
50 A=INT(RND(0)*7) + 65<br/>
70 PRINT CHR$(A);</p>

<p>Für weniger Versierte sei gesagt, daß RND(0) eine Zufallszahl zwischen 0 und 0,99 erzeugt, mit 7 multipliziert gibt das eine Zahl zwischen 0 bis 6,93. Die Funktion INT macht daraus eine ganze Zahl, zwischen 0 und 6, mit 65 addiert letztlich eine Zahl zwischen 65 und 71 — ASCII-Werte der Buchstaben A bis G.</p>

<p>Den Ausdruck der Buchstaben nebeneinander erreichen wir durch das Semikolon in Zeiel 70, die laufende Wiederholung durch einen Rücksprung in Zeile 320.<br/>
320 GOTO 50</p>

<p>Damit es nicht zu schnell geht, verzögern wir das Ganze mit einer Warteschleife in Zeile 80.<br/>
80 FOR T = 1 TO 1000:NEXT T</p>

<p>Probieren Sie es mit RUN aus. Zeile 80 übrigens erlaubt Ihnen später den Schwierigkeitsgrad zu verändern.</p>

<p>Die geforderte richtige Reihenfolge der Buchstaben A, ich nenne sie hier R, setzen wir am Anfang auf 65 und erhöhen sie schrittweise um 1.<br/>
30 R = 65<br/>
310 R = R+1</p>

<p>In Zeile 60 prüfen wir, ob die Endzahl 71 für das G überschritten ist. Wenn ja, springen wir auf Zeile 400, mit der wir das Spielende anzeigen.<br/>
60 IF R > 71 THEN 400<br/>
400 PRINT”TODO SPIELENDE'&lsquo;**&ldquo;&rdquo;</p>

<p>Bitte RUNnen Sie das Fragment wieder zur Probe.</p>

<p>Jetzt kommt die Beeinflussung der Reihenfolge mit der DEL-Taste. Wie gelernt fragen wir diese Taste mit einer GET-Schleife ab (Zeilen 100,110), ihre Lösch-Wirkung erreichen wir in Zeile 120 durch einen PRINT-Befehl (mit Semikolon!). Nach Drücken der DEL-Taste darf der Reihenfolge-Zähler der Zeile 310 natürlich nicht wirken, deshalb springen wir schon vorher aus der Zeile 210 zurück.<br/>
100 GET A$<br/>
110 IF A$&lt;&gt;&ldquo;TODO&rdquo; THEN 300<br/>
120 PRINT ”TODO";<br/>
210 GOTO 50</p>

<p>Sie sehen oben, daß ich für die Abfrage der DEL-Taste die Finkel-Methode vorschlage. Die anderen Methoden gehen natürlich auch.</p>

<p>Nach RUN springt das Programm auf die noch nicht existierende Zeile 300 (was prompt zur Fehlermeldung führt), es sei denn, Sie drücken rechtzeitig die DEL-Taste.</p>

<p>In der Zeile 300 wollen wir prüfen, ob ein Fehler gemacht wurde, das heißt ob A mit der Reihenfolge R übereinstimmt. Im Fehlerfall wird die Fehlerzahl F um 1 erhöht. Vorher aber muß F auf 0 gesetzt werden.<br/>
20 F=0<br/>
300 IF A&lt;&gt;R THEN F = F+1</p>

<p>Sie können jetzt schon das Spiel üben. Aber es fehlen noch ein paar Feinheiten.<br/>
10 PRINT CHR$(147)<br/>
410 PRINT F &ldquo;Fehler”</p>

<p>Zeile 10 ist klar, Zeile 410 druckt am Spielende die Fehlerzahl F aus.</p>

<p>Aber es gibt noch einen Fehler des Spielers, nämlich wenn er aus Versehen einen richtigen Buchstaben zurückweist. Deshalb fragen wir nach erfolgtem Drücken der DEL-Taste in den Zeilen 100 bis 120 nach, ob der Buchstabe tatsächlich falsch war. Wenn nicht, wird die Fehlerzahl F um 1 erhöht.<br/>
200 IFA = RTHENF=F+1</p>

<p>Damit uns nach RUN der erste Buchstabe nicht überrascht, verzögern wir sein Erscheinen mit<br/>
40 FOR T= 1 TO 600: NEXT T</p>

<p>Zum Finkeln-Üben arrangieren wir die Anzeige des Spielendes und der Fehler etwas um. Alle Anweisungen sollen in nur einer Zeile stehen. Löschen Sie bitte die Zeile 410. In Zeile 400 wird gefinkelt und zwar mit dem Zeichen für SHIFT RETURN, welches laut Tabelle 2 mit SHIFT M erzeugt wird.</p>

<p>400 PRINT &ldquo;TODO DAS SPIEL IST ZU ENDE&rdquo;;&ldquo;TODO F "FEHLER”.</p>

<p>Bei LIST und bei Ausdruck mit einem Drucker sehen die gefinkelten Zeilen 110, 120 und 400 natürlich kurios aus und wie gesagt, sie lassen sich bei einem Tippfehler nicht korrigieren, sondern müssen neu geschrieben werden.</p>

<h2 id="der-bildschirm-code">Der Bildschirm-Code</h2>

<p>Der Vollständigkeit halber will ich noch die letzte der vorher genannten drei Methoden, ein Zeichen auf den Bildschirm zu bringen, erwähnen, insbesondere, weil der dabei verwendete Bildschirm-Code (auch Video-Code genannt) oft zu Verwechslungen mit dem ASCII-Code führt.</p>

<p>Auf Anhieb ist es auch nicht einzusehen, warum Commodore einen anderen Code verwendet, wenn ein Zeichen direkt auf den Bildschirm — oder genauer gesagt in den Bildschirm-Speicher — gePOKEt werden soll.</p>

<p>Der Grund dafür liegt darin, daß dem ASCII-Code nicht nur Zeichen zugeordnet sind, sondern auch Farben und Funktionen. Außerdem sind im ASCII-Code die reversen Zeichen nicht enthalten, sondern müssen — wie Sie ja inzwischen wissen —jeweils umgeschaltet werden. Das alles ist für ein Betriebssystem viel zu kompliziert.</p>

<p>Es ist viel einfacher, im Festspeicher (ROM) alle Zeichen der zwei Zeichensätze fest zu verankern, von wo sie das Betriebssystem herausholen und auf den Bildschirm bringen kann.</p>

<p>Die Reihenfolge der Zeichen und ihr Code sehen Sie in der Tabelle 3. Sie ähnelt in mehreren Bereichen der ASCII-Reihenfolge, einige Spalten sind sogar identisch. Das macht eine Umrechnung — auch für das Betriebssystem — sehr einfach.</p>

<p>Folgende Blöcke der beiden Codearten entsprechen einander:</p>

<p>Ein Programm zur Umrechnung von ASCII-Code in Bildschirm-Code sieht dementsprechend aus wie in Programm 3 (VC 20 und C 64).</p>

<p>Dabei habe ich als Variable gewählt:</p>

<ul>
<li>ACII = ASCII-Code</li>
<li>Bild = Bildschirm-Code</li>
</ul>


<p>Im Hinblick darauf, daß unser Hauptthema die Abfrage der Tastatur ist, soll uns dieser Ausflug genügen.</p>

<p>(Dr. Helmut Hauck)</p>

<h1 id="strubs-– ein-precompiler-für-basic-programme-(teil-4)">Strubs – Ein Precompiler für Basic-Programme (Teil 4)</h1>

<blockquote><p>In der heutigen letzten Folge wollen wir einige Teite des Programmes Strubs genauer ansehen und untersuchen, wie man das Programm um zusätzliche Funktionen erweitern kann. Dabei werden wir sehen, daß ein solches Übersetzungsprogramm auch für ganz andere Aufgaben eingesetzt werden kann.</p></blockquote>

<p>In den vorausgehenden Folgen wurde bereits erwähnt, daß die strukturierte Programmierung vor allem Vorteile in bezug auf Wartung, Änderungen und Erweiterbarkeit von Programmen bietet. Dies gilt auch für das Programm Strubs. Um in den Genuß dieser Vorteile zu gelangen, ist allerdings der Zugang zum Quellprogramm erforderlich. Wenn Sie sich das in Heft 5 abgedruckte Objektprogramm ansehen, werden Sie feststellen, daß es auch nicht viel aussagekräftiger als ein unkommentiertes Assemblerlisting ist. Wenn Sie an der Entwicklung eigener Programmerweiterungen interessiert sind, sollten Sie sich deshalb beim Verlag das Quellprogramm besorgen. Da ich hier davon ausgehen muß, daß die meisten Leser das Quellprogramm nicht besitzen, lohnt es sich gar nicht erst, systematisch die einzelnen Programmteile vorzustellen.</p>

<p>Statt dessen wollen wir nur die für Programmerweiterungen wichtigsten Programmelemente vorstellen und anhand einiger exemplarischer Erweiterungen, die auch, ohne sich weitere Gedanken zu machen, einfach eingetippt werden können, aufzeigen, wie man Erweiterungen implementieren kann und was dabei zu beachten ist. Aus dem gleichen Grund geben wir nur die Änderungen an, die im Objektprogramm vorzunehmen sind. Eine Anpassung an das Quellprogramm dürfte keine Probleme bereiten.</p>

<p>Achten Sie bei allen Programmänderungen darauf, daß das geänderte Programm abgespeichert wird, bevor es zum ersten Mal gestartet wird, da das Programm den Zeiger auf das Programmende verstellt. Sollte das Programm durch Erweiterungen so lang werden, daß es in den Editbereich hineinreicht, kann der Anfang des Editbereichs in Schritten zu 256 Byte nach oben verschoben werden, um Platz zu schaffen. Dazu ist in den Zeilen 70 bis 80 die Zahl 40 überall, wo sie auftaucht, durch eine größere Zahl (jeweils 4 für jedes Kilobyte) zu ersetzen (vgl. auch den Schluß der 3. Folge).</p>

<h2 id="die-wichtigsten-programmelemente">Die wichtigsten Programmelemente</h2>

<p>Eine grobe Übersicht über den Aufbau des Programms haben wir bereits in der 2. Folge gegeben. Bevor wir uns nun mit einzelnen Erweiterungen beschäftigen, wollen wir zunächst einmal die wichtigsten Programmelemente vorstellen, die man für Änderungen und Erweiterungen des Programms benötigt. Wie bereits erwähnt, liest Strubs das Quellprogramm zweimal vom Anfang bis zum Ende durch. Um Zeit zu sparen, wird im 1. Lauf nur jeweils der Anfang einer Zeile untersucht. Deshalb müssen alle Befehle, die bereits im 1. Lauf zu behandeln sind, auch am Anfang einer Zeile stehen, während Befehle, die nur im 2. Lauf behandelt werden, überall stehen können. Ein Beispiel:</p>

<p>Die Definition von Marken muß am Zeilenanfang erfolgen, während der Aufruf von Marken an jeder Stelle erfolgen kann. Die Aufgabe des 1. Laufs besteht darin, verschiedene Tabellen anzulegen, mit deren Hilfe dann im 2. Lauf das endgültige Objektprogramm erzeugt wird.</p>

<p>Jede dieser Tabellen besteht aus einem oder mehreren Array(s), einer Variablen, deren zweiter Buchstabe ein »M« für »Maximal« ist und die Dimension, das heißt die maximale Zahl von Einträgen festlegt, und aus einer Variablen, deren zweiter Buchstabe ein »P« für »Pointer« ist und die auf den jeweils nächsten freien Listenplatz zeigt. Bei Speicherplatzproblemen brauchen nur die Werte der Dimensionsvariablen im Init-Teil geändert zu werden. Möchte man zum Beispiel mehr als 99 Marken (die jetzige Maximalzahl) benutzen, dann schreibt man in Zeile 45060 zum Beispiel »MM = 150:&hellip;«.</p>

<p>Die Tabellen werden in den Zeilen 45050 bis 45200 definiert (Bild 1). Die Dimension des Stacks bestimmt die mögliche Schachtelungstiefe. Dazu kommen die Tabellen der neuen Befehle (Zeile 45260 bis 45274) und der Fehlermeldungen (Zeile 45480 bis 45514).</p>

<p>Dem schrittweisen Lesen des Quellprogramms dienen die Variablen C und NC. Die Variable C enthält den Code des jeweils zuletzt gelesenen Zeichens, wobei der Wert 0 ein Zeilenende markiert. Die Variable NC enthält die Adresse des nächsten zu lesenden Zeichens. Im 2. Lauf wird zeilenweise das Objektprogramm erzeugt, wobei die jeweils aktuelle Zeile in der Variablen Z$ aufgebaut wird. Dabei enthalten die beiden ersten Zeichen von Z$ Low- und Highbyte der Zeilennummer (so wie sie später im Speicher steht), und das letzte Zeichen der fertigen Zeile besteht aus dem Zeichen CHR$(0).</p>

<p>Die relevanten Zeichencodes, auf die Strubs reagiert, werden in den Zeilen 45240 bis 45254 definiert (Bild 2). Die Variable ZA enthält die Adresse des Anfangs der Zeile, die gerade bearbeitet wird. In EA steht die Startadresse des Editbereichs.</p>

<p>Damit kommen wir zu den für Erweiterungen wichtigen Modulen von Strubs. Die Prozedur »NEXT-CHAR« sucht ab Adresse NC das nächste relevante Zeichen des Quellprogrammtextes und liefert dessen Code in der Variablen C. Dabei werden Leerzeichen (Zeile 250) und Kommentare (Zeile 280-295) überlesen. Strings werden direkt in die Ausgabezeile Z$ übertragen (Zeile 350). Der Zeiger NC wird auf das nächste zu lesende Zeichen gesetzt. Die Prozedur »HOLNAME« (Zeile 750-830) liest ab aktueller Adresse NC einen Namen (zum Beispiel Befehl, Label) und zwar bis eines der Trennzeichen »:«, »,«, Blank oder Zeilenende erscheint. Der Name wird in der Variablen T$ ausgegeben, C enthält das erste relevante Zeichen hinter dem Namen (das ist außer beim Blank das Trennzeichen), und NC zeigt auf das nächste Zeichen.</p>

<p>Die Prozedur »SCHREIBZEILE« (Zeile 550-580) generiert auf der Diskette aus den nacheinander eingegebenen Zeilen Z$ das zusammenhängende Objektprogramm und gibt die Nummer der aktuellen Zeile auf dem Bildschirm aus. Die Variable AA (Linkadresse) darf außerhalb dieser Routine nicht verändert werden!</p>

<p>Die Prozedur »ERROR« (Zeile 8050 bis 8099) erwartet als Eingabe einen Fehlercode ER. Dabei handelt es sich um den Index der Fehlermeldung in der Tabelle der Fehlermeldungen. Die Zeilennummer und die Fehlermeldung werden auf dem Bildschirm ausgegeben und zugleich in eine Fehlertabelle eingetragen, die man sich nach der Übersetzung auf Bildschirm oder Drucker ausgeben lassen kann. Zusätzlich wird die Fehlermeldung in die Ausgabezeile Z$ geschrieben, so daß sie auch im Objektprogramm erscheint. Die Übersetzung wird mit der folgenden Zeile fortgesetzt.</p>

<p>Die Prozedur »ABBRUCH« (Zeile 50000 bis 50030) sorgt für einen kontrollierten Abbruch der Übersetzung. Sie erwartet ebenfalls als Eingabe den Fehlercode ER und gibt die entsprechende Fehlermeldung aus. Danach wird die Tabelle der bisher bemerkten Fehler ausgegeben, offene Files ordnungsgemäß geschlossen und Strubs neu gestartet.</p>

<p>Die Prozedur »WARTEN« (Zeile 49550 bis 49570) fordert den Benutzer auf, eine Taste zu drücken und wartet auf den Tastendruck.</p>

<p>Die Prozedur »INIT« (Zeile 45050 bis 45999) enthält die Definition der Variablen und Tabellen sowie die Interpretererweiterung.</p>

<p>Im »MENÜ« (Zeile 40050 bis 40495) können die verschiedenen Funktionen angewählt werden.</p>

<p>Die Prozeduren »BEFEHLE IM 1. LAUF« (Zeile 1550-2497) und »BEFEHLE IM 2. LAUF« (Zeile 2550-3640) werden von Strubs aufgerufen, sobald im Quellprogramm das Erkennungszeichen »!« für Befehle (Code in der Variablen BE) entdeckt wird. Sie holen den Namen des Befehls, suchen diesen in der Befehlstabelle und rufen entsprechend dem Index (+1) des Befehls in dieser Tabelle em Unterprogramm auf. Falls der Befehl nicht in der Tabelle gefunden wird, wird eine entsprechende Fehlermeldung ausgegeben. Im 1. Lauf kommt noch die Ausgabe der Blockstruktur hinzu. Hierzu dient die Variable In (für Indentmodus). IN = 0 bedeutet, auf der gleichen Schachtelungsebene zu bleiben.</p>

<p>Damit haben wir nun das notwendige Wissen zusammen, um an dem Programm Strubs einige Änderungen und Erweiterungen vorzunehmen.</p>

<h2 id="andere-anwendungen">Andere Anwendungen</h2>

<p>Bei den Programmtexten, die Strubs übersetzt, handelt es sich zwar um erweiterte Basicprogramme, aber nichtsdestoweniger um Basicprogramme. Deshalb ist es relativ einfach, Strubs auch zur Bearbeitung ganz normaler Basic-Programme einzusetzen. Zwei sinnvolle Möglichkeiten wollen wir im folgenden vorstellen.</p>

<ol>
<li>Ein SPEED-UP-Programm, um normale Basicprogramme schneller zu machen.</li>
<li>Ein Programm, das besser lesbare Listings erstellt.</li>
</ol>


<p>Dabei ist zu beachten, daß die Änderungen, die wir dazu vornehmen, nicht wie die Makro-Funktion eine Erweiterung des eigentlichen Programmes Strubs und seiner Funktion darstellen, sondern daß wir zwei völlig neue Programme mit völlig neuen Aufgaben erhalten. Deshalb sollten auch die erhaltenen Programme unter neuen Namen, beispielsweise »SPEED-UP« und »LISTER«, abgespeichert werden. Das Arbeiten mit diesen Programmen unterscheidet sich nicht von der Arbeit mit dem »normalen« Strubs-Programm.</p>

<h2 id="schnelleres-basic">Schnelleres Basic</h2>

<p>Zunächst wollen wir Strubs so ändern, daß es normale Basicprogramme in Programme übersetzt, die keine Leerzeichen und Kommentare mehr enthalten und dadurch schneller ablaufen. Wie Sie sich erinnern werden, benutzt Strubs für Kommentare, die gelöscht werden sollen, ein eigenes Zeichen »'«. Kommentare, die mit REM gekennzeichnet werden, bleiben im Objektprogramm erhalten. Da Strubs bereits alle Blanks entfernt (außer in Strings), brauchen wir nur noch dafür zu sorgen, daß Strubs auf das REM-Token reagiert wie bisher auf das Kommentarzeichen »’«. Die relevanten Zeichencodes, auf die Strubs reagiert, werden in den Zeilen 45250 bis 45254 definiert (Bild 2). Wir brauchen nur in Zeile 45250 das KO = ASC(» ’«) durch KO = 143 (143 ist das REM-Token) ersetzen und schon ist das Speed-Up-Programm fertig. Genauso können Sie die Erkennungszeichen für Label und die neuen Befehle ändern. Dies ist, um Konflikte zu vermeiden, für den Fall sinnvoll, daß Sie mit Strubs Programme für Interpretererweiterungen übersetzen, die ihrerseits »!« oder das Pfundzeichen als Erkennungszeichen für ihre neuen Befehle benutzen.</p>

<h2 id="listings">Listings</h2>

<p>Wollen Sie im »64’er« eigene Programme veröffentlichen? Dann können Sie den Lesern viel Ärger ersparen, wenn Sie das Listing vorher mit dem Programm »LISTER« aufbereiten. »LISTER« übersetzt Basic-Programme in Programmtexte, in denen die schwer entzifferbaren Steuer- und Grafikzeichen innerhalb von Strings durch lesbare Worte »&lt;CDOWN&gt;« oder »&lt;HOME&gt;« ersetzt sind (Bild 3).</p>

<p>Dazu ändern wir eine Zeile innerhalb der Prozedur »NEXTCHAR«. In Zeile 350 werden gelesene Zeichen mit dem ASCII-Code C innerhalb von Strings direkt in die Ausgabezeile Z$ übertragen. Wenn wir nun in Zeile 350 Z$=Z$+CHR$&copy; durch Z$=Z$+C$&copy; ersetzen, dann können wir ein Array C$(255) definieren, das in jedem ASCII-Wert den String enthält, der dafür im Objektprogramm erscheinen soll. Die Definition dieses Arrays gehört in das Modul »INITIALISIERUNG«:<br/>
45300 DIM C$(255):FOR I = 0 TO 255:C$(I) = CHR$(I):NEXT</p>

<p>Damit haben wir zugleich unser Array mit den normalen Werten vorbesetzt. Jetzt bleiben nur noch die Ersetzungen:<br/>
45310 C$(17)= &ldquo;(CDOWN)&rdquo;:C$(19)=&ldquo;&lt;HOME&gt;&rdquo;<br/>
45312 C$(28) = &ldquo;&lt;ROT&gt;&rdquo;:C$(31)=&ldquo;&lt;BLAU&gt;&rdquo;<br/>
&hellip; usw.</p>

<p>Hier können Sie nun jedem Zeichen ein beliebiges Wort zuordnen: Den ASCII-Code der einzelnen Zeichen finden Sie im C-64 Handbuch auf S. 135 oder Sie können ihn einfach durch Eingabe von<br/>
PRINT ASC(&ldquo;X&rdquo;)<br/>
feststellen, wobei »X« für das interessierende Zeichen steht. Bei sehr vielen Zeichen innerhalb eines Strings kann es allerdings vorkommen, daß die Zeilen zu lang werden. Deshalb sollten die Worte möglichst kurz gewählt werden.</p>

<h2 id="makros">Makros</h2>

<p>An einem etwas umfangreicheren Beispiel wollen wir nun zeigen, wie man neue Strubs-Befehle implementiert und wie man die Prozeduren von Strubs benutzen kann. Dies soll am Beispiel einer Makro-Funktion demonstriert werden.</p>

<p>Makros, vor allem von Assemblern her bekannt, stellen so etwas wie Abkürzungen für kurze Programmausschnitte dar. Dadurch verringert sich die Tipparbeit und vor allem werden die Quellprogramme übersichtlicher.</p>

<p>In der Makro-Definition wird ein Makro-Name definiert und diesem ein Programmstück zugeordnet. Überall, wo nun im Quellprogramm ein Makro aufgerufen wird, erscheint im Objektprogramm an dieser Stelle das entsprechende Programmstück. Ein einmal definiertes Makro kann wie ein Label beliebig oft aufgerufen werden.</p>

<p>Für die Definition eines Makros wollen wir den Befehl »IDMAKRO« und für den Aufruf eines Makros den Befehl »!M« wählen. Ein Beispiel mag die Wirkungsweise der neuen Befehle demonstrieren:<br/>
10 !DMAKRO:NAME SYS 833:X= PEEK (878)<br/>
&hellip;<br/>
200 PRINT X:!M,NAME:PRINT X</p>

<p>Die Definitionszeile 10 wird gelöscht, da sie nur für die Übersetzung notwendige Informationen enthält. Die Zeile 200 mit dem Makro-Aufruf sieht im Objektprogramm folgendermaßen aus:<br/>
200 PRINTX:SYS833:X=PEEK(878): PRINTX</p>

<p>Einige Beispiele für Makros und deren korrekte Benutzung sowie das sich ergebende Objektprogramm zeigt Bild 4. Vor allem ist darauf zu achten, daß Makronamen wie alle Befehls- und Labelnamen mit einem der Trennzeichen abgeschlossen werden müssen. Insbesondere darf bei der Makrodefinition und beim Aufruf mit nachfolgenden Parametern (Spritemakros in Zeile 120 und 130) nicht das Blank hinter dem Makronamen vergessen werden! Jede Makrodefinition benötigt eine eigene Zeile. Eine Übergabe von Parametern an ein Makro ist nicht möglich. Achten Sie bei der Arbeit mit Makros darauf, daß die entstehenden Zeilen des Objektprogramms nicht zu lang werden. Zeilen, die länger als 80 Zeichen sind, lassen sich nicht mehr editieren. Zeilen, die länger als 256 Zeichen werden, führen zum unkontrollierten Abbruch der Übersetzung mit »String too long error«. In diesem Fall kann man mit »GOTO 50000« die Nummer der verantwortlichen Zeile erfahren und offene Files schließen.</p>

<p>Um die Übersetzung zu ermöglichen, muß im 1. Lauf eine Tabelle der Makronamen und der zugehörigen Programmausschnitte angelegt werden. Im 2. Lauf werden dann alle Aufrufe durch den zugehörigen Text ersetzt. Die Verteilung auf zwei Läufe bietet den Vorteil, daß ein Makro (ebenso wie Labels) auch schon vor der Definition aufgerufen werden kann.</p>

<p>Zur Implementation sind folgende Schritte erforderlich: Zunächst muß dem Übersetzungsprogramm mitgeteilt werden, daß es zwei neue Befehle gibt. Dann müssen wir die notwendige Tabelle definieren und auch entsprechende Fehlermeldungen vorsehen. Diese Erweiterungen gehören in den INIT-Teil.</p>

<p>Schließlich muß noch dafür gesorgt werden, daß Strubs weiß, wie es im 1. und 2. Lauf auf die neuen Befehle zu reagieren hat.</p>

<p>Die Befehlstabelle wird in Zeile 45265 definiert. Hier erhöhen wir die Zahl der Befehle um 2 und fügen dann noch eine DATA-Zeile mit den beiden neuen Befehlsnamen ein:<br/>
45265 BM = 15:&hellip;<br/>
45275 DATA DMAKRO,M</p>

<p>Wählt man Befehlsnamen, die reservierte Basic-Worte enthalten, dann müssen die Tokens berücksichtigt werden (wie dies für IF in der Zeile 45271 geschieht). Für einen Befehl »DEFMAKRO« wäre zum Beispiel<br/>
BE$(14) = CHR$(150) + &ldquo;MAKRO” zu setzen (150=DEF-Token).</p>

<p>Für die Tabelle wählen wir ein Array NA$(NM,1), da der Name M bereits für die Markentabelle vergeben ist. Die Dimension (..,0) soll die Namen und die Dimension (..,1) den zugehörigen Text aufnehmen.<br/>
45155 NM = 40:DIM NA$(NM,1): NP = 0</p>

<p>Damit können 41 Makros definiert werden. Indem wir die Zahl der Fehlermeldungen von 9 auf 11 erhöhen, erhalten wir die beiden neuen Fehlercodes 10 und 11 für »zu viele Makros« und »undefiniertes Makro«.<br/>
45480 EM = ll:DIM&hellip;<br/>
45500 FOR I = 0 TO EM:READ &hellip;<br/>
45515 DATA &ldquo;ZU VIELE MAKROS”, ’’UNDEFINIERTES MAKRO”</p>

<p>Nun müssen wir in die beiden Module »BEFEHLE IM 1. LAUF« beziehungsweise »BEFEHLE IM 2. LAUF« jeweils zwei Routinen für die neuen Befehle einfügen. Da die beiden Verteilerzeilen bereits voll sind, legen wir zwei neue Verteilerzeilen, an, die dann aber auch gleich für 10 weitere neue Befehle Platz bieten:<br/>
1571 IF I>14 THEN ON I-14 GOSUB 2350,2380<br/>
für den 1. Lauf und<br/>
2571 IF I>14 THEN ON I-14 GOSUB 3700,3750<br/>
für den 2. Lauf.</p>

<p>Die Routine für »IDMAKRO« im 1. Lauf soll zunächst prüfen, ob noch Platz in unserer Makro-Tabelle ist und, falls nicht, mit entsprechendem Fehlercode die Abbruch-Routine anspringen:<br/>
2350 IF NP>NM THEN ER = 10: GOTO 50000</p>

<p>Jetzt können wir mit Hilfe der Prozedur »HOLNAME« den Makro-Namen lesen und in unserer Tabelle speichern:<br/>
2355 Z$ = &ldquo; &rdquo;:GOSUB750:NA$(NP,0) =T$</p>

<p>Nun übertragen wir den Rest der Definitionszeile mit Hilfe von »NEXT-CHAR« nach Z$ (dadurch werden auch Strings mit übertragen. Als Ausgabezeile dient Z$ ja erst im 2. Lauf).<br/>
2360    Z$ = Z$ + CHR$&copy;:GOSUB<br/>
250:IFC&lt;&gt;0THEN 2360</p>

<p>Nun brauchen wir nur noch den Text in die Tabelle aufzunehmen, den Zeiger zu erhöhen und den Indentmodus angeben.<br/>
2370 NA$(NP,l) = Z$:NP = NP + l:IN = 0<br/>
2375 RETURN</p>

<p>Der Aufruf eines Makros interessiert im 1. Lauf nicht, also:<br/>
2380 IN=0:RETURN</p>

<p>Im 2. Lauf soll die Definitionszeile gelöscht werden. Dazu löschen wir den Ausgabestring und weisen C den Code für Zeilenende zu:<br/>
3700 Z$ = ””:C = 0:RETURN</p>

<p>Beim Aufruf eines Makros mit »!M« holen wir zunächst den Namen des Makros mit »HOLNAME« und suchen ihn in der Tabelle:<br/>
3750 GOSUB 750<br/>
3755 FOR I = 0 TO NP: IF NA$(I,0) &lt;&gt;T$ THEN NEXT</p>

<p>Falls der Name nicht gefunden wird, erfolgt ein Sprung zur Error-Routine mit dem Code für »undefiniertes Makro«:<br/>
3760 IF I>NP THEN ER=11: GOTO 8050</p>

<p>Nun ist nur noch das definierte Programmstück in die Ausgabezeile zu übertragen:<br/>
3760 Z$ = Z$ + NA$(I,l):RETURN</p>

<p>Dadurch, daß diese Makro-Erweiterung Zeile für Zeile besprochen wurde, um zu zeigen, wie man die von Strubs vorgegebenen Prozeduren benutzen kann, ist vielleicht der Eindruck entstanden, eine solche Erweiterung sei relativ kompliziert. Wenn Sie sich aber das Ganze noch einmal genauer ansehen, können Sie feststellen, daß für die Implementation neuer Befehle im Prinzip nur drei Schritte erforderlich sind:</p>

<ol>
<li>Eintrag der neuen Befehlsnamen in die Befehlstabelle</li>
<li>Einfügen der entsprechenden Routinen</li>
<li>Eintrag der Adressen dieser Routinen in die beiden Verteilerzeilen</li>
</ol>


<p>Die ganze Arbeit des Suchens und Decodierens übernimmt Strubs automatisch.</p>

<p>Wie neue Funktionen (beispielsweise die Ausgabe der Makro-Tabelle) in das Menü aufgenommen werden können, haben sie bereits in der letzten Folge am Beispiel der RENUMBER-Funktion gesehen.</p>

<p>Eine Zusammenstellung der oben besprochenen Erweiterungen finden Sie in Bild 5.</p>

<h2 id="strubs-und-interpretererweiterungen">Strubs und Interpretererweiterungen</h2>

<p>Wollen Sie mit Strubs Programme für Interpretererweiterungen bearbeiten, dann sind einige weitere Dinge zu beachten. Entfernen Sie zunächst wie in Folge 3 beschrieben die Interpretererweiterung von Strubs.</p>

<p>Falls die Erweiterung, die Sie benutzen wollen, nicht in den Editor ingreift, sondern ihre neuen Befehle durch besondere Zeichen (meistens »!«) gekennzeichnet werden, dann ändern Sie wie bereits oben beschrieben die entsprechenden Erkennungszeichen, die Strubs benutzt.</p>

<p>Bei Erweiterungen wie Simon’s Basic, die in den Editor eingreifen und die neuen Befehle wie der Basic-Interpreter durch eigene Tokens darstellen, ist es am einfachsten, den Strubs-Befehlen, deren Namen solche Befehle enthalten, neue Namen zu geben. Im Fall von Simon&rsquo;s Basic sind davon beispielsweise Strubs-Befehle wie »!REPEAT«, »!UNTIL« oder »!ELSE« etc. betroffen.</p>

<p>Dazu sind nur die Namen in den DATA-Zeilen 45272 bis 45274 zu ändern. Sie können die betroffenen Strubs-Befehle aber auch wie oben am Beispiel von »DEFMAKRO« beschrieben aus den Tokens zusammensetzen. Dabei ist aber zu berücksichtigen, daß die Tokens von Simon’s Basic aus zwei Zeichen und nicht wie die normalen Tokens aus nur einem Zeichen bestehen.</p>

<p>Eine Liste der von Strubs benutzten Variablen bietet Bild 6. Dabei kennzeichnet das Zeichen »*« Zeilennummern, in denen eine Wertzuweisung an die Variable erfolgt.</p>

<p>Zum Abschluß hoch einige Berichtigungen zu den ersten Folgen: Die abgedruckte Programmversion wird nicht wie behauptet mit einem Kaltstart, sondern mit normalem »END« (Zeile 40190) beendet. Bei den in Teil 2 auf S. 121 angeführten Beispielen für Markendefinition und Externdeklaration haben sich Fehler eingeschlichen. Die korrekte Form entnehmen Sie bitte Bild 7.</p>

<p>(Matthias Törk)</p>

<h1 id="reise-durch-die-wunderwelt-der-grafik-(teil-4)">Reise durch die Wunderwelt der Grafik (Teil 4)</h1>

<blockquote><p>Nachdem in den ersten drei Folgen unseres Grafikkurses alle Grundlagen geschaffen wurden, nähern wir uns endlich mit Riesenschritten unserem Ziel: Die hochauflösende Grafik des Commodore 64, die von uns endlich aus ihrem Dornröschenschlaf geweckt wurde, gezielt in unseren Basic-Programmen einzusetzen. Die nötigen Hilfsmittel, wie zum Beispiel eine kleine Bibliothek von Grafik-Unterprogrammen, werden in dieser Folge vorgestellt.</p></blockquote>

<p>Sie können bisher Zeichen im Mehrfarbenmodus und (aber nicht gleichzeitig) mit veränderten Hintergrundfarben darstellen. Das Prinzip der Bit-Map ist Ihnen vertraut und Sie wissen, wie man dem Computer sagt, daß er nun seine Bildschirminformationen aus dieser Bit-Map holt. Sie können in diesem Modus die Farben bestimmen und schließlich auch Punkte exakt in die Bit-Map setzen. Wenn Ihnen der Inhalt der Bit-Map nicht mehr gefällt, können Sie sie löschen.</p>

<p>In dieser vierten Folge werden wir lernen, wie man die Speicher des Commodore 64 für Grafikanwendungen umkrempelt. Wir werden »Dornröschen« in mehreren Farben erleben und schließen diesen Teil der hochauflösenden Grafik mit einer kleinen Unterprogrammbibliothek ab. Der einleitenden Worte sind genug gesagt, Dornröschen wartet.</p>

<h2 id="wir-krempeln-den-commodore-64-um:-speicherveränderungen-für-hochauflösende-grafik">Wir krempeln den Commodore 64 um: Speicherveränderungen für hochauflösende Grafik</h2>

<p>Wenn Sie als stolzer Besitzer eines C 64 früher auch mal ebenso stolzer Besitzer eines VC 20 waren, dann ist Ihnen sicherlich in wehmütiger Erinnerung, was Sie sehen, wenn Sie durch die POKE-Kommandos<br/>
POKE 51,255:POKE 52, 31:POKE 55,255:POKE 56,31<br/>
in der letzten Folge die Bit-Map vor dem Überschreiben durch Basic geschützt haben und dann mal mit PRINT FRE (1) nach dem freien Basic-Speicher fragten: Da zeigte sich: 6144 (ohne Programm)!</p>

<p>Geht das Ringen um jedes Byte nun wieder los? Wie soll denn in diese 6 KByte ein besseres Spiel mit Hochauflösungsgrafik — ganz zu schweigen von anspruchsvolleren Programmen, zum Beispiel einer Kurvendiskussion — hineinpassen? Nun, keine Sorge: Wozu haben wir im C 64 denn 64 KByte RAM? Wir müßten nur wissen, wie wir sie nutzen können.</p>

<p>Dazu sehen wir uns nochmal den VIC-II-Chip an. Im Gegensatz zur CPU (unserem Prozessor 6510), die über 16 Adressenleitungen verfügen kann, stehen beim VIC-II-Chip lediglich 14 zur Disposition. Während man also mit 16 Leitungen alle Adressen<br/>
von 0 bis 1111 1111 1111 1111 = 65535<br/>
ansteuern kann, ist bei 14 Leitungen ein Maximum<br/>
von 11 1111 1111 1111 = 16383Adressen möglich, also 16 KByte.</p>

<p>Der gesamte Speicherraum des C 64 ist in vier solche 16 KByte-Blöcke aufteilbar und wie wir wissen, blickt der VIC-II-Chip im Normalfall auf den ersten 16 KByte-Block (siehe Bild 1). Nun kann man dem VIC-II-Chip mitteilen, daß er seine Aufmerksamkeit auf die anderen Speicherviertel richten möge. Das erfordert die Mitarbeit des »Portiers« CIA 2 (siehe Folge 1). Er hat im Gebäude 56576 zwei Zimmer (Bits 0 und 1), aus denen dem VIC-II-Chip die Anweisungen gegeben werden, um welches Viertel unseres Speichers er sich kümmern soll. Auf welche Weise diese Bits den VIC-II-Chip-Zugriff regeln, sehen Sie aus Tabelle 1.</p>

<p>Commodore empfiehlt nun noch sicherzustellen, daß die zu dieser Abschnittsauswahl gehörigen Bits des Datenrichtungsregisters Port A im CIA 2 (Speicherstelle 56578) auf 1, also auf Ausgabe, gestellt werden. In allen Programmen, die ich bisher verwendet habe, wäre das eigentlich nicht nötig gewesen, jedenfalls habe ich nichts bemerkt, als ich das nicht getan habe.</p>

<p>Trotzdem gebe ich hier diese Empfehlung weiter, falls in Ihren Programmen diese Maßnahme notwendig wird. Falls Sie vergessen haben sollten (Folge 2), wie man Bits setzt oder löscht, hier die nötigen Programmzeilen dazu:<br/>
20 POKE 56576, (PEEK(56576) AND 252) OR I<br/>
30 POKE 56578, PEEK(56578) OR 3</p>

<p>I ist dabei der in Tabelle 1 gezeigte Dezimalwert der Bits 0 und 1.</p>

<p>Der VIC-II-Chip managt auch den Bildschirm. Im Einschaltzustand packt er den Bildschirmspeicher — wie wir schon wissen — in den Bereich 1024 und 2023. Wenn wir nun einen anderen 16 KByte-Abschnitt wählen, legt er den Bildschirm an die entsprechende Stelle dieses Abschnittes, also:<br/>
In Abschnitt 0: Bildschirm von 1024 bis 2023<br/>
in Abschnitt 1: Bildschirm von 16384 + 1024 = 17408<br/>
bis 16384 + 2023 = 18407<br/>
in Abschnitt 2: Bildschirm von 32768 + 1024 = 33792<br/>
bis 32768 + 2023 = 34791<br/>
in Abschnitt 3: Bildschirm von 49152 + 1024 = 50176<br/>
bis 49152 + 2023 = 51175.</p>

<p>Damit brauchen wir uns aber nicht zufrieden geben.</p>

<h2 id="multivisio-—-unter-64-bildschirm-wählen">Multivisio — unter 64 Bildschirm wählen</h2>

<p>Im 16 KByte-Speicherabschnitt hat der Bildschirmspeicher ja 16mal Platz und wir können ihn ohne weiteres an eine andere Stelle schieben. Damit kehren wir nochmal zur schon oft besungenen Speicherstelle 53272 zurück. Die Bits 4 bis 7 geben dem VIC-II-Chip den Ort des Bildschirmspeichers an. Durch Verändern dieser 4 Bits können wir tatsächlich die 16 Bildschirme pro 16 KByte-Abschnitt einrichten. Der Zusammenhang zwischen den Bits 4 bis 7 von Adresse 53272 und dem Ort des Bildschirmspeichers im Abschnitt 0 (und entsprechend parallelverschoben in den anderen Abschnitten) ist in Tabelle 2 gezeigt.<br/>
Um die entsprechende Bitanordnung zu erreichen, müssen wir also eingeben:<br/>
40 POKE 53272, (PEEK(53272) AND 15) OR W<br/>
Dabei ist W der Dezimalwert der Bits 4 bis 7 aus Tabelle 2.</p>

<p>Das Betriebssystem muß auch noch erfahren, daß der Bildschirmspeicher verlegt worden ist. Man kann es ihm mitteilen, indem man die Pagenummer der Bildschirmstartadresse in Speicherstelle 648 einPOKEd. Also ist zum Beispiel der normale Inhalt von Speicher 648: 1024/256 = 4. Auf Page 4 beginnt der Bildschirm ja im Einschaltzustand. Die Pagenummer ergibt sich aus I und W (siehe Tabelle 1 und 2) durch folgende Rechnung:<br/>
50P = (W/16<em>1024 + 16384</em>(3-I))/256<br/>
und wird dann eingePOKEd:<br/>
55 POKE 648,P<br/>
So! Jetzt können wir theoretisch 64 Bildschirme erzeugen. Um uns das in der Praxis mal anzusehen, ergänzen wir die bisher verwendeten Programmzeilen (die Sie hoffentlich noch nicht mit RUN gestartet haben, das wäre nämlich mit etwas Glück eine gute Methode, den Rechner abstürzen zu lassen!) noch um folgendes:<br/>
10INPUT"I,W";I,W:PRINTCHR$(147)<br/>
60 PRINT CHR$(147)I,W:END<br/>
65 PRINT CHR$(147)<br/>
70 POKE 56576,151:POKE 56578,63: POKE 53272,21:POKE 648,4<br/>
80 I = 3:W=16:PRINT CHR$(147)I,W<br/>
90 END</p>

<p>Bevor Sie das starten, sollten Sie bitten daran denken, daß einige I,W-Kombinationen den Computer zum totalen Black-Out führen: Zum Beispiel I = 3,W= 0 legt den Bildschirmstart direkt in die Zeropage, ist also nicht empfehlenswert. I = 3 ,W = 32 zerstört unser Programm, das genau bei 2048 anfängt. Am besten speichern Sie das Programm vor dem Starten ab.</p>

<p>Jeweils nach RUN und Eingabe der Werte I und W, zum Beispiel I = 3, W = 48, wird der Bildschirm gelöscht und in der obersten Zeile wird der I- und der W-Wert angegeben. Danach meldet sich READY und ein Cursor. Jetzt befinden wir uns im neuen Bildschirm (unser Beispiel also 3072 bis 4071) und können damit herumexperimentieren.</p>

<h2 id="bildschirm-experimente">Bildschirm-Experimente</h2>

<p>Wenn wir jetzt (falls keine Programmänderung in der Zwischenzeit durchgeführt wurde) CONT eingeben, wird der Ursprungszustand (Bildschirm bei 1024) wieder hergestellt und dies durch die Angabe der I- und W-Werte 3 und 16 angezeigt.</p>

<p>Wenn Sie mit diesem Programm in den Bereich 4096 bis 8191 vorstoßen, werden Sie feststellen, daß hier kein normaler Bildschirm möglich ist. Hier stören die mehrfach schon beschworenen Geisterbilder des Zeichen-ROM, die in diesem Bereich liegen. Es kann sogar passieren, daß der Rechner nach der Eingabe von CONT nur noch SYNTAX ERRORs meldet und nicht mehr in den Normalzustand zurückzuführen ist. Ab 8192 bis 15360 (jeweils Start des Bildschirmes) kann man wieder ohne Störung Bildschirme einrichten. Wenn Sie jetzt mal I = 2 und verschiedene W-Werte versuchen, sehen Sie nur Nonsens oder gar nichts auf dem Bildschirm, dasselbe geschieht bei I = 0.</p>

<p>Das ist wieder eine Besonderheit des VIC-II-Chip. Er ist so strukturiert, daß der (im Normalfall) in diesen beiden Abschnitten keinen Zugang zu den normalen Zeichenspeichern hat. Dafür gibt es in Abschnitt 1 (I = 2) keine Störung durch die Zeichen-Geisterbilder, ebenso in Abschnitt 3 (I = 0). In Abschnitt 2 (I = 1) begegnen wir zwischen 36864 und 40959 wieder den hier ein zweites Mal vorhandenen Zeichen-Gespenstern. Unterhalb von 36864 läßt sich der neue Bildschirm gut verwenden.</p>

<h2 id="der-verborgene-speicher-—-ram-bereiche-unter-dem-rom">Der verborgene Speicher — RAM-Bereiche unter dem ROM</h2>

<p>Ein Problem stellt sich hier und auch im obersten Abschnitt aber noch auf andere Weise: Wenn wir den Bildschirm zum Beispiel mit I = 1 und W=128 nach 40960 legen (tun Sie es bitte nicht!), dann erhalten wir bei jeder Eingabe nur noch »SYNTAX ERRORs« und können den Computer nur durch Aus- und Einschalten wieder zu normaler Tätigkeit bewegen. Was ist da los? Die Erklärung ist, daß von 40960 bis 49151 das Basic-ROM und von 57344 bis 65535 das Betriebssystem dem RAM überlagert sind. Wenn man in diese Regionen hineinPOKEd, landet die Information natürlich im darunterliegenden RAM. Das was auf dem Bildschirm erscheint wenn wir aus dem Programm-Modus aussteigen, ist allerdings — leider — der Inhalt des darüberliegenden ROM. Ersetzen Sie aber mal das »END« in Zeile 60 durch die folgenden Zeilen:<br/>
60 PRINT CHR$(147)I,W:PRINT" BILDSCHIRM LIEGT UNTER DEM ROM«<br/>
65 GET A$:IF A$ = ” ”THEN 65<br/>
Siehe da! Es funktioniert also im Programm-Modus (zum Beispiel mit I = 1 und W= 128). Wir können daher unter das Basic-ROM auf diese Weise acht Bildschirme legen. Unter das Betriebssystem lassen sich so auch Bildschirme legen, nur können wir hier den Text nicht lesen, weil der VIC-II-Chip — wie gesagt — hier keinen Zugriff zum Zeichen-ROM hat. So legt zum Beispiel I = 0 und W=240 den Bildschirm nach 64512, was leicht nachprüfbar ist durch die Zeile:<br/>
62 POKE 65000, 1:POKE 55784,1.</p>

<p>Damit wenden wir uns nun dem kritischen Bereich zwischen 53248 und 57343 zu. Hier liegen ja das Zeichen-ROM und die Ein- und Ausgabebausteine. Normalerweise — wie man auch durch unsere POKE in diesen Bereich erkennen kann — sind hier die Ein- und Ausgabe- Bausteine eingeschaltet. Wenn wir hierher Bildschirme legen, kann alles mögliche passieren, weil wir Register des VIC-II-Chip, des SID und CIAs beeinflussen. Hier sollte man mit viel Vorsicht und gegebenenfalls nur in Maschinensprache operieren.</p>

<p>Was wir durch die Programmzeile 62 noch erkennen können: Das Bildschirmfarben-RAM verschiebt sich nicht, egal, welches Speicherviertel wir wählen und wohin wir den Bildschirm auch legen: Das Farb-RAM liegt immer von 55296 bis 56295.</p>

<h2 id="wohin-mit-der-bit-map?">Wohin mit der Bit-Map?</h2>

<p>Nun aber zum großen Speicherfresser: Zur Bit-Map. Mit ihren 8000 Byte paßt sie im Prinzip achtmal in unseren Computer. Im ersten Viertel (0 bis 16383) haben wir sie schon gehabt und das als unbefriedigend empfunden. Nun wollen wir uns andere Möglichkeiten ansehen und dabei noch bedenken, daß wir auf den normalen Zeichensatz verzichten können (wir stellen ja hochauflösende Grafik dar!). Zu diesem Zweck werden wir das bisher verwendete Bildschirmtestprogramm um einen Hochauflösungsteil erweitern (Listing 1). Um die leidige Eintipperei minimal zu halten, wurde auf Schönheit und erläuternde REM-Zeilen verzichtet. Der Hochauflösungsteil stimmt weitgehend mit dem Programm aus der letzten Folge überein. Geben Sie also jetzt das Listing 1 ein, speichern Sie es möglichst gleich ab und probieren Sie es aus.</p>

<p>In Bild 2 sind alle möglichen Positionen der Bit-Map und des Bildschirmes angegeben.</p>

<p>Wie man sehen kann, scheiden die Kombinationen Nummer 1 und Nummer 7 von vornherein aus, weil wir mit dem Löschen der Bit-Map auch das Lebenslicht unseres Rechners ausblasen. Die Kombination Nummer 2 kennen wir schon: So haben wir in der letzten Folge hochauflösende Grafik betrieben und waren enttäuscht über den geringen verbliebenen Basic-Speicher. Bei Nummer 5 funken uns die Zeichen-Spiegelbilder in die Bit-Map, diese Kombination scheidet also auch aus. Nett sieht es aus, wenn wir die Kombinationen Nummer 6 und Nummer 8 testen. Hier machen sich die ROM-Inhalte grafisch zwar ganz interessant aus, aber mit dem Sinn unserer hochauflösenden Grafik hat das nichts mehr zu tun. Für uns brauchbar sind die Positionen im Abschnitt 1: Kombinationen Nummer 3 und Nummer 4. Ein Maximum an Basic-Speicher findet man bei der letzten gezeigten Kombination Nummer 9, wo ab 23552 der Bildschirm und ab 24576 die Bit-Map liegen. Wenn Sie den Basic-Speicher für diese Anordnung schützen, mit POKE 55,0:POKE 56,92:POKE 52,92 und den Computer dann mit PRINT FRE(I) nach dem freien Speicherplatz fragen, dann erhalten Sie als Antwort immerhin satte 21501 freie Byte.</p>

<p>Der Idealfall wäre es, wenn man die Bit-Map unter das ROM legen könnte (Kombinationen 6 oder 8). Das geht natürlich auch! Von Basic aus wird ein Programm dann allerdings noch langsamer, weil man für jeden Punkt ähnliche Operationen vornehmen müßte, wie wir sie in der zweiten Folge beim Kopieren des Zeichen-ROM ins RAM verwendet haben. Auch so ist die ganze Hochauflösungsgrafik schon ziemlich langsam. Wir werden aber in kommenden Folgen einige Routinen in Maschinensprache kennenlernen, die uns mehr Möglichkeiten eröffnen.</p>

<h2 id="die-grafik-bekennt-farbe:-der-bit-map-mehrfarben-modus">Die Grafik bekennt Farbe: Der Bit-Map-Mehrfarben-Modus</h2>

<p>Hochauflösende Grafik in Farbe: Kann das der C 64 überhaupt? Die Antwort lautet Ja und Nein. Ja, weil der bislang von uns verwendete Bit-Map-Modus anstelle der zwei bisher benutzten auch mit vier Farben ablaufen kann. Nein, weil die Punkteauflösung dann eigentlich nicht mehr die Bezeichnung »hochauflösend« verdient. Die horizontale Auflösung geschieht hier nämlich nur noch in 160 Positionen anstelle der bisher ansprechbaren 320. Meine persönliche Meinung dazu ist, ernsthafte hochauflösende Grafik sollte sich im bisher besprochenen Bit-Map-Modus abspielen, denn ein Bildschirm mit 64000 Bildpunkten ist schon eine Minimalanforderung. 32000 Bildschirmpositionen sind allenfalls für Spielereien ganz nett, wenn auch etwas teuer, denn ohne Farbmonitor haben Sie von der Farbe nicht viel und über den Unterschied zwischen Farbfernseher und Farbmonitor haben wir im Verlauf dieser Serie schon etwas erfahren.</p>

<p>Nach dieser etwas desillusionierenden Vorrede widmen wir uns also der mehrfarbigen Bit-Map-Grafik. Es handelt sich um eine Kombination aus der bisher bekannten Bit-Map-Grafik und dem Mehrfarben-Modus, den wir schon bei den mehrfarbigen Zeichen kennengelernt haben. Auf dem Bildschirm wird der Inhalt der Bit-Map wiedergegeben, aber die Farben der Zeichnungen sind abhängig von Bit-Paaren. Welche Farben Sie bei welcher Paarung sehen, darüber gibt Tabelle 3 Aufschluß.</p>

<p>Es existiert also eine Hintergrundfarbe für den gesamten Bildschirm, die überall dort auftaucht, wo in der Bit-Map ein Bit-Paar 00 vorhanden ist. Diese Hintergrundfarbe ist durch den Zahlenwert in Register 53281 bestimmt. Die anderen drei Farben treten jeweils in den 8 x 8-Bit-Bildschirmfeldern auf, in die das Video-RAM, beziehungsweise der Bildschirmfarbspeicher aufgeteilt sind.</p>

<p>Wir ergänzen unser Programm 1 für den Mehrfarben-Modus: Außer dem Bit-Map-Modus muß hier also noch der Mehrfarb-Modus eingeschaltet werden. Das haben wir in der letzten Folge kennengelernt: 145 POKE 53270,PEEK(53270) OR 16 Weiterhin ändern wir noch die Zeile 5 und schreiben anstelle von F=6 jetzt GOSUB 300. Folgende Zeilen kommen neu hinzu:<br/>
300 PRINT CHR$(147)CHR$(17)&ldquo; FARBENWAHL:”<br/>
310 PRINT CHR$ (17)"HINTER-GRUNDFARBE"TAB (30);:INPUT F0<br/>
320 PRINT "BITS 4-7 VIDEOMATRIX"TAB(30);:INPUT F1<br/>
330 PRINT "BITS 0-3 VIDEOMATRIX"TAB(30);:INPUT F2<br/>
340 PRINT ’’BILDSCHIRMFARBSPEICHER"TAB(30);:INPUT F3<br/>
350 POKE 53281,F0:F=16*Fl+F2: FOR I = 55296 TO 56295:POKE I,F: NEXTI<br/>
360 PRINT CHR$(147):RETURN</p>

<p>Um des Effektes willen ändern wir noch die Zeile 220, in der die Videomatrix mit den Farbzahlen belegt wird:<br/>
220 FOR J = 0TO 998 STEP 2:POKE J,F:NEXT J:FOR J = lTO 999 STEP 2:POKE J,F+l:NEXTJ</p>

<p>Starten Sie dieses Programm nach dem Abspeichern mit RUN, probieren Sie alle möglichen Farbkennzahlen aus. Sie werden fast immer bemerken, daß die Hoch- und Tiefpunkte der Kurve nicht mitgezeichnet werden. Das liegt daran, daß unter Verfahren der Berechnung, welches Bit in welchem Byte gesetzt werden soll, noch auf einzelne Bits und nicht die paarweise Verwendung abgestimmt ist. Es gibt zwei Möglichkeiten: Entweder ändert man das Berechnungsverfahren in Zeile 240, um an die richtige Stelle die passenden Bit-Paare zu bekommen, oder wir ändern die Programmzeile 230 zu:<br/>
230 FOR I = 0 TO 319 STEP 2:Y= FNA(X)</p>

<p>Das ist zwar mal wieder etwas primitiv, aber — wie gesagt — sind meine Ambitionen zur Mehrfarben-»Hochauflösung« sowieso nicht so stark. Wer Lust hat, kann sich ja gerne mal mit der korrekten Weise der neuen Berechnungherumschlagen. Das Wissen, diese Aufgabe zu bewältigen, haben Sie jetzt. Auf dem Schwarzweiß-Monitor sieht zum Beispiel folgende Zahlenkombination ganz gut aus:<br/>
Hintergrundfarbe: 7<br/>
Bits 4 bis 7: 5<br/>
Bits 0 bis 3: 1<br/>
Bildschirmspeicher: 0<br/>
Außerdem natürlich noch: I = 2, W=112, B = 1.</p>

<p>Mit dem hier folgenden Abschnitt soll zunächst einmal die hochauflösende Grafik beiseite gelegt werden. Dornröschen ist erwacht und genesen, allerdings noch nicht voll bei Kräften. Das wird in einer späteren Folge noch anders werden. Davor wollen wir aber noch weitere Grafik-Besonderheiten des C 64 behandeln. An dieser Stelle wollen wir jedoch einen Zwischenhalt einlegen und eine kleine Sammlung von Basic-Unterprogrammen zur Grafik-Programmierung vorstellen. In Listing 2 sind diese Grafik-Unterprogramme, in Listing 3 ein Beispiel-Aufrufprogramm abgedruckt. Beim Eintippen beider Programme können Sie die REM-Zeilen ohne Schaden weglassen.</p>

<h3 id="erläuterungen-zu-listing-2-(zeilenbereich-49990-bis-51500)">Erläuterungen zu Listing 2 (Zeilenbereich 49990 bis 51500)</h3>

<h3 id="sprungtabelle:">Sprungtabelle:</h3>

<p>Das ist in Basic im allgemeinen nicht üblich, sondern wird häufiger bei Maschinensprache-Programmen verwendet. Trotzdem hat es auch hier seine Vorteile. Es kann ja sein, daß Sie einige Änderungen oder Ergänzungen in den Unterprogrammen vornehmen wollen. Sie müßten dann auch immer die Adressen in den jeweils aufzurufenden Hauptprogrammen umschreiben. Mit der Sprungtabelle ist das nicht mehr nötig, denn die GOSUB-Adressen im Hauptprogramm bleiben unverändert, nur die neuen GOTO-Adressen im Unterprogramm sind einzusetzen.</p>

<h3 id="hires-an">HIRES an</h3>

<p>Hier machen wir uns die Erkenntnisse dieser Folge zunutze und legen den Bildschirm nach 23552 und die Bit-Map nach 24576. Beides müssen wir — wie gehabt — vor dem Überschreiben durch Basic schützen mit:<br/>
POKE 52,92:POKE 56,92.</p>

<p>Am besten packt man diese POKE-Befehle gleich in die ersten Zeilen des aufrufenden Hauptprogramms.</p>

<h3 id="bit-map-löschen">Bit-Map-Löschen</h3>

<p>Hierzu gibt es nichts mehr zu sagen, außer, daß I als Laufvariable dient.</p>

<h3 id="farbgebung">Farbgebung</h3>

<p>Bevor dieses Unterprogramm aufgerufen wird, müssen im Hauptprogramm<br/>
F1 = Zeichenfarbe und<br/>
F2 = Hintergrundfarbe<br/>
definiert sein. An Variablen treten noch auf:<br/>
F = Farbcodezahle auf Fl und F2<br/>
I = Laufvariable</p>

<h3 id="hires-aus">HIRES aus</h3>

<p>Dieses Programm stellt die ursprüngliche Speicherorganisation wieder her (Bildschirm- und Zeichenspeicher) und schaltet in den Normalmodus zurück.</p>

<h3 id="punkt-setzen">Punkt setzen</h3>

<p>Auch hier müssen vor dem Aufruf des Unterprogramms im Hauptspeicher die<br/>
Punktkoordinaten X,Y<br/>
definiert sein (siehe Bild 3) sowie die<br/>
L — Löschmarke</p>

<p>Wenn L = 0 ist, wird der Punkt gesetzt (Zeile 50930), so, wie wir das schon kennen. Ist L = 1, dann wird ein vorhandener Punkt gelöscht (Zeile 50920).</p>

<p>Die Zeile 50905 achtet darauf, daß keine Punktkoordinate außerhalb des Bildschirms liegt, was unter Umständen ein Aussteigen mit Fehlermeldung im Hochauflösungsverfahren zur Folge hätte. Das ist hier zwar nicht so tragisch, weil man durch Eingeben von GOTO 50030 »RETURN« schnell wieder in den Normalmodus gelangen kann (eventuell muß vorher noch »SHIFT« + »CLR/ HOME« gedrückt werden). Trotzdem ist es dumm, wenn inmitten all dieser zeitraubenden Grafiktätigkeiten auch noch der Rechner aussteigt. Eine Grenzüberschreitung der Koordinaten ist um so leichter möglich, als die Punkt-Routine von allen folgenden Unterprogrammen aufgerufen wird. Außer X,Y und L tauchen noch die Variablen BY und BI auf, die wir schon kennengelernt haben als das Byte, in dem ein Bit zu setzen oder zu löschen ist.</p>

<h3 id="punkt-löschen">Punkt löschen</h3>

<p>Hier geschieht nichts anderes, als die Löschmarke L auf 1 zu setzen und dann in die Punkt-Setz-Routine zu springen. Deswegen gilt für dieses Unterprogramm dasselbe wie für das vorangegangene.</p>

<h3 id="strecke-zeichnen">Strecke zeichnen</h3>

<p>Vor dem Aufruf müssen dem Rechner schon<br/>
der Startpunkt (X1,Y1) und<br/>
der Endpunkt (X2,Y2) der Strecke<br/>
bekannt gemacht sein (siehe Bild 4).</p>

<p>Den mathematisch Versierten wird es bei der Betrachtung der Zeilen 51120 beziehungsweise 51160 schon aufgefallen sein, daß zur Berechnung der Punkte, aus denen sich die Strecke zusammensetzt, die sogenannte 2-Punkte-Form der Geradengleichung verwendet wurde:</p>

<p>YY1 = Y2-Y1 X-X1 X2-X1 TODO</p>

<p>Den mit Mathematik nicht so vertrauten Lesern sei gesagt, daß es sich um eine Formel aus der sogenannten analytischen Geometrie handelt. Das ist ein Gebiet der Mathematik, das für die Grafik auf Computern eine nicht unerhebliche Rolle spielt.</p>

<p>Die Punkte (XI, Y1) und (X2, Y2) dürfen auch außerhalb des Bildschirmsystems liegen. Im ersten Teil des Unterprogramms dient die Übergabevariable X auch gleichzeitig als Laufvariable während Y berechnet wird. Wenn allerdings der Absolutbetrag von X2-X1 kleiner als 5 wird, verkehren sich die Verhältnisse: Y wird Laufvariable und X berechnet. Das beschleunigt das Zeichnen von Senkrechten und verhindert außerdem eine Division durch Null. Der Wert von 5 ist dabei ziemlich willkürlich gewählt. L ist wieder die Löschmarke.</p>

<h3 id="strecke-löschen">Strecke löschen</h3>

<p>Es gilt dasselbe wie für das Unterprogramm Strecke zeichnen, nur daß hier wieder die Löschmarke gesetzt wird.</p>

<h3 id="ellipse-zeichnen">Ellipse zeichnen</h3>

<p>Vor dem Aufruf müssen folgende Werte schon definiert sein (siehe auch Bild 5):<br/>
(XM,YM) = Mittelpunktkoordinaten<br/>
HX = Halbmesser in X-Richtung<br/>
HY = Halbmesser in Y-Richtung<br/>
WU,WO = Der zu zeichnende Ellipsenbogen beginnt beim Winkel WU und endet beim Winkel<br/>
WO (Gradmaß)</p>

<p>Eine volle Ellipse wird also gezeichnet, wenn WU = 0 und WO = 360 ist. Der Kreis ist ein Sonderfall der Ellipse. Dann muß nur HX = HY sein.</p>

<p>Für mathematisch Interessierte: Es werden die Parametergleichungen der Ellipse verwendet:<br/>
X = XM + HX<em>COS(WB) und Y=YM + HX</em> SIN(WB)</p>

<p>Auch hier gibt es keine Einschränkung wie beim Strecken-Zeichnen m der Größe von XM, YM, HX, WU, WO.</p>

<p>W ist eine Laufvariable (ein Winkel) der in WB (gleicher Winkel im Bogenmaß) umgerechnet wird. L ist wieder die Löschmarke.</p>

<h3 id="ellipse-löschen">Ellipse löschen</h3>

<p>Bis auf das Setzen der Löschmarke gilt dasselbe wie für das Zeichnen der Ellipse.</p>

<h3 id="kombination">Kombination</h3>

<p>Erfordert schon definierte Farbkennzahlen F1 und F2 (siehe Farbgebung) und schaltet dann die Hochauflösung an, löscht die Bit-Map und sorgt für die Farbe.</p>

<p>Soweit die Unterprogramme in Listing 2.</p>

<h2 id="ein-beispiel-für-die-möglichkeiten-der-grafik-bibliothek">Ein Beispiel für die Möglichkeiten der Grafik-Bibliothek</h2>

<p>Als ein Beispiel für die Möglichkeiten der Unterprogramm-Sammlung habe ich (ohne nun besonders auf Schönheit zu achten — das sind Sie ja von mir schon gewohnt), noch ein Hauptprogramm angefügt, mit dem Sie etwas herumprobieren können (Listing 3). Das Listing ist ausführlich kommentiert, so daß hier nur wenige Erläuterungen folgen müssen.</p>

<p>Beim Eintippen müssen Sie für einige Zeilen die Abkürzungen (siehe Handbuch Seite 130 ff) der Basic-Befehle eingeben, da die Zeilen sonst länger als 80 Zeichen werden.</p>

<p>Nach »RUN« sehen Sie ein Menü, das alle Möglichkeiten der Grafik-Unterprogramme ansteuert. Die Optionen 8 (Strecke zeichnen) bis B (Ellipse löschen) sowie 4 (Farbgebung) und 5 (Kombinationen) erfordern Eingaben. Es ist daher sinnvoll, diese Optionen nur im Normalmodus anzuwählen. Der Normalmodus ist immer dann zu erreichen, wenn Zeichenoperationen im Hochauflösungsmodus abgeschlossen sind. Drücken Sie dann &ldquo;2', sind Sie wieder im normalen Rechnerbetrieb.<br/>
Sollten Sie durch irgendeinen Umstand (zum Beispiel durch Drücken der »RUN/STOP«-Taste) im Hochauflösungsmodus aus dem Programm fallen, dann hilft der folgende Weg:</p>

<ol>
<li>»SHIFT« + »CLEAR/HOME«</li>
<li>»RUN« »RETURN«</li>
<li>dann »2« eingeben</li>
</ol>


<p>Die Option »C« zeigt eine kleine Demonstration von Möglichkeiten der Grafik-Unterprogramme. Allerdings sollten Sie ein bißchen Zeit mitbringen, wenn Sie C anwählen: Das ganze dauert zirka 25 Minuten.</p>

<p>Option 6 (Punkte zeichnen) ist so eingerichtet, daß 320 Punkte in Form einer Sinus-Funktion gezeichnet und mit Option 7 (Punkte löschen) teilweise wieder gelöscht werden.</p>

<h3 id="ausblicke-—-schnellere-grafik-durch-maschinensprache">Ausblicke — schnellere Grafik durch Maschinensprache</h3>

<p>Diese Folge soll nicht beendet werden, ohne einen kleinen tröstlichen Ausblick. Wie Sie — besonders im letzten Programm — feststellen konnten, braucht man schon einiges Sitzfleisch für hochauflösende Grafik in Basic. Wenn Sie aber ein kommerzielles Grafik-Programm laufen sehen, geht das alles erheblich schneller. Was ist der Unterschied? Da wäre zunächst einmal die Programmiersprache: Unser C 64 kann eigentlich gar kein Basic. Er braucht den Basic-Interpreter, der zunächst jeden Befehl liest und dann in Maschinensprache übersetzt. Die versteht unser Rechner zwar, die Übersetzung und das Lesen dauern jedoch lange Zeit. Eine starke Beschleunigung der Grafik ist möglich durch Programmieren in Maschinensprache. Einige solche Maschinenspracheprogramme zur beschleunigten Grafik werden in den nächsten Folgen gezeigt. Allerdings stoßen wir da bald an die Grenzen unseres Commodore. Ein 8-Bit-Computer mit zirka 1 Megahertz Taktfrequenz wie unser C 64 ist beispielsweise in der Fließkomma-Arithmetik (wie sie für das Zeichnen von Ellipsen nötig ist) zeitlich gehandicapt, und deswegen sind der Geschwindigkeit bei komplexerer Grafik doch einige Grenzen gesetzt.</p>

<p>(Heino Ponnath)</p>

<h1 id="computer-bringen-den-kreislauf-in-schwung">Computer bringen den Kreislauf in Schwung</h1>

<blockquote><p>Der VC 20 und der C 64 werden gerne als Spielzeug abgetan. Der Gegenbeweis liegt vor. Im Institut für Physiologische Chemie in München wurden fünf Commodore bei Untersuchungen im Labor eingesetzt.</p></blockquote>

<p>Gekachelte Wände, kalter Steinfußboden, Neonlicht, auf dem großen, grauen Arbeitstisch in der Mitte des Raumes ein Gewirr von Plastikschläuchen, an Stahlstangen aufgehängt. Große und kleine Plastikflaschen — etwas abseits Meßinstrumente und ein VC 20. Der erste Eindruck: steril und kompliziert — dennoch, der Blick durch die Glastür in dieses Labor der Abteilung Stoffwechselregulation des Instituts für Physiologische Chemie an der Uni München erweckt Neugier.</p>

<p>Franz M. Zwiebel, einer der wissenschaftlichen Mitarbeiter, öffnet einladend die Tür. Drei Schritte bis zu dem dominierenden Schlauchlabyrinth, und es wird noch rätselhafter: In den Schläuchen pulsiert eine klare Flüssigkeit. An dem Tisch sitzt ein junger Mann. Er könnte bestimmt erklären, was sich in dem Schlauchwirrwarr abspielt, wozu dieser Laboraufbau dient. Doch seine hochkonzentrierte Miene läßt keine Frage zu. Offensichtlich hat er überhaupt nicht bemerkt, daß jemand hereingekommen ist. Geduldig und präzise näht er an einem kleinen roten ovalen Etwas, das gut ausgeleuchtet im Scheinwerferlicht vor ihm an den Schläuchen baumelt. Es pulsiert rhythmisch. Erste Assoziation: ein rohes Stückchen Fleisch — nichts für jemanden mit schwachen Nerven. Der junge Mann, Thomas Kapsner, Medizinstudent im sechsten Semester, näht an einem pulsierenden Rattenherz.</p>

<p>Während der ganzen Zeit steht Franz M. Zwiebel schmunzelnd in einer Ecke des Labors. Er kennt die erstaunten und neugierigen Blicke der Outsider. Für ihn ist es Arbeitsalltag, was hier passiert. Wieder draußen auf dem Flur erklärt er: »Wir untersuchen Stoffwechselvorgänge an intakten Tier-Organen. Es ist der beste Weg, verläßliche Angaben über den menschlichen Stoffwechsel zu bekommen. Reagenzglasforschung bringt da nichts. Was Sie eben gesehen haben, ist ein isoliertes Rattenherz, das über einen künstlichen Kreislauf am Leben erhalten wird.« Aha, das leichte Schaudern vorhin war also berechtigt. Und die Schläuche mit der Flüssigkeit stellen den künstlichen Kreislauf dar. Franz M. Zwiebel fährt fort: »Unsere Abteilung erforscht Stoffwechselvorgänge in der Zelle und den Transport von Stoffen über die Zellmembran. Das hört sich sehr kompliziert an, aber im Grunde genommen geht es darum, Wirkungen von Hormonen, anderen körpereigenen Stoffen sowie Medikamenten auf die Spur zu kommen.«</p>

<h2 id="der-vc-20-regelt-den-kreislauf">Der VC 20 regelt den Kreislauf</h2>

<p>Das klingt alles recht einleuchtend, doch was soll der Commodore dabei? Franz Zwiebel schien die Frage erraten zu haben: »Der VC 20 ist für uns ein unentbehrlicher Helfer geworden. Er regelt den künstlichen Kreislauf bei unseren Experimenten. Nehmen wir als Beispiel das Herz. In einem lebenden Organismus pumpt ein Herz—je nach Belastung — unterschiedliche Blutmengen pro Zeiteinheit durch das Gefäßsystem. Dasselbe geschieht auch bei dem isolierten Herz: Mal kontrahiert der Muskel mehr, mal weniger. Folge ist, daß nicht zu jedem Zeitpunkt eine konstante Menge der Flüssigkeit aufgenommen und abgegeben wird. Dieser Flüssigkeit wollen wir eine bestimmte Konzentration des interessierenden Stoffes zusetzen. Um genaue Ergebnisse zu bekommen, muß die zugepumpte Menge der Durchflußgeschwindigkeit angepaßt werden. Schwankungen, die das lebende Organ bewirkt, sind über den Schrittmotor der Infusionspumpen zu regulieren. Und diese Regulation übernimmt der VC 20 für uns. Über eine Meßeinrichtung nimmt er die Menge der Flüssigkeit pro Zeiteinheit auf und bei Abweichungen vom Sollwert weist er den Schrittmotor an, schneller oder langsamer zu arbeiten.«</p>

<h2 id="ohne-computer-geht-nichts">Ohne Computer geht nichts</h2>

<p>Diese Erklärung vermittelt den Eindruck: Ohne Computersteuerung können die Stoffwechsel-Untersuchungen überhaupt nicht durchgeführt werden. Franz M. Zwiebel bestätigt: »Vorher wurden die Werte gemessen, Abweichungen sowie die notwendigen Neueinstellungen des Schrittmotors wurden mit Papier und Bleistift errechnet. Es war schon eine Revolution, als dafür ein Taschenrechner hergenommen werden konnte. Aber trotzdem, ehe man addiert, subtrahiert, dividiert, multipliziert und dann den Motor neu reguliert hatte, war oftmals schon zu viel Zeit vergangen. Eine Reihe von Untersuchungen brauchten erst gar nicht ausgewertet zu werden — die Arbeiten waren aufgrund der zu langen Verzögerungen wertlos.«</p>

<p>In einem anderen Labor läuft gerade ein Versuch mit einer Ratten-Leber. Auch hier wieder der bekannte Versuchsaufbau: Computer Schrittmotor, künstlicher Kreislauf. Mit höchster Aufmerksamkeit perfundiert die medizinisch-technische Assistentin Ursula Schwabe das Tier-Organ; das heißt in genau ausgeklügelten Zeitabständen spritzt sie Hormone ein.</p>

<p>Hier im Institut für Physiologische Chemie werden Grundlagen des Stoffwechsels erforscht. Sie sind Voraussetzung für weitere medizinische Forschungsprojekte. Es kann oft Jahre dauern, bis ein Patient von diesen Erkenntnissen profitiert.</p>

<h2 id="einer-ist-zu-wenig">Einer ist zu wenig</h2>

<p>Ein Computer ist nur ein Tropfen auf den heißen Stein — nach diesem Motto schafften sich die Münchner gleich eine ganze Handvoll dieser Helfer für ihre Abteilung an. Alle gehören der Großfamilie Commodore an: zwei VC 20, ein C 64, ein 64 SX und ein cbm 8032. Auf den Geschmack ist man vor drei Jahren gekommen — kurz nach dem Erscheinen des VC 20 auf dem deutschen Markt wurde er gekauft. Die Ausstattung war damals sehr mager: 5 KByte Arbeitsspeicher. Erst ein Jahr später gab es dann das dringend notwendige Zubehör: Speichererweiterung, Drucker, Laufwerke. Die Software schrieb Franz M. Zwiebel zum großen Teil selbst. Die Computer bewährten sich schnell. Ein Commodore kann nicht nur einen (künstlichen) Kreislauf zuverlässig regulieren, sondern er ist auch ein vortrefflicher »Rechenkünstler« und geduldiger Datenschlucker. Denn zur Auswertung der Daten, die bei den oftmals sehr langfristig angelegten Versuchen anfallen, wird er ebenfalls herangezogen.</p>

<p>Franz M. Zwiebel schildert einen typischen Versuch: »Bei Untersuchungen von schnellen Transportvorgängen über die Zellmembran werden die Rohdaten wesentlich durch drei Faktoren mitbestimmt. Da ist die Größe des Gefäßraums und dessen Verzweigungen zu nennen sowie die Anzahl der Zellen. Wir brauchen aber unbedingt »saubere« Werte, die auch auf andere als die untersuchten Organe übertragbar sind. Es nützt nichts, zu wissen, wie schnellzum Beispiel Milchsäure im Stoffwechsel einer Versuchs-Leber verarbeitet wird, wenn man nicht gleichzeitig Angaben über den Gefäßraum und die übrigen beiden Faktoren machen kann. Deshalb geben wir bei jedem Versuch sogenannte Markierungstoffe in das zu untersuchende Organ, die entsprechende Rückschlüsse zulassen. Eine Substanz zur Markierung des Leber-Gefäßraums ist Zucker, im medizinischen Sprachgerauch Saccharose. Dieser Stoff geht nicht in die Zellen, nur in den Gefäß-Raum. Als Markierung für die Anzahl und Größe der Zellen nehmen wir Harnstoff. Er dringt in die ganze Leber ein. Die Werte für die interessierende Substanz, Milchsäure liegen zwischen den Werten für Saccharose und Harnstoff. Die Interpretation, wie schnell die Milchsäure in der Leber verarbeitet wird, können wir nur in Relation zu diesen Markierungsdaten vornehmen.«</p>

<p>Der Datenanfall pro Versuch ist enorm: bis zu 6000 Daten müssen in einigen Fällen verrechnet werden. Mit den Mikros lassen sich die notwendigen Umrechnungen der Rohdaten und die grafische Darstellung vornehmen. Werden umfangreichere Matrizen- oder Vektorrechnungen gefordert, ist der Commodore nicht mehr zuständig — dann läßt Franz M. Zwiebel die Daten auf dem Großrechner im Leibnitz-Rechenzentrum auswerten. Doch auch dann braucht er einen der Kleincomputer: Der Datentransfer geht über Lochstreifen oder Modem an das Rechenzentrum.</p>

<h2 id="auch-bei-der-ausbildung-hilft-der-computer">Auch bei der Ausbildung hilft der Computer</h2>

<p>Regulation des künstlichen Kreislaufs während eines Versuchs, Auswertung der Daten nach dem Experiment — das sind längst nicht alle Einsatzgebiete der fünf Commodore-Computer. Franz M. Zwiebel verlangt noch ein bißchen mehr: So hat er Berichte- und sonstige Texte auf der Diskette abgespeichert. Die Schreibmaschine als »Textverarbeitungssystem« hat längst ausgedient.</p>

<p>Die Ausbildung von Studenten ist eine weitere Aufgabe, die zum Arbeitsalltag des eifrigen Münchner Forscherteams gehört. Und auch hier hat Franz M. Zwiebel ein sinnvolles Einsatzgebiet für seine Computer gefunden. Bei der Organisation des Unterrichts, der Vorbereitung und Auswertung von Prüfungsaufgaben hilft ihm ebenfalls die Commodore-Familie.</p>

<p>Wunschlos glücklich ist Franz M. Zwiebel aber noch nicht. Er »bastelt« an einer Vernetzung der Computer. Die Materie ist ihm inzwischen hinreichend vertraut — wer sich beruflich so viel mit Mikrocomputern beschäftigt will »der Sache auch auf den Grund gehen«. »Denn alles wird einfacher« prophezeit Franz M. Zwiebel, »wenn der VC 20 und der C 64 auf dieselben Datenbestände zugreifen können«.</p>

<p>(kg)</p>

<h1 id="wettbewerb:-das-schönste-sprite">Wettbewerb: Das schönste Sprite</h1>

<blockquote><p>Viele Leser werden schon auf die Gewinner unseres Wettbewerbs gewartet haben. Hier sind sie, die schönsten Sprites.</p></blockquote>

<p>Sie können sich vorstellen, daß uns eine Entscheidung nicht leichtgefallen ist. Denn es haben sich viele Leser an diesem Wettbewerb beteiligt und ein Sprite sah schöner aus als das andere. Schließlich mußte sich jeder Redakteur vor den Monitor  setzen und zu jedem Sprite seine eigene Beurteilung abgeben. Zum Schluß wurden die Beurteilungen ausgewertet, dann stand der Sieger fest. Das Multicolor Sprite von Ralph Meyer aus Hamburg bekam die meisten Stimmen. Es ist eines der wenigen Sprites, die in Multicolor erstellt wurden und sieht doch recht hübsch aus.</p>

<p>Wenn Sie das beistehende Listing abtippen und das Programm starten, bemerken Sie auch die Liebe fürs Detail, die in jeder Bewegung des kleinen Männchens steckt.</p>

<p>Ähnliches gilt auch für das Motorrad, das Erwin Schaal aus Auenwald schickte. Nur ist es kein Multicolor-Sprite und kam deshalb auf den zweiten Platz. Multicolor Sprites haben zwar den Nachteil, daß die Auflösung des Sprites geringer ist, es wird gröber, aber es ist etwas schwieriger zu programmieren.</p>

<p>Auf eine ganz andere Idee kam Stefan Hübner aus Hannover. Die an sich langweilige Computerschrift läßt sich mit seinem Sprite sehr gut verzieren. Etwa als Anfangsbuchstabe eines Absatzes.</p>

<p>Das verzierte »G» von Gandalf aus dem »Hobbit» brachte ihm den dritten Platz ein.</p>

<h2 id="salomonisches-urteil">Salomonisches Urteil</h2>

<p>Als wir begannen, die Lesereinsendungen zu prüfen und zu bewerten, merkten wir, daß es fast unmöglich sein würde, einen Sieger zu erhalten, dessen Sprite als einziges den Gesamtpreis von 1000 Mark rechtfertigen würde. Zu gering waren die Unterschiede. Deshalb entschieden wir uns für eine gerechtere Verteilung des Gesamtpreises. Der Sieger erhält 350 Mark, der zweite Platz, das Motorrad, fährt mit 200 Mark nach Hause und das hübsche »G« wird mit 100 Mark honoriert. Da die restlichen Sprites unserer TOP-TEN auch sehr hübsch sind und auch nicht wesentlich schlechter ausfallen, beschlossen wir, jedem von ihnen eine Prämie von je 50 Mark zukommen zu lassen.</p>

<p>Dem aufmerksamen Beobachter wird auffallen, daß zwei der abgebildeten Sprites sich von allen anderen unterscheiden. Und zwar sind das der Pumuckl und der Supermann. Diese Sprites sehen zwar sehr schön aus, bestehen aber leider nicht aus einem, sondern aus mehreren Sprites. Deshalb kamen sie auch nicht unter die ersten drei Gewinner. Wir hoffen, daß die Leser und auch die Gewinner mit dieser »salomonischen« Regelung einverstanden sind.</p>

<p>(Die 64’er Redaktion)</p>

<h1 id="impressum">Impressum</h1>

<p>Herausgeber: Carl-Franz von Quadt, Otmar Weber   Chefredakteur: Michael M. Pauly (py)<br/>
Stellv. Chefredakteur: Michael Scharfenberger (sc)<br/>
Redakteure: aa = Albert Absmeier, leitender Redakteur (130), ev = Volker Everts (278), kg = Karin Gößlinghoff (269), gk = Georg Klinge (130), rg = Christian Rogge (278)<br/>
Redaktionsassistenz: Dagmar Zednik (237)<br/>
Fotografie: Janos Feister, Titelfoto: Alex Kempkens  Layout: Leo Eder (Ltg.), Willi Gründl, Walter Höß, Cornelia Weber    Auslandsrepräsentation:<br/>
Schweiz: Markt&amp;Technik Vertriebs AG, Alpenstrasse 14, CH-6300 Zug, Tel. 042-22 3155/56, Telex: 8 62 329 mut ch<br/>
USA: M&amp;T Publishing, 2464 Embarcadero Way, Palo Alto, CA 94303; Tel. 001-4240 600; Telex 752 351     Manuskripteinsendungen: Manuskripte und Programmlistingswerden gerne von der Redaktion angenommen. Sie müssen frei sein von Rechten Dritter. Sollten sie auch an anderer Stelle zur Veröffentlichung oder gewerblichen Nutzung angeboten werden, so muß dies angegeben werden. Mit der Einsendung von Manuskripten und Listings gibt der Verfasser die Zustimmungzum Abdruck in von der Markt &amp; Technik Verlags AG herausgegebenen Publikationen und zur Vervielfältigung der Programmlistings auf Datenträger. Honorare nach Vereinbarung. Für unverlangt eingesandte Manuskripte und Listings wird keine Haftung übernommen.<br/>
Herstellung: Klaus Buck (180), Leo Eder (181)    Anzeigenleitung: Peter Schrödel (156)<br/>
Anzeigenverkauf: Alfred Reeb (211)<br/>
Anzeigenverwaltung und Disposition: Michaela Hörl (171)<br/>
Anzeigenformate: 1/1-Seite ist 266 Millimeter hoch und 185 Millimeter breit (3 Spalten TODO 58 mm oder 4 Spalten TODO 43 Millimeter). Vollformat 297x210 Millimeter. Beilagen und Beihefter siehe Anzeigenpreisliste.    Anzeigenpreise: Es gilt die Anzeigenpreisliste Nr. 1 vom 1. März 1984.<br/>
Anzeigengrundpreise: 1/1 Seite sw: DM 7400,- Farbzuschlag: erste und zweite Zusatzfarbe aus Europaskala je DM 1000,- Vierfarbzuschlag DM 3000,- Plazierung innerhalb der redaktionellen Beiträge: Mindestgröße 1/1-Seite<br/>
Anzeigen im Einkaufs-Magazin: Die ermäßigten Preise im Einkaufs-Magazin gelten nur innerhalb des geschlossenen Anzeigenteils, der ohne redaktionelle Beiträge ist. 1/1-Seite sw: DM 5400,- Farbzuschlag: erste und zweite Zusatzfarbe aus Europaskala je DM 1000,- Vierfarbzuschlag DM 3 000,- Anzeigen in der Fundgrube: Private Kleinanzeigen mit maximal 5 Zeilen Text DM 5,- je Anzeige. Gewerbliche Kleinanzeigen: DM 10,- je Zeile Text.<br/>
Auf alle Anzeigenpreise wird die gesetzliche MwSt, jeweils zugerechnet.<br/>
Vertriebsleitung, Werbung: Hans Hörl (114)<br/>
Vertrieb Handelsauflage: Inland (Groß-, Einzel- und Bahnhofsbuchhandel) sowie Österreich und Schweiz: Pegasus Buch- und Zeitschriften-Vertriebs GmbH, Plieninger Straße 100, 7000 Stuttgart 80 (Möhringen), Telefon (0711) 7 20 04-0     Erscheinungsweise: 64’er, Magazin für Computerfans, erscheint monatlich, Mitte des Vormonats.    Bezugsmöglichkeiten: Leser-Service: Telefon 089/46 13-1 19. Bestellungen nimmt der Verlag oderjede Buchhandlung entgegen. Das Abonnement verlängert sich zu den dann jeweils gültigen Bedingungen um ein Jahr, wenn es nicht zwei Monate vor Ablauf schriftlich gekündigt wird.     Bezugspreise: Das Einzelheft kostet DM 6,- Der Abonnementspreis beträgt im Inland DM 72,- pro Jahr für 12 Ausgaben. Darin enthalten sind die gesetzliche Mehrwertsteuer und die Zustellgebühren. Der Abonnementspreis erhöht sich um DM 18,- für die Zustellung im Ausland, für die Luftpostzustellung in Ländergruppe 1 (z.B. USA) um DM 38,-, in Ländergruppe 2 (z.B. Hongkong) um DM 58,-, in Ländergruppe 3 (z.B. Australien) um DM 68,-   Druck: Druckerei E. Schwend GmbH, Schmollerstr. 31, 7170 Schwäbisch Hall<br/>
Urheberrecht: Alle im »64'er« erschienenen Beiträge sind urheberrechtlich geschützt. Alle Rechte, auch Übersetzungen, vorbehalten. Reproduktionen gleich welcher Art, ob Fotokopie, Mikrofilm oder Erfassung in Datenverarbeitungsanlagen, nur mit schriftlicher Genehmigung des Verlages. Anfragen sind an Klaus Buck zu richten. Für Schaltungen und Programme, die als Beispiele veröffentlicht werden, können wir weder Gewähr noch irgendwelche Haftung übernehmen. Aus der Veröffentlichung kann nicht geschlossen werden, daß die beschriebenen Lösungen oder verwendeten Bezeichnungen frei von gewerblichen Schutzrechten sind. Anfragen für Sonderdrucke sind an Klaus Buck zu richten.          © 1984 Markt &amp; Technik Verlag Aktiengesellschaft,<br/>
Redaktion »64’er«.<br/>
Verantwortlich: Für redaktionellen Teil: Michael M. Pauly.<br/>
Für Anzeigen: Peter Schrödel.      Vorstand: Carl-Franz von Quadt, Otmar Weber     Anschrift für Verlag, Redaktion, Vertrieb, Anzeigenverwaltung und alle Verantwortlichen:<br/>
Markt&amp;Technik Verlag Aktiengesellschaft, Hans-Pinsel-Straße 2,<br/>
8013 Haar bei München, Telefon 0 89/4613-0, Telex 5 22 052  Mitteilung gem. Bayerischem Pressegesetz: Aktionäre, die mehr als 25% des Kapitals halten: OtmarWeber, Ingenieur, München; Carl-Franzvon Quadt, Betriebswirt, München. Aufsichtsrat: Dr. Robert Dissmann (Vorsitzender), Karl-Heinz Fanselow, Hans-Jochen Wolf, Eduard Heilmayr.<br/>
Telefon-Durchwahl im Verlag:<br/>
Wählen Sie direkt: Per Durchwahl erreichen Sie alle Abteilungen direkt. Sie wählen 089-4613 und dann die Nummer, die in Klammern hinter dem jeweiligen Namen angegeben ist.</p>

<h1 id="vorschau:-64er-im-august">Vorschau: 64er im August</h1>

<h2 id="testbericht-ism-64">Testbericht ISM 64</h2>

<p>ISM 64 ist ein Hilfsprogramm für Programmierer zur Erstellung von Datei-Verwaltungsprogrammen. Für wen sich dieses Programm eignet, was man bei der Programmierung beachten muß und was es leistet, ist in einem mehrmonatigen Test festgestellt worden.</p>

<h2 id="drei-sprachen-im-vergleich">Drei Sprachen im Vergleich</h2>

<p>Pascal, Forth, Basic – drei bekannte Programmersprachen. Wo liegen die Stärken dieser Sprachen, wie schnell und effizient laufen die Programme? Was nützt ein Basic-Compiler?<br/>
Ein Vergleichstest auf der Basis von Benchmark-Programmen gibt darüber Auskunft.</p>

<h2 id="eprom-brenner">EPROM-Brenner</h2>

<p>Sind EPROMs eine Alternative zum Floppy-Laufwerk? Was EPROM-Brenner leisten, was sie kosten und wie man mit ihnen umgeht, haben wir getestet.</p>

<h2 id="sequentielle-dateien">Sequentielle Dateien</h2>

<p>Nachdem wir Ihnen die relativen Dateien erläutert haben, stellen wir in der nächsten Ausgabe die sequentiellen Dateien vor.</p>

<h2 id="das-diskettenlaufwerk-vc-1541-durchleuchtet">Das Diskettenlaufwerk VC 1541 durchleuchtet</h2>

<p>Wie sieht das Floppy-Laufwerk von innen aus, wie funktioniert überhaupt ein Floppy-Laufwerk und wie kann man eventuell anfallende Reparaturen selbst erledigen? Auf diese und noch weitere Fragen werden wir versuchen eine Antwort zu geben.</p>

<h2 id="modem-und-akustikkoppler">Modem und Akustikkoppler</h2>

<p>Welche Akustikkoppler und Modem auf dem deutschen Markt erhältlich sind, ob sie von der Post zugelassen sind und was sie kosten, wird Ihnen unsere Marktübersicht zeigen. Außerdem werden einige neue Akustikkoppler getestet.</p>

<h2 id="paint-magic">Paint Magic</h2>

<p>Bilder malen im Computerzeitalter: Der Bildschirm ersetzt die Leinwand, der Joystick den Pinsel und die Tastatur die Farbpalette. Wir haben eines der eindrucksvollsten Mal- und Zeichenprogramme getestet. Wie ist die Handhabung, welche Qualität hat die Bildschirmdarstellung, sind Vorkenntnisse im Zeichnen erforderlich? Unser ausführlicher Bericht zeigt die vielfältigen kreativen Möglichkeiten, die sich mit »Paint Magic« auftun.</p>

<h2 id="der-vc-20-videochip">Der VC 20-Videochip</h2>

<p>Im VC 20 steckt doch mehr, als das Handbuch zugeben will. Wir zeigen nicht nur, wie man hochauflösende Grafik programmiert und sich eigene Zeichensätze erstellt, sondern bringen auch Anregungen, um andere wenig bekannte Eigenschaften des VIC-Chips zu nutzen. Erstellen Sie sich zum Beispiel Ihr eigenes Bildschirmformat oder schalten Sie doch zwischen mehreren Bildschirmbereichen hin und her. Besonderer Leckerbissen: Listing einer Grafikhilfe in Maschinensprache.</p>

<h2 id="listings">Listings</h2>

<ul>
<li><b>Anwendung des Monats</b><br>Ein Fakturierungsprogramm für Selbständige</li>
<li><b>Listing des Monats</b><br>Castle of Doom – ein Abenteuerspiel</li>
<li>Durch die Kopplung von zwei C 64 einen fünfstimmigen Synthesizer realisieren</li>
<li>Programmumwandlung von den älteren Commodore-Computern auf den C 64 und umgekehrt</li>
<li>View Bam: optische Darstellung der Sektorenbelegung auf der Diskette</li>
<li>Der Nachwuchs von Pacman ist da: Pacboy auf dem C 64</li>
<li>und natürlich wieder viele Tips und Tricks für den VC 20 und C 64</li>
</ul>
