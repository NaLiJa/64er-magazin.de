
# Abenteuer total \[3]

> Warum haben Abenteuerspiele in der letzten Zeit einen immer größer werdenden Anhängerkreis gefunden? Weil sie logisches Denkvermögen, Fantasie, Ausdauer und Kreativität fördern und fordern. Abenteuerspiele sind wie geschaffen für den Heimcomputer, oder besser, wurden erst durch diesen möglich. Gründe genug, um ein ganzes Sonderheft dieser Kategorie der Freizeitbeschäftigung mit dem Computer zu widmen.

Im Gegensatz zu Schieß-, Action-, Arcade- oder Sportspielen, bei denen hauptsächlich die motorischen Fähigkeiten des Spielers gefragt sind und die schon nach relativ kurzer Zeit eine gewisse Monotonie hervorrufen, fesseln interessante Adventures oft über Monate hinweg. Sie schlüpfen dabei in die Rolle eines Schatzsuchers, Piraten, Archäologen, Forschers, Weltraumreisenden, Ritters oder Prinzen. Vielfältige Gefahren lauern auf Sie: feuerspeiende Drachen, hinter-hältigeZwerge, feindlicheGalaxienbewohner, heimtückische Fallen, verschrobene Professoren, undurchdringliche Urwälder, rätselhafte Schlösser, hungrige Ureinwohner oder einfach verbohrte Mitspieler.

All denen gilt es Paroli zu bieten. Begeben Sie sich mit uns in die faszinierende Welt der computerisierten Abenteuer.

Dazu haben wir dieses Sonderheft in vier Abschnitte unterteilt:

* ein kompletter Kurs zur Programmierung eigener Abenteuerspiele,
* sieben fertige Abenteuerlistings zum Abtippen,
* viele Lösungen zu professionellen Abenteuerspielen
* und allgemeine Hinweise, wie Abenteuerspiele zu lösen sind.

Der Kurs ist sowohl für Anfänger als auch Profis geeignet. Es wird Ihnen schrittweise gezeigt, wie Sie eigene Ideen für ein Abenteuerspiel finden, diese ausfeilen, an die konkrete Ausarbeitung herangehen, die Ideen in kompakte Programmmodule umsetzen und schließlich ein vollständiges Adventure selbst programmieren.

Es werden dabei einige sehr interessante Programmiertechniken vermittelt, die Sie unter anderem mit der Stringverarbeitung, der Analyse ganzer Sätze, dem modularen Aufbau eines Programms und der bool’schen Algebra vertraut machen sollen. Als Autor dieses Grundkurses konnten wir den Entwickler des deutschen Abenteuerspiels Gordon Saga gewinnen. Er plaudert aus seiner Trickkiste der Abenteuerspiel-Programmierung. Wenn Sie den Adventure-Kurs gründlich durchgearbeitet haben, sind Sie in der Lage, selbst gute Abenteuerspiele zu programmieren. Voraussetzungen sind nur Grundkenntnisse in Basic und die Bereitschaft, das Gelernte in die Tat umzusetzen.

Gleichsam als Anschauungsmaterial werden im zweiten Teil sieben Abenteuerspiele zum Abtippen geliefert. Darunter befindet sich auch Zauberschloß, das erste in Deutschland veröffentlichte Abenteuerlisting. Die restlichen sechs Adventures sind bisher unveröffentlichte Listings der Spitzenklasse. »Odyssee — Kampf der Bruderschaft« fällt etwas aus der Reihe. Es handelt sich dabei um ein Rollenspiel, eine Untergruppe der Adventures. Doch lassen Sie sich überraschen. Diese Listings wurden unabhängig vom Kurs entwickelt, jedes hat seine spezifischen Stärken und Schwächen. Durch genauen Vergleich des im Kurs Gelernten, und dem in den Listings Realisierten, können Sie die Vorteile der unterschiedlichen Methoden für eigene Programmeverwen-den.

Alle Listings, sowohl die des Kurses, als auch die Abenteuerspiele sind mit einer speziellen Prüfsumme versehen, wie Sie sie bereits vom 64’er Stammheft kennen. Dadurch reduziert sich die Fehlerquote beim Eintippen erheblich. Lesen Sie sich also vor dem Eintippen irgendwelcher Listings den Artikel über den Checksummer 64 aufmerksam durch.

Der dritte und vierte Teil des Sonderheftes »Abenteuerspiele« wendet sich an die oft verzweifelten Besitzer von käuflich erworbenen, professionellen Adventures. Nun hat man sich also »Gruds in Space« oder »Ultima III« besorgt, und kommt und kommt einfach an einer bestimmten Stelle nicht weiter. Auch Freunde oder Bekannte, die das selbe Spiel besitzen, können nicht helfen. Für all jene, die entnervt, mit zerwühltem Haar, der Verzweiflung und dem Aufgeben nahe, seit Monaten vor dem Adventure sitzen, haben wir im dritten AbschnittSchritt-für-Schritt-Lösungen von bekannten Abenteuerspielen gesammelt. Wie diese Lösungen eingesetzt werden, bleibtjedem selbst überlassen. Er kann sie in einem durchspielen, dann ist der Reiz ein für allemal weg, oder er nimmt sie her, um über eine für ihn besonders heikle Stelle hinwegzukommen, und dann denn Rest des Weges wieder allein zu gehen, oder es zumindest zu versuchen. Der vierte Abschnitt gibt dazu wertvolle, allgemeine Tips.

### Für wen ist dieses Sonderheft gedacht?

Sicher für alle, die sich sowieso für Abenteuerspiele interessieren. Aber auch jenen, die bisher mit einer gewissen Skepsis dieser Sorte von Spielen gegenüberstanden sei wärmstens empfohlen, einmal »reinzuriechen«. Dann natürlich für alle, die zwar Adventures gerne spielen, aber noch nie daran gedacht haben, selbst welche zu programmieren. Vielleicht kommen Sie durch dieses Sonderheft auf den Geschmack.

### Welche weiteren Sonderhefte sind geplant?

Die 64’er-Redaktion macht die Sonderhefte nicht auS »Spaß an der Freud’«, sondern weil derWunsch einer komprimierten Abhandlung über ein bestimmtes Thema von vielen Lesern geäußert wurde. Bei uns bestimmen Sie, was im 64’er Stammagazin erscheint, und welche Schwerpunkte als Sonderheft in allen Details behandelt werden sollen. Daher der Aufruf an alle Leser: Teilen Sie uns Ihre Vorstellungen über die nächsten Sonderhefte mit. Sie entscheiden, über welches Thema, sei es nun Drucker, DFÜ, Spiele, Massenspeicher (Diskettenlaufwerkund Datasette), Anwendungsprogramme, Grafik, Musik, Tips & Tricks, Hardware-Erweiterungen, etc., wir das nächste Sonderheft machen werden.

(aa)

TODO ASIDE

## Listing-Service

Auch an die Leser, die zu wenig Zeit oder Geduld zum Abtippen der oft sehr umfangreichen Listings haben, wurde wieder gedacht. Alle Listings (Kurs und Abenteuerspiele) sind auch auf Diskette erhältlich.

Bitte verwenden Sie für Ihre Bestellung die beigefügte Postscheck-Zahlkarte zur Überweisung des Rechnungsbetrags. Sie erleichtern uns die Auftragsabwicklung und Sie **sparen** sich die **3,— DM** Versandkosten!

**Bestell-Nr.: L685 S2 / DM 34,90**


# Abenteuer selbst programmiert \[7]

> Abenteuerspiele auf dem Commodore 64 gehören mittlerweile zu den beliebtesten Freizeitbeschäftigungen mit einem Computer. Dieser Kurs wird Sie in die Lage versetzen, nahezu professionelle Abenteuerspiele selbst zu programmieren.' Alles was Sie brauchen ist ein bißchen Basic-Erfahrung, gute Ideen, viel Fantasie und Spaß am Programmieren.

Eine unheimliche Stille liegt in der Luft...

Sie befinden sich in einem großen Raum, in dessen Mitte auf dem kalten Steinboden ein kleiner roter Teppich liegt, Eine kleine Fackel, die an der Wand in einer Halterung steckt, beleuchtet den Raum nur spärlich. Am Boden liegt ein zwei Meter langes stabiles Holzbrett.

Während Sie sich umschauen, fällt plötzlich ein schweres Eisenfallgitter hinter Ihnen herunter und versperrt den einzigen Ausgang.

Alle Ihre Versuche, das Fallgitter zu heben oder einen geheimen Ausgang zu finden, scheitern. Mit großem Schrecken vernehmen Sie plötzlich ein lautes Rattern — die Zimmerdecke bewegt sich langsam, aber sicher nach unten. Erst jetzt bemerken Sie die spitzen Eisenstangen, die von der Decke herunterragen. Sie erinnern sich sofort an den Zauberring, den ein Monster verloren hatte, nachdem Sie es getötet hatten. Sie greifen in Ihre Tasche, holen den Ring heraus und stecken ihn sich an den Finger. Sie drehen den Ring mit der Hoffnung, daß er Sie durch seine Zauberkraft befreien kann, aber es passiert nichts. Inzwischen hat sich die Decke bis auf etwa drei Meter Höhe gesenkt! Ihr nächster Gedanke ist das stabile Brett, Sie klemmen es zwischen Boden und Decke. Sie atmen auf, als Sie feststellen, daß das Brett die Decke, jedoch nicht das Rattern zum Stillstand bringt. Aber ihre Freude hat ein schnelles Ende, als das Brett dem ungeheueren großen Druck der Decke nachgibt und zerbricht. Die Decke ist nun so weit unten, daß Sie nicht mehr aufrecht stehen können. In letzter Sekunde kommt Ihnen schließlich der rettende Gedanke: Sie stürzen auf den kleinen roten Teppich zu...

Dies könnte eine von vielen Action-Szenen eines Abenteuerspiels sein, wie Sie es vielleicht schon bald selbst schreiben werden.

Was ist ein Abenteuerspiel oder englisch »Adventure« eigentlich? Eine einfache Antwort hierfür wäre zum Beispiel: »Das Gegenteil von einem Ballerspiel.« Während bei dem »Baller-«, »Weltraum-« oder »Grafik-« Action-Spiel flinke Finger und ein starrer Blick zum Bildschirm nötig sind, bezieht sich ein Adventure mehr auf scharfen Verstand.

Wer ein Adventure spielen will, muß viel Fantasie und Einfühlungsvermögen mitbringen. Bei einem Adventure stellt der Computer ein Fenster in eine andere Welt dar, deren Grenzen und Gesetze vom Programmierer gesetzt werden.

Am besten läßt sich das Prinzip eines Abenteuerspiels anhand eines Rollenspiels erklären.

Diese Rollen- beziehungsweise Fantasierollenspiele sind besonders in England unter dem Titel Dungeons & Dragons (Höhlen und Drachen) verbreitet. Diese Rollenspiele können sich manchmal über ein ganzes Wochenende hinziehen.
Wie ist solch ein Rollenspiel aufgebaut?

Da gibt es zum einen den Dungeon-Master (Höhlenmeister). Dieser ist der Ersteller des Spiels und somit auch der Spielleiter. Den einzelnen Spielern werden Charaktere wie Zauberer, Fee oder Zwerg etc. zugeteilt.

Außerdem gibt es Nichtspielercharaktere, Dies sind zum Beispiel Monster und Kreaturen, die in dem Spiel auftreten: auch sie werden vom Höhlenmeister gelenkt. Der Höhlenmeister ist der absolute Schiedsrichter. Er verteilt während des Spiels die Punkte. Falls sich im Spiel eine besondere Situation ergibt, so muß er improvisieren, um den Spielern gerecht zu werden.

Dies fordert besonders große Fantasie und Ideenreichtum von ihm. Ein Rollenspiel könnte folgendermaßen ablaufen:

Höhlenmeister: Ihr befindet euch in einer großen, trockenen Höhle mit Fackeln an den Wänden. Was macht ihr jetzt?

Die Spieler beraten sich nun.

Sprecher der Spieler: Wir untersuchen die Höhle genauer. Der Höhlenmeister schaut nun in seinen Plänen und Notizen nach, ob in der Höhle sonst noch etwas zu finden ist.

Höhlenmeister: Ihr entdeckt eine Geheimtür, Was nun?
Die Spieler beraten sich.

Sprecher der Spieler: Wir öffnen die Tür und lassen unseren stärksten Mann vorausgehen.

An diesem Beispiel können Sie die Aufgaben des Höhlenmeisters erkennen. Unser Ziel soll nun sein, den Computer als Höhlenmeister arbeiten zu lassen. Hierzu geben wir ihm Pläne, Tabellen etc., aus denen er ersehen kann, welche Antworten er uns geben soll.

Das Problem hierbei ist, daß der Computer auch ein wenig an den Plänen, die wir ihm geben, manipulieren und während des Spiels improvisieren soll, damit keine Langeweile beim Spieler aufkommt.

Bevor wir uns an dieses Problem wagen, müssen wir lernen, wie man Pläne erstellt, also wie man sich ein Spielkonzept ausdenkt.

Sie können Ihren Computer also ruhig ausschalten, sich in einen bequemen Sessel zurücklehnen und aufmerksam die folgenden Kapitel lesen...

## 1. Kapitel:<br>Die Speicher-Grenzen oder wieviel Abenteuer paßt in den C64 ?

Im Prinzip gibt es nur zwei Faktoren, die uns beim Erstellen von Abenteuerspielen einschränken: Zum einen die Grenzen unserer Fantasie und zum anderen die Speicherkapazität unseres C64.

Wieviel Abenteuer paßt in 38 KByte? Mit dieser Frage wollen wir uns nun einmal beschäftigen.

Vorweg möchte ich jedoch sagen, daß Sie Ihre Fantasie niemals aus Angst vor Speicherplatzmangel einschränken sollten.

Sollten Sie die Idee zu einem gigantischen Spiel haben, dann kürzen Sie es keinesfalls so lange, bis es in den C64´er paßt. Teilen Sie es lieber in mehrere Programme auf, die nacheinander geladen und gespielt werden. Die Antwort auf die Frage hängt hauptsächlich von der Art des Spiels ab. Wir unterscheiden folgendermaßen:

a) Spiele mit überwiegend Grafik (Grafik-Adventure)

b) Spiele mit überwiegend Text (Text-Adventure)

Bei Grafikabenteuerspielen findet man für jeden Raum ein Bild. Unter diesem Bild ist ein kleines Textfenster zur Befehlseingabe, ein Beispiel hierfür wäre das Adventure »Zauberschloß« von Happy Software. Bei Textabenteuerspielen findet man anstelle von Bildern lange Texte, die jeden Raum aus-führlich beschreiben — das Bild entsteht also in der Fantasie des Spielers, der den Text liest.

Als ich mein erstes Adventure schrieb, war ich besonders darauf aus, viele Räume zu haben, weil ich dachte, daß dies für ein sehr gutes Adventure unbedingt notwendig sei. Ich bemerkte jedoch bald, daß ich hier völlig falsch lag — das Resultat war ein Spiel mit 200 (9 Räumen, aber kaum Action. Alles was man konnte, war herumlaufen und laufen und laufen. Auch die Befehlsanalyse, auf die ich in einem später folgenden Kapitel ausführlich zu sprechen kommen werde, war viel zu knapp geraten.

Wir wollen unsere anfänglich gestellte Frage deshalb nun erweitern: Wie sieht ein gutes Adventure aus, und wie bringt man es auf 38 KByte? Das Wesentliche an jedem Adventure, das letztendlich auch über dessen Qualität entscheidet, ist der Komfort der Befehlseingabe und deren Analyse. Damit hängt natürlich auch der Wortschatz des Spiels zusammen. Damit es nun nicht zu kompliziert wird, ein Beispiel:

Wir stellen uns einfach ein Abenteuerspiel des Titels X vor.

Wenn X einen Befehl erwartet, fragt es »WAS NUN?«.

Wir geben nun folgendes ein: »Nimm Schwert«.

X antwortet uns: »Sie nehmen das Schwert«.

Geben wir jedoch »Nimm das Schwert« ein, so antwortet X: »Ich kenne (das) nicht.« oder »Sie können (das) nicht nehmen« oder einfach »Das geht nicht«. etc.

Was haben wir nun falsch gemacht?
Für uns ist »Nimm Schwert« und »Nimm das Schwert« gleichermaßen verständlich, obwohl »Nimm das Schwert« besseres Deutsch ist.

Warum versteht uns der Computer jedoch nicht?
Ganz einfach — Die Befehlsanalyse von X sieht so aus:

X versteht nur Befehle, die aus zwei Worten – VERB + OBJEKT bestehen.

Wenn wir also »Nimm das Schwert« eingeben, so nimmt X an, daß das Wort »das« das Objekt des Befehls ist.

X sieht in seiner Objekttabelle nach und kann »das« nicht finden.

X versteht den Befehl also nicht!
 
### Spiel ohne Grenzen

Sie sehen also, was mit guter Befehlsanalyse gemeint ist: Das Spiel soll Sätze wie »Nimm das Schwert, den Ring und das Brett und gehe nach Norden« verstehen. Hierauf werden wir später zurückkommen.

Ein weiteres Kriterium für ein gutes Spiel ist das folgende: Der Spieler sollte viel mehr Möglichkeiten haben, als nur Gegenstände zu nehmen, zu verlieren und herumzulaufen. Gute Spiele müssen so viele Möglichkeiten bieten, daß der Spieler kaum an die Grenzen des Spiels stößt. Es ist nämlich äußerst frustrierend, wenn man ständig eine Antwort wie »Ich verstehe das nicht« nach einer Befehlseingabe erhält.

Wenn wir ein gutes Adventure-Programm schreiben wollen, so müssen wir dem Spieler die Möglichkeit bieten, sich nach Lust und Laune in unserer Abenteuerwelt auszutoben, auch dann, wenn der Spieler etwas macht, das mit der Lösung des Spiels kaum etwas zu tun hat.

Stellen wir uns einmal einen Raum vor, in dem eine große Kiste und ein Fenster ist.

Wir sollten dem Spieler dann folgende Dinge ermöglichen:

- Er kann die Kiste öffnen und schließen (wenn wir wollen, muß er dafür einen Schlüssel haben).
- Er kann Gegenstände in die Kiste legen. Er kann die Kiste mitnehmen, falls sie nicht zu schwer ist.
- Er kann sich in der Kiste verstecken (falls sie groß genug ist).
- Er kann die Kiste verschieben, wenn sie zu schwer zum Tragen ist.

Aber Achtung: Der Spieler kann nur in die Kiste gehen, wenn alle Gegenstände, die er hat, mit in die Kiste passen. Ansonsten muß er sie vorher ablegen.

- Er kann das Fenster öffnen und schließen sowie hinaussehen.
- Er kann aus dem Fenster springen, wenn ihm das Spiel zu langweilig wird, oder aus Angst vor einem Monster, das den Raum betritt.

Sie sehen also, wie viele Möglichkeiten in der Ausgangssituation (Kiste und Fenster) stecken. Falls die Kiste enorm groß ist, dann kann der Spieler sich vielleicht sogar mit einer Prinzessin, die er kurz zuvor gerettet hat, in ihr verstecken...

Stichwort »Prinzessin« — Wie Sie sehen, sind lebendige Personen in einem guten Adventure nicht fehl am Platz.

Allerdings ist es langweilig, wenn man nur auf Taubstumme trifft. Wenn Personen im Spiel vorkommen, so sollten sie mehr können, als nur herumstehen oder wortlos hinter dem Spieler herrennen. Ein Spiel, welches ein gutes Beispiel im Bezug auf »selbstdenkende« Spielcharaktere abgibt, ist das englische Adventure »The Hobbit« von Melbourne House. Wer dieses Spiel kennt (wahrscheinlich jeder Adventure Freak), weiß, was Thorin, Gandalf, Elrond, Bard, der Butler oder Smaug, der Drache, im Spiel alles selbständig treiben. Leider ist beim Hobbit auch einiges zu kritisieren:

Sagt man seinem Freund Elrond »Lies die Karte«, so kann es manchmal vorkommen, daß dieser einfach nein sagt. Auch kann es passieren, daß man von Monstern gefangen wird und dann auf die Rettung durch einen Freund wartet - manchmal kommt dieser jedoch nicht.

Wir können also nun zusammenfassen, was ein gutes Adventure auszeichnet.

1. Der Spieler sollte so viele (auch unsinnige) Möglichkeiten haben, daß ihm so wenig wie nur irgend möglich auffällt, daß das Spiel Grenzen hat.
2. Das Spiel muß einen großen Wortschatz und eine großzügige Befehlsanalyse haben — das heißt, das Spiel soll nicht Worte allein erkennen, sondern den Sinn eines Satzes verstehen.
3. Das Spiel sollte zu jedem Raum einen ausführlich beschreibenden Text haben. Grafiken sollten diesen Text ab und zu unterstützen — es sollte jedoch nicht so sein, daß ein Spieler erst rätseln muß, was die Grafik darstellt, bevor er den Sinn erkennt. Grafiken sind nur Ergänzungen zu einem guten Text — sie können ihn nicht völlig ersetzen.
4. Wenn im Spiel Personen (Charaktere) auftreten, so sollten sie auch einen eigenen Willen haben, sowie sprechen und verstehen können. Dadurch besteht die Möglichkeit, eine lebendige Adventure-Welt zu erbauen und nicht eine tote, in der nur der Spieler umherläuft.

Nehmen wir als Beispiel noch einmal den Raum mit der Kiste und dem Fenster:

Angenommen, ein selbstdenkender Spielcharakter, wie ein Geist, kommt in diesen Raum, so hat er genau dieselben oder ähnliche Möglichkeiten wie der Spieler, wenn er sich in diesem Raum befindet.
Wir spinnen einmal weiter...

Angenommen, ein Geist betritt den Raum mit der Kiste (der Spieler ist gerade woanders).

Der Geist sieht also die Kiste und beschließt, sich in dieser zu verstecken. Er öffnet die Kiste also, geht hinein und schließt sie von innen. Wenn der Spieler nun in den Raum kommt, so bieten sich jetzt viele neue Möglichkeiten.

a) Der Spieler öffnet die Kiste:

- Der Geist erschreckt und flieht.
- Der Geist erschreckt den Spieler zu Tode.
- Die Kiste ist leer. Warum? Ganz einfach dem Geist ist es zu langweilig in der Kiste geworden und er hat sie wieder verlassen, bevor der Spieler den Raum betreten hat, und ist nun bereits in einem anderen Raum.

b) Der Spieler öffnet die Kiste nicht, bleibt aber im Zimmer:

- Der Geist kommt aus der Kiste heraus...
- Der Spieler hört plötzlich ein Schluchzen und Weinen. Warum? Ganz klar, der dumme Geist hat sich selbst in der Kiste eingeschlossen, beziehungsweise diese ist zugeschnappt, er ist gefangen und bittet Sie, ihn herauszulassen.<br>Der Spieler hilft dem Geist:<br>I.	Der Geist belohnt den Spieler großzügig<br>II. Der böse Geist tötet den Spieler trotzdem

c) Der Spieler gibt dem Geist einen Kuß:

- Es passiert nichts.
- Der Geist verschwindet empört.
- Abrakadabra — der Geist war gar kein Geist, sondern eine atemberaubend hübsche, verzauberte Prinzessin (Ist die Kiste enorm groß?).

d) Der Spieler öffnet die Kiste und erwischt den Geist beim Flirten mit einer Hexe.

Sie sehen also, wie viele Möglichkeiten in der Situation »Kiste, Fenster, Geist und Spieler« stecken, und es gibt noch tausende mehr.

Sicherlich haben Sie schon eigene Ideen ausgeheckt — was beweisen würde, daß Sie bereits Fortschritte machen.

Falls Sie noch Anregung benötigen, so stellen Sie sich einfach noch eine zusätzliche Person zu unserer Ausgangssituation vor.

Was passiert,

- wenn der Spieler auf diese Person trifft?
- wenn diese Person auf den Geist trifft?
- wenn sich die Person (zum Beispiel Hexe) und der Geist verbünden und gemeinsam gegen den Spieler vorgehen?

Nun aber vorerst genug des Geredes über Geister, Kisten etc. Schließlich sind wir schon fast am Ende dieses Kapitels angelangt, und unsere Frage, wieviel Adventure denn nun in 38 KByte passen, ist noch immer nicht beantwortet.

Es hat natürlich seinen Grund, warum ich die Antwort auf meine Frage so lange hinausgezögert habe — ich weiß keine Antwort.

Hoffentlich sind Sie mir nicht böse, aber die letzten Seiten sollten Ihnen nur begreiflich machen, warum eine konkrete Antwort unmöglich ist.

Vielleicht fragen Sie sich jetzt, warum jemand überhaupt eine Frage stellt, wenn er selbt keine Antwort zu geben vermag.

Auch dies hat seinen Grund!
Gerade ein Anfänger beziehungsweise jemand, der zum ersten Mal ein Adventure schreibt, ist nicht oder nur sehr schlecht in der Lage, abzuschätzen, wieviel Speicher für das Spiel benötigt wird, das er sich ausgedacht hat. Dieses Abschätzen will auch gelernt sein.

Doch dazu mehr, wenn wir den Computer einschalten und die ersten kleinen Programmteile entwickeln.

## 2. Kapitel: Ohne Drehbuch kein Film

Am ehesten kann man das Schreiben von Abenteuerspielen wohl mit dem Drehen eines Films vergleichen.

Während an einem Film jedoch viele mitarbeiten, müssen wir alle Arbeiten ganz alleine verrichten: Wir sind Drehbuchautor, Regisseur, und Kameramann in einem, um nur die wichtigsten zu nennen.

Lange bevor ein Filmregisseur zu drehen beginnen kann, braucht er zunächst eine Idee, was für einen Film er drehen will.

Genauso muß der Programmierer eines Adventures zuerst eine Idee aufgreifen, aus der später das Spiel entstehen soll. Dies ist wahrscheinlich der schwierigste Teil von allen. Es ist nicht leicht, ein wirklich neues und möglichst originelles Spielthema zu finden. Denken Sie hierbei nur einmal an die zahlreichen Spiele, bei denen eine Burg oder ein Schloß im Mittelpunkt steht: Zauberschloß, Burg des Schreckens, Schloß des Grauens etc. Genauso viele Spiele finden in Höhlen (Caves) statt.

Sie sollten deshalb bei ihren Überlegungen ein Spiel anstreben, das sich in einem ganzen Abenteuerland und nicht in einer Burg abspielt.

Im Prinzip sind folgende Spieltypen möglich:

- Märchen (Beispiel: Der Hobbit)
- Science Fiction
- Modernes Adventure (Beispiel: Dallas Quest)

Unter »Märchen« versteht man ein Spiel mit Zauberern, Hexen, Drachen etc.

Bei »Science-Fiction« könnte es sich um ein Weltraum- oder ein Zukunftsabenteuer handeln.

Ein »modernes Adventure« spielt sich in unserer Zeit ab.

Selbstverständlich können sich diese Themen auch überschneiden, zum Beispiel wenn man mit einer Zeitmaschine reist. Alle Möglichkeiten ausführlich zu erläutern, würde den Rahmen dieses Kurses sprengen. Ich will jedoch nicht fortfahren, ohne Ihnen als Beispiel einige Gedanken vorzuführen.

Angenommen, ich möchte ein Spiel schreiben, das sich in der Vergangenheit abspielt. Ich brauche also zu Beginn des Spiels eine Zeitmaschine, mit der der Spieler in die Vergangenheit reisen kann. Da es in der heutigen Zeit jedoch noch keine Zeitmaschine gibt, muß ich den Anfang des Spiels in die Zukunft verlegen. Unser erster Spielgedanke könnte sein: Im Jahre 2000 wird eine Zeitmaschine mit zwei Mann Besatzung in die Vergangenheit geschickt. So schön, so gut. Der Spieler gehört also zur Besatzung der Zeitmaschine. Damit er nicht alleine ist, geben wir ihm einen Begleiter, einen Wissenschaftler, mit auf den Weg (dieser Wissenschaftler wird im Programm als selbstdenkender Spielcharakter behandelt). Natürlich müssen wir dem Spieler auch eine Aufgabe mit auf den Weg geben. Sein Ziel könnte sein, herauszufinden, warum die Dinosaurier damals ausgestorben sind.

Damit hätten wir unseren ersten Gedanken — die Ausgangssituation — abgeschlossen. Ist dieser erste Schritt getan, so ist es nicht mehr sehr schwer, weitere Gedanken auszuhecken. Unser Spieler fliegt in die Vergangenheit. Nun müssen wir uns ausdenken, was ihn dort erwartet. Vielleicht trifft er auf Steinzeitmenschen, oder gar Außerirdische. Er könnte von den Steinzeitmenschen gefangen werden. Nun sind Sie an dem Punkt angelangt, bei dem Sie sich voll und ganz in Ihre Fantasie stürzen müssen. Sicherlich kommen dann zahlreiche Ideen, was dem Spieler alles passieren kann, und wie er es zu meistern hat.

## 3. Kapitel: Von der Idee zum Spiel

Lange bevor ein Spiel in ein Programm umgesetzt wird, muß es in Form von Skizzen und Tabellen nahezu völlig fertig vorliegen.

Natürlich gibt es auch viele Programmierer, die sich an den Computer setzen und einfach drauflostippen — nach dem Motto erst Tippen, dann Denken.

Selbstverständlich kann auf diese Weise nur äußerst selten ein vernünftiges Programm entstehen:

Zum einen kommen Spiele dabei heraus, die so viele stilistische und programmbedingte Fehler enthalten, daß sich ein Spielen kaum noch lohnt, Solche Spiele wandern dann in die Schubladen und werden schnell vergessen. Zum anderen wird beim Programmieren nach einiger Zeit der Überblick verloren, so daß Korrekturen am Programm nur noch sehr mühselig vorzunehmen sind. Dann geht schnell die Lust am Weiterprogrammieren verloren, und das Spiel wandert ebenfalls in die Schublade.

Einige könnten nun einräumen, daß sie ihre Programme äußerst gut strukturiert haben und der Überblick somit gewährleistet ist.

Das mag schon stimmen, soweit es sich um die Programmierung eines Schießspiels etc. handelt. Jedoch aus eigener Erfahrung kann ich Ihnen versichern, daß es unmöglich ist, ein 38 KByte-Adventure bis auf die letzte Variable zu strukturieren — irgendwann findet man sich auch in der besten Struktur nicht mehr zurecht, außerdem sind strukturierte Programme oft viel länger als herkömmliche und verbrauchen somit den, besonders bei Adventurespielen, benötigten Speicherplatz.

Natürlich möchte ich von Ihnen nicht verlangen, jedes Adventure vor der Umsetzung zum Programm bis ins letzte, klitzekleinste Detail auszuarbeiten. Sie sollen vielmehr erfahren, welche Unterlagen man stets beim Programmieren neben sich liegen haben sollte, um problemlos und schnell Änderungen am Spiel vornehmen zu können.

Generell empfehle ich Ihnen für jedes Adventure ein Heft (Format A4) zu führen, in dem alle wichtigen Informationen und Tabellen zum Spiel enthalten sind.

Nun aber zum eigentlichen Thema. Am Anfang aller Arbeit steht, wie schon die Überschrift des Kapitels verrät, die Idee.

Wie kommt man nun aber zu einer guten, neuen Idee?

Hierzu bietet es sich zunächst an, sich einmal auf dem Softwaremarkt umzuschauen und dann einige Adventures zu spielen. Gute Adventures die ich Ihnen empfehlen kann, wären zum Beispiel »The Hobbit«, »Ulysses« und »Enchanter«. Äußerst interessant ist auch »Gordon Saga«. Dieses Spiel enthält völlig neue Elemente und zeichnet sich außerdem durch einen nahezu unerschöpflichen Wortschatz und unbegrenzte Spielmöglichkeiten aus. Natürlich sollen Sie diese Spiele nicht spielen, um die in ihnen enthaltenen Ideen in Ihrem eigenen Spiel zu kopieren — Sie sollen aus diesen Spielen lernen, wie andere Autoren ihre Ideen ausgebaut haben. Es macht auch nichts aus, wenn Sie an ein extrem schlechtes Adventure geraten, denn Sie werden aus den Fehlern dieser Spiele lernen und umzugehen, daß sich diese Fehler in den eigenen Spielen wiederholen.

Oft wird unter einem Adventure ein Spiel verstanden, in dem wie in Märchen Zauberer, Zwerge, Feen und Monster auftreten. Leider ist dieser Gedanke kaum zutreffend.

Unter Abenteuer sollte man vielmehr Erleben verstehen – Adventures sollten deshalb nicht nur Spiele sein, in denen der Spieler einen Zauberer besiegen oder Schätze finden muß. Ein Adventure ist einfach ein Spiel, das der Spieler selbst beeinflussen kann und dabei einiges erlebt.

Sehen Sie sich doch einmal die folgenden Themen an:

1. Ein kleiner Wanderzirkus kommt in die Stadt. In der Nacht bricht ein gefährlicher Löwe aus und macht die Stadt unsicher.<br>Die Aufgabe des Spielers besteht nun darin, den Löwen zu finden und zu fangen.
2. Auf einem riesigen Reiseschiff (ä la Traumschiff) befindet sich eine Gräfin. Aus ihrer Kabine werden plötzlich die gesamten Juwelenschmuckstücke entwendet. Der Täter kann das Schiff erst verlassen, wenn es im nächsten Hafen anlegt.<br>Aufgabe des Spielers ist den Dieb zu entlarven, bevor die Schiffsreise beendet ist.
3. Eine Flaschenpost wird gefunden, die eine Seekarte enthält, auf der eine bisher unbekannte Insel eingezeichnet ist.
Aufgabe des Spielers: Zur Insel reisen und sie erforschen.
4. Aufgabe des Spielers: Per Autostop von Frankfurt nach Rom zu trampen.
5. Man schreibt das Jahr 2002. Ein Raumschiff wird, mit tiefgefrorener Besatzung, zu einer langen Reise ins Weltall geschickt. Viele Jahre später landet das Schiff wieder auf der Erde, die sich völlig verändert hat. Der Spieler ist der Kommandant des Sternenschiffes.<br>Aufgabe: Herausfinden, was mit der Erde geschehen ist.

Diese fünf Themen sind Beispiele, wie die zündende Idee zu einem Spiel aussehen könnte. Ich habe solche Beispiele gewählt, die noch einen Bezug zur Realität haben — sich also in unserer Zeit und Welt abspielen könnten.

Das einzige Problem besteht nur noch darin, diese zündende Idee zu haben. Glücklicherweise ist es einfach, sich Anregungen zu verschaffen. Es gibt zum Beispiel eine riesige Menge an spannenden Abenteuerbüchern.

Ich möchte Sie auffordern, sich einmal in Büchereien und Bibliotheken oder Buchhandlungen umzusehen. Sie werden sicherlich ein Buch finden, von dem Sie sich Anregung zu einem Spiel versprechen. Empfehlenswert sind auch die Fantasy-Buchreihen der verschiedenen Buchverleger.

Weitere Anregungen können Sie durch Kinofilme finden —denken Sie nur an die verschiedenen Filme, von denen bereits Programme entstanden sind (zum Beispiel »Der dunkle Kristall« oder »Ghost Buster«).

Wichtig ist, daß Sie wissen, daß es nicht nur auf die Ausgangsidee ankommt und diese deshalb einzigartig gut sein muß, sondern vielmehr darauf, was Sie aus Ihrer Idee machen. Wir wollen uns die fünf Themen, die ich Ihnen vorgestellt habe, nun noch einmal genauer betrachten:

1. Auf den ersten Blick scheint in der Idee, »Spieler muß ausgerissenen Löwen fangen«, nicht allzu viel zu stecken.<br>Sicher ist auf jeden Fall, daß der Spieler einige Aufgaben zu bewältigen hat, bevor er den Löwen fangen kann. Der Spielort: Eine große Stadt. Damit das Spiel nicht zu monoton wird (der Spieler also einfach alle Straßen der Stadt abläuft, bis er den Löwen findet), setzen wir noch einige Parks oder Grünanlagen in die Stadt.<br>Um den Löwen zu fangen, braucht der Spieler einen Käfig und frisches Fleisch, um den Löwen anzulocken. Den Käfig kann er nur mit einem Lastwagen befördern, den der Spieler zum Beispiel mieten muß. Der Lastwagen braucht natürlich ab und zu Diesel. Alle diese Dinge, kosten jedoch Geld — und das hat der Spieler noch nicht. Vielleicht gibt es in der Stadt jedoch eine Spielhölle oder eine freundliche Bank, wo sich der Spieler Geld leihen kann. Vielleicht gibt es aber auch ein paar Diebe, die auf das erworbene Geld scharf sind? Was passiert, wenn der Lastwagen unterwegs kaputt geht? Solche und viele andere kleine Zwischenfälle können dem Spieler widerfahren, bis er den Löwen endlich im Käfig hat.<br>Sie müssen zugeben, daß sich mehr und mehr ein Spiel aus unserer bescheidenen Anfangsidee entwickelt. Natürlich müssen noch viele weitere Einfälle realisiert werden, bis man das Spiel als nahezu vollendet bezeichnen kann. Je mehr man sich jedoch in die Materie vertieft, desto einfacher wird es, die Gedanken zu fassen.
2. Lassen Sie uns noch einmal das zweite Beispiel betrachten. Der Spielort ist eindeutig ein Schiff — also Kabinen, Speisesaal, Aufenthaltsräume, Decks etc. Die Handlung kann man mit der eines Kriminalfalls vergleichen. In dieser Art von Adventure müssen also viele Personen mitspielen, die alle Motive und Alibis haben. Der Spieler kann die Personen beschatten und befragen — er übernimmt in etwa die Rolle eines Detektivs. Während der Suche nach dem Täter kann zur Steigerung der Spannung ein Mordanschlag vorkommen (dieser kann, muß aber nicht unbedingt gelingen) — zum Beispiel auch ein Mordanschlag auf eine andere Person auf dem Schiff (nicht den Spieler), die den Täter kennt und somit nach dessen Ansicht zu viel weiß.<br>Ein Spiel dieser Art in ein Programm zu packen, ist durchaus möglich, jedoch auch relativ schwierig. Das Programm muß alle Personen (außer den Spieler) steuern. Die Personen müssen sich bewegen, handeln und auf den Spieler eingehen (reagieren) können. Wie man solche kniffligen Programmteile schreibt, erfahren Sie im Programmierteil, Zunächst sollten Sie sich bei Ihren ersten Adventures jedoch auf Spiele beschränken, in denen nur möglichst wenige Personen auftreten.

3. Beispiel 3 ist typisch für ein Fantasie-Adventure. Durch eine Seekarte findet der Spieler den Weg zu einer unbekannten Insel. Man kann den Spieler und damit das Adventure — gleich auf der Insel beginnen lassen, oder den Spieler erst eine Schiffsreise antreten lassen. Auf der Insel leben dann vielleicht noch längst für ausgestorben gehaltene Tiergattungen (Saurier), sowie Steinzeitmenschen. Auf der Insel kann es Höhlensysteme, Flüsse, Dschungel, Berge, Seen und vielleicht auch einen Vulkan geben. Natürlich birgt die Insel ein Geheimnis, das der Spieler entdecken muß. Am einfachsten wäre es, einfach einen Schatz zu verstecken. Man kann dem Spiel jedoch auch Utopie verleihen: Der Spieler entdeckt im Inneren des Vulkans eine technisch hochentwickelte Apparatur, die die Lebewesen auf der Insel steuert — die Lebewesen erweisen sich hier als perfekte Roboter. Wer hat jedoch die Apparatur aufgestellt, und welchen Zweck beabsichtigt er? — Außerirdische? Ein verrückter Professor? Vielleicht ist die Insel nur eine Tarnung für eine geheime Raumschiff Abschussstation.<br>Anhand dieses Beispiels können Sie gut erkennen, wie man überraschende Effekte erzielt, durch die der Spieler, der eigentlich glaubt, er müsse nur einen vergrabenen Schatz finden, völlig verblüfft wird.

4. Die Ausarbeitung dieses Themas erfordert besonders viel Einfalls- und Ideenreichtum. Auf den ersten Blick scheint auch in diesem Ausgangsthema nicht viel Abenteuer zu stecken. Tatsache ist jedoch, daß gerade diese Problematik uns extrem viele Möglichkeiten bietet.<br>Sicherlich ist es langweilig, wenn der Spieler nur die Aufgabe hat, an der Straße zu stehen und auf ein Auto zu warten, das ihn mitnimmt. Am Anfang des Spiels wollen wir den Spieler deshalb mit etwas Geld versehen und in ein Geschäft schicken, in dem er sich eine Ausrüstung kaufen kann. In dem Geschäft gibt es alles — vom Schlafsack über Kleidung bis hin zur Zahnbürste. Unser Spieler ist also ausgerüstet und begibt sich zur Autobahn, von der er lostrampen will.<br>Nun wird es Zeit, sich über den Fortgang des Spiels und dessen Aufbau Gedanken zu machen.<br>Wir wollen einmal festlegen, daß der Spieler 8 Tage Zeit für sein Unternehmen hat. Des weiteren legen wir fest, daß der Spieler während des Spiels niemals umkommt. Er muß höchstens kapitulieren, wenn ihm das Geld ausgeht, er abends keinen günstigen Schlafplatz findet (er hat auf keinen Fall genug Geld für ein auch noch so billiges Hotel bei sich) oder das Essen knapp wird. Der Spieler steht also auf der Straße und hofft, daß ein Auto hält und ihn mitnimmt. Wenn ein Auto hält, sind folgende Dinge möglich:<br>– das Auto fährt in Richtung Rom<br>– das Auto fährt in eine abweichende Richtung<br>Der Spieler hat nun die Wahl, ob er mitfahren will oder nicht. Wir lassen mehrere mögliche Routen zu — welche möglich sind, kann man leicht durch einen Atlas mit Reisekarte erfahren.<br>Es ergeben sich hier also schon zahlreiche Kombinationsmöglichkeiten. Allerdings darf nicht alles dem Zufall überlassen werden. Wir wollen nun noch festlegen, daß der Spieler immer von einer Großstadt zur anderen gelangt. Eine mögliche Route wäre Frankfurt—Nürnberg—München—Verona—Florenz—Rom. Übernachten kann der Spieler in öffentlichen Parkanlagen, Bahnhöfen etc.<br>Nun müssen wir uns noch einfallen lassen, was ihm alles zustoßen kann. Er könnte einen Teil seines Geldes verlieren oder es wird gestohlen. Er kann gute und schlechte Bekanntschaften machen. Sicherlich haben auch Sie schon Dinge erlebt, aus denen man ein Adventure machen kann. Ich will damit sagen, daß ein Adventure nicht unbedingt in einer anderen Welt oder Zeit ablaufen muß, um als Adventure anerkannt zu werden — lassen Sie Ihrer Fantasie freien Lauf...
5. Bei diesem Beispiel sollen Sie sich nun einmal selbst ein paar Gedanken machen. Versetzen Sie sich dazu einfach in die Lage des Spielers und verfahren Sie nach einem Gedankenschema, wie ich es in den letzten vier Beispielen vorgeführt habe.

Nun möchte ich einmal ein Beispiel herausgreifen. an dem wir lernen wollen, welche Tabellen man erstellen muß und wie man eine Adventure-Karte zeichnet.

Wir nehmen dazu Beispiel 3 — Die geheimnisvolle Insel. Den zündenden Gedanken hatten wir ja bereits — aber wie arbeiten wir ihn zum Spiel um? Jetzt gleich Aufgaben und Spielwitz zu suchen, ist sehr schwierig. Wir wollen uns deshalb zunächst einmal Gedanken über die Umgebung der Insel machen.

Dazu denkt man einfach nach, welche Dinge auf einer Insel vorkommen. Zum einen ist da der Strand — das soll später auch die Stelle der Insel sein, bei der das Spiel beginnt. Der Spieler rudert mit einem kleinen Boot vom großen Schiff aus zum Strand. Vom Strand aus könnte er vielleicht in einen tropischen Regenwald oder Dschungel gelangen. Außerdem soll es auf unserer Fantasie-Insel ein Gebirge geben (die Insel ist sehr groß), in dessen Zentrum ein riesiger Vulkan aufragt. Außerdem erstrecken sich mehrere Flüsse über die Insel, deren Quellen im Gebirge liegen. Wo Flüsse und Vulkane sind, muß es eigentlich auch heiße Quellen und Lagunen geben.

Damit die Insel auch Leben erhält, soll sich auf ihr auch ein kleines Dorf mit Eingeborenen befinden. Vielleicht auch mehrere Dörfer unterschiedlicher Stämme, aber dies soll uns zunächst nicht so sehr beschäftigen. Was wir nun brauchen ist eine erste Skizze. Man nehme also einfach einmal ein Blatt Papier und Stifte und male dann ein Bild, das in etwa so aussehen könnte.
 
Es muß sich bei dieser ersten Skizze nicht um ein grafisches Meisterwerk handeln, an dem man stundenlang zeichnen muß. Es soll vielmehr ein Bild sein, das man mit einem Bleistift schnell auf ein Stück Papier kritzelt. Dieses Bild hat natürlich noch sehr wenig mit einer richtigen Adventure-Spielkarte gemeinsam. Die Größenverhältnisse auf dem Bild sind ebenfalls sehr vage. Es soll also nur ein Bild sein, das einen Überblick über die angestrebte Adventurelandschaft darstellt. Man kann an ihm auch in etwa erkennen, wo was liegt. Bei der vorgestellten Skizze von unserer Insel sind folgende Interpretationen möglich:

Ein riesiges Gebirge erstreckt sich über den westlichen Teil der Insel. Im Zentrum des Gebirges steht ein Vulkan. Vom Gebirge gehen auch mehrere Flüsse aus, die sich über die ganze Insel verzweigen. Einer dieser Flüsse mündet in einen großen See, der sich im östlichen Teil der Insel befindet. An einem der anderen Flüsse, der ins Meer fließt, liegt ein kleines Dorf mit Eingeborenen.

Im nordwestlichen Teil, am Fuß des Gebirges, befindet sich eine riesige Mauer. Hinter der Mauer liegt ein Tempel versteckt. Der restliche Teil der Insel besteht aus Wäldern und Sümpfen.

Sie haben sicher bereits erkannt, worin der Sinn unserer ersten Skizze liegt man gewinnt einen bildlichen Eindruck über die Gegend, in der das Adventure später stattfinden soll. Des weiteren findet man im Rahmen der Bildbetrachtungen viele neue Ideen und Anregungen über den Verlauf des Adventures.

Worüber wir uns bisher noch keinerlei Gedanken gemacht haben, ist der Spielwitz — sprich die Aufgaben, die der Spieler lösen muß.

Der nächste Schritt besteht nun darin, die eigentliche Spielkarte zu entwerfen, mit deren Hilfe wir das Spiel später programmieren werden. Man kann darüber streiten, ob es besser ist, zuerst den Spielwitz und dann die Spielkarte auszuarbeiten oder umgekehrt. Ich halte es für sinnvoll, wenn man beides gleichzeitig behandelt, da Spielkarte und Spielwitz sehr eng miteinander zusammenhängen.

Eines der größten Probleme ist das folgende:

Wenn man die Spielkarte erst einmal ausgearbeitet hat, so ist es oft sehr schwierig und mühselig, später noch einmal Änderungen vorzunehmen.

Während man jedoch das Spiel programmiert, kommen einem noch viele Ideen, die den Spielwitz betreffen und die man noch mit einbauen will. Deshalb muß die Spielkarte sehr sorgfältig und sauber gezeichnet werden, damit die Übersicht nie verloren geht.
 
Wie geht man nun beim Entwurf der Spielkarte vor?

Die Gedankengänge zum Entwurf einer Spielkarte sind genau die Umkehrung derer, mit denen man ein Adventure löst.

Sicherlich haben auch Sie schon einmal ein Adventure gespielt und sich dabei Notizen gemacht, wo was ist. Es gibt natürlich auch Spieler, die sich keine Notizen machen, im Spiel immer wieder hin- und herlaufen und die Orientierung und somit die Freude am Spiel schnell verlieren.

Ein gewissenhafter Abenteurer, der ein Adventure bis zum Ende bestehen will, geht jedoch ganz anders vor er zeichnet einen Lageplan zum Spiel.

Wie macht er das?

Wir gehen einmal vom Beginn eines Spiels aus. Der Computer beziehungsweise das Programm liefert seinen ersten Lagebericht, der so lauten könnte:

SIE BEFINDEN SICH IN EINEM GROSSEN ZIMMER

IM NORDEN BEFINDET SICH EINE TUER, DIE OFFEN IST

MOEGLICHE RICHTUNGEN: S, N, O
Nun macht sich der gewissenhafte Abenteurer seine erste Notiz, die so aussieht:

TODO

Er macht also ein Kästchen, in dem er mit einem kurzen Wort den jeweiligen Raum beschreibt. In diesem Fall also »großes Zimmer«.

Von dem Kästchen gehen Pfeile in die verschiedenen möglichen Richtungen. Dabei ist es wichtig, daß auch Pfeife — nicht etwa nur Linien— markiert werden. Der Pfeil zeigt immer in die Richtung, in die man von diesem Raum ausgehen kann. Wenn man zum Beispiel nach Norden läuft, so ist es nicht sichergestellt, ob man anschließend durch Bewegung nach Süden wieder zum Ausgangsort gelangt. Deshalb also zunächst nur einen Pfeil.

Der nächste Schritt besteht also darin, die einzelnen Richtungen auszuprobieren. Wir wollen einmal nach Osten gehen.
Das Programm liefert daraufhin folgenden Lagebericht:

SIE BEFINDEN SICH IN EINEM LANGEN GANG

AM ENDE DES GANGES IST EIN KLEINES FENSTER

MOEGLICHE RICHTUNGEN: W, O
Damit können wir den Lageplan folgendermaßen ergänzen:

TODO

Aus der Lageberichtserstattung des Programms geht hervor daß man nach Westen und nach Osten laufen kann (vom langen Gang aus). Logischerweise müßte man nun eigentlich wieder in das große Zimmer gelangen, wenn man zurück nach Westen läuft. Wir wollen dies nur ausprobieren und laufen zurück in westliche Richtung — und tatsächlich gelangen wir wieder in das große Zimmer. Wir können also einen zweiten Pfeil in die Skizze einzeichnen.

TODO

Sinnvoller ist es natürlich, anstelle der beiden Pfeile nur einen Pfeil mit zwei Spitzen einzuzeichnen. Also:

TODO

Lassen Sie uns jedoch auch den traurigen Fall betrachten, was passiert wäre, wenn wir nicht wieder in das große Zimmer gelangt wären. Dann wäre es schon etwas verwirrender einen vernünftigen Spielplan zu zeichnen.

Es scheint viele Adventure-Programmierer zu geben, denen es eine wahre Freude bereitet, den Spieler durch unlogischen Pläne zu verwirren.

Auch in einigen sehr guten Adventures, zum Beispiel »The Hobbit« wird dieses Verwirrspiel getrieben. Eigentlich schade, denn bei einem guten Adventure, das vom Spieler viel Ideenreichtum bis zur Lösung erfordert, kann es äußerst frustrierend für den Spieler sein, wenn der Spielplan völlig unlogisch aufgebaut ist. Deshalb auch mein Rat an die angehenden Adventure-Programmierer: Schreiben Sie stets nur Adventures mit logischem Spielplan. Das Hauptziel eines Adventures soll schließlich sein, den Spieler zu unterhalten und nicht zu frustrieren. Der Spieler sollte so wenig wie nur irgend möglich vom Spiel abgelenkt werden, weder durch ständige Fehlermeldungen, die auf einen mangelhaften Wortschatz des Spiels schließen lassen, noch durch einen Spielplanaufbau, in dem man sich kaum zurechtfinden kann. Natürlich gibt es auch Fälle, bei denen man tatsächlich nicht mehr umkehren kann, um wieder an den Ausgangsort zu gelangen.

Dies ist dann der Fall, wenn

- man in eine Grube hinabstürzt.
- plötzlich ein Fallgitter herunterfällt und den Ausgang versperrt.
- hinter dem Spieler plötzlich eine Tür zufällt, die sich nicht mehr öffnen läßt.

Eine Szene, bei der ein Fallgitter herunterfällt, würde man folgendermaßen skizzieren:

TODO

Hier wurde an dem Pfeil noch kurz vermerkt, warum eine Umkehr nicht möglich ist. Wir wollen festlegen, daß in einem Fall, bei dem eine Umkehr unmöglich ist, immer eine kleine Begründung neben den Pfeil geschrieben wird. Zu dieser Begründung genügt meistens ein einziges Wort, wie Fallgitter.
 
Oftmals befinden sich Türen zwischen einzelnen Räumen. Diese Türen werden im Plan so skizziert:

TODO

Wie Sie sehen, wird die Tür durch eine gestrichelte Linie dargestellt. Bei dieser Linie steht wieder eine Bemerkung: Schlüssel.

Diese Bemerkung stellt also die Bedingung dar, mit deren Hilfe man durch die Tür gelangt: Man braucht den Schlüssel, um durch diese Tür gehen zu können. Im Fall einer magischen Tür, bräuchte man vielleicht einen Zauberspruch oder bei einer elektronisch gesicherten Tür eine Identitätskarte.

Steht jedoch keine Bemerkung neben der gestrichelten Linie, so heißt dies, daß man die Tür ohne weiteres passieren kann — sie stellt in diesem Fall also kein Hindernis dar.

Lassen Sie uns nun folgenden Fall betrachten:

Der Spieler stürzt in eine Grube, die er nur unter Zuhilfenahme eines Seils wieder verlassen kann. Hier sieht die Skizze so aus:

TODO

Diese Skizze ist so zu verstehen:

Wenn man vom großen Zimmer aus in südliche Richtung läuft, so stürzt man in eine Fallgrube, die man nur mit einem Seil wieder verlassen kann_ Die Bedingung »Seile« steht hierbei in einem großen Pfeil, der von der Grube zum großen Zimmer führt.

Man könnte die Bedingung auch neben einen einfachen Pfeil schreiben, durch den großen Pfeil ist der Sachverhalt jedoch besser ersichtlich.

Aus diesem Beispiel läßt sich auch etwas lernen — man sollte den Spieler nie vor vollendete Tatsachen stellen (beziehungsweise in aussichtslose Lagen bringen). Es gibt zahlreiche Adventures, die sich nach einer Bewegung des Spielers mit einem solchen Wortlaut meiden:

SIE SIND IN EINE FALLGRUBE GESTUERZT UND HABEN

SICH DAS GENICK GEBROCHEN!

WOLLEN SIE NOCHMAL SPIELEN?
Solche Spiele spiele ich in der Regel nur einmal.

Worin besteht der Witz eines solchen Falls?

Da läuft der Spieler herum, ist der Lösung des Adventures auf der Spur und bekommt plötzlich die Meldung, daß er verloren hat.
 
Bei einem guten Adventure sollte der Spieler nur auf Grund von eigenem Fehlverhalten verlieren, Dies müßte eigentlich das Grundmotto eines jeden Adventure-Autors sein.

Damit wären wir schon fast am Ende der Lageplan-Grundlagen.

Scheuen Sie sich nicht davor, zehn Himmelsrichtungen zu verwenden — N, S, O, W, NO, NW, SO, SW, RAUF, RUNTER — denn dadurch lassen sich viel interessantere Pläne erstellen, als mit nur vier Himmelsrichtungen.

Die Richtungen N, S, 0, W, NO, NW, SO, SW werden auf der Lagekarte mit einfachen Pfeilen dargestellt. Die Richtungen RAUF und RUNTER hingegen mit Doppelpfeilen, damit keine Irrtümer auftreten können.

Ein Beispiel:

TODO

Anhand dieser Beispiele wissen Sie nun also, wie man Landkarten für Adventures zeichnet.

Doch nun zurück zu unserem Inselbild. Wie setzt man diese Skizze denn nun in einen sinnvoll aufgebauten Lageplan um?

Die Insel jetzt gleich in einen riesigen Lageplan umzusetzen, ist nicht sinnvoll. Es empfiehlt sich nun erst einmal Gedanken über den Spielverlauf zu machen.

Wir wollen davon ausgehen, daß sich der Spieler zu Beginn des Spiels auf dem Schiff befindet. Von dort aus begibt er sich mit Hilfe eines kleinen Ruderbootes zur Insel. Er kommt so also zum Strand der Insel.

Nun muß er eine Wald- und Sumpflandschaft durchqueren, um zum Dorf der Eingeborenen zu gelangen. Das Dorf liegt, wie aus der ersten Skizze ersichtlich, an einem Fluß. Trotzdem kann der Spieler mit seinem Ruderboot nicht vorn Meer aus über den Fluß zum Dorf gelangen, da die Strömung zu stark ist und dem Meer entgegenfließt. Im Dorf der Eingeborenen, die friedlich sind, erfährt der Spieler ein Geheimnis, das so lauten könnte:

»Der seit Jahren erloschene Vulkan im Nebelgebirge strahlt seit einigen Wochen ab und zu ein merkwürdiges Licht aus. Dies flößt den Eingeborenen große Angst ein, Neugierige, die sich auf den gefährlichen Weg durch das Nebelgebirge zum Vulkan begeben haben, sind nie mehr zurückgekehrt. Außerdem berichtet eine alte Legende von einer riesigen, hunderte Meter langen Mauer, die sich irgendwo im nordwestlichen, unbewohnten Teil der Insel befindet. Niemand weiß, was sich hinter dieser Mauer verbirgt. Abenteurer haben erzählt, daß ein schwarzer, schneller Fluß durch die Mauern zum großen See fließt.«

Sie müssen zugeben, daß dieses Geheimnis schon ziemlich interessant ist. Was ist hinter der Mauer? Was ist mit dem Vulkan los? Wo sind die verschwundenen Abenteurer, die nie wieder heimgekehrt sind?

Diese Frage wird sich der Spieler jetzt stellen — und er wird versuchen wollen, diese Geheimnisse (also das Abenteuer) zu lösen.

Solche Einleitungen zu einem Adventure sind sehr empfehlenswert, da sie das Interesse des Spielers am Spiel steigern, obwohl sie nur sehr oberflächliche Informationen enthalten.

In unserem Insel-Adventure wird die Einleitungsstory im Dorf der Eingeborenen gegeben — also während des Spiels. Sinnvoller ist es allerdings eine solche Einleitung an den Anfang des Spiels zu stellen, man könnte sie dann in ein separates Titelprogramm schreiben. Das heißt, der Spieler lädt erst die Einleitung in den Computer und liest sie. Ist die Einleitung abgelaufen, dann wird das eigentliche Spiel geladen und gestartet.
 
Dieser Tip gilt hauptsächlich für Datasetten-Anwender. Besitzern von Diskettenlaufwerken, die Spiele schreiben können, die selbständig Programmteile nachladen, stellt sich dieses Problem wohl kaum.

Der Spieler kennt also nun die Geheimnisse, die er lüften will. Er weiß natürlich noch nicht, daß sich hinter der hohen Mauer ein Tempel verbirgt. Wir wissen bereits, daß der erste Weg, den der Spieler zurücklegen muß, der Weg vom Inselstrand zum Dorf der Eingeborenen ist.

Aber wohin soll er von dort aus gehen? Im Prinzip haben wir noch zwei Möglichkeiten — das Nebelgebirge mit dem Vulkan und die hohe Mauer.

Ich muß hierbei anmerken, daß wir momentan nur den absolut richtigen Weg betrachten, also den Weg, den der Spieler verfolgen muß, um das Spiel so schnell wie möglich zu bezwingen. Irrwege werden im Moment noch nicht berücksichtigt. Dabei möchte ich noch klarstellen, daß der Spieler sich selbstverständlich auf der Insel frei bewegen kann — er kann, wenn er will, vom Dorf auch wieder durch den Dschungel zurück zum Strand, ins Boot steigen und zurück zum Schiff rudern.

Nun aber zurück zum absolut richtigen Weg. Nehmen wir einmal an, der Spieler begibt sich anschließend über das Nebelgebirge zum Vulkan.

Er ergründet dort das Geheimnis des Vulkans. Im Inneren des Vulkans befindet sich eine hochentwickelte, technische Fabrik, die völlig automatisiert ist. Sie wird von Robotersklaven betrieben, deren Herr ein wahnsinniger Professor ist, der die Weltherrschaft an sich reißen will.

Der Spieler ist also in der Fabrik eines Wahnsinnigen. Er erlebt dort wieder einige Abenteuer, und entdeckt schließlich einen Geheimgang, der unter dem Nebelgebirge hindurch zum Tempel hinter der Mauer führt. Der Spieler kommt also in den Tempel und muß dort wieder einige Nüsse knacken. Danach gelangt er über den schwarzen Fluß unter der Mauer hindurch zum großen See und von dort zum Strand und zurück zum Schiff — das Adventure ist gelöst.

Buh, aufhören, könnten Sie jetzt vielleicht rufen, da unser Spielkonzept zwar schon sehr interessant klingt, jedoch noch keine Details und Action enthält. Wir sind bisher nur durch eine leere Landkarte gelaufen. Es wird bald Zeit, darüber nachzudenken, welche Abenteuer der Spieler bestehen muß und in welchen Bereichen der Insel sie versteckt liegen (einige Andeutungen habe ich ja bereits gemacht).
 
Vorher wollen wir jedoch eine neue Skizze zeichnen, oder besser gesagt unsere alte Inselskizze ein wenig überholen —sie in die Grundlandkarte umsetzen. Darunter versteht man eine Karte, die sehr grob nach dem vorgestellten Kästchen- und-Pfeil-Prinzip angefertigt wird. Diese Karte für unser Spiel sieht folgendermaßen aus:

TODO

Diese Landkarte ist natürlich noch sehr oberflächlich, zeigt aber dennoch bereits viel deutlicher als unsere erste Zeichenskizze, wie das Spiel aufgebaut ist.

In der Landkarte sind fünf große Bereiche eingezeichnet und ihre Verbindung zueinander. Diese Bereiche sind Urwald, Nebelgebirge, Vulkan, Tempel und der große See. Ich habe also beim Anfertigen dieser Karte nichts anderes gemacht, als die Hauptgebiete der Insel in einzelne Blöcke zu fassen. Von solch einer Blockgebietskarte ist es viel leichter die eigentliche Landkarte anzufertigen, als von der ersten Skizze.

Als kleine Blöcke habe ich den Strand und das Schiff eingezeichnet. Man kann also sagen, daß ein Blick um so mehr Räume enthält, je größer er ist. Zwischen den einzelnen Blöcken befinden sich einfache und doppelte Pfeile. Die einfachen Pfeile stellen die bereits besprochenen Verbindungen zwischen den einzelnen Räumen dar — in unserem Fall, Verbindungen zwischen den einzelnen Gebieten. Die Doppelpfeile sind ebenfalls Verbindungspfeile — mit der Ausnahme, daß sie Bedingungen stellen. So kann man, anhand der Doppelpfeile, aus der Karte lesen, daß man nur über den Geheimgang vom Vulkan zum Tempel gelangen kann. Des weiteren gelangt man vom Tempel nur über den Fluß zum großen See.

Der nächste Schritt besteht nun darin, die einzelnen Gebietsblöcke in einzelne Räume zu gliedern — es entsteht also die komplette Spielkarte. Dieser Ausbau kann je nach Wunsch gering oder sehr komplex sein.

Vielleicht interessiert es Sie, wie viele tatsächliche Räume die bekannten Adventures denn im einzelnen so haben.

Das Adventure »The Hobbit« hat zirka 80 Räume. Allerdings ist nicht jeder Raum mit Action gefüllt. Bei etwa 25 Räumen erhält man als Raumbeschreibung immer wieder die Anwort »Sie befinden sich in einem dunklen Höhlensysteme« Man muß oft lange Strecken zurücklegen, um zu den einzelnen Aufgaben zu gelangen. Adventures, wie man sie aus Zeitschriften vom Abtippen her kennt, haben eine durchschnittliche Raumanzahl von zirka 30 Räumen.

Es ist sehr schwer, detaillierte Tipps zu geben, wie viele Räume und wieviel Action man in ein gutes Adventure packen sollte. Als Faustregel könnte man vielleicht sagen, daß eine gute Relation zwischen Raumanzahl und Action etwa 1 zu 1 betragen sollte.

Um nicht allzu sehr vom Thema abzukommen, zurück zur Spielkarte.

Hier der komplette Spielplan, das heißt ein Spielplan, wie man ihn zu diesem Spiel gestalten könnte.

Ich habe mich bei diesem Plan nur auf einen kleinen Aufbau beschränkt, da ein Aufbau im Großen viel zu komplex zu erklären wäre (siehe Spielplan).

Der Plan liegt nun nahezu fertig vor uns. Aus ihm ist eindeutig ersichtlich, welche Räume existieren und wie sie miteinander verbunden sind. Wie ich bereits gesagt habe, ist dieser Plan nur wenig ausgebaut. Ein perfekter Ausbau kann erreicht werden, indem man den Wald vergrößert. Der Spieler könnte durch den Wald zu der hohen Mauer gelangen. Er kann zwar dort nichts anfangen, da er den Tempel nur durch den unterirdischen Geheimgang vom Gebirge aus erreicht, und später durch den unterirdischen Fluß wieder verläßt, aber wir haben in der Vorgeschichte des Spiels die sagenumwobene Mauer erwähnt. Also sollte sie auch im Spiel auftauchen. Des weiteren müßte die unterirdische Fabrik, sowie die gesamten Wandermöglichkeiten im Gebirge und der Tempelplan erweitert werden.

Nun wird es langsam Zeit, sich Gedanken über den Actionverlauf des Spiels zu machen. Woher kommen die Ideen zu den Aufgaben, die der Spieler später lösen muß? Nun, ganz einfach! Innerhalb eines Kurses, wie diesem hier, ist es schwierig, Gedanken die parallel ablaufen, gleichzeitig im Kurs zu erklären, ohne Verwirrung zu stiften.

Tatsächlich arbeitet man beim Erstellen von Adventurespielen immer an mehreren Dingen gleichzeitig:

Während man die Landkarte zeichnet, kommen einem neue Ideen. Betrachten Sie doch die Karte einmal ganz genau! In Raum 11 finden Sie eine Höhle. Von dieser Höhle im Gebirge war bisher noch nie die Rede gewesen. Aber wie kommt sie denn nun in den Plan? Nun, ganz einfach: Während ich die Landkarte für das Gebirge zeichnete, dachte ich mir, daß es eigentlich monoton ist, wenn der Spieler mehrmals die Beschreibung »Sie befinden sich im Gebirge« erhält. So kam ich auf die Idee, daß sich im Gebirge zur Abwechslung auch eine Höhle befinden könnte. Wie wird der Spieler reagieren, wenn er die Lagebeschreibung »Sie befinden sich im Gebirge. Sie sehen einen Höhleneingang!« erhält? Ich versetzte mich also in die Lage des Spielers und überlegte, was ich machen würde, wenn ich ein Adventure spiele und diese Beschreibung erhalte. Nun, ich würde sicher aus Neugier in die Höhle gehen, so wie jeder neugierige Abenteurer es auch macht. Gut, der Spieler geht also in die Höhle. Was soll der Spieler in der Höhle vorfinden? Eine leere Höhle wäre schließlich zu langweilig. Ich beschließe deshalb, in die Höhle einen Gegenstand zu legen, der für den Fortlauf des Spiels sehr wichtig ist. Dieser Gegenstand könnte ein Schlüssel, ein Schwert oder ähnliches sein.

Dadurch, daß ich einen so wichtigen Gegenstand in die Höhle lege, stelle ich auch sicher, daß der Spieler in die Höhle gehen muß — früher oder später.

Selbstverständlich bekommt man bei einem Adventure nur dann etwas, wenn man es sich verdient hat. Der Spieler soll also nicht einfach in die Höhle gehen können, den Gegenstand nehmen und die Höhle dann wieder verlassen. Welche Aufgabe kann ich ihm denn stellen?

Primitive Lösungen wären, den Gegenstand im Boden der Höhle zu vergraben, oder einfach zu verstecken (der Spieler braucht dann eben eine Schaufel). ich versuche also eine schwierigere Aufgabe zu finden, bei der der Spieler nur durch Nachdenken weiterkommen oder überleben kann.

Und da ist auch schon die Idee geboren: Wilde Bären hausen doch in Höhlen im Gebirge. Nun stelle ich mir die Spielszene einmal vor. Der Spieler entdeckt einen Höhleneingang und geht hinein. in der Höhle, die völlig verlassen ist, findet der Spieler einen interessanten Gegenstand. Er nimmt den Gegenstand. Plötzlich hört er ein gefährliches Brummen vor dem Höhleneingang. Kurz darauf betritt ein riesiger Bär mit lautem Gebrüll die Höhle und nähert sich dem Spieler. Dies ist der Moment, wo der Spieler seine grauen Zellen bemühen muß. Wie kommt er lebend aus der Höhle heraus? Einfach am Bären vorbeilaufen (wegrennen) ist sicher zu leicht. Den Bären mit einem Schwert erlegen, soll auch unmöglich sein, da der Bär zu stark ist. Angenommen, der Spieler hat ein Schwert und greift den Bären an, so soll er ihn verletzen können. Dadurch soll dieser aber höchstens noch wilder werden und ... game over.

Nun gut, ich habe viele Ideen wie der Spieler die Situation verlieren kann, aber er muß schließlich auch eine Chance haben zu entkommen. Wir haben ja bereits klargestellt, daß man den Spieler nie vor vollendete Tatsachen stellen sollte, wenn man ein gutes Adventure schreiben will. Die Idee: Bären haben Angst vor Feuer. Der Spieler muß also schnell etwas Holz vom Boden nehmen (das selbstverständlich dort liegt) und es mit seinem Feuerzeug (das er hoffentlich in seiner Ausrüstung hat) entzünden. Der Bär bekommt dann Angst vor der so entstandenen Fackel und flieht mit panischer Angst – der Spieler hat es geschafft!

Anhand dieses Beispiels können Sie erkennen, wie man vorgehen muß, um Action-Szenen zu gestalten.

Die Arbeitsschritte sind:

1. Ausdenken einer Gefahrensituation. Nicht davor zurückschrecken, wenn diese Gefahrensituation zunächst ausweglos erscheint.
2. Darüber nachdenken, durch welche Ideen der Spieler verliert.
3. Über eine Lösung nachdenken.

Vorn 1. Schritt direkt zum 3. überzugehen, ist sehr schwer. Deshalb fügt man einen zweiten Schritt ein, bei dem man sich erst einmal Gedanken macht, wodurch der Spieler verlieren kann, also welche falsche Reaktionen des Spielers in Betracht gezogen werden können.

Dabei kommt man dann meistens auch auf die Lösung der jeweiligen Gefahrensituation.

Bedenken Sie dabei: Je länger Sie an dem Problem arbeiten und je schwieriger es für Sie ist eine vernünftige Lösung zu finden, desto interessanter und anspruchsvoller wird das Spiel für den Abenteurer später sein. Betonen möchte ich hierbei noch einmal den Ausdruck »vernünftige Lösung«. Damit ist gemeint, daß Sie keine utopischen Lösungen aushecken sollen, sondern Lösungen, die auch wirklich oder wenigstens zum Teil in der Realität vorkommen.

Eine utopische Lösung wäre, wenn man den Bären einfach mit Anbrüllen zur Flucht bewegen könnte.

Lassen Sie sich ruhig mehrere Tage Zeit, die Lösungen zu den einzelnen Aufgaben zu finden. Ein anderes Beispiel für eine solche Action-Szene stand bereits in der Einleitung zu diesem Kurs. Es stammt aus dem Adventure »Gorden Saga«.

Oft bringt der Einbau von Action-Szenen auch eine Änderung der Spielkarte mit sich. Sie sehen, daß es beim Schreiben von Adventures nahezu unmöglich ist, einzelne Arbeitsschritte nacheinander durchzuführen — man muß vielmehr immer an mehreren gleichzeitig arbeiten, da sie alle eng mit-einander verbunden sind.

Ich möchte jetzt nicht auf weitere Action-Szenen eingehen, die man in das Spiel einbauen kann. Es sollen statt dessen noch einige Erläuterungen zur Karte gemacht werden.

Vom Raum 1 (Strand) kann man in mehrere Richtungen gehen, die alle zum Urwald führen. Betrachten Sie nun einmal die Räume 4 und 7 im Wald und ihre Verbindungen zueinander. Sie werden feststellen, daß man von Raum 7 nach Südosten gehen muß, um zu Raum 4 zu gelangen etc. Es ist besonders wichtig, daß Sie auch die Himmelsrichtungen NO, SO, SW, NW in der Karte verwenden, Dies ist zwar später ein bißchen schwerer zu programmieren, als nur vier Richtungen, aber die Karten werden durch acht oder zehn Richtungen (mit rauf und runter) viel komplexer. Der Spieler wird somit gezwungen, Aufzeichnungen während des Spiels zu machen, und kann die Karte nicht gleich auswendig lernen, wenn sie nur wenig Räume hat.

Zwischen den Räumen 13 und.14 befindet sich eine gestrichelte Linie, mit der Bezeichnung Felsspalt. Diese gestrichelte Linie bedeutet, wie bereits besprochen, daß der Spieler nicht direkt von Raum 13 zu Raum 14 gelangen kann, sondern nur durch einen Felsspalt, den er finden muß. Dieser Spalt könnte durch einen Felsblock versperrt sein, den man erst wegrollen muß. Der Felsspalt kann als Tür zwischen Raum 13 und 14 angesehen werden. Zwischen den Räumen 16 und 17 befindet sich ebenfalls eine gestrichelte Linie mit der Bezeichnung Geheimtür; man gelangt also nur durch eine Geheimtür von Raum 16 nach Raum 17.

Zwischen Raum 14 und 15 befindet sich ein Doppelpfeil mit der Bezeichnung Aufzug. Man muß in Raum 14 (der Grotte) also in einen Aufzug steigen, diesen aktivieren, und gelangt dann zu Raum 15. In diesem Fall hätte man auch eine gestrichelte Linie statt eines Doppelpfeils verwenden können. Zwischen den Räumen 24 und 25 (dem Fluß) befindet sich ein Pfeil, der nur in eine Richtung weist. Dies ist logisch, da der Spieler nur in die Richtung kann, in der der Fluß treibt. Der Fluß ist so schnell, daß er nicht in der Lage ist, gegen die Strömung zu rudern.

Sicher haben Sie bereits den Sinn erkannt, die die Durchnummerierung der Räume in sich birgt. Sie können sich so leichter Notizen zu den einzelnen Räumen machen. Es empfiehlt sich zu jedem Raum eine kleine Notiz zu machen, was dort ist, und was dort passieren kann.

Des weiteren sollten Sie sich eine Tabelle anfertigen, die aussagt, wo sich die einzelnen Gegenstände befinden; oder zeichnen Sie die Gegenstände einfach in die Karte ein. Wichtig ist nur, daß Sie später beim Programmieren genügend Notizen angefertigt haben, auf die Sie dann zurückgreifen können.

Zeichnen Sie die endgültige Spielkarte sauber und deutlich. Damit wären wir auch schon am Ende des ersten Kursteils angelangt. Sie haben jetzt vieles über Adventures erfahren, wissen wodurch sich gute Adventures von schlechten unterscheiden, und wie man eine Adventurekarte entwirft und ein Spiel mit Action versieht. Es gibt natürlich noch einige weitere Tricks zum Schreiben und Ausdenken von Adventures. Es werden Ihnen sicher noch viele Ideen kommen, was man so alles machen kann. Sie werden schon bald Ihren eigenen Stil entwickeln.

## 4. Kapitel: Die Programmiertechnik

Wir haben bislang gelernt, wie man sich ein Abenteuerspiel ausdenkt und es ausarbeitet.

Jetzt wollen wir lernen, wie man solch ein ausgearbeitetes Spiel in ein Basic-Programm für den C64 umsetzt.

Vielleicht haben Sie schon etwas von sogenannten Adventure-Generatoren gehört. Dies sind Programme, die es jedem, auch ohne jegliche Basic-Kenntnisse, ermöglichen, Adventure-Spiele zu erzeugen. Mit solchen Generatoren lassen sich oft relativ umfangreiche (mit vielen Räumen) Abenteuerspiele erstellen. Umfangreich heißt jedoch lange noch nicht anspruchsvoll.

Vom Kauf eines solchen Generators möchte ich Ihnen unbedingt abraten. Auch die allerbesten Generatoren schränken Ihre Kreativität in erheblichem Maße ein. Man erkennt auch meist von welchem Generator das Spiel erzeugt wurde, Sie sollen jedoch lernen, wie Sie Ihrem Adventure eine persönliche Note verleihen. Man soll erkennen, daß das Spiel von Ihnen programmiert wurde, und nicht von irgendeinem Programmgenerator.

Das Ziel dieses Kurses ist, Ihnen das Wissen zu vermitteln, das nötig ist, um anspruchsvolle Adventures zu schreiben, die den kommerziellen Spielen in keiner Weise an Qualität nachstehen. Die zahlreichen Beispiel-Programme (Listings) sind ausführlich dokumentiert. Ausreichende Basic-Kenntnisse und Erfahrung sind jedoch unbedingt erforderlich, da dieser Kurs kein Basic-Kurs ist, Selbstverständlich werde ich auf Kniffe und Programmiertricks ausführlich eingehen.

### Arbeitsmittel und Methoden

Zum Programmieren gehen wir von folgender Hardware aus: Computer C 64 und Datasette (oder Diskettenlaufwerk). Ein Drucker und ein Diskettenlaufwerk wären zwar äußerst sinnvolle Ergänzungen, aber ich möchte vom Computerbesitzer ausgehen, der diese Erweiterungen nicht besitzt.

Für die Programme werden wir, früher oder später, alle 38 KByte RAM benötigen. Deshalb müssen wir auf Erweiterungen wie Sirnons Basic verzichten. Nicht zuletzt auch, weil solche Erweiterungen den Anwenderkreis stark einschränken. Simons Basic wäre vielleicht noch vertretbar (abgesehen von den 8 KByte Basic-Speicher, die es belegt), da es schon weit verbreitet ist, aber andere Erweiterungen würden es nur demjenigen ermöglichen das Adventure zu spielen, der diese Erweiterung besitzt.
 
Äußerst sinnvoll hingegen sind Erweiterungen, die den Programmierkomfort unterstützen, der beim C 64, abgesehen vom Full-Screen-Editor, sehr gering ist.

Ich meine hiermit Zusatzbefehle wie:
DUMP		zum Variablen auflisten
HELP		zur Fehlerbeseitigung
TRACE		zum Überprüfen des Programmablaufs sowie
KEY		zur Funktionstastenbelegung etc...

Gemeint sind also Befehle, die nicht im Programm verwendet werden, sondern nur direkt, wie der Befehl LIST arbeiten.

Eine empfehlenswerte Erweiterung ist das mittlerweile weitverbreitete Turbotape — eine Schnellade-Routine, die die Ladegeschwindigkeit der Datasette um den Faktor 10 erhöht. Turbotape benötigt keinen Basic-Speicher. Durch die hohe Baudrate entfallen langwierige LOAD- und SAVE-Vorgänge. Eine andere sinnvolle Erweiterung ist das KFC-Supermodul. Es enthält Turbotape, sowie die oben erwähnten Befehle und noch einige mehr. Da es jedoch 8 KByte Speicher benötigt, kann es nur so lange eingesetzt werden, wie das Adventure die Länge von 30 KByte unterschreitet.

Reichen die 30 KByte schließlich nicht mehr aus, so muß das Modul abgeschaltet und somit auf die Hilfsbefehle verzichtet werden. Dadurch erklärt sich auch die Tatsache, daß die schwierigsten und kompliziertesten Programmteile zu Beginn geschrieben werden müssen. Um das Spiel später mit Grafik zu versehen, werden keine Trace- und Dump Befehle mehr benötigt.

Eine weitere Schwierigkeit besteht darin, den Überblick über ein 38-KByte-Programm zu behalten, wenn man keinen Drucker besitzt. Ich kann Ihnen jedoch aus eigener Erfahrung versichern, daß ein Drucker bei einer guten Programmiertechnik nicht unbedingt erforderlich ist.

Sicherlich kann man den Überblick über ein langes Basic Programm gewährleisten, wenn man es gut strukturiert. Da strukturierte Programme jedoch viel länger sind als nicht strukturierte, müssen wir eine Zwischenlösung von strukturierter und »chaotischer« Programmierung suchen.

Ich habe mich für folgende Lösung entschieden:

- Das Programm wird in kleine Teilprogramme (Module) zerlegt.
- Diese Module werden ausführlich in ihrer Funktionsweise erklärt. Jedes Modul ist in sich abgeschlossen. Es kann individuell für jedes Programm verwendet werden. Das Modul wird im Normalfall mit GOSUB aufgerufen.
- Die einzelnen Module werden innerhalb des Programms vom Hauptmodul aufgerufen. Das Hauptmodul ist also der zentrale Punkt des Listings beziehungsweise des Programms.
- Die Module stehen immer in den selben Zeilennummern; zum Beispiel Befehlseingabemodul immer von Zeile 50000 bis maximal Zeile 50999 etc.

Die Module werden in den folgenden Abschnitten ausführlich behandelt. Ein Abschnitt baut auf dem anderen (vorhergehenden) auf. Deshalb ist es erforderlich, daß Sie die Module nicht nur einfach abtippen, sondern auch verstehen lernen. Sind Sie mit der Funktionsweise eines Moduls vertraut, so versuchen Sie damit zu experimentieren.

Im nächsten Kapitel wird ein wichtiges Modul behandelt—die Befehlseingabe. Es werden hierbei mehrere Möglichkeiten vorgestellt. Ziel eines jeden Kapitels soll sein, Ihnen das Wissen, das nötig ist, das jeweilige Modul zu programmieren, zu vermitteln. Damit Sie überprüfen können, ob Sie genug für das jeweils folgende Modul gelernt haben, werde ich Ihnen am Ende eines jeden Abschnittes eine Aufgabe stellen. Hierzu jedoch später.

Speichern Sie alle Beispielprogramme nach dem Eintippen stets auf Kassette/Diskette ab, damit Sie später darauf zurückgreifen können.

Bevor Sie nun beginnen, sollten Sie einen Blick in den Anhang dieses Kurses werfen, da dort mehrere Hilfsprogramme zu finden sind.

Während des Kurses werden wir öfter auf Programme aus diesem Anhang zu sprechen kommen. Also, Computer einschalten und Los geht's...

### String-Operationen

Gerade beim Programmieren von Abenteuerspielen ist es unbedingt notwendig, mit der Technik der Stringverarbeitung vertraut zu sein. Obwohl die eigentlichen Stringfunktionen im Basic leicht verständlich sind, haben Anfänger oft erhebliche Schwierigkeiten, sie sinnvoll einzusetzen. Dieser Fall tritt insbesondere dann auf, wenn mehrere Funktionen ineinander verschachtelt werden müssen.

Hier nun eine kleine Einführung in die Stringverarbeitung. Das Basic des Commodore 64 bietet folgende Stringfunktionen an:

TODO

ASC(X$):

Geben Sie Ihrem Computer im Direktmodus einmal folgenden Befehl ein:
X$= "A ":? ASC(X$) <RETURN>.
Als Ergebnis erhalten wir 65. Im C 64-Handbuch auf Seite 135 bis 137 finden Sie eine Tabelle der ASCII- und CHR$-Codes. Diese Tabelle ordnet jedem Zeichen eine Zahl zu. Bei der Zahl 65 finden wir den Buchstaben A.
Die ASC-Funktion liefert uns also den Zahlenwert zu jedem Zeichen und zwar jeweils den Wert des 1. Zeichens des definierten Strings.

CHR$(X):

CHR$ ist die Umkehrung der ASC-Funktion. CHR$(X) ergibt das Zeichen, das dem Zahlenwert X zugeordnet ist. Geben wir ? CHR$ (65) ein, so erhalten wir als Antwort das Zeichen A. Mit CHR$(X) können auch Sonderfunktionen wie Farben und Groß-/Kleinumschaltung ausgeführt werden. Die Tabelle im Handbuch gibt hier ausführlich Antwort.

LEN(X$):

Diese Funktion ergibt die Anzahl der Zeichen, die ein String enthält.
X$ = "ABENTEUER"
? LEN(X$)
Das Ergebnis wäre hierbei 9, da das Wort »Abenteuer« 9 Buchstaben enthält. Achtung: Auch Leerzeichen im String werden mitgezählt.

LEFT$(X$,X):

Diese Funktion ergibt die linken »Zeichen von X$.
Beispiel:
X$ = →ABENTEUER→
? LEFTS(X$,5) ergibt »ABENT«.

RIGHT$(X$,X):

Diese Funktion ergibt die rechten X-Zeichen von X$

MIDS(X$,S,X):

Diese Funktion ergibt X-Zeichen von X$, beginnend mit dem Zeichen an Position S.
X$ = "ROTGELBGRUEN"
? MID$(X$,4,4) ergibt GELB.
Der dritte Parameter kann fortgelassen werden. MID$(X$,S) ergibt dann alle Zeichen ab Position S, in unserem Beispiel also »GELBGRUEN«

STR$(X):

STR$(X) gibt uns die Möglichkeit, eine Zahl in einen String zu verwandeln.
X = 100+20+3
X$ = STR$(X)
? X$ ergibt 123

VAL(X$):

Diese Funktion ist im wesentlichen die Umkehrung der STR$-Funktion.
VAL("100") ergibt 100
VAL("123ABC") ergibt 123
VAL("ABC123") ergibt 0, da das erste Zeichen keine Zahl ist.

Dies waren nun auch schon alle Funktionen, die Ihnen nun verständlich sein sollten.
 
Nun aber einige Anwendungsbeipiele.

1. Prüfen, ob ein String in einem anderen enthalten ist.<br>Eine solche Routine ist besonders dann nützlich, wenn man dem Spieler ermöglichen will, Befehle abzukürzen (zum Beispiel UNT statt UNTERSUCHE).<br>Beispiel: Es soll überprüft werden, ob B$ in A$ enthalten ist.<br>10 A$="UNTERSUCHE"<br>20 B$="UNT"<br>30 IF B$=LEFTS(A$,LEN(B$)) THEN PRINT" B$ KOMMT IN A$ VOR! "<br>40 END<br>Eine Programmdokumentation erübrigt sich hier. Falls Sie das Programm nicht verstehen, so studieren Sie nochmals ausführlich die einzelnen String-Befehle.
2. Ausdruck einer Zahlenkette.<br>Geben Sie einmal folgendes Programm ein:<br>10 FOR I=1 TO 5<br>30 PRINT I; ", ";<br>40 NEXTI<br>50 END

Wenn Sie das Programm nun mit RUN starten, wird auf dem Bildschirm folgendes ausgedruckt 1 , 2 , 3 , 4 , 5 ,

Uns stören hierbei die Zwischenräume (oder sollten uns zumindest stören). Deshalb soll das Programm so verändert werden, daß folgendes Ergebnis erreicht wird: 1,2,3,4,5,

Um dies zu erreichen, machen wir in dem Programm einen kleinen Umweg über den STR$(X)-Befehl.

Wir ergänzen das Programm um Zeile

20 X$=MID$(STR$(I),2)

und ändern Zeile 30 um

30 PRINT X$;",";

Ich hoffe, Sie sind mir nicht böse, daß ich schon wieder keine ausführliche Dokumentation zu Zeile 20 liefere, aber Ziel des Kurses soll schließlich sein, ihnen Programmieren beizubringen. Ich werde mich deshalb hauptsächlich auf die Dokumentation von kniffligen Problemen beschränken und Sie die einfacheren Aufgaben selbst ausarbeiten lassen. Aber nur keine Angst. Es wird bestimmt nicht zu schwer für Sie werden. Wenn Sie sich im Gebrauch von String-Befehlen nun einigermaßen sicher fühlen, dann können Sie sogleich mit dem nächsten Abschnitt fortfahren.
 
### Die Befehlseingabe

In diesem Abschnitt werden wir einen Programmteil erarbeiten, der für jedes Text-Adventure unentbehrlich ist: die Befehlseingabe.

Darunter versteht man den Programmteil, bei dem der Computer einen Befehl vom Spieler erwartet. Bei den meisten Adventures erscheint dann auf dem Bildschirm die Frage »WAS NUN?«. Bereits daran, wie gut die Befehlseingabe ist, kann man über die Qualität des Spiels entscheiden. Ziel dieses Abschnitts soll sein, Ihnen soviel Wissen über Texteingaberoutinen zu vermitteln, daß Sie in der Lage sind, eine Befehlseingaberoutine zu schreiben, die professionellen Spielen in nichts nachsteht. Ziel ist es also, ein Befehlseingabe-Modul zu schreiben, das später universell eingesetzt werden kann.

Im Kapitel Arbeitsmittel und Methoden habe ich Ihnen bereits erklärt, daß jedes Modul immer in den selben Zeilennummern stehen soll, damit man auch bei längeren Programmen nicht den Überblick verliert.

Das Befehlseingabe-Modul wollen wir künftig immer in den Zeilen 50000 bis maximal 50999 unterbringen. Es wird folglich mit GOSUB 50000 aufgerufen.

a) Befehleingabe Modul 1<br>Geben Sie nun einmal Listing 1 in den Computer ein:

TODO Listing 1

Wenn Sie das Programm laufen lassen, so fragt der Computer »WAS NUN?« und wartet auf eine Befehlseingabe, etwa auf einen Befehl wie »NIMM SCHWERT« der mit RETURN abgeschlossen wird.

Dokumentation zum Listing:

10	Aufruf des Befehlseingabe-Moduls
20	Ausdruck des Befehls, den wir als BE$ bezeichnen wollen
30	Zurück zum Anfang
50000	POKE 198,0 setzt den Tastaturpuffer auf Null. Dadurch wird verhindert, daß die Befehlseingabe einfach übersprungen wird, weil noch Zeichen im Tastaturpuffer stehen. Außerdem wird der String, in dem der Befehl steht, gelöscht (BE$ = " ")
50020	Mittels eines einfachen INPUT-Befehls wird der Befehlsstring BE$ eingelesen
50030	Ende des Moduls

Hiermit hätten wir auch schon unser erstes Modul. Leider hat diese einfache Befehlseingabe einige Haken:

- Man kann mit dem Cursor über den ganzen Bildschirm fahren und beliebig »herumwüten«.
- Bei Eingabe von Komma erfolgt ein »?EXTRA IGNORED ERROR«.
- Professionelle Routinen fahren mit dem Programmablauf fort, wenn über einen längeren Zeitraum keine Eingabe erfolgt.
 
Dies ist bei unserer ersten Routine noch nicht der Fall. Wir müssen eingestehen, daß der NPUT-Befehl anscheinend doch nicht das Wahre für eine professionelle Eingaberoutine ist.

Das Problem ist noch einmal neu anzupacken.

b) Befehlseingabe Modul 2<br>Geben Sie bitte das folgende Programm (Listing 2) ein und lassen Sie es nach SAVE laufen.

TODO Listing 2

Auf den ersten Blick scheint sich nicht viel geändert zu haben. Bei intensiverem Ausprobieren werden Sie jedoch einige Unterschiede zum vorhergehenden Programm bemerken:

- Die Cursortasten sind ausgeschaltet
- Es werden nur noch folgende Zeichen akzeptiert: A bis Z und " und die Tasten SPACE, DEL, RETURN
- Mit DEL kann nur die Eingabe gelöscht werden — nicht jedoch die »WAS NUN?«-Frage.

Damit haben wir eine schon fast »idiotensichere« Routine, wie man sie in professionellen Spielen findet.

Dokumentation zum Listing:

50010	Tastaturpuffer und BE$ löschen. »WAS NUN?« fragen.
50020	POKE 204,0 zum Einschalten des Cursors.
50030	Auf Eingabe eines einzelnen Zeichens X$ warten.
50040	Jeder Taste ist ein bestimmter Wert zugeordnet (zum Beispiel RETURN = 1). Mittels PEEK (203) erfährt man, welche Taste gedrückt worden ist. Wird also die RETURN Taste gedrückt oder die Länge des Befehls BE$ überschreitet die Länge von 68 Zeichen, so wird die Routine beendet: der Cursor wird gelöscht und gestoppt.
50050	Hier wird die Eingabemöglichkeit auf die oben erwähnten Zeichen und Tasten eingeschränkt (vgl. auch ASCII-Werte mit Commodore-Handbuch).
50060	Hier wird verhindert, daß mittels DEL mehr Zeichen gelöscht werden als vorher eingegeben worden sind.
50070	Prüfung, ob DEL-Taste gedrückt worden ist. Wenn Ja, dann Cursor ausschalten. Letztes Zeichen löschen. Vom Befehlsstring BE$ das letzte Zeichen wieder löschen.
50080	Das neue Zeichen X$ ausdrucken. Den Befehlsstring BE$ um das neue Zeichen X$ erweitern. Neues Zeichen von Tastatur abwarten.

Nun möchte ich Ihnen noch eine Routine (Listing 3) vorstellen. Erfolgt 30 Sekunden lang keine Eingabe, so endet die Routine und fährt im Programm fort— die Bedenkzeit des Spielers wird also eingeschränkt. Bei dieser Routine werden Sie feststellen, daß der Bildschirm in zwei Abschnitte unter-teilt ist, wie es bei Adventures mit Grafik und Text vorkommt. Die oberen 3/4 des Bildschirms sind als Grafik-Fenster, das untere Viertel als Texteingabe-Fenster definiert.

TODO Listing 3

Auf eine ausführliche Dokumentation verzichte ich hier, da nur wenige neue Elemente im Listing auftauchen.

Dies sind:

a)	TI$ wird zum Einschränken der Abfragedauer eingesetzt. Wenn die Zeit von 30 Sekunden überschritten wird, so fährt das Programm automatisch fort (Zeile 50020).
b)	Werfen Sie bitte einen Blick auf Zeile 50000.<br>Dort heißt es: POKE 214,18: POKE 211,0:SYS 58732<br>Durch diese POKE-Stellen kann man bestimmen, wo der Cursor oder das nächste PRINT erscheint.<br>POKE 214, Zeile (0-24)<br>POKE 211, Spalte (0-39)<br>danach SYS 58732, um eine Betriebssystem-Routine aufzurufen, die den Cursor an der neuen Stelle positioniert.

Damit wären wir auch schon am Ende des ersten Abschnitts angelangt. Sie sollten nun gelernt haben, wie man mit den String-Funktionen umgeht und Befehlseingabe-Routinen schreibt. Bevor Sie mit dem nächsten Abschnitt fortfahren, sollten Sie ein wenig mit den vorgestellten Routinen experimentieren und sie nach eigenen Wünschen und Ideen umgestalten.

Schreiben Sie sich sodann ein Befehlseingabe-Modul (welches wie vereinbart in den Zeilen 50000 bis maximal 50999 liegt), das Sie dann in den folgenden Abschnitten verwenden können.

Das Modul muß durch GOSUB 50000 aufgerufen werden können und dann einen String BE$ liefern, der den Befehlssatz enthält.
 
### Die Befehlszerlegung

Nachdem wir nun unser Befehlseingabe-Modul fertiggestellt haben, wollen wir uns einem neuen Modul »dem Befehlszerlegemodul« zuwenden und somit einen ersten Schritt zur Befehls-Analyse beginnen.

Was ist eigentlich der Unterschied zwischen Befehlszerlegung und Befehls-Analyse, werden Sie jetzt vielleicht fragen?

Ganz einfach. Die Befehlszerlegung (also unser neues Modul) besteht darin, einen Befehlssatz BE$ in kleine einzelne Befehle zu zerlegen. Dies ist nötig, da der Computer immer nur einen Befehl nach dem anderen und nicht einen Mehrfachbefehl auf einmal bearbeiten kann. Die Befehls-Analyse besteht darin, die Einzelbefehle auszuführen. Das Programm reagiert auf den Befehl.

Vielleicht haben Sie schon einmal das englische Adventure »The Hobbit« gespielt oder zumindest davon gehört.

»The Hobbit« ist ein Adventure mit äußerst gelungener Befehls-Analyse. Der Wortschatz kennt kaum Grenzen. Hier ein Beispiel, wie es beim Hobbit sein könnte:

SIE SEHEN:	SCHWERT
SEIL
DIE FELSENTUER
MOEGLICHE RICHTUNGEN: SUEDEN
WAS NUN? Nimm das Schwert, das Seil und geh nach Sueden.
SIE NEHMEN DAS SCHWERT.
SIE NEHMEN DAS SEIL.
SIE GEHEN NACH SUEDEN.

Diesen Textausschnitt (den ich ins Deutsche übersetzt habe) wollen wir nun einmal näher betrachten.

Der Computer teilt dem Spieler mit, was er sieht und welche Richtungen möglich sind und erwartet sodann einen Befehl »WAS NUN?«.

Der Spieler gibt seinen Befehlssatz (bei uns BE$) ein.

Der Computer meldet sich jedoch nicht mit »SIE NEHMEN DAS SCHWERT, DAS SEIL UND GEHEN NACH SUEDEN.«, sondern gibt drei Meldungen aus — für jeden Teilbefehl eine.

Daran können wir erkennen, daß auch dieses professionelle Adventure Befehle nacheinander ausführt.

Unser Ziel soll nun sein, eine Befehlszerlegung und Befehls-Analyse zu programmieren, die der oben erwähnten professionellen in nichts nachsteht. Bevor wir uns wieder zum Programmieren begeben, müssen wir einiges an Theorie durchkämmen.

Schauen wir uns doch einmal folgende Befehlssätze, die jeweils einen Befehl enthalten, an:

1.	NIMM DAS SCHWERT.
2.	GEH NACH NORDEN.
3.	UNTERSUCHE DAS SCHWERT.
4.	WIRF DAS SEIL.
5.	OEFFNE DIE TRUHE.
6.	LEGE DAS SCHWERT IN DIE TRUHE.
7.	TOETE DAS MONSTER MIT DEM SCHWERT.
8.	WARTE.

Dies sind typische Befehlssätze BE$, wie sie vom Spieler eingegeben werden.

Nun wollen wir die Befehlssätze auf das Nötigste komprimieren, das heißt, daß alle Worte, die für das Verständnis des Befehls unnötig sind, aussortiert werden.

Wir erhalten dann für die Tabelle:

1.	NIMM SCHWERT
2.	N
3.	UNTERSUCHE SCHWERT
4.	WIRF SEIL
5.	OEFFNE TRUHE
6.	LEGE SCHWERT TRUHE
7.	TOETE MONSTER SCHWERT
8.	WARTE

Diese Sätze sind zwar komprimiert, aber dennoch ist ihr Sinn eindeutig. Die Sätze 6 und 7 sind zwar extrem schlechtes Deutsch und für uns vielleicht zweideutig, aber für unser späteres Analyse-Programm gut verständlich.

Auffallend ist, daß unsere komprimierten Befehlssätze aus maximal drei Worten bestehen. Denken Sie sich doch einmal einige komplizierte Befehlssätze aus und sortieren Sie dann alle überflüssigen Worte aus. Der Befehl, der dann übrigbleibt, besteht garantiert aus nicht mehr als drei Worten. Diese Garantie gilt natürlich für Befehlssätze mit nur einem Befehl, es darf also kein »und« oder »,« im Satz vorkommen.

Befehlssätze mit mehreren Befehlen werden immer in Einbefehlssätze aufgeteilt.

Aus »NIMM DAS SCHWERT UND GEH NACH NORDEN« würde also »NIMM DAS SCHWERT« und »GEH NACH NORDEN«. Die beiden Sätze, die sich aus dieser Trennung ergeben, können dann wieder nach obigem Schema zerlegt werden.

Als nächstes wollen wir unsere komprimierten Befehlssätze auf folgende Elemente untersuchen:

VERBEN:

Wörter wie NIMM, OEFFNE und Himmelsrichtungen (N, S). Der Befehl N ist eine Abkürzung für GEH NACH NORDEN und kann somit als Verb interpretiert werden.

OBJEKTE:

Wörter wie TUER, TRUHE, BAUM, HAUS; also im wesentlichen Dinge, die man nicht transportieren kann. Außerdem Personen im weitesten Sinne (zum Beispiel MONSTER).

GEGENSTÄNDE:

Dies sind Objekte, die man transportieren kann. Zum Beispiel SCHWERT, SCHLUESSEL, TRUHE, SEIL. Dinge wie die Truhe, können sowohl Gegenstände als auch Objekte sein; dazu jedoch später.

Ich werde folgende Abkürzungen verwenden:

ve für VERB

ob für OBJEKT

ge für GEGENSTAND

Wenn wir die zweite Tabelle auf die obigen Elemente überprüfen, so erhalten wir folgende neue Tabelle:

1.	ve + ge
2.	ve
3.	ve + ge
4.	ve + ge
5.	ve + ob oder auch ve + ge (falls Truhe transportabel)
6.	ve + ge + ob
7.	ve + ob + ge
8.	ve
 
Aus dieser Tabelle können wir folgendens erkennen:

- jeder Befehlssatz enthält ein und nur ein Verb
- das Verb steht immer an erster Stelle und ist somit das erste Wort des Befehlssatzes
- nach dem Verb können Objekte und Gegenstände aufgeführt sein.

Im allgemeinen sind folgende ve-ob-ge-Kombinationen möglich:

a)	ve		»WARTE«
b)	ve + ge	»NIMM SCHWERT«
c)	ve + ob		»OEFFNE TUER«
d)	ve + ge + ob 	»LEGE SCHWERT TRUHE«
e)	ve + ob + ge 	»TOETE MONSTER SCHWERT«
f)	ve + ge + ge 	»VERKNOTE SEIL BRETT«

Wir wissen nun also, daß jeder Satz immer mit einem Verb beginnt. Das folgende zweite Wort kann dann ein Gegenstand oder ein Objekt sein. Das dritte Wort genauso. Schön und gut. Wir haben nun einiges an Grammatik-Theorie durchgekaut, und wissen wie man Sätze auf das Nötigste komprimieren kann. Wie programmiert man denn nun aber solch eine Befehlszerlegung?

Bevor wir mit dem Programmieren beginnen, wollen wir deshalb noch einige Gedankenexperimente durchführen: Greifen wir doch noch einmal auf den vorangegangenen Abschnitt zurück, in dem wir das Befehlseingabemodul behandelt haben.

Es ist Ihnen sicherlich bereits klar, daß dieses Modul immer vor dem Befehlszerlegungsmodul (das wir nun besprechen) aufgerufen werden muß, denn bevor man einen Befehlssatz zerlegen kann, muß man ja erst einmal einen haben. Wenn man das Befehlszerlegungsmodul aufruft, so läßt es den Spieler einen Befehl eingeben, der als BE$ gespeichert wird.

Zum Beispiel: BE$= "NIMM DAS SCHWERT"

Dieser Befehlsstring BE$ wird dann in das Befehlszerlegemodul geschickt, wo es weiterbehandelt wird. Das Schema ist folgendermaßen:

TODO

Das Befehlseingabemodul liefert also den Befehlsstring BE$ an das Befehlszerlegungsmodul. Was macht das Zerlegungsmodul nun mit dem String BE$?

Während das Befehlseingabemodul nur eine einzige Aufgabe hat, nämlich als eine komfortable INPUT-Routine zu fungieren, muß das Befehlszerlegemodul schon wesentlich mehr leisten.

In dem Zerlegungsmodul sind mehrere Module vereint, die folgende Aufgaben haben:

1.	String-Zerlegung
2.	String-Sortierung
3.	String-Codierung

Diese Aufgabenbereiche wollen wir nun einmal im Einzelnen betrachten.

Wir wollen bei den folgenden Betrachtungen von einem Befehlsstring BE$ ausgehen, der so aussieht:

BE$= "NIMM DAS SCHWERT".

Dieser Befehlsstring wird nun also vom Befehlseingabenmodul zum Befehlszerlegungsmodul geschickt.
 
Im Befehlszerlegungsmodul geschieht dann folgendens mit dem BE$:

1.	Der erste Schritt besteht darin, den Befehlsstring BE$ in einzelne Worte aufzuschlüsseln.<br>Jedem Wort des Befehlsstrings BE$ wird ein neuer String zugeordnet. Diese neuen Strins werden als BE$(1) bis BE$(X} bezeichnet, wobei X die Zahl der im Satz vorkommenden Worte darstellt.<br>Für unser Beispiel würde dann gelten:<br>BE$ "NIMM DAS SCHWERT"<br>BE$(1)= "NIMM"<br>BE$(2)= "DAS"<br>BE$(3)= "SCHWERT"
2.	Der zweite Schritt besteht anschließend darin, den Satz zu komprimieren, also alle überflüssigen Worte aussortieren. Auszusortierende Worte sind Worte, die zum Verständnis des Satzsinns überflüssig sind.<br>Also Wörter wie DER, DIE, DAS, DEN, DEM, UEBER, UNTER, AUF VON, IN etc.<br>Für unser Beispiel gilt hier:<br>BE$ = "NIMM DAS SCHWERT"<br>BE$(1) = "NIMM"<br>BE$(2) = "SCHWERT"<br>Eigentlich ist es falsch, dies als den zweiten Schritt zu bezeichnen, da der zweite Schritt parallel zum 1. Schritt abläuft. Es ist also nicht so, daß der Satz in BE$(1) bis BE$(X) zerlegt wird und dann die überflüssigen Wörter aussortiert werden und somit BE$(1) bis BE$(X) neu formatiert werden muß.<br>Dieser parallele Ablauf sieht also so aus:<br>Das Zerlegemodul holt sich ein Wort aus dem Befehlsstring und überprüft sofort, ob es überflüssig ist oder nicht. Wenn ja, dann wird es erst gar nicht in die Befehlswortkette BE$(1) bis BE$(X) aufgenommen.<br>Für die folgenden Seiten und Abschnitte sind Kenntnisse über den Umgang mit dem DIM-Befehl notwendig.
3. Was nun folgt ist die String-Codierung.<br>Wie das Wort Codierung bereits verrät, kommen jetzt Zahlen mit ins Spiel. Der Trick besteht darin, den gesamten Befehlssatz in eine Zahl umzuwandeln. Dies hat den Vorteil, daß viel Speicherplatz gespart wird. Damit jedoch der Überblick über die vielen Zahlen gewährleistet bleibt, ist es unbedingt erforderlich, ständig schriftliche Notizen zu machen (Tabellen etc.)<br>Bevor der Computer Befehle analysieren kann, braucht er erst einmal ein Vokabular, einen Wortschatz, auf den er ständig zurückgreifen kann.<br>Wie Sie bereits wissen, zeichnet sich ein gutes Adventure hauptsächlich durch einen umfangreichen Wortschatz aus. Das eigentliche Problem besteht nun darin, einen möglichst großen Wortschatz in möglichst wenig Speicher zu stecken. Es gibt zahlreiche Möglichkeiten, dieses Problem zu lösen. Leider jedoch auch viele schlechte.<br>Sicherlich kennen auch Sie Adventures, bei denen die Aufgabe des Spielers hauptsächlich darin besteht, den spärlichen Wortschatz des Spiels zu erraten. Solche Spieler belohnen Befehlseingaben ständig mit Antworten wie »Ich kenne dieses Wort nicht!« etc. Andere Spiele bringen nicht einmal eine Fehlermeldung, sondern ignorieren den Befehl einfach. Durch solche Fehlermeldungen wird der Spieler ständig vom eigentlichen Adventure abgelenkt und verliert schnell die Lust am Weiterspielen.<br>Im Rahmen dieses Kurses werde ich Ihnen deshalb ein Befehlsanalysesystem vorstellen, das kaum Schwächen hat und universell für jedes Adventure einsetzbar ist.<br>Bei diesem System sind im Computer Wort-Tabellen gespeichert, die jedem Wort einer Gruppe eine Zahl zuordnen.<br>Die verschiedenen Wortgruppen sind<br>- Verben<br>- Gegenstände<br>- Objekte<br>- sowie Personen –,<br>die wir zunächst vernachlässigen wollen, Natürlich gibt es auch eine Tabelle, die alle Wörter enthält, die aussortiert werden müssen.<br>Und so sehen diese Tabellen aus:

TODO

Die Beispieltabellen sind nur sehr kurz gehalten. In Wirklichkeit können sie beliebig lang sein, und je länger sie sind, desto größer ist der Wortschatz des Adventures.

Wir haben vier Grundtabellen: Verben, Gegenstände, Objekte und Personen. Die Tabellen ordnen jedem Wort, das in ihnen enthalten ist, eine Zahl zu, Diese Zahlen sind jedoch nicht willkürlich gewählt, sondern das erste Wort jeder Tabelle hat immer den Wert 1 und das letzte Wort immer den Wert X, wobei X die Anzahl der in der Tabelle vorkommenden Worte darstellt.

Wie die Tabelle programmiert wird, soll uns im Moment noch nicht interessieren. Wir wissen nur, daß wir verschiedene Tabellen haben, die bestimmten Worten Zahlen zuordnen. Sicher erinnern Sie sich daran, daß ich Ihnen empfohlen habe, während und vor dem Programmieren ständig schriftliche Notizen zu machen (Heft zu führen). Gerade bei diesen Tabellen ist es wichtig, daß sie in sauberer schriftlicher Form vorliegen. Sie werden während der Programmierung des Spiels ständig benötigt.

Gehen wir doch noch einmal von unserem Beispielsatz aus:

Wir hatten BE$ = "NIMM DAS SCHWERT"

Diesen Satz haben wir dann in einzelne Worte zerlegt. Es ergab sich:

BE$(1) = "NIMM"
BE$(2) = "DAS"
BE$(3) = "SCHWERT"

Als nächstes hatten wir alle unwichtige Worte aussortiert und erhielten so:

BE$(1) = "NIMM"
BE$(2) = "SCHWERT"
 
Die Zahlen in den Klammern hinter BE$ geben an, wo das Wort im Satz steht – BE$(1) ist also das erste Wort im Satz (das Wort mit dem der Satz beginnt). Denken wir noch einmal zurück an unsere kleine Grammatiklehre, in der wir folgendes festgestellt haben:

1.	Das Verb ist immer das erste Wort im Satz (also BE$(1))
2.	Die folgenden Worte sind Objekte. Gegenstände oder Personen

Nun ist es nicht mehr schwer, zu erraten, wie die Befehlscodierung funktioniert:

Wir nehmen unser erstes Wort BE$(1) und suchen dann in der Tabelle für die Verben (da das erste Wort immer ein Verb ist) welche Zahl ihm zugeordnet ist. Für das Wort BE$(1) = "NIMM erhalten wir gemäß Tabelle den Wert 1.

Wir können somit sagen: VERBZAHL = 1

Nun kommen wir zu unserem zweiten Wort BE$(2). Da wir nicht wissen, ob BE$(2) ein Gegenstand, ein Objekt oder eine Person ist, müssen wir in allen drei Tabellen nach dem Wort suchen.

Als Ergebnis erhalten wir dann entweder eine Gegenstands-, eine Objekt- oder eine Personenzahl.

Für unser Wort BE$(2) = "SCHWERT" erhalten wir also die Gegenstandszahl 1, da BE$(2) in der Tabelle für Gegenstände steht.

Die gesamte Codierung für unseren Satz BE$ = "NIMM DAS SCHWERT" hat uns also folgende Werte geliefert:

VERBZAHL = 1
GEGENSTANDSZAHL = 1
OBJEKTZAHL = 0
PERSONENZAHL = 0

Damit haben wir nun eine Möglichkeit kennengelernt, mit der man einen Satz durch Zahlen ausdrücken kann, die natürlich in Tabellen mit Wörtern definiert sein müssen.

Bei unserem Beispiel haben wir als Wert für die Objektzahl und die Personenzahl jeweils 0 erhalten. Dies liegt daran, daß in unserem Ausgangssatz »NIMM DAS SCHWERT« weder eine Person noch ein Objekt vorkommen. Das Schwert ist ein Gegenstand; Objekte sind Dinge, die nicht transportiert werden können (wie wir bereits definiert hatten).

Allerdings hat dieses Analyse- beziehungsweise Codierungssystem noch einen Haken:

Was passiert, wenn in einem Satz zwei Gegenstände auftreten? Zum Beispiel:

BE$= »VERKNOTE DAS SEIL AM SCHWERT«.

In diesem Satz treten zwei Gegenstände, Seil und Schwert, auf. in unserer Gegenstands-Tabelle hat Schwert den Wert 1 und Seil den Wert 3. Was ist aber nun unsere Gegenstandszahl?

Um dieses Problem zu lösen, müssen wir noch einmal auf unsere Tabelle, die alle möglichen ve-ob-ge-Kombinationen darstellt, zurückgreifen (die Personen werden vorerst noch vernachlässigt).

Aus dieser Tabelle können wir folgendes lesen:

1.	Ein Befehlssatz enthält maximal 1 Verb — also nur 1 Verbzahl.
2.	Ein Befehlssatz enthält maximal 1 Objekt — also nur 1 Objektzahl.
3.	Ein Befehlssatz kann bis zu maximal zwei Gegenstände enthalten — folglich brauchen wir auch zwei Gegenstandszahlen.<br>Wir bezeichnen diese als 1. Gegenstandszahl und 2. Gegenstandszahl

Was ist nun mit den Personen los?

Lassen Sie uns dazu folgende Beispiele von dem Adventure »The Hobbit« hernehmen, in dem besonders viele Personen auftreten.

a)	SAGE THORIN »GEB MIR DIE KARTE«.
b)	SAGE ELROND »LIES DIE KARTE«.
c)	SAGE BARD »ERSCHIESSE DEN DRACHEN«.

Satz a und b sind eindeutig. Es kommt nur eine Person vor, und somit wird zur Codierung auch nur eine Personenzahl benötigt, In unserem Beispiel c kommen jedoch zwei Personen vor— Bard und der Drache. Dennoch wird nur eine Personenzahl benötigt.

Dies liegt daran, daß vom Befehlssatz nur eine Person betroffen ist. Die Person ist Bard. Der Drache kommt wiederum im Befehlssatz vor, der für Bard gilt.

Punkt c ist damit ein Beispiel für einen indirekten Befehl. Während wir bisher nur dem Computer direkt Befehle gaben, erhält der Computer jetzt den Befehl, einer bestimmten Person etwas zu befehlen (sagen).
 
Der Befehl für die Person Bard »ERSCHIESSE DEN DRACHEN« wird im Programm nicht vom Modul behandelt, das wir gerade aufbauen, sondern wird an ein Modul weitergeleitet, das für Reaktionen von Personen verantwortlich ist. Dazu jedoch später.

Wir wissen nun allerdings, daß im Modul, das für unsere direkten Befehle zuständig ist, nur eine Personenzahl benötigt wird, da wir nie mehr als eine Person gleichzeitig ansprechen können.

Wir können also zusammenfassen, daß bei der Codierung eines Befehlssatzes folgende Werte ausgegeben werden:

VERBZAHL
1. GEGENSTANDSZAHL
2. GEGENSTANDSZAHL
OBJEKTZAHL
PERSONENZAHL

Hiermit sind nun auch schon die ersten Schritte auf dem Weg getan, der uns zum Programmieren der kompletten Befehlsanalyse führen wird. Im folgenden Diagramm ist das Ablaufschema unseres neuen Moduls (dem Befehlszerlegungs- und Codierungs-Modul) noch einmal in seinen Grundzügen zusammengefasst.

TODO

Hier noch einige Beispiele:

Geben wir als Befehlsstring BE$=»OEFFNE DIE TUER« in das Codier-Modul, so erhalten wir als Ausgabe:

VERBZAHL = 3
1. GEGENSTANDSZAHL = 0
2. GEGENSTANDSZAHL = 0 
OBJEKTZAHL = 2
PERSONENZAHL = 0
(alle Angaben gemäß unserer Beispieltabelle)

Für die Eingabe BE$ = »VERLIERE DIE FACKEL« erhalten wir die Ausgabe:

VERBZAHL = 2
1. GEGENSTANDSZAHL = 4
2. GEGENSTANDSZAHL = 0 
OBJEKTZAHL = 0
PERSONENZAHL = 0
 
Für die Eingabe BE$=»GIB DEM GEIST DEN SCHLUESSEL« erhalten wir die Ausgabe:

VERBZAHL = 4
1. GEGENSTANDSZAHL = 2
2. GEGENSTANDSZAHL = 0
OBJEKTZAHL = 0
PERSONENZAHL = 1

Für die Eingabe BE$=»BEFESTIGE DAS SEIL AM FENSTER« erhalten wir die Ausgabe:

VERBZAHL = 7
1. GEGENSTANDSZAHL = 3
2. GEGENSTANDSZAHL = 0
OBJEKTZAHL = 1
PERSONENZAHL = 0

Hiermit wäre die Therorie für unser neues Modul nahezu abgeschlossen. Allerdings müssen wir später noch Fälle betrachten und berücksichtigen, bei denen lange Sätze auftreten,
die UND-Worte enthalten.

## Programmierung des Zerlege – Chiffrier - Moduls

Bevor das Modul arbeiten kann, müssen die Tabellen programmiert werden. Für unsere Verb Tabelle geht das folgendermaßen:

Die einzelnen Verben werden zunächst in DATA-Zeilen abgelegt.

Es gilt also:

..DATA NIMM, VERLIERE, OEFFNE, GIB, SAGE, INVENTUR, BEFESTIGE

Nun brauchen wir eine Variable, die die Anzahl der Verben beinhaltet. Für die Verb Tabelle sei dies die Variable VZ (VZ = Anzahl der Verben — nicht zu verwechseln mit der Verbzahl VE).

Für unsere Verb-Tabelle, die aus sieben Worten besteht, gilt also:

VZ = 7

Für unsere Verb-Tabelle müssen wir nun ein Feld indizieren:

Das Feld für die Verb Tabelle bestimmen wir als Stringfeld VE$. Es gilt also:

DIM VE$(VZ)

Falls Sie mit dem DIM-Befehl noch nicht genug vertraut sind, sollten Sie gleich im Commodore-Handbuch ab Seite 98 nachlesen.

Nun müssen wir das Feld füllen:

FOR I=1 TO VZ: READ VE$(I) NEXT I

Nach diesem Verfahren werden alle Tabellen programmiert. Für die Verb-Tabelle sieht das so aus:

VE$(1) = "NIMM"
VE$(2) = "VERLIERE"
VE$(3) = "OEFFNE"
VE$(4) = "GIB"
VE$(5) = "SAGE "
VE$(6) = "INVENTUR"
VE$(7) = "BEFESTIGE"

Wir nehmen nun einmal an, wir hätten ein Verb BE$(1)= "OEFFNE".

Wenn wir wissen wollen, welche Verbzahl BE$(1) hat, so gehen wir folgendermaßen vor:

10 F0R I=1 TO VZ
20 IF BE$(1)=VE$(I) THEN VE-1
30 NEXT I
40 PRINT "VERBZAHL = ";VE

Wir können Zeile 20 auch so ändern, daß Abkürzungen akzeptiert werden.

20 IF BE$(1)=LEFT$(VE$(I),LEN(BE$(1))) THEN VE=1
 
Der Spieler kann nun also statt VERLIERE auch einfach nur V eingeben, und das Programm versteht trotzdem, was gemeint ist. Es werden jedoch nur Abkürzungen verstanden, die eindeutig sind. Will man das Verb SUCHE mit S abkürzen, so darf in der Verbtabelle neben dem Verb SUCHE kein anderes Verb mehr vorkommen, das mit S beginnt.

Ist dies jedoch der Fall, so wird stets das Verb erkannt, das in der Tabelle den höheren Wert hat. Dies ist jedoch nicht tragisch, da der Spieler im Laufe des Spiels schnell herausfinden wird, wie er Wörter abkürzen muß, damit sie richtig interpretiert werden.

Bitte geben Sie nun einmal Listing 4 ein:

TODO Listing 4

Wenn Sie das Programm anschließend starten, so werden Sie um die Eingabe eines Befehls BE$ gebeten.

Wenn Sie einen Befehl eingeben und anschließend RETURN drücken, so wird auf dem Bildschirm ausgegeben, wie der Befehlsstring BE$ in BE$(1) bis BE$(10) zerlegt wird. Es können also nur Sätze eingegeben werden, die nicht mehr als zehn Worte enthalten (natürlich kann das leicht ausgebaut werden).

Geben Sie einmal verschiedene Sätze ein, und sehen Sie was passiert. Dieses Programm, in dem der Befehlsstring BE$ in einzelne Worte zerlegt wird, was ja der erste Schritt zur Befehlscodierung ist, hat jedoch noch einen kleinen Haken.

Wenn man zwischen den Worten im Satz mehrere SPACEs läßt, so werden diese SPACEs als Worte interpretiert. Diesen Fehler werden wir bald beheben.

Unser neues Modul soll immer ab Zeile 51000 stehen, also direkt nach dem Befehlseingabe-Modul.


Dokumentation zu Listing 4:

TODO

10 bis 70	sind nur zur Demonstration des Moduls 51000
gedacht, und müssen deshalb in ihrer Funktionsweise hier nicht 
näher besprochen werden.
51000		Beginn des Zerlege-Moduls
51010		Hier wird das Feld, das die einzelnen Wörter des
Befehlssatzes enthält, gelöscht, damit später keine Irrtümer auftreten können.
51020		Hier wird die Wort-Zählvariable WZ auf 1 gesetzt.
51030		Diese Schleife durchläuft den Befehlsstring BE$
vom ersten bis zum letzten Zeichen.
51040		Prüfung, ob es sich beim jeweiligen Zeichen um ein Leerzeichen (SPACE) handelt. Wenn ja, so weiß das Programm, daß ein neues Wort beginnt. In diesem Fall wird die Wort-Zählvariable WS um 1 erhöht,
51045		Hier wird verhindert, daß die zulässige Wortzahl von 10 überschritten wird.
51050		Das aktuelle Wort BE (WZ) wird aufgebaut.
51060		Sprung zum Beginn der Schleife I
61070		Ende des Moduls

Dieses Modul liefert nach Aufruf bis jetzt also die Werte BES(1) bis BE$(WZ) — die einzelnen Worte von BES und WZ — die Variable die für die Anzahl der Wörter steht.

Die Funktionsweise dieses Moduls dürfte bis jetzt eigentlich leicht zu verstehen sein. Falls Sie Schwierigkeiten haben, so gehen Sie das bisher Gesagte noch einmal ausführlich durch.

Der nächste Schritt zur Fertigstellung des Moduls besteht nun, wie bereits theoretisch behandelt, darin, überflüssige Worte auszusortieren, beziehungsweise erst gar nicht in die Wortkette BE$(1) bis BES(1 0) aufzunehmen. Wir müssen unser erstes Programm also entsprechend Listing 5 verbessern:
 
Dokumentation zum Listing 5:

TODO
5		Hier wird das Unterprogramm, das die Tabellen definiert, aufgerufen.
10 bis 70	Sind wiederum nur für die Demonstration des Programmes nötig.
51000-51070	Sind analog zu Listing 4 — jedoch mit einer kleinen Änderung in Zeile 51040,
51040		Hier wird, wie auch schon im ersten Programm festgestellt, wann ein neues Wort beginnt (ein Leerzeichen SPACE wird gesucht in BES). Angenommen wir haben ein Leerzeichen gefunden, so wurde im ersten Programm das aktuelle Wort BE$(1) bis BE$(10) übernommen und die Wort-Zählvariable WZ um 1 erhöht (um das nächste Wort zu bilden). Dadurch wurde jede durch SPACE getrennte Zeichenfolge als Wort anerkannt (so ergab sich auch der oben erwähnte Fehler, bei dem mehrere Leerzeichen hintereinander als Wort interpretiert wurden). Zur Korrektur dieses Fehlers und zur Aussortierung der überflüssigen Wörter wird deshalb jetzt ein kleines Unterprogramm ab Zeile 51100 aufgerufen, in dem entschieden wird, ob das aktuelle Wort BE$(WZ) mit in die Wortkette BE$(1) bis BE$(10) aufgenommen wird oder nicht.
60000-60015	Hier wird die Tabelle für die Wörter, die aussortiert werden sollen, definiert, nach dem Schema, das wir bereits besprochen haben. Das Stringfeld für die auszusortierenden Wörter sei AUS.
Die Anzahl der Wörter in der AU$-Tabelle ist AZ

Und so sieht dieses Unterprogramm aus:

TODO
51100		Start des Unterprogrammes
51110		Die Check-Variable IC wird auf 0 gesetzt. Die Schleife I1
durchläuft sodann die AU$- Tabelle.
51120		Prüfung, ob es sich bei dem aktuellen Wort BE$(AW) um ein Wort handelt, das in der AU$-Tabelle vorkommt, und somit aussortiert werden muß. Ist dies der Fall, so wird die Check-Variable IC auf 1 gesetzt,
51130		Sprung zum Schleifenbeginn
51140		Nachdem die Schleife I1 durchlaufen ist, wird der Wert der Check-Variable IC geprüft. Ist IC= 0, so kommt das aktuelle Wort nicht in der AU$-Tabelle vor und muß auch nicht aussortiert werden; es wird in die Wortkette BE$(1) bis BE$(10) übernommen, der Wortzähler WZ wird um 1 erhöht und das Unterprogramm ist beendet.
51150		Die Bedingung in Zeile 51140 wurde nicht erfüllt, also muß es sich bei dem aktuellen Wort BE$(AW) um ein Wort der AU$ Tabelle handeln, es muß aussortiert werden. Dazu wird BE$(AW) gelöscht und der aktuelle Wortzähler WZ nicht erhöht. Die Check-Variable IC dient uns also zum Überprüfen von Bedingungen.

Starten Sie das Programm mit RUN. Da es durch die Zeilen 10 bis 70 dokumentiert ist, braucht der Programmablauf hier nicht näher erklärt zu werden. Geben Sie bitte mehrere Befehlssätze ein, und untersuchen die Ergebnisse. Wenn Sie allerdings wirre Buchstabenketten eingeben, so werden diese akzeptiert, solang sie nicht in der AU$ Tabelle vertreten sind. Wenn Sie die DATA-Zeile betrachten, in der die Worte stehen, die aussortiert werden sollen (die also die AU$-Tabelle bilden), so werden Sie dort auch ein Leerzeichen finden; es ist nötig, um den bereits besprochenen Fehler (mehrere Leerzeichen zwischen den Wörtern in BE$) zu beheben, Leerzeichen werden nun nicht mehr als Worte akzeptiert.

Als kleine Zwischenübung können Sie einmal versuchen die AU$ -Tabelle zu erweitern. Sie müssen dazu nur die DATA Zeilen erweitern und die AZ-Variable entsprechend anpassen.

Unser nächster Arbeitsschritt besteht nun darin, die Wort-Codierung zu programmieren.

Zunächst wieder einige Grundbetrachtungen: Bisher haben wir immer nur Befehlssätze betrachtet, die nur einen Befehl enthielten, in denen also kein UND vorhanden war.

Für die folgenden Betrachtungen und Programme müssen jedoch auch Sätze, die mehrere Befehle enthalten, berücksichtigt werden.

Zu Beginn habe ich Ihnen bereits eine kleine Eingabe-Szene aus dem Adventure »The Hobbit« dargestellt. Daraus war zu erkennen, daß bei dem Analysesystem des Hobbits immer nur ein Befehl nach dem anderen ausgeführt werden kann. Dies ist daran zu erkennen, daß der Computer auf einen Befehlssatz wie »Nimm das Schwert und das Seil« nicht etwa »Sie nehmen das Schwert und das Seil« antwortet, sondern sich erst mit »Sie nehmen das Schwert« und danach mit »Sie nehmen das Seil« meldet.

Betrachten wir einmal den folgenden Befehlssatz, der mehrere Befehle enthält: BE$ = »NIMM DAS SCHWERT UND DAS SEIL UND GEH NACH NORDEN«.

Nachdem das Modul den Satz zerlegt und überflüssige Wörter AU$ aussortiert hat, liegt folgendes Ergebnis vor:

BE$(1) = "NIMM"
BE$(2) = "SCHWERT"
BE$(3) = "UND"
BE$(4) = "SEIL"
BE$(5) = "UND"	— bisher nicht berücksichtigt
BE$(6) = "NORDEN"	— bisher nicht berücksichtigt

Wörter wie UND dürfen nicht aussortiert werden.
Bitte wundern Sie sich nicht, warum ich das Verb »GEH« aussortiert habe — Richtungsangaben sind Ausnahmefälle, die in einem der nächsten Abschnitte ausführlich behandelt werden.

Damit die folgenden Erklärungen nicht zu kompliziert werden, wollen wir BE$(5) und BE$(6) zunächst wieder streichen.

Wir betrachten also nur noch BE$(1) bis BE$(4), also einen Befehlssatz, der zwei Befehle enthält.

Da das Programm ein Wort nach dem anderen liest, brauchen wir einen Wortzähler, den wir mittels der Variablen WZ aufbauen wollen.

Am Anfang des Satzes, also vor Beginn des Lesevorgangs wird WZ auf 1 gesetzt. Nun liest der Computer das Wort BE$(WZ).

Nachdem er es gelesen und codiert hat, erhöht er den Wortzähler um 1, es gilt also WZ=WZ + 1.

Nun wird überprüft, ob das Wort BE$(WZ) existiert, das heißt, es wird überprüft, ob der String BE$(WZ) Zeichen enthält oder er "" (leer) ist.

Erweist sich der String BE$(WZ) als nicht leer, so wird der Lesevorgang fortgesetzt. Andernfalls wird er beendet.

Das Ablaufschema für das Lesen des Befehlssatzes sieht also folgendermaßen aus:

TODO

Achtung: Mit ein Wort LESEN ist das gleiche wie mit ein Wort CODIEREN gemeint.
 
Dieses Ablaufschema ist noch relativ einfach zu verstehen.

Für unsere Zwecke ist es im Moment jedoch nicht ausreichend. Es reicht höchstens für Programme die nur Zwei-Wort-Befehle verstehen.

Um dies besser verstehen zu können, müssen wir einen Blick auf das gesamte Ablaufschema eines Adventures werfen:

TODO

Das Befehlseingabemodul und das Befehlscodiermodul (worin natürlich auch Zerlegung und Aussortierung enthalten sind) sind mit einem Kästchen gestrichelt umrandet. Wir werden diese Module schon bald zu einem einzigen Modul zusammenfassen, das für jedes Adventure universell einsetzbar ist. In dem gestrichelten Kästchen ist unter anderem auch das Ablaufschema des Lesevorganges, das wir gerade zuvor behandelt haben, enthalten.

Das Gesamtablaufschema ist eigentlich relativ leicht zu verstehen. Am Anfang erscheint das Titelbild des Spiels und die Spielanleitung, und es werden Tabellen eingelesen, eventuell Sprites definiert etc. Danach beginnt das Spiel.

Dabei wird zunächst das Befehlseingabe- und Codiermodul aktiviert.

Daraufhin geht es zum Actionmodul. Dies ist das eigentliche Adventure, das heißt, das Actionmodul ist von Spiel zu Spiel verschieden.

Im Actionmodul wird auf Befehle reagiert, Lagebericht erstattet, und außerdem werden Personen, wie Monster gesteuert, bewegt, lebendig gemacht. Das Actionmodul stellt auch die Aufgaben und verwaltet die Spielkarte, das heißt es weiß, wo gerade welcher Gegenstand liegt, wo sich jede Person befindet, was sie gerade macht, welche Türen offen und welche geschlossen sind und noch vieles mehr. Der Umfang dieses Moduls bestimmt letztendlich die Qualität und Länge des Spiels.

Am Ende des Actionmoduls wird bestimmt (geprüft), ob das Spiel zu Ende ist (verloren oder gewonnen), oder ob es weiter geht, also zurück zum Befehlseingabe- und Codiermodul.

Sie sehen also, wie einfach das Grundprinzip eines Adventures eigentlich ist, Und dies ist ja schließlich das Ziel dieses Kurses. Sie sollen lernen sich gute Adventures auszudenken, und diese dann möglichst problemlos und ohne großen Aufwand in ein anderes Programm umzusetzen.

Nachdem das Befehlszerlegemodul den Befehlsstring sortiert und in einzelne Worte zerlegt hat, gibt es diese Worte BE$(1) bis BE$(X) an das Codiermodul weiter.

Der Sinn der vier dort vorkommenden Wörter lautet in Kurzform:

NIMM SCHWERT UND SEIL
 
Wie liest das Codiermodul diesen Satz nun eigentlich? 

Eine erste Antwort auf diese Frage ist, wie bereits besprochen, »Wort für Wort«.

Welches Wort bearbeitet wird, bestimmt die Variable WZ (Wortzähler). Damit das Lesen beim ersten Wort beginnt, setzten wir die Wortzähl-Variable WZ am Anfang des Lese-beziehungsweise Codiermoduls auf 1.

Sodann wird das Wort BE$(WZ) gelesen, also codiert. Und das geht folgendermaßen:

Zuerst wird die Check-Variable IC und die Wortvariablen auf 0 gesetzt.

IC=0 : VE=0 G1=0 : G2=0 : OB=0 : PE=0

Nun wird überprüft, ob der String BE$(WZ) in der Verb-Tabelle enthalten ist.

FOR I=1 TO VZ : REM VZ = Anzahl der Verben
IF BE$(WZ) = VE$(I) THEN IC=1:VE=I
NEXT I

Wird bei diesem Vorgang also ein Verb gefunden, so wird dieses Verb zur Verbzahl VE codiert und die Check-Variable IC auf 1 gesetzt. Auf die gleiche Art und Weise werden auch alle anderen Wort-Tabellen durchlaufen (Gegenstände, Objekte, Personen).

Es werden also alle Tabellen auf das Wort BE$(WZ) hin untersucht. Sie könnten nun einräumen, daß wir für das erste Wort doch eigentlich nur die Verb-Tabelle durchsuchen müßten, da das erste Wort eines Satzes ja immer nur ein Verb sein kann. Damit haben Sie recht. Ich schlage jedoch trotzdem die obige Methode vor. Damit das Modul jedoch möglichst schnell abläuft, kann man nach jedem Tabellendurchlauf überprüfen, ob sich die Check-Variable zum Wert 1 geändert hat und in diesem Falle (IC=1) die restlichen Tabellen überspringen. Dies ist möglich, da ein Wort, das in Tabelle A gefunden worden ist, auf keinen Fall ebenfalls in Tabelle B vertreten sein kann. Es gibt schließlich kein Wort, das gleichzeitig Verb und Person ist. Wenn alle Tabellen durchlaufen sind, wird die Check-Variable IC wieder auf ihren Zustand hin überprüft.

Erweist sich IC als 0, so steht fest, daß das Wort BE$(WZ) in keiner Tabelle vertreten ist. Natürlich auch nicht in der Tabelle der AU$-Worte (Tabelle der Worte, die überflüssig sind).

Ist dies der Fall, so bringt das Programm die Fehlermeldung "Mein Wortschatz kennt das Wort ":BE$(WZ);" nicht ; ".

Daraufhin wird die Befehlscodierung abgebrochen, und es ist folgendes möglich:

a)	Es erfolgt ein Sprung zum Actionmodul. Dies hat zur Folge, daß alle Monster, Geister etc. wieder am Zug sind. Angenommen, der Spieler begegnet gerade einem Monster und gibt als Befehl »Ermorde das Monster« ein. Da der Computer jedoch leider das Wort »ermorde« nicht kennt, schlägt das Monster bei Fall a) voll zu — GAME OVER.
b)	Es erfolgt ein Rücksprung zum Befehlseingabemodul. Die Methode a) ist die, die am meisten vertreten ist.

Ich halte es jedoch für sinnvoller, Methode b) zu verwenden, da hier sichergestellt ist, daß der Spieler nicht auf Grund eines Mißverständnisses verliert.

Bei einem guten Adventure sollte der Spieler nur auf Grund von taktischen Fehlern verlieren und niemals auf Grund von Tippfehlern.

Wir wollen nun aber annehmen, daß keine Fehlermeldung auftritt und das Programm in seinem Ablauf fortfährt. Die Check-Variable IC ist also 1. Damit ist auch eine Wortzahl (Verbzahl VE, 1. Gegenstandszahl G1, etc.) gefunden worden, Bei dem ersten Wort, also wenn WZ = 1 ist, muß es sich im Normallfall stets um die Verbzahl VE handeln. Das erste Wort ist somit codiert. Nun wird die Wortzählvariable um 1 erhöht, Das nächste Wort wird bearbeitet. Zunächst wird überprüft, ob dieses Wort überhaupt existiert, also ob der String BE$(WZ) Zeichen enthält. Wenn nicht, so ist der Lesevorgang beendet und das Actionmodul ist dran, Wir nehmen jedoch an, daß das Wort BE$(WZ) existiert.

Gemäß unserem Ablaufschema wird der Lesevorgang nun für das neue Wort wiederholt.

Halt! Was passiert eigentlich, wenn es sich bei dem neuen String BE$(WZ) um »UND« handelt, also ein neuer Befehl innerhalb des Befehlssatzes folgt? Das heißt auch, daß nach dem »UND« ein neues Verb folgen wird, oder auch nicht, wie es bei »NIMM SCHWERT UND SEIL« der Fall ist.

Angenommen es folgt jedoch ein neues Verb (NIMM SCHWERT UND OEFFNE TUER), dann würde sich unsere Verbzahl ändern und der NIMM-Befehl verloren gehen.

Die Lösung dieses Problems lautet wie folgt:

Bevor der Lesevorgang für das neue Wort BE (WZ) beginnt, wird überprüft, ob dieses Wort gleich »UND« ist. »UND« braucht nicht in einer Tabelle definiert zu werden.
Wir fragen im Programm direkt

IF BE$(WZ) = "UND"...

Ist dies der Fall, so setzen wir die Variable UD auf 1.

Dann wird der Lesevorgang beendet. Es folgt ein Sprung zum Actionmodul. Im Actionmodul wird nun auf den ersten Befehl des Befehlssatzes reagiert. In unserem Fall meldet sich der Computer mit

»SIE NEHMEN DAS SCHWERT«

Nachdem dies geschehen ist, kehren wir (nach Schema) zurück zum Befehlseingabemodul.

Halt! Wir können doch nicht einfach einen neuen Befehlsstring BE$ vom Spieler holen, wo der alte BE$ doch noch nicht voll ausgewertet ist. Wir müssen in der ersten Zeile des Befehlseingabemoduls deshalb abfragen, welchen Zustand die Variable UD hat.

Hat sie den Wert 1, so wissen wir, daß der letzte Befehlsstring noch nicht voll ausgeführt ist.

Das Befehlseingabemodul muß also übersprungen werden und zwar direkt zum Lese-(Codier-)Modul.

Der Sprung muß jedoch so sein, daß der Wortzähler WZ nicht wieder wie zuvor auf 0 gesetzt wird, es soll schließlich an der Stelle im Satz weitergelesen werden, an der vorher unterbrochen wurde und nicht wieder vom ersten Wort des Satzes an.

Auch Verbzahl VE, Objektzahl OB und Personenzahl PE dürfen nicht gelöscht werden. Würde man bei unserem Beispielsatz »NIMM SCHWERT UND SEIL« nach der Befehlsausführung von NIMM SCHWERT die Verbzahl löschen, so würde der Computer nach Beendigung des zweiten Lesevorgangs nur wissen, daß ein Seil gemeint ist, jedoch nicht, was er damit machen soll. Falls jedoch ein neues Verb gefunden wird, so nimmt die Verbzahl einfach den Wert dieses neuen Verbs an und vergißt somit den alten Wert. Durch dieses Verfahren wird gewährleistet, daß alle UND-Zusammenhänge richtig interpretiert werden.

Dies ist ein besonders bemerkenswerter Vorteil unserer Befehlscodierung, den kaum ein anderes Adventure bietet. Die ersten Zeilen des Codiermoduls müssen folglich lauten:

1.	Zeile: IF DU=1 THEN UD=0 : GOTO 3.Zeile
2.	Zeile: WZ=1 : VE=0 : OB=0 : PE=0
3.	Zeile: IC=0 : G1=0 : G2=0

In der ersten Zeile wird UD wieder auf Null gesetzt, damit das Befehlseingabemodul nicht wieder übersprungen wird. Findet sich im Laufe des zweiten Lesevorgangs jedoch wieder ein UND, so wird die UND-Variable UD einfach wieder auf 1 gesetzt.

Dies findet in dem nun verbesserten Ablaufschema seinen Ausdruck:
 
TODO

Durch diese Veränderung ändert sich natürlich auch in unserem Grundschema für Adventures etwas. Das neue Ablaufschema sieht deshalb folgendermaßen aus:

TODO
 
Damit wäre die Theorie für die Vervollständigung unseres neuen Moduls auch schon beendet. Unser neues Modul, das Befehlseingabe, -zerlegung, -sortierung und -codierung (der Lesevorgang) in sich vereint, steht im Programm wieder ab Zeile 50000. Dieses Modul können wir schon als halbwegs »intelligente« bezeichnen, da es immer mit GOSUB 50000 aufgerufen wird und dann selbständig entscheidet, woran es arbeiten muß, für die Befehlseingabe oder für die weitere Ausführung eines Befehlssatzes, der UND-Elemente enthält, also aus mehreren Befehlen besteht.

Diese Intelligenz macht es uns möglich, das Modul für jedes Abenteuer einzusetzen. Dabei muß höchstens der Wortschatz (die Worttabellen) abgeändert werden. In dem verbesserten Grundablaufschema für Abenteuerspiele können Sie erkennen, wie unser neues Modul eingesetzt werden muß.

Das Listing zum neuen Modul, werde ich nur noch leicht dokumentieren, da es schon ausführlich erklärt worden ist.

Während des Abtippens vom Listing sollten Sie ständig Blicke auf die Variablentabelle, die gleich folgt, werfen, damit Ihnen der Bezug zur Theorie deutlich wird.

Hier sind nun alle Variablen, die im Listing auftauchen:

TODO
AZ	Anzahl der Wörter, die in der Tabelle der auszusortierenden Wörter (der, die, das etc.) stehen.
AU$(1) bis AU$ (AZ)	Tabelle der auszusortierenden Worte
VZ	Anzahl der Verben
VE$(1) bis VE$(VZ)	Tabelle der Verben
GZ	Anzahl der Gegenstände
GE$(1) bis GE$(GZ)	Tabelle der Gegenstände
OZ	Anzahl der Objekte
OB$(1) bis OB$(OZ)	Tabelle der Objekte
PZ	Anzahl der Personen
PE$(1) bis PE$(PZ)	Tabelle der Personen
UD	UND-Variable (wurde bereits erklärt)
BE$	String, der den kompletten Befehlssatz enthält.
BE$(1) bis BE$(max 10)	Einzelne Worte des Befehlssatzes BE$, wobei überflüssige Worte bereits aussortiert sind.
WZ	Wortzählvariable, gibt an, welches Wort gerade bearbeitet wird.
IC	Checkvariable
I	Schleife
I1	Schleife, innerhalb der Schleife I

Alle Variablen die mit I beginnen sind entweder Check-Variablen oder Schleifen.

TODO
VE	Verbzahl (wird aus Verbtabelle ermittelt)
OB	Objektzahl (wird aus Objekttabelle ermittelt)
PE	Personenzahl (wird aus Personentabelle ermittelt)
G1,G2	1, und 2. Gegenstandszahl (werden aus Gegenstandstabelle ermittelt)

Dies wären auch schon alle auftretenden Variablen. Diese Variablen sind im ganzen Kurs beibehalten, damit Sie niemals unnötig verwirrt werden. Auf eventuelle Änderungen werde ich stets besonders hinweisen. Natürlich werde ich die Tabelle der Variablen im Laufe des Kurses ständig ergänzen. Ich empfehle Ihnen, bei allen Ihren Adventures immer die gleichen Variablen zu verwenden, das heißt, daß die Wortzählvariable WZ in jedem Adventure WZ lautet.

Durch dieses System ist es möglich, sehr schnell Adventures zu programmieren. Man hat ein eindeutiges Schema und kann sich beim Programmieren des Adventures voll und ganz auf das Abenteuer konzentrieren und muß nicht ständig über Programmierung und Variablenbelegung nachdenken. Man kann sich eine Karte anlegen, auf der alle Variablen, die in jedem Adventure verwendet werden, verzeichnet sind. Diese Tabelle hat man dann beim Programmieren als Hilfe immer neben sich liegen.

Ich würde mich freuen, wenn alle, die an diesem Kurs teilnehmen, auch diese Variablen übernehmen. Man könnte so vielleicht einen Standard für die Adventureprogramrnierung festlegen, der sicherstellt, daß jeder Kursteilnehmer das Programm eines anderen Kursteilnehmers schnell verstehen und eventuell Fehler auch besser finden kann.

Wenn Sie schon einmal ein längeres Adventure aus einer Zeitschrift abgetippt haben, so wissen Sie sicher, wie chaotisch diese Listings oftmals sind und in welchem Maße eine Fehlersuche dadurch zu einem fast unmöglichen Unterfangen wird.

Geben Sie nun das Listing 6 der neuen Module ein, und versuchen Sie, es bereits beim Abtippen unter Zuhilfenahme der Variablentabelle zu verstehen.

TODO Listing 6
 
Dokumentation zum Listing 6:

TODO
5,10 bis 80	Aufruf zum Definieren der Wort-Tabellen Steuerung des Adventures. Hier muß später auch das Actionmodul aufgerufen werden (vgl. auch letztes Grundschema).
50000			Anfang des Moduls
50000 bis 50030	Befehlseingabe
50010	Wenn UD=1 ist, der letzte Befehlsstring also mehrere Befehle enthielt, die noch nicht alle ausgeführt worden sind, so wird die Befehlseingabe übersprungen und der alte Befehlsstring wird weiterbehandelt.
51000 bis 51150	Zerlegung des Befehlssatzes BE$ in einzelne Worte BE$(1) bis BE$(maximal 10).
52000 bis 52170	Befehlscodierung (Lesevorgang)
52005	Ist UD =1, so steht fest, daß es sich um die Weiterbehandlung eines alten Befehlssatzes handelt. Deshalb darf der Wortzähler nicht auf 1 gesetzt werden, es muß bei dem Wort weitergelesen werden, bei dem schon vorher abgebrochen wurde. Damit Sätze wie »NIMM DAS SCHWERT UND DAS SEIL« verstanden werden, dürfen die Variablen VE, OB, PE ebenfalls nicht gelöscht werden.
52025 bis 52135	Hier werden alle Tabellen (Worttabellen) auf das aktuelle Wort BE$(WZ) hin untersucht. Wird das Wort in einer Verbtabelle gefunden, so erhält die Verbzahl VE ihren Wert etc.
Wenn das Wort in irgendeiner Tabelle gefunden wird, so wird die Checkvariable IC auf 1 gesetzt. Nach jedem Tabellendurchlauf wird IC überprüft. Ist IC=1, so werden alle weiteren Tabellendurchläufe übersprungen, da ein Wort niemals in zwei Tabellen vertreten ist. Dieses Überspringen dient lediglich dazu, die Verarbeitungsgeschwindigkeit des Moduls zu erhöhen.
52137	Überprüfung, ob BE$(WZ) = "UND" ist. Wenn ja, so wird UD gleich 1 gesetzt.
52140	Wenn IC nun immer noch 0 ist, so steht fest, daß das Wort BE$(WZ) in keiner Tabelle beziehungsweise dem gesamten Wortschatz vertreten ist. Es erfolgt somit eine Fehlermeldung, die ausdrückt, welches Wort nicht erkannt wurde.
52150			Die Wortzählvariable wird auf das nächste Wort gesetzt.
52160	Überprüfung, ob der Befehlssatz die zulässige Wortzahl von maximal 10 Worten überschreitet, ob das neue Wort BE$(WZ) = " " ist oder ob UD = 1 ist. Trifft eine dieser Bedingungen zu, so wird der Codiervorgang.
a)	beendet, wenn der Befehlssatz zu-ende ist (BE$(WZ)= " ").
b)	unterbrochen, wenn ein Teilbefehl des Befehlssatzes BE$ ausgeführt werden muß, also wenn UD=1 ist.
52170	Die Check-Variable IC wird auf 0 gesetzt. Der Lesevorgang beginnt erneut.
Ab 60000	Definieren der Worttabellen

Bevor Sie nun im Kurs fortfahren, sollten Sie unser neues Modul bis ins letzte Detail verstanden haben.

Wenn Sie das Modul abgetippt haben, so starten Sie es nun bitte. Es erfolgt der Aufruf, einen Befehlssatz einzugeben »WAS NUN?«. Sie können nun einen Befehl eingeben, der aus Worten besteht, die im Wortschatz enthalten sind (also in Tabellen).

Wenn Sie anschließend RETURN drücken, so gibt das Programm die Zahlen aus, die aus der Codierung hervorgehen:

Verbzahl VE
1. Gegenstandszahl G1
2. Gegenstandszahl G2
Objektzahl OB
Personenzahl PE
 
Geben Sie nun einmal verschiedene Befehlssätze (auch Sätze die mehrere Befehle enthalten) ein, und untersuchen Sie die jeweiligen Ergebnisse.

Sie können auch einmal die Beispielssätze, die wir bereits theoretisch codiert haben, eingeben und die Ergebnisse mit den theoretisch gewonnenen vergleichen. Ergibt der Vergleich keine Unterschiede, so arbeitet unser Modul tadellos. Wenn nicht, so muß irgendwo ein Tippfehler vorliegen, den Sie anhand Ihres bisherigen Wissens jedoch leicht finden müßten. Ich gebe zu, daß es momentan etwas trocken und monoton zugeht, aber ich kann Ihnen getrost versichern, daß wir uns schon bald interessanteren Bereichen der Programmierung zuwenden werden.

Bevor ich jedoch das Geheimnis lüfte, was wir eigentlich mit den ganzen Verbzahlen, Objektzahlen etc. anfangen werden, müssen wir uns noch einem kleinen Problem zuwenden.

Betrachten Sie einmal die folgenden beiden Sätze:

1. VERLIER DAS SEIL.
2. VERLIERE DAS SEIL.

Für uns Deutsche ist hier zunächst eigentlich kein Unterschied zu sehen. Tatsache ist jedoch, daß das Verb im ersten Satz VERLIER und im zweiten Satz VERLIERE lautet. Trotzdem ist der Sinn des Satzes eindeutig. Der Befehlssinn des ersten Satzes ist also exakt der gleiche, wie der des zweiten, eigentlich korrekten Satzes. Doch wie kann man das dem Computer klarmachen?

Nun, dazu wollen wir die beiden Worte VERLIER und VERLIERE noch einmal näher betrachten. Genausogut könnten wir für diese Betrachtung auch das Beispiel SAG und SAGE hernehmen.

Das Problem ist einfach zu lösen.

Bisher lief die Verb-Untersuchung im Programm (Zeile 52025 bis 52060) ja so, daß wir überprüft haben, ob das aktuelle Befehlswort BE$(WZ) in der Verbtabelle enthalten ist. Dies sah so aus:

IF BE$(WZ) = VE$(I) THEN VE=I : IC = 1

Die Variable I durchläuft dabei die Werte 1 bis VZ, wobei VZ die Anzahl aller Verben darstellt.

Wir müssen diese Abfrage nun so umändern, daß nicht mehr überprüft wird, ob BE$(WZ) mit VE$(I) identisch ist, sondern nur ob BE$(WZ) im Verb VES(I) enthalten ist.

Wie man überprüft, ob ein String in einem anderen String enthalten ist, haben Sie bereits im Kapitel Stringoperationen gelernt (lesen Sie dort gegebenenfalls nochmal nach).

Dies sieht zwar ziemlich kompliziert aus, ist bei näherem Betrachten jedoch ganz einfach.

Schreiben Sie jetzt im Programm die Zeile 52040, in der die Abfrage stattfindet, um:

52040 :IF BE$(WZ)=LEFT$(VE$(I),LEN(BE$(WZ))) THEN VE=I:IC=1

Starten Sie nun das Programm erneut und überprüfen Sie, ob es ordungsgemäß abläuft.

Ist dies der Fall, so müßte für VERLIER und VERLIERE eine identische Verbzahl und keine Fehlermeldung herauskommen.

Wenn Sie einfach V eingeben, so erhalten Sie ebenfalls die Verbzahl, die Sie auch für VERLIERE erhalten. Jeder Verb-Befehl kann also jetzt beliebig abgekürzt werden.

Allerdings kann es bei Abkürzungen auch schnell zu Mißverständnissen kommen. Wenn in der Verbtabelle zum Beispiel zwei Verben enthalten sind, die mit den gleichen Buchstaben beginnen (zum Beispiel SAGE und SUCHE) und der Spieler als Befehlsabkürzung S eingibt, so kann das Programm nicht wissen ob SAGE oder SUCHE mit dieser Abkürzung gemeint ist. Es nimmt in einem solchen Fall immer die Verbzahl an, die die Größte ist. Diese Tatsache braucht uns jedoch nicht zu stören, da der Spieler schnell herausfinden wird, welche Befehle er wie abkürzen kann.

Das Befehisanalyseprogramm, das uns nun zur Verfügung steht, ist ohne Zweifel schon sehr gut, aber wir wollen noch einen Schritt weitergehen.

Hierzu wollen wir einmal die folgenden beiden Verben betrachten: NIMM und NEHME.

Im Prinzip besteht zwischen den Befehlssätzen NIMM DAS SCHWERT und NEHME DAS SCHWERT kein Unterschied. Trotzdem gibt es kaum deutsche Adventures, die beide Worte akzeptieren. Bei unserem Befehlsanalysesystem soll dieses Problem jedoch endgültig gelöst werden.

Bevor wir uns jedoch mit der Lösung beschäftigen, wollen wir noch ein anderes Beispiel betrachten. Nehmen wir einmal an, unser Spieler hat ein Brett und ein Seil. Er will das Seil am Brett festbinden.
 
Er könnte folgende Befehlssätze ausprobieren:

1.	Binde das Seil am Brett fest.
2.	Befestige das Seil am Brett.
3.	Verknote das Seil am Brett.
4.	Verbinde das Seil mit dem Brett.
5.	Mache das Seil am Brett fest.
6.	Binde das Seil ans Brett.

Zugegeben, einige Satzmöglichkeiten sind vielleicht extrem außergewöhnliche Beispiele, aber wir wollen einmal damit rechnen.

Diese Sätze sind auch gute Beispiele dafür, warum wir zwei Gegenstandsvariablen G1 und G2 für die Befehlsanalyse reserviert haben, denn in jedem der sechs Sätze kommen zwei Gegenstände vor: Seil und Brett.

Die Gegenstände, die in den Sätzen auftauchen, sind also immer identisch. Nun wollen wir einmal betrachten, welche Wörter Verben VE$ sind, und welche aussortiert werden müssen (AU$).

1.	VE$ :BINDE	AU$ : das, am, fest
2.	VE$ :BEFESTIGE	AU$ : das, am
3.	VE$ :VERKNOTE	AU$ : das, am
4.	VE$ :VERBINDE	AU$ : das, mit, dem
5.	VE$ :MACHE	AU$ : das, am, fest
6.	VE$ :BINDE	AU$ : das, ans

Wir haben jetzt also mehrere Verben, die alle den gleichen Sinn haben (in Bezug auf unseren Satz) — eine Verbfamilie also.

Den Satz Nummer 5 wollen wir verbieten.

In ihm ist kein eindeutiges Verb vorhanden. »Mache« kann als Verb betrachtet werden, da zu »mache« immer noch ein Bezugswort gehört (zum Beispiel mache fest, wobei fest das Bezugswort ist). Das Wort »fest« kann aber wiederum nicht als Verbersatz dienen, da es in Satz 1 als ein auszusortierendes Wort betrachtet wird. Wir wollen Sätze mit »mache« also grundsätzlich verbieten. Immer wenn der Spieler also einen Befehlssatz eingibt, der das Wort »mache« enthält, wird er die Fehlermeldung »ICH KENNE DAS WORT MACHE NICHT« vom Programm erhalten.

Natürlich brauchen wir diese Fehlermeldung für das Wort »mache« nicht extra programmieren. Unser Befehlsanalyseprogramm bringt nämlich für jedes Wort, das nicht in einer der Worttabellen vertreten ist (einschließlich der Tabelle der auszusortierenden Worte) automatisch eine Fehlermeldung. Unser Problem, das wir lösen wollen, ist also, daß die Befehlsanalyse sich nicht nur auf einzelne Verben, sondern auch auf ganze Verbfamilien bezieht. Die Verben NIMM und NEHME sind auch eine solche Verbfamilie.

Eine einfache Lösung des Problems wäre die folgende:

Wir erweitern die Verbtabelle VE$ einfach um das Verb »Nehme« (für das Beispiel der Wortfamilie Nimm, Nehme). Das Verb »NEHME« bekäme in diesem Fall eine eigene Verbzahl zugeordnet. Die hätte zur Folge, daß die Verbzahlen für »NIMM« und »NEHME« unterschiedlich wären.

Diese Tatsache müßte man dann später im Actionmodul berücksichtigen. Wenn das Actionmodul später also feststellen will, ob der Spieler etwas nehmen will, dann würde die Abfrage hierzu folgendermaßen aussehen:

IF VE = A OR VE = B THEN:REM: SPIELER WILL ETWAS NEHMEN.

A ist hierbei die Verbzahl für das Wort »NIMM« und B die Verbzahl für das Wort »NEHME«.

Diese Lösung würde für unser erstes Beispiel zwar gut funktionieren, aber beim 2. Beispiel (Spieler will Seil mit Brett verbinden) wäre schon eine ziemlich lange IF-THEN-Abfrage nötig. Die erste Lösung frißt also zuviel vom eh' sehr kostbaren RAM-Speicherplatz.

Eine bessere Lösung wäre, wenn man für das Verb NIMM und das Verb NEHME die gleiche Verbzahl erhalten würde. Bei diesem Idealfall wäre die im Actionmodul nötige Abfrage schon wesentlich unkomplizierter:

IF VE = A THEN:REM: SPIELER WILL ETWAS NEHMEN.

Wir sind uns also einig, daß eine solche Lösung die Ideallösung ist. Wie programmiert man diese Ideallösung jedoch am einfachsten?

Eine Möglichkeit wäre, mehrere Alternativ-Verbtabellen zu erstellen. In der normalen Verbtabelle stände dann an erster Stelle das Verb NIMM und in der alternativen Verbtabelle das Alternativ-Verb zu NIMM, also NEHME. Wenn wir jedoch wieder unsere zweite Wortbeispieltabelle betrachten, bemerken wir, daß wir hier mehrere alternative Worttabellen benötigen würden, da unsere zweite Verbfamilie aus vier Mitgliedern (binde, befestige, verknote, verbinde) besteht. Diese Lösung wäre viel zu kompliziert zu realisieren und bräuchte auch zu viel Speicherplatz. Ich will Sie nun nicht länger auf die Folter spannen, und die Katze aus dem Sack lassen — die Ideallösung!

Und so sieht sie aus:

Das Wort beziehungsweise Verb »NIMM« steht ja bereits in unserer Verbtabelle in der DATA-Zeile 60060.

60060 DATA NIMM, VERLIERE, OEFFNE, GIB, SAGE, INVENTUR, BEFESTIGE
60060 DATA NIMM, NEHME1, VERLIERE, OEFFNE, GIB, SAGE, INVENTUR, BEFESTIGE

Wir haben das Verb »NEHME« also direkt hinter dem Verb »NIMM« eingefügt. Jedoch haben wir nicht einfach »NEHME« sondern »NEHME1« eingefügt — der Einser direkt nach dem Wort »NEHME« ist **kein** Druckfehler.

Was soll denn der Einser, werden Sie jetzt sicherlich mit Recht fragen. Stören tut er ja nicht, denn wenn wir das Programm starten und das Wort »Nehme« eingeben, so wird dies ja akzeptiert. Der Computer betrachtet »nehme« einfach als eine Abkürzung für das in seiner Verbtabelle an zweiter Stelle gespeicherte Verb »NEHME1«.

Oh, da sehe ich doch, daß mir soeben ein kleiner Fehler unterlaufen ist. Haben Sie ihn auch schon entdeckt? Nun, ich habe vergessen die VZ-Variable in Zeile 60070 umzuändern.

Denn da ich ein neues Verb in die Tabelle eingebaut habe, muß ich auch die VZ-Variable umändern, da VZ für die Anzahl der Verben in der Verbtabelle steht. Diese Änderung wollen wir jetzt schnell nachholen:

60070 VZ=8,..

Solche Fehler sind sehr tückisch, da sie meist nur selten im Programm wirksam werden und daher nur schwer zu finden sind. Denken Sie also stets daran, daß Sie immer, wenn Sie irgendeiner Worttabelle eine weiteres Wortzufügen, auch die entsprechende Variable, die angibt wieviele Worte in dieser Tabelle stehen, korrigieren müssen.

Nun aber zurück zur Frage »Warum NEHME1?«.

Voraussetzung für das Funktionieren dieser Ergänzung ist natürlich, daß Sie Zeile 52040 bereits geändert haben (wie vor kurzem beschrieben). Können Sie sich noch an den VAL-Befehl erinnern, den wir beim Kapitel Stringoperationen besprochen haben?

Nach der Änderung der Verbtabelle sieht diese so aus:

VE$(1) = "NIMM" 
VE$(2) = "NEHME1"
VE$(3)... etc.

Probieren Sie doch einmal aus, was VAL (VE$(2)) ergibt.

Geben Sie dazu im Direktmodus ? VAL ("NEHME") ein.

Nun, was glauben Sie was passiert, wenn man nach dieser Eingabe RETURN drückt?

Die richtige Antwort lautet Null, was Sie ja leicht überprüfen können.

Fall Sie als Antwort 1 erwartet haben, so beherrschen Sie den VAL-Befehl noch nicht. Geben Sie nun die folgende Zeile im Direktmodus ein:

? VAL(RIGHT$("NEHME1",1))

Nach Drücken von RETURN erhalten wir endlich das gewünschte Ergebnis. 1. Wenn wir für »NEHME1« den String »NIMM« einsetzen, erhalten wir als Ergebnis 0. Es ist also egal, ob wir »NIMM« oder »NIMM0« einsetzen.

Wir wollen also einmal folgendes festlegen:

Das Stammverb steht immer vor den alternativen Verben in der Tabelle. Die alternativen Verben folgen in der Tabelle direkt nach dem Stammverb und sind mit Zahlen versehen.

Betrachten wir nun nochmals die Verbfamilie BINDE, BEFESTIGE, VERKNOTE, VERBINDE.

In eine Verbtabelle eingebaut, würde diese Worttabelle so aussehen (wobei es immer egal ist, welches Mitglied der Familie als Stammverb gewählt wird):
 
VE$(1) = "BINDE"
VE$(2) = "BEFESTIGE1"
VE$(3) = "VERKNOTE2"
VE$(4) = "VERBINDE3"

Bei der Numerierung habe ich unsere bisherige Verbtabelle völlig außer Acht gelassen.

Wie ich bereits gesagt habe, besteht unser Ziel darin, für jedes Mitglied einer Verbfamilie die gleiche Verbzahl VE zu erhalten.

Ich lege nun fest, daß die Verbzahl, die man später für jedes Verb der Verbfamilie erhält, identisch ist mit der Verbzahl, die man für das Stammverb dieser Verbtabelle erhält.

Sicher wissen Sie noch, wie wir unsere Verbzahl bisher erhalten haben: Wir haben eine Schleife I, die VE$-Tabelle von 1 bis VZ (Anzahl der Verben) durchlaufen lassen. Dabei haben wir überprüft, ob das aktuelle Befehlswort BE$(WZ) gleich VE$(1) war. Stimmten beide Strings überein, so sagten wir einfach VE = 1. Also Verbzahl = momentaner Stand der Schleife.

Im Programm sah dies so aus (in der ersten Version):

52030 FOR I = 1 TO VZ
52040 :IF BE$(WZ) = VES(I) THEN VE=I
52050 NEXT I

Dieses Programm habe ich soweit wie möglich vereinfacht.

Wenn wir bei diesem Prgramm unsere obige Verbtabelle durchlaufen lassen, so erhalten wir im Moment noch für jedes Verb eine spezielle Verbzahl. Wie stellen wir es nun an, daß wir für jedes Wort einer Verbfamilie die gleiche Verbzahl VE erhalten?

Bisher war unsere Verbzahl VE nur vom jeweiligen Stand der Schleifenvariable l abhängig, bei dem sich BE$(WZ) mit VE$(I) als identisch erwies. Nun müssen wir einen Weg finden, bei dem sich VE in Abhängigkeit von der Schleifenvariablen I und von dem VAL-Wert des jeweiligen Verbs VE$(I) ergibt.

Dazu wollen wir nochmals unsere neue Verbtabelle betrachten:

Für das Stammverb »BINDE« erhalten wir den VAL-Wert 0.

Für das erste Alternativverb »BEFESTIGE« ist der VAL-Wert gleich 1.

Für das zweite Alternativverb entsprechend 2.

Für das dritte Alternativverb schließlich 3.

Die Ziffer im String gibt also an, das wievielte Alternativverb eines Stammverbs der String ist.

Es wurde ja bereits festgelegt, daß die Verbzahl für alle Mitglieder einer Verbfamilie identisch sein soll mit dem Wert des Stammverbs dieser Familie, also dem Verb mit dem VAL-Wert 0.

Damit dürfte die Lösung des Problems eigentlich schon klar sein:

52030 FOR I = 1 TO VZ
52040 :IF BE$(WZ) = VE$(I) THEN VE = I-VAL (RIGHTS(VE$(I),1))
52050 NEXT I

Wir ziehen von dem I-Wert, bei dem die Identität festgestellt wurde, einfach den VAL-Wert ab. Wenn wir vom I-Wert, der sich für das Stammverb ergibt, den VAL-Wert des Stammverbs abziehen, so erhalten wir den Verbzahl-Wert VE des Stammverbs (da der VAL-Wert des Stammverbs ja immer 0 ist).

Wenn wir vom I-Wert, der sich für das erste Alternativverb ergibt, den VAL-Wert des ersten Alternativverbs abziehen, so erhalten wir wieder die selbe Verbzahl VE (da der VAL-Wert des ersten Stammverbs ja immer 1 ist). Für die weiteren Alternativverben gilt natürlich das Entsprechende.

Wir haben unsere angestrebte Ideallösung also gefunden. Und das Besondere ist, daß unsere neue Befehlsanalyse nur um ein paar Bytes länger geworden ist.

Wir dürfen jedoch nicht vergessen, die Zeile 52040 wieder so umzuändern, daß der Vergleich zwischen BE$(WZ) und VE$(I) wieder nur so erfolgt, daß überprüft wird, ob BE$(WZ) in VES(I) enthalten ist. Denn nur dann werden Abkürzungen für Verben akzeptiert, und dies ist auch die Grundbedingung, die es uns erlaubt, die Strings der Alternativverben mit Nummern zu versehen.

Die endgültige Zeile 52040 lautet folglich:

52040 :IF BES(WZ)=LEFT$(VE$(I),LEN(BE$(WZ))) THEN VE = I-VAL(RIGHT$(VE$(I),1)) :IC =1
 
Damit haben wir es endlich geschafft: Unser Analysemodul ist fertig. Anschließend noch ein Listing, bei dem eine komplette Befehlseingabe mit unserer idealen Befehlsanalyse zu einem Unterprogramm, das ab Zeile 50000 steht, zusammengefaßt ist— das Programm ist soweit wie möglich komprimiert. Also ohne viele REM-Zeilen etc.

Es ist die Grundbasis, für alle folgenden Beispielprogramme. Dieses Modul kann für jedes Adventure verwendet werden, da es nichts programmspezifisches enthält. Änderungen können Sie leicht vornehmen, da das Modul jetzt ja ausführlich besprochen worden ist.

Das Modul kann natürlich nur dann arbeiten, wenn vorher im Programm die Worttabellen mit den entsprechenden Variablen definiert werden.

Zu beachten ist hierbei, daß die Verbtabellen immer die längstmöglichen Wörter enthalten. Also »VERLIERE« und nicht »VERLIER«, denn nur dann ist gewährleistet, daß Verben abgekürzt werden können.

Man könnte im Prinzip auch für die anderen Worttabellen, wie die Objekttabelle, Abkürzungen erlauben. Ich halte dies jedoch für überflüssig. Geben Sie nun bitte das Listing 7 ein und speichern Sie es auf Kassette oder Diskette ab, damit Sie in den folgenden Kapiteln darauf zurückgreifen können.
 
TODO Listing 7

Bitte betrachten Sie einmal die folgenden Zeilen, die auch im Listing enthalten sind:

50250 FORI=1TOVZ:IFBE$(WZ)=VE$(1)THENVE=1:IC=1
50251 IFLEN(BE$(WZ))<3THEN50260

Die beiden IF-THEN-Abfragen sorgen dafür, daß die Abkürzungen für die Verben mindestens drei Buchstaben haben müssen.

Verben mit ein bis zwei Buchstaben werden jedoch akzeptiert, wenn sie in der Verbtabelle enthalten sind (zum Beispiel Richtungsangaben wie N, S, 0, W, NW etc.)

## 5. Kapitel: Die Spielkarte

Als Resultat des letzten Kapitels steht uns nun ein komfortables Befehlsanalyse-System zur Verfügung.

Es ist keine Übertreibung, zu behaupten, daß wir dem kompletten Adventure nun schon sehr nahe sind. Da im letzten Abschnitt sehr viel Theorie enthalten war, die sich auch schon ein wenig auf den gesamten Ablauf eines Adventures bezog, haben wir die wesentliche Gedankenarbeit bereits geleistet Sie haben gelernt Tabellen zu definieren und mit Strings zu arbeiten.

Für die folgenden Kapitel werde ich die Theorie deshalb etwas knapper halten. Nun aber gleich zum Thema — der Spielkarte.

Eine Spielkarte zu programmieren, ist das Problem, das jeden Adventure-Programmierer am meisten beschäftigt. Wer sich ein Adventure-Listing aus einer Computerzeitschrift schon einmal näher angeschaut hat, wird wissen, wie verwirrend die Listings oft aussehen: Schier unendlich viele Variablen und GOTO/GOSUB-Anweisungen leisten ihren Beitrag zur Unübersichtlichtkeit, so daß es nahezu unmöglich ist, den Programmablauf vernünftig zu verfolgen. Eine weitere Tatsache ist, daß in keinem anderen Listing so viele Fehler auftauchen, wie bei Abenteuerspielen. Das liegt hauptsächlich daran, daß sich die meisten Adventure-Programmierer nach einiger Zeit in ihrem Listing nicht mehr zurecht finden, da sie zu »chaotisch« programmiert haben.

Unser System zur Programmierung der Spielkarte soll folgende Eigenschaften haben:

1.	Sehr gute Übersichtlichkeit — Fehler können leicht behoben werden.
2.	Möglichst geringer Speicherplatzverbrauch — denn besser das System zur Kartenprogrammierung ist, desto mehr Räume können untergebracht werden.
3.	Es muß nur eine Variable verändert werden, um das Spiel an jeder beliebigen Stelle (Raum) starten zu lassen — wichtig zum späteren Testen des Spiels.

Im Prinzip gibt es verschiedene Grundmöglichkeiten. Alle haben jedoch ihre Mängel. Nach längerem Ausprobieren der einzelnen Möglichkeiten hat sich bei mir die Technik, die ich Ihnen nun vorstellen werde, bis jetzt tadellos bewährt.

Mit dem herkömmlichen Basic des C 64 ist diese Technik jedoch nicht realisierbar. Unser erster Schritt soll deshalb darin bestehen, das bescheidene Basic des C 64 um drei entscheidende Befehle zu erweitern, beziehungsweise drei bereits vorhandene Befehle zu modifizieren.

Bitte geben Sie das folgende Programm ein und speichern Sie es anschließend ab. Noch besser ist es, wenn Sie zuerst das Befehlseingabemodul, das Sie hoffentlich bereits abgetippt haben, laden, und es um das folgende Listing 8 ergänzen.
 
TODO Listing 8

Nachdem das Programm gestartet wurde, stehen uns folgende neue, beziehungsweise erweitere Befehle zur Verfügung:

GOTO X, GOSUB X, RESTORE X.

Diese drei Befehle sind also so restauriert worden, daß sie auch in Abhängigkeit von einer Variablen und sogar von einem Formelausdruckfunktionieren. Der ON GOTO- und der ON GOSUB-Befehl kann nun getrost auf den »Müll« geworfen werden.

Folgende Programmierung ist nun möglich:

10 rem demoprogramm
20 X = 100
30 GOTO X
100 PRINT "SPITZE ! "
110 END

oder:

10 rem demoprogramm
20 GOSUB 90+10
30 END
100 PRINT "SPITZE ! " : RETURN

sowie:

10 rem demoprogramm
20 INPUT"WERT'; X
30 IF X <1 OR X > 3 THEN GOTO 20
40 RESTORE 100*3 : READX$ : PRINT X$ : GOTO 20
100 DATA HALLO
200 DATA WIE
300 DATA GEHTS
 
Wer sich das letzte Beispielprogramm genau anschaut und nachdenkt, dem kommt vielleicht jetzt schon eine Idee, wie die Kartenprogrammierung funktionieren könnte.

Bevor wir uns nun mit der Kartenprogrammierung beschäftigen, müssen wir den folgenden Aspekt berücksichtigen:

Durch die drei neuen Befehle bietet sich eine vollkommen neue Programmiermöglichkeit, bei der beachtet werden muß beziehungsweise sollte, wie man die einzelnen Programmzeilen 0 bis 63999 belegt.

Betrachten Sie bitte einmal die folgende Skizze:

TODO

Damit wäre die Spielkarte nun auch schon zum ersten Teil programmiert.

Raum 1 steckt in den Zeilen 10100 bis 10120

Raum 2 steckt in den Zeilen 10200 bis 10220 entsprechend die anderen Räume.

Dieses Programm ist jedoch noch nicht lauffähig, da jegliche Steuerung fehlt. Die Steuerung ist Aufgabe des Actionmoduls, das in den Zeilen 1000 bis maximal 9999 steht (wie der letzten Skizze zu entnehmen).

Wir wollen zunächst eine primitive Steuerung simulieren. Geben Sie dazu bitte folgende weitere Zeilen ein:

1000 REMACTIONMODUL
1010 INPUT" IN WELCHEN RAUM WOLLEN SIE GEHEN? ":ZN
1015 IF ZN <1 OR ZN> 6 THEN PRINT" DAS GEHT NICHT":GOT01010
1020 GOSUB 10000+ZN*100
1030 GOTO 1000
 
Nun ist das Programm lauffähig.

Wie auch bei den meisten folgenden Listings erübrigt sich hier eine Dokumentation. Interessant ist lediglich Zeile 1020.

Dort steht die Formel, mit der dann mittels GOSUB der aktuelle Raum erreicht werden kann.

Das vorliegende Actionmodul ist selbstverständlich noch extrem einfach. Im Moment kann man noch beliebig jeden Raum direkt anlaufen — falls man überhaupt von »Laufen« reden kann.

Löschen Sie bitte nun folgende Zeilen wieder: 1010, 1015, 1020 und 1030. Wichtig ist nur, daß Sie sich die Formel zur Errechnung des jeweiligen Raumes merken:

Raum = 10000+ZN*100.

ZN ist die jeweilige Zimmernummer, identisch mit den Nummern auf dem gezeichneten Spielplan. Der Raum beziehungsweise die Formel bestimmt die Zeilennummer, ab der der Raum im Programm steht. Es wird nun höchste Zeit, daß wir unser Befehlseingabemodul in Bewegung setzen.

Das Actionmodul muß so geändert beziehungsweise gestaltet werden, daß man nicht mehr Räume direkt ansteuern, sondern nur noch von Raum zu Raum laufen kann.

Zunächst ein wenig Theorie:

Wir wollen dem Spieler unseres Adventures erlauben, direkte Himmelsrichtungen einzugeben, wenn er sich bewegen will.

Wenn er zum Beispiel nach Norden gehen will, so muß er einfach »N« eingeben.

Manche Adventures hingegen verlangen Eingaben wie »GEHE NORD«. Dies ist meines Erachtens nach jedoch unnötig, da es dem Spieler schnell auf die Nerven fallen kann, denn es ist wesentlich einfacher nur ein bis zwei Buchstaben zum Laufen einzugeben und nicht immer zwei Worte.

Vielleicht können Sie sich noch daran erinnern, daß ich bereits im Kapitel zur Programmierung unseres ersten Moduls festgelegt habe, daß Himmelsrichtungen wie gewöhnliche Verben behandelt werden können.

Deshalb wollen wir die zehn möglichen Himmelsrichtungen (inklusiv rauf und runter) nun in unserer Verbtabelle aufnehmen — beziehungsweise mit dem Programmieren der einzelnen Worttabellen beginnen.

Geben Sie bitte folgende Zeilen zum bisherigen Programm ein:

52000 REM TABELLEN
52005 RESTORE 52000
52010 REM VERBTABELLE ________
52020 DATA N,S,W,O,NW,NO,SW,SO,RAUF,RUNTER
52100 VZ=10: DIM VE$(VZ):FOR I =1 TO VZ : READ VE$(I) : NEXT
53000 RETURN

Bitte legen Sie sich nun ein Blatt Papier an, auf dem Sie die einzelnen Tabellen, die bald kommen, ausführlich notieren —also den jeweiligen Wert zu jedem einzelnen Verb, Objekt, Gegenstand etc. ...

Nun müssen wir in den Kopf noch den Aufruf zum Unterprogramm der Tabellen einbauen. Dazu folgende Zeile eingeben:

30 GOSUB 52000: REM TABELLEN DEFINIEREN

Wir erhalten somit also Verbzahlen VE für die einzelnen Himmelsrichtungen. Bevor wir jedoch die GEH-Routine im Actionmodul einbauen können, müssen wir die Spielkarte noch verbessern.

Bisher bestand die Spielkarte nur aus knappen Texten. Nun müssen noch Informationen eingebaut werden, die angeben, wie die Räume miteinander verbunden sind. Dies geht relativ einfach:

Geben Sie bitte wieder die Ergänzungszeilen aus Listing 9 ein:

TODO Listing 9

Wir haben in jedem »Raum« nun noch eine DATA-Zeile mit zehn Werten. Diese Werte geben an, ob und in welche Richtungen gelaufen werden kann. Jedesmal, wenn der Spieler einen Raum betritt, werden diese zehn Zahlen in das Feld RI(1) bis RI(10) eingelesen.

Dieses Feld ist so aufgebaut:

TODO

Diese Skizze zeigt innerhalb welcher Programmzeilen welche Programmteile liegen.

Bisher haben wir nur einige Zeilen des Kopfes (Befehlserweiterung um GOTO X etc.) sowie ab 50000 für das Befehlseingabemodul belegt.

Die Zeilen 10000 bis maximal 49999 sind der Spielkarte gewidmet.

Wir haben also 39999 Zeilen für die Programmierung der Spielkarte zur Verfügung. Man kann davon ausgehen, daß man für die Programmierung eines einzelnen Raumes der Spielkarte (Text und Action) allerhöchstens 100 Zeilen benötigt. in 39999 Zeilen lassen sich also maximal 400 Räume unterbringen. Ein vernünftiges Adventure in Bezug auf Räume und Action wird jedoch bestimmt nicht 400 Räume haben, da dies mit 38 KByte RAM wohl kaum möglich sein dürfte. Ich war trotzdem so großzügig und habe 39999 Zeilen für ein Maximum von 400 Räumen zur Verfügung gestellt (was natürlich nicht heißen soll, daß Ihre Spiele viele Räume haben müssen), denn es ist besser, wenn man sich zehnmal überschätzt als einmal unterschätzt hat, was die Menge und Verteilung der Programmzeilen anbelangt. Das vorgestellte System ist somit auch zukunftssicher (vielleicht gibt es doch einmal eine Basic-RAM-Erweiterung für den C 64, oder man setzt den neuen PC 128 ein).

Für die nächsten Überlegungen werden wir uns auf die folgende Spielkarte beziehen:

TODO

Dies ist ein Spielplan mit sechs Räumen. Wie man solche Pläne anfertigt, haben Sie bereits im Theorie-Teil dieses Kurses gelernt. Die einzelnen Räume sind von 1 bis 6 durchnummeriert. Ich habe den Plan absichtlich so kurz gehalten, da er für unsere ersten Versuche völlig ausreicht, und ich Ihnen unnötige Abtipparbeit soweit wie möglich ersparen möchte.

Bitte ergänzen Sie Ihr bisheriges Programm (Basic - Erweiterungsroutine und Befehlseingabe-modul) nun um die Zeilen von Listing 10.

TODO Listing 10

Zum Verständnis soll folgendes Beispiel dienen:
Der Spieler steht im Raum A.

Im Feld RI(1) bis RI(10) ist festgelegt, welche Räume von Raum A unter welchen Richtungen erreicht werden können.

Nehmen wir einmal an, es gibt nur eine mögliche Richtung von Raum A aus, und zwar die Richtung Sueden (S), durch die man zu Raum B gelangt. Die DATA-Zeile für Raum A müßte in diesem Fall so aussehen:

DATA 0,B,0,0,0,0,0,0,0,0

Praktisch würde man für B natürlich den Wert des Raumes B einsetzen. Durch diese DATA-Zeile bedingt, muß das RI-Feld so aussehen:

RI(1)=0, RI(2)=B, RI(3) bis RI(10)=0

Wir nehmen nun an, daß der sich in Raum A befindliche Spieler in Richtung Norden (N) laufen will.

Auf die Frage »WAS NUN?« gibt er folglich »N« ein.

Das Befehlseingabemodul gibt sodann den Wert für das eingegebene Verb »N« aus. Also den Wert VE=1.

Nun tritt das Actionmodul in Kraft.
 
Zuerst überprüft es, ob der Verbzahlwert VE im Bereich zwischen 1 und 10 liegt— also, ob der Spieler sich bewegen will oder nicht (VE größer als 10). Das Actionmodul stellt fest, daß der Spieler sich bewegen will und fährt fort.

Es überprüft nun, ob die Richtung, in die sich der Spieler bewegen will, überhaupt existiert.

Es überprüft dazu, ob RI(VE) gleich Null ist oder nicht.

Ist RI(VE) = 0, so erfolgt die Fehlermeldung »Kein Weg in diese Richtung!«.

Ist RI(VE) jedoch ungleich Null (was in Raum A der Fall ist, wenn sich der Spieler nach Süden bewegen will), so fährt das Modul fort. Hätte unser Spieler also »S« statt »N« eingegeben, so wäre folgendes passiert.

Das Actionmodul hätte erst einmal die neue Zimmernummer registriert:

ZN = RI(VE)

Danach: GOSUB 10000 + ZN*100

Dann: neues Feld RI von Raum B einlesen.

Fertig.

Diese Theorie wird mittels den folgenden Ergänzungszeilen nun in die Praxis umgesetzt:

1010 GOSUB 50000: REM BEFEHLSEINGABEMODUL 
1100 REM GEHEN IN EIN NEUES ZIMMER 
1105 IF VE< 1 OR VE> 10 THEN 1200
1110 IF RI(VE)=0 THEN PR1NT " KEIN WEG IN DIESE RICHTUNG ! ":GOT0 1200
1120 ZN = Rl(VE) : PRINT " {CLR} "
1130 GOSUB 10000 + ZN*100
1140 RESTORE 1 0000 + ZN *100
1150 FOR I=1 TO 10 : READ RI(I) : NEXT
1200 GOTO 1000

Nun sind wir schon fast fertig.

Wir müssen im Kopf des Programmes nur noch eine Zeile einfügen, in der bestimmt wird, in weichem Zimmer der Spieler sich zu Beginn des Spiels befindet,

also: 100 ZN = 1 GOTO 1130

Das Spiel beginnt somit in Raum 1. Um das Spiel in irgend einen anderen Raum beginnen zu lassen, muß man nur den Wert in Zeile 100 entsprechend ändern, was beim späteren Fehlersuchen und Testen des Spiels eine große Hilfe darstellt.

Hiermit ist unser Ziel erreicht — Sie wissen nun, wie man eine Spielkarte programmiert.

TODO Listing 11

Die vorgestellte Spielkarte ist natürlich jedoch nur mit einem sehr spärlichen Raumbeschreibungstext ausgestattet. Dies können Sie aber leicht selbst verbessern — das nötige Wissen dazu haben Sie jetzt. Wenn Sie bisher mitgearbeitet haben, müßten Sie nun das Listing 11 im Computer haben.

Wir haben nun ein Adventure mit Räumen der primitivsten Art vorliegen. Alles was man bisher machen kann, ist herumlaufen.

Es ist nun sehr wünschenswert, daß man nach jeder Raum-beschreibung eine Angabe erhält, in welche Richtung man sich bewegen kann.

Wir schreiben deshalb nun eine kleine Routine, die nach jeder Raumbeschreibung »MÖGLICHE RICHTUNGEN:...« ausgibt.

Dies läßt sich ganz einfach realisieren, wenn man unser bisheriges Programm durch Listing 12 ergänzt:

TODO Listing 12
 
Eine Beschreibung erübrigt sich, da es sich um eine einfache Testschleife handelt, wie wir sie bereits des Öfteren besprochen haben.

Im Prinzip ist die Programmierung der Spielkarte nun fast abgeschlossen. Wir brauchen nur noch zwei kleine Routinen. Eine davon sorgt dafür, daß bei jeder Raumbeschreibung ausgegeben wird, welche Gegenstände sich im jeweiligen Raum befinden.

Dazu müssen wir jedoch zunächst unseren Wortschatz mit einigen Gegenständen erweitern.

Die Gegenstandsnamen werden, wie bereits besprochen, in dem Feld GE$(1) bis GE$(GZ) abgelegt, wobei GZ die Anzahl der Gegenstände darstellt.

Wir brauchen jedoch noch ein weiteres Feld für die Gegenstände, in dem angegeben wird, in welchen Räumen sich diese befinden.

Dieses Feld sei GE(1) bis GE(GZ).

Wir ergänzen unser Programm nun um Listing 13.

TODO Listing 13

Bitte notieren Sie sich auch diese Tabelle auf Papier. In jeder DATA-Zeile dieser Tabelle steht zuerst der Name des Gegenstands, und danach eine Zahl, die angibt, in welchem Raum sich der Gegenstand befindet (Raumzahl: vergleiche Karte).

TODO Listing 14

Nun wird die Routine eingefügt, die dafür sorgt, daß bei jeder Raumbeschreibung die sich im Raum befindlichen Gegenstände aufgezählt werden.

Tippen Sie bitte Listing 14 ein.

Wenn Sie nun wieder im Spielplan »herumlaufen« , so können Sie leicht feststellen, wo sich die einzelnen Gegenstände befinden. Nun müssen wir uns den Objekten zuwenden (Türen, Fenster, Schränke etc.) Zunächst wird wieder die Tabelle für die Objekte definiert.

Die Objektnamen werden in OB$(1) bis OB$(OZ) untergebracht. Außerdem legen wir noch ein Feld OO(1) bis OO(OZ) an, in dem, analog zu den Gegenständen, gespeichert wird, wo sich die einzelnen Objekte befinden. Wir ergänzen durch Listing 15.

TODO Listing 15
 
Was nun folgt ist ganz klar: Es muß eine Routine geschrieben werden, die bei jeder Raumbeschreibung die Objekte aufzählt (ganz analog zu den Gegenständen). Da es stilistisch schöner ist, die Objekte in der Aufzählung den Gegenständen voranzustellen, fügen wir in die bereits geschriebene Routine für die Gegenstände einfach eine Schleife ein, die die Objekte ausgibt falls im Raum welche vorhanden sind.

Es muß nur beachtet werden, daß in Zeile 1188 (Schleife für Gegenstände) die Checkvariable IC nicht mehr auf Null gesetzt werden darf, da die Meldung »Nichts besonderes« nur dann erfolgen soll, wenn sich weder Objekt noch Gegenstand im Raum befinden.

Ergänzen Sie bitte nun um Listing 16.

TODO Listing 16

Hiermit wären wir auch schon am Ende der Spielkarten-Programmierung angelangt. Sie haben dafür eine Programmiertechnik kennengelernt, die folgende besondere Merkmale hat:

—	geringer Speicherplatzverbrauch
—	leichte Korrekturmöglichkeit der Spielkarte
—	vollkommen ausbaufreundlich

Das somit vorliegende Adventure ist also leicht modifizierbar.

Sie können jeden Raum mit beliebigem Text versehen, Gegenstände und Objekte auf der Spielkarte verteilen und Sie haben die Möglichkeit, das Spiel in jedem beliebigen Raum beginnen zu lassen (dazu muß nur der ZN-Wert in Zeile 100 verändert werden), was beim späteren Testen des Spiels sehr wichtig ist. Sie können auch jederzeit neue Gegenstände und Objekte in die Karte einfügen — dazu müssen nur die Tabellen, die ab Zeile 52000 liegen, ergänzt und die Variablen GZ, OZ etc. entsprechend angepaßt werden.

Wenn Sie bis jetzt richtig mitgearbeitet haben, so müssen Sie Listing 17 im Computer haben.

TODO Listing 17
 
Mit diesem Listing werden wir in den folgenden Abschnitten weiterarbeiten — vergessen Sie deshalb nicht, es richtig abzuspeichern!

Leider ist das vorliegende Adventure noch ohne jeglichen Witz.

Im folgenden Abschnitt lernen Sie, wie man das Actionmodul mit Routinen wie NIMM, VERLIERE, INVENTUR, SCHAU, OEFFNE etc. programmiert.

Bitte lesen Sie aber erst dann weiter, wenn Sie die Programmierung der Spielkarte in allen Einzelheiten gut verstanden haben.

### Ausbau des Actionmoduls

Endlich ist es soweit – wir bringen Leben in unser bisher bescheidenes Adventure.

Im allgemeinen kann man die Actionprogrammierung in zwei Hauptgruppen aufteilen:

a)	Allgemeine Action<br>Dies sind Dinge, die der Spieler ständig machen kann —also überall auf der Spielkarte (zum Beispiel NIMM, VERLIERE, WARTE, SINGE, INVENTUR).
b)	Raumspezifische Action<br>Bei dieser Action handelt es sich um etwas, das nur in einem bestimmten Raum durchgeführt werden kann, zum Beispiel Öffnen einer Tür, einer Truhe oder Drücken eines Knopfes, der sich an der Zimmerwand befindet.

Wir wollen uns zunächst der allgemeinen Action zuwenden. Dazu müssen wir zunächst die Verbtabelle um einige Verben ergänzen, die im Rahmen der allgemeinen Action verwendet werden.

OEFFNE: Dieser Befehl dient zum Öffnen von Türen, Kisten etc.

SCHLIESSE: Umkehrung von OEFFNE

SCHAUE, UNTERSUCHE: Diese Verben haben Doppelfunktion.

Alleinstehend angewandt (»SCHAUE«) geben Sie die Raumbeschreibung wieder.

In Verbindung mit einem Objekt oder Gegenstand (»UNTERSUCHE TRUHE«) geben sie eine Beschreibung dieses Gegenstands beziehungsweise Objekts wieder.

NIMM, NEHME, HOLE: Sie dienen zum Nehmen von Gegenständen.

VERLIERE, LEGE, WIRF, WERFE: Umkehrung von NIMM.

INVENTUR: Mittels diesem Befehl erfährt der Spieler, welche Gegenstände er zur Zeit bei sich hat. Lassen Sie uns nun die Verbtabelle ergänzen:

52030 DATA OEFFNE,SCHLIESSE,SCHAUE,UNTERSUCHEI,NIMM,NEHME1,HOLE2 
52035 DATA VERLIERE,LEGE1,WIRF2,WERFE3,INVENTUR

Der VZ-Wert in Zeile 52100 muß entsprechend auf VZ —22 geändert werden.

Nach dieser Ergänzung sieht unsere Verbtabelle so aus:

TODO
1 bis 10	Himmelsrichtungen
11		OEFFNE
12		SCHLIESSE
13		SCHAUE, UNTERSUCHE
15		NIMM, NEHME, HOLE
18		VERLIERE, LEGE, WIRF, WERFE
22		INVENTUR

Sicher können Sie sich noch an den Abschnitt »Befehlsanalyse« erinnern, in dem der Begriff Alternativverb eingeführt worden ist.

Dadurch läßt sich auch erklären, warum die Verben nicht direkt durchnumeriert sind.

Die Tabelle sagt zum Beispiel aus, daß ganz egal, ob der Spieler nun NIMM, NEHME oder gar HOLE eingibt, die Verbzahl VE = 15 entsteht.

Entsprechendes gilt für die anderen Verbfamilien. Lassen Sie uns nun die einzelnen Routinen in unser Adventure einbauen.

#### NIMM-Routine

Auf unserem Spielplan haben wir bereits einige Gegenstände verteilt (Schwert, Seil, Schlüssel, Diamant). Wir wollen unserem Spieler nun erlauben, diese Gegenstände auch einsammeln zu können.

Wir ergänzen das Actionmodul um Listing 18.
 
TODO Listing 18

Bitte starten Sie das Adventure.

Geben Sie nacheinander folgende Befehle ein:

NIMM SCHWERT, S, N

Damit haben Sie in Raum 1 das Schwert genommen und sind nach S und dann, wieder mittels N, zurück nach Raum 1 gegangen — das Schwert wird in der Raumbeschreibung nun nicht mehr erwähnt. Wie funktioniert diese Routine?

Gehen wir einmal von der Befehlseingabe »NIMM SCHWERT« aus:

Das Befehisanalysemodul liefert an das Actionmodul folgende Werte:

VE	= 15	(Verbzahl)
G1	= 1	(1. Gegenstandszahl) vgl. auch Gegenstandstabelle.

Daraufhin läuft die NIMM-Routine so ab:

TODO
2110:	Wenn die Verbzahl VE ungleich 15 ist, so wird die NIMM-Routine übersprungen. Mit so einer Abfrage beginnt jede Routine.
2120:	Wenn der Gegenstand GE(G1) nicht im gleichen Zimmer wie der Spieler ist, erfolgt eine Fehlermeldung.
2125:	Wenn der Spieler den Gegenstand bereits hat, erfolgt eine Fehlermeldung, denn man kann nichts nehmen, was man bei sich trägt.
2130:	Wenn sich der Gegenstand im Zimmer befindet (GE(G1) = ZN), so nimmt der Spieler ihn (GE(G1) = -1).

Wir legen fest: Jeder Gegenstand, der im Besitz des Spielers ist, hat, beziehungsweise bekommt, den Wert -1.

#### INVENTUR-Routine

Mit dem Befehl INVENTUR erfährt der Spieler jederzeit, welche Gegenstände in seinem Besitz sind.

Bitte ergänzen Sie das Adventure um Listing 19.

TODO Listing 19

Die Routine besteht im Prinzip nur aus einer Schleife, die die Gegenstandstabelle durchläuft und überprüft, welche Gegenstände den Wert-1 haben — also im Besitz des Spielers sind.

Wenn Sie Ihr bisheriges Wissen einmal anwenden wollen, so können Sie einmal versuchen, die VERLIER-Routine, die ab Zeile 2300 stehen soll, selbst zu programmieren. Dies ist nicht schwer, da diese Routine fast analog zur NIMM-Routine läuft. Wer es selbst versuchen will, der sollte das Heft nun zunächst einmal weglegen.
 
Die **VERLIER-Routine** ist in Listing 20 abgebildet.

TODO Listing 20

Das Listing ist leicht zu verstehen. Wenn Sie Schwierigkeiten haben, so vergleichen Sie es bitte mit dem Listing der NIMM-Routine.

#### SCHAU-Routine

Der Befehl SCHAU alleine angewandt, gibt eine Raumbeschreibung aus, beziehungsweise wiederholt eine Raumbeschreibung.

In Verbindung mit einem Gegenstand oder einem Objekt, gibt er eine Beschreibung dieses Gegenstands beziehungsweise Objekts aus.

Bitte ergänzen Sie durch Listing 21.

TODO Listing 21

Auch dieses Listing ist leicht zu verstehen.

Der Sprung GOTO 1130 in Zeile 2410 bewirkt die Neuausgabe der Raumbeschreibung.

Mit der Ergänzung durch diese Routinen sind wir unserem Ziel — dem fertigen Adventure — schon ziemlich nahe gekommen.

Sie haben jetzt das Wissen, das nötig ist, um große Spiellandschaften zu programmieren, in denen man herumlaufen und Gegenstände transportieren kann.

Sie müssen jetzt noch lernen, wie man Aufgaben ins Spiel einbaut, die der Spieler lösen muß.

Dies lernen Sie alles im folgenden Abschnitt — die raumspezifische Action. Zunächst jedoch wieder ein Kontrollisting 22 zum Vergleich mit dem, was Sie momentan bei richtiger Mitarbeit vorliegen haben sollten.

TODO Listing 22

### Action in Räumen

Die raumspezifische Action bereite meisten den größten Programmieraufwand, und bringt somit auch das größte Chaos in die anfangs gut strukturierten Listings. Uns soll dies nicht passieren.

Wo bringt man die raumspezifische Action denn am besten im Listing beziehungsweise im Programm unter?

Die einfachste Lösung wäre es, die raumspezifische Action einfach an das Actionmodul anzuhängen. Man würde sich so für jeden Raum zirka 100 Zeilen reservieren (zum Beispiel 2500 bis 2599 für Raum 1) und vor jedem Raum eine IF – THEN - Abfrage stellen, die feststellt, ob der Raum übersprungen oder behandelt werden soll. Dieses Verfahren hat jedoch einen großen Verzögerungseffekt auf die Bearbeitungsgeschwindigkeit des Adventures zur Folge.
 
Um diesem und allen anderen Problemen auszuweichen, schreiben wir unsere raumspezifische Action direkt auf die Spielkarte. Dies geht ganz einfach:
Betrachten wir zunächst einmal erneut den Aufbau der Spielkarte und nehmen als Beispiel Raum 1.

Raum 1 liegt in den Zeilen 10100 bis maximal 10199.

Am Kopf des Raumes steht eine DATA-Zeile, die die möglichen Richtungen und ihre Zielorte zu diesem Raum enthält.

Die DATA-Zeile wird mittels

RESTORE 10000 + ZN*100

und einer READ-Schleife gelesen.

Danach wird die Raumbeschreibung mittels GOSUB 10000 + ZN*100 ausgegeben.

Die Raumbeschreibung steht dabei in PRINT-Zeilen von 10105 bis maximal 10119.

Was liegt nun näher, als die raumspezifische Action einfach in die Zeile von 10120 bis maximal 10199 zu legen?

Das allgemeine Ablaufschema für einen einzelnen Raum der Spielkarte samt Action sieht nun so aus:

TODO

Aus diesem Schema geht hervor, daß die raumspezifische Action zum Raum ZN (ZN = Zimmernummer der Karte) mittels
GOSUB 10000 + ZN*100 + 20
aufgerufen wird.

Um die Action des Raumes 1 aufzurufen, müßte man also
GOSUB 10000 + 1*100 + 20,
was identisch mit
GOSUB 10120 ist, eingeben.

Die raumspezifische Action wird immer am Ende des Actionmoduls aufgerufen. Ergänzen Sie Ihr Programm nun bitte um Listing 23.

TODO Listing 23

Damit ist eine übersichtliche Methode gegeben, unser Adventure mit jeder nur denkbaren Art von Action zu versehen. Der Vorteil der vorgestellten Methode liegt hauptsächlich darin, daß Fehler leicht beseitigt werden können, sofern sie im Spielverlauf auftreten.
 
Angenommen, wir sind in Raum 1 und irgendetwas funktioniert nicht, so muß man nur Zeile 10100 bis 10199 auflisten und kann sofort gezielt nach dem Fehler suchen.

Auf den folgenden Seiten finden Sie nun noch einige Beispiele zum Einbau und zur Programmierung von raumspezifischer Action.

#### Programmierung einer Tür

Unser Ziel soll nun sein, eine Tür zwischen den Räumen 2 und 5 zu programmieren.

Bisher kann man einfach von Raum 2 mittels der Eingabe »S« zu Raum 5 gelangen. Die Tür wird jedoch bereits in der Raumbeschreibung erwähnt, da sie in der Objekttabelle vertreten ist.

Zu bemerken ist hier, daß jede Tür immer zweimal in der Objekttabelle vertreten sein muß – denn man kann eine Tür immer von zwei Räumen aus sehen – den Räumen, die durch die Tür getrennt werden.

Vergleichen Sie bitte auch in Ihrem Listing die Zeilen 52416 und 52418. Der erste Schritt zur Programmierung der Tür besteht darin, den Verbindungsweg zwischen den beiden Räumen, zwischen die die Tür später soll, zunächst zu entfernen.

Für die Tür in unserem Beispiel (Raum 2 und 5) müssen wir die Richtungs-DATA-Zeilen der beiden Räume folgendermaßen ändern:

10202 DATA 0,0,1,0,0,0,0,6,0,0
10502 DATA 0,0,0,0,0,0,0,0,0,0

Damit ist die Verbindung zwischen Raum 2 und Raum 5 auch schon unterbrochen. Nun brauchen wir noch eine Variable, die den Zustand der Tür bestimmt.

Wir unterscheiden zwischen drei Zuständen:

1. Die Tür ist offen. Der Variablenwert zur Tür sei dann 0.
2. Die Tür ist zu und kann mittels »OEFFNE TUER« geöffnet werden. Der Variablenwert sei hierbei 1.
3. Die Tür ist zu und kann nur mit einem Hilfsmittel (zum Beispiel Schlüssel) geöffnet werden. Hierbei sei die Variable 2.

Unsere Türvariable soll TU(1) sein. Das Feld TU(1) bis TU(X) ist für die Zustände aller Dinge verantwortlich, die man öffnen und schließen kann.

Unsere Tür soll zunächst ohne Schlüssel geöffnet werden können. Die Türvariable TU(1) hat folglich den Wert 1.

Bitte ergänzen Sie das Listing nun um folgende Zeilen:

52900 REM ALLGEMEINE VARIABLEN
52910 TU(1) = 1 : REM TUER 2/5

Jetzt müssen wir die raumspezifische Action in den Räumen 2 und 5 zum Öffnen und Schließen der Tür programmieren. Dies geht so:

10220 IF TU(1)=0 THEN RI(2)=5
10225 IF VE=11 AND OB=5 AND TU(1)=1 THEN PRINT "OK.":TU(1)=0:RI(2)=5
10230 IF VE=12 AND OB=5 AND TU(1)=0 THEN PRINT "OK. "TU(1)=1:RI(2)=0
10250 RETURN

Damit unser Programm jedoch einwandfrei läuft, müssen wir im Actionmodul selbst erst noch eine kleine Änderung vornehmen: Bitte fügen Sie Zeile 1130 REM und 1155 GOSUB 10000+ZN*100 in das Programm ein. Eine Erklärung für diese Änderung folgt gleich. Nun die Erklärung zur Türprogrammierung in Raum 2:

TODO Tabelle

10220

In dieser Zeile wird der Zustand der Tür überprüft. Wird dabei festgestellt, daß die Tür offen ist, so gilt RI(2).= 5. Wie bereits festgelegt, ist RI(2) für die Richtung SUEDEN zuständig. Dadurch, daß die Tür offen ist, muß RI(2) also auf den Wert 5 gesetzt werden, was nichts anderes heißt, als daß man durch die Tür zu Raum 5 gelangt. Der ganze Trick der Türprogrammierung besteht darin, daß man zunächst den Verbindungsweg zwischen den Räumen entfernt, und im Falle einer offenen Tür einfach wieder herstellt, Diese Wiederherstellung erfolgt in dieser Zeile.

Hierduch läßt sich auch begründen, warum wir das Actionmodul ein wenig verändern mußten: Wenn der Spieler einen neuen Raum betritt, geschieht folgendes:

1.	Der DATA-Zeiger wird mittels RESTORE 10000+ZN*100 auf die DATA-Zeile des neuen Raumes gesetzt.
2.	Nun werden die Richtungsmöglichkeiten RI(1) bis RI(10) mittels READ-Befehl eingelesen.
3.	Sodann wird mittels GOSUB 10000 +100*ZN die Raumbeschreibung aufgerufen, bei der gegebenenfalb (Tür ist offen) auch der Verbindungsweg wieder hergestellt wird.

Die Änderung des Actionmoduls bestand also lediglich in der Vertauschung der Arbeitsschritte 2 und 3 auf die jetzige Reihenfolge. Nur bei der jetzigen Ordnung funktioniert das Programm einwandfrei.
 
10225

Hier wird geprüft, ob die Befehlseingabe des Spielers »OEFFNE TUER« lautet. Man schaut dazu einfach nach, ob VE=11 und OB=5 ist. Außerdem wird geprüft, ob die Tür zu ist, denn eine offene Tür kann man logischerweise nicht öffnen.

Stimmt alles, so wird TU(1) nun auf den Wert 1 (Tür ist offen) gesetzt, und der Verbindungsweg zu Raum 5 hergestellt: RI(2)=5.

10230

Analog zu 10225, nur das die Tür hier geschlossen wird.

Achtung: Sicher haben Sie sich bereits gewundert, wie die Abfrage, ob im Befehlssatz des Spielers die TUER vorkommt, erfolgt. Die Abfrage hierfür lautete einfach IF OB= 5 THEN... Warum muß OB gleich 5 und nicht gleich 4 sein?

Lassen Sie uns einmal einen Blick auf die Objekttabelle werfen:

TODO Tabelle

OB$(1)="TRUHE"	OO(1)=5
OB$(2)="SCHACHT"	OO(2)=6
OB$(3)="EISENRING"	OO(3)=6
OB$(4)="TUER"	OO(4)=2
OB$(5)="TUER"	OO(5)=5

Wie Sie bereits wissen, stammt der OB-Wert aus dem Befehlsanalysemodul. Sie erinnern sich sicher auch noch daran, wie das Modul den OB-Wert erhält:

Es durchläuft mit einer Schleife einfach die Objekttabelle:

FOR 1=1 TO OZ : IF BE$(WZ) = OB$(1) THEN OB=I

Somit wird klar, warum der erhaltene OB-Wert 5 und nicht 4 ist. Wir müssen also darauf achten, daß für Objekte, die den gleichen Namen haben, immer der OB-Wert des Objekts ausgegeben wird, welches in der Tabelle zuletzt gefunden wird beziehungsweise, das in der Tabelle den höchsten Wert hat.

Nun müssen wir natürlich noch den Raum 5 mit der spezifischen Action versehen, die auch in Raum 2 enthalten ist (was das Öffnen und Schließen der Tür anbelangt).

Bitte ergänzen Sie mit Listing 24.

TODO Listing 24

Die Programmierung der Tür könnte nun eigentlich als abgeschlossen betrachtet werden. Allerdings ist es erstrebenswert, dem Spieler die Möglichkeit zu geben, mittels »GEH TUER« durch die Tür zu gelangen.

Bisher muß man nach dem Öffnen der Tür noch den Befehl »SCHAU« eingeben, um zu erfahren, welche weitere Richtung sich durch das Öffnen der Tür ergeben hat. Dazu müssen wir die Verbtabelle wieder um das Verb »GEH« erweitern:

52030 .DATA GEHE,BETRETE1
und in Zeile 52100 den VZ-Wert auf 24 erhöhen. Nun kann die raumspezifische Action in den Räumen 2 und 5 erweitert werden:

10240 IF VE=23 AND OB=5 THEN VE=2
10540 IF VE=23 AND OB=5 THEN VE=1

Nebenbei muß auch das Actionmodul noch so ergänzt werden, damit diese Routinen angenommen werden:

1110 IF RI(VE)=0 THEN PRINT" KEIN WEG IN DIESE RICHTUNG ! ": VE=0:GOTO 1200
1130 VE=0
2520 IF VE>0 AND VE<11 THEN 1100
 
Wenn Sie wissen möchten, warum diese Änderungen unbedingt notwendig sind, dann spielen Sie das Adventure einmal vor und einmal nach der Änderung des Actionmoduls durch (die Tür-Szene). Bisher kann die Tür noch problemlos geöffnet werden. Nun wollen wir das Öffnen und Schließen der Tür von einem Schlüssel abhängig machen — die Tür kann nur dann noch geöffnet werden, wenn der Spieler im Besitz des Schlüssels ist.

Viele englische Adventures verlangen als Befehlssyntax zum Öffnen einer verschlossenen Tür mit einem Schlüssel etwa folgendes:

ENTRIEGLE TUER
OEFFNE TUER
GEH TUER

Im Deutschen ist es allerdings nicht besonders üblich »entriegle Tür« zu sagen. Wir wollen deshalb den ersten Schritt weglassen,-und folgenden Ablauf vereinbaren:

* Wenn der Spieler die Tür mit »OEFFNE TUER« öffnen will, jedoch keinen passenden Schlüssel bei sich hat, so erhält er die Meldung »ICH HABE KEINEN PASSENDEN SCHLUESSEL«.
* Hat er einen Schlüssel bei sich und gibt als Befehl wieder »OEFFNE TUER« ein, so erhält er die Meldung »OK.«.

Es ist pure Haarspalterei, vom Spieler Eingaben wie zum Beispiel »OEFFNE DIE TUER MIT DEM SCHLUESSEL« beziehungsweise »ENTRIEGLE DIE TUER MIT DEM SCHLUESSEL« und dann »OEFFNE TUER« zu verlangen. Wichtig ist nur die Tatsache, daß der Spieler einen Schlüssel gefunden haben muß, um durch die Tür zu gelangen.

Die Routine für die Schlüsselabfrage ist ganz einfach zu programmieren: Wir müssen vor der Tür-öffnen-Routine einfach eine Abfrage einbauen, die feststellt, ob GE(3) den Wert -1 hat, also, ob der Schlüssel im Besitz des Spielers ist.

Dazu sind nur zwei neue Ergänzungszeilen aus Listing 25 notwendig.

TODO Listing 25

Wenn Sie Ihr Programm ergänzt haben, dann machen Sie gleich einmal ein Probespiel und probieren das Öffnen der Tür mit dem Schlüssel aus.

Spielen Sie auch einmal die folgende Variante durch:

1.	Schlüssel holen
2.	Tür in Raum 2 öffnen.
3.	Schlüssel verlieren.
4.	In Raum 5 gehen.
5.	Tür schließen.

Sie sind nun in Raum 5 und können diesen nicht mehr verlassen, da das Türschloß zugeschnappt ist, und der Schlüssel sich in Raum 2 befindet, Man kann den Spieler also in eine Falle laufen lassen.

Interessant hierbei ist, daß kaum ein Spieler eine Tür wiederschließt, nachdem er sie erst einmal geöffnet hat. Die Programmierung dieses Effekts (die in der bisherigen Tür-Logik bereits enthalten ist) ist allein dadurch interessant, daß der Spieler überrascht wird.

#### Die Truhe

Wenn Sie sich in Raum 5 begeben, werden Sie feststellen, daß sich dort eine Truhe befindet.

Transportieren kann man die Truhe nicht, da wir bereits festgelegt haben, daß Objekte vom Spieler nicht transportiert werden können (eventuell, weil sie dazu zu schwer sind).

Lassen Sie uns zunächst noch eine Fehlermeldung in unser Adventure einbauen — wenn der Spieler versucht ein Objekt zu nehmen (Tür, etc.), so erhält er die Antwort »DAS GEHT UEBER MEINE KRAEFTE!«.

Diese Fehlermeldung läßt sich ganz einfach in die NIMM-Routine einbauen:

2115 IF OB<>O THEN PRINT " DAS GEHT UEBER MEINE KRAEFTE ! ":GOT0 2200

Nun zur Truhe speziell:

In der Truhe können selbstverständlich Gegenstände liegen. Für die Gegenstände haben wir bisher folgendes definiert: Wenn GE(X) größer als Null ist, so liegt der Gegenstand in diesem Raum.

Wenn GE(X) den Wert -1 hat, so ist dieser Gegenstand im Besitz des Spielers.

Nun ergänzen wir mit folgender Bedingung:

Wenn GE(X) den Wert -2 hat, so liegt der Gegenstand in der Truhe.

Wir wollen unsere Gegenstandstabelle nun so umändern, daß das Schwert nicht mehr wie bisher in Raum 1 liegt, sondern sich zukünftig in der Truhe befindet, also:
 
52210 DATA SCHWERT,-2

Nun liegt das Schwert in der Truhe.
Wie kommen wir im Verlauf des Spiels jedoch wieder zum Schwert?

Nun ganz einfach, wir müssen die Truhe öffnen. Dazu ist es erforderlich, in die raurnspezifische Action von Raum 5 eine Routine einzubauen, die das OEFFNEN der TRUHE erlaubt. Im Prinzip können wir die Truhe wie eine Tür betrachten, denn auch bei der Truhe sind drei Zustandsformen möglich (offen, zu, verriegelt).

Wir benötigen also wieder eine Variable, die Auskunft über den jeweiligen Zustand der Truhe gibt. Diese Variable sei TU(2) und der Ausgangszustand der Truhe sei 1 (also Truhe ist zu und kann mittels OEFFNEN ohne irgendeinem Hilfsmittel a la Schlüssel geöffnet werden).

Wir ergänzen:

52920 TU(2)=1:REM TRUHE

Nun müssen wir die OEFFNE-Routine für Raum 5 programmieren. Dies geht ganz einfach:

10545 IF VE=11 AND OB=1 AND TU(2)=1 THEN PRINT "OK. ":TU(2)=0

Was man öffnen kann, kann man auch schließen, also:

10546 IF VE=12 AND OB=1 AND TU(2)=0 THEN PRINT "OK. ":TU(2)=1

Sie sehen schon, daß die meisten Routinen relativ einfach programmiert werden können, da wir zu Beginn viel Arbeit und Gedanken in die Programmierung des Befehlsanalysemoduls gesteckt haben. Diese Arbeit macht sich nun bezahlt, denn wir können nun jegliche Routine programmieren, und müssen dabei nur den Wortschatz entsprechend erweitern, in der Routine selbst nur VERBZAHL, OBJEKTZAHL etc. abfragen, und danach TUER-Variablen etc. entsprechend verändern.

So schön, so gut!

Wir können die Truhe nun öffnen und schließen, aber vom Schwert ist noch keine Spur zu sehen. Dazu müssen wir die Raumbeschreibungs-Routine erweitern. Die Gegenstände, die sich in der Truhe befinden, sollen künftig auch in der Raumbeschreibung erwähnt werden, unter der Bedingung einer geöffneten Truhe. Dazu genügt wieder eine einzige Abfrage:

1189 IF GE(I)=-2 AND TU(2)=0 AND ZN=5 THEN PRINT GE$(I);",";:IC=1

Diese Abfrage steht innerhalb der Schleife, in der auch geprüft wird, ob sich im betreffenden Raum ein Gegenstand befindet.

In der Truhenabfrage muß also berücksichtigt werden, daß der Gegenstand nur dann in der Raumbeschreibung vorkommen darf, wenn der Spieler sich in Raum 5 (wo die Truhe steht) befindet, wenn die Truhe offen ist, und wenn in der Truhe Gegenstände liegen (also deren GE-Wert gleich -2 ist).

Wenn Sie nun in Raum 5 gehen und mittels »OEFFNE TRUHE« die Truhe öffnen, und danach den Befehl »SCHAU« eingeben, so wird das Schwert sichtbar. Wenn Sie die Truhe jedoch wieder schließen, so verschwindet das Schwert auch wieder aus der Raumbeschreibung.

Das Schwert ist nun sichtbar. Wenn Sie jedoch versuchen, sich das Schwert mit »NIMM SCHWERT« anzueignen, so werden Sie mit der Fehlermeldung »ICH SEHE DIESEN GEGENSTAND HIER NICHT!« enttäuscht. Unser Programm fragt nämlich nur, ob der Gegenstandswert des Gegenstands, den man nehmen will, der Zimmernummer ZN entspricht (also GE(G1) gleich ZN ist.).

Wir müssen nun eine Abfrage einbauen, die es dem Spieler erlaubt auch Gegenstände zu nehmen, die in der Truhe liegen, wenn diese offen ist, und wenn wir uns in dem Raum befinden, in dem die Truhe steht.

Diese Abfrage muß natürlich wieder in der raumspezifischen Action zu Raum 5 vorkommen. Wir benötigen wiederum nur eine Zeile:

10548 IF VE=15 AND GE(G1)=-2 AND TU(2)=0 THEN PRINT"OK.":GE(G1)=-1

Damit können auch Gegenstände aus der Truhe herausgenommen werden.

Allerdings erfolgt immer noch die Fehlermeldung »ICH SEHE...«.

Um diesen Fehler zu beseitigen, stellen wir der Zeile, in der diese Fehlermeldung produziert wird, folgende Zeile voran:

2119 IF GE(G1)=-2 AND ZN=5 AND TU(2)=0 THEN 2125

Damit ist das Problem auch schon gelöst.

Wir sind jedoch noch nicht am Ende der Truhen-Programmierung angelangt. Aus einer Truhe, aus der man etwas herausnehmen kann, muß man auch etwas hineinlegen können.

Gerade solche Kleinigkeiten sind es letztendlich, die ein gutes Adventure ausmachen.

Um das »LEGEN« von Gegenständen in die Truhe möglich zu machen, müssen wir eine VERLIER-Routine erstellen, die auf Objekte bezogen ist.

Gemäß unserer Worttabelle besteht die VERLIER-Wortfamilie aus folgenden Mitgliedern: VERLIERE, LEGE, WIRF, WERFE.

Wir nehmen nun einmal an, der Spieler steht in Raum 5 und hat die Truhe bereits geöffnet. Wenn er den Befehl »VERLIER« und Gegenstand eingibt, so nimmt dieser Gegenstand den Wert ZN an (GE(G1) =ZN) und liegt nun in Raum 5.

Wir müssen nun eine Routine programmieren, die dem Gegenstand bei einer Eingabe wie »LEGE (GEGENSTAND) IN TRUHE« den Wert -2 verpaßt.

Dies bringen wir wieder in der raumspezifischen Action zu Raum 5 unter:

10550 IF VE=18 AND OB=1 AND TU(2)=0 AND GE(G1)=-1 THEN PRINT "OK.":GE(G1)=-2

10590 RETURN

Zusätzlich muß noch eine Abfrage in die Verlier-Routine eingebaut werden, die dafür sorgt, daß die normale Verlier-Routine übersprungen wird, wenn der VERLIER-Befehl sich auf ein Objekt wie die Truhe bezieht:

2301 IF OB<>0 THEN 2400

Wenn der Spieler die Kiste beziehungsweise die Truhe untersucht, so erfährt er, daß sie sehr groß ist.

Der Spieler kommt nun vielleicht auf die Idee, in die Truhe zu gehen. Auch dies wollen wir ihm ermöglichen.

Dazu müssen wir die Truhe zunächst als Raum programmieren. Wir nehmen dazu Raum 7 — also ab Zeile 10700:

10700 REM IN DER TRUHE
10702 DATA 0,0,0,0,0,0,0,0,0,0
10705 PRINT" IN DER TRUHE. "
10720 RETURN

Um in die Truhe zu gelangen, muß der Spieler in Raum 5 den Befehl »GEH TRUHE« eingeben, aber erst, nachdem er die Truhe geöffnet hat.

Dazu ergänzen wir die raumspezifische Action in Raum 5:

10560 IF VE=23 AND OB=1 AND TU(2)=0 THEN RI(1)= 7:VE=1

Wie Sie aus dieser Zeile ersehen können, besteht der Trick des GEH-Befehls also einfach darin, in die Richtung RI(1) den Wert des Zielraums zu schreiben (für die Truhe also 7), und danach die Verbzahl VE auf den Wert 1 zu setzen, wodurch das GEHEN bewirkt wird.

Einmal in der Truhe, werden Sie enttäuscht feststellen, daß Sie das Schwert überhaupt nicht sehen können. Wenn Sie in der Truhe einen Gegenstand verlieren, so läßt sich dieser nur dann wieder nehmen, wenn Sie dazu in die Truhe gehen.

Dies liegt daran, daß wir zuvor bestimmt haben, daß jeder Gegenstand, der sich in der Truhe befindet, den Wert -2 bekommt. Da die Truhe nun aber selbst zu einem Raum geworden ist, müssen alle Gegenstände, die sich in ihr befinden den Wert 7 haben, da 7 der Raumwert der Truhe ist.

Wenn Sie den Fehler also beheben wollen, so müssen Sie lediglich alle -2-Werte in den Wert 7 umwandeln.

Damit die Truhe auch wieder verlassen werden kann, müßen wir die raumspezifische Action der Truhe programmieren:

Der Wortschatz wird zunächst um das Verb VERLASSE erweitert:

52045 DATA VERLASSE

52100 VZ=25……….	(VZ-Wert anpassen!)

Nun die Action zum Verlassen der Truhe in Raum 7:

10720 IF VE=25 AND OB=I AND TU(2)=0 THEN RI(1)=5:VE=1

Diese Abfrage ist lediglich die Umkehrung zur Abfrage in der die Truhe betreten wird. Sonderbar ist jedoch, daß auch abgefragt wird, ob die Truhe offen ist, wenn man sie verlassen will.

Schließlich läßt sich die Truhe doch nur dann betreten, wenn man sie geöffnet hat, und wenn man erst einmal in der Truhe ist, dann kann man sie von dort aus doch nicht schließen! Wozu also die Abfrage, ob die Truhe auch offen ist? Wer sollte sie denn schließen?

Damit kommen wir auch schon zum nächsten Abschnitt des Kurses:
 
### Ein Gespenst geht um ...

Wie ich bereits zu Beginn des Kurses erwähnt habe, sind Adventures mit Nichtspielercharakteren — Spielfiguren, die vom Programm selbst gesteuert werden — besonders reizvoll.

Da die Programmierung solcher Spielfiguren oft für sehr schwer gehalten wird, treten nur in sehr wenigen Spielen solche Figuren auf.

Ein Meisterbeispiel für solche Adventures ist »Hobbit«. Tatsächlich ist es jedoch relativ einfach, Nichtspielercharaktere zu programmieren.

Das erste Problem besteht darin, einen Weg zu finden, wie der Nichtspielercharakter (in unserem Falle das Gespenst) in der Spielkarte umherlaufen kann. Eine Möglichkeit wäre es, das Gespenst per Randout (zufallsgesteuert) von Raum zu Raum irren zu lassen. Diese Lösung erweist sich auf die Dauer jedoch als zu primitiv, da die Gefahr groß ist, daß das Gespenst sich in einer Sackgasse verfängt und dort sehr lange umherirrt. Dadurch trifft der Spieler nur äußerst selten auf das Gespenst, was nicht der Fall sein soll. Das Gespenst soll dem Spieler oft in die Quere geraten.

Eine weitere, primitive Lösung wäre es, das Gespenst erst gar nicht herumlaufen zu lassen, sondern es einfach per Zufall gesteuert plötzlich im Raum des Spielers auftauchen zu lassen.

Folgende Lösung hat sich in meinen Adventures bisher bestens bewährt: Zunächst wird das Gespenst einmal in die Personentabelle aufgenommen:

52600 REM PERSONENTABELLE
52610 DATA GESPENST
52700 PZ=1:DIM PE$(PZ):FOR I=1 TO PZ:READ PE$(I): NEXT

Als nächster Schritt wird eine genaue Route festgelegt, die das Gespenst später ablaufen soll.

Für unser Adventure eignet sich die folgende Route:

1 – 3 – 4 – 3 – 1 – 2 – 5 – 2 – 6 – 2 – 1

Diese Zahlen beziehen sich selbstverständlich auf die einzelnen Räume. Das Gespenst beginnt also in Raum 1, geht dann nach Raum 3 etc.

Wichtig ist dabei nur, daß der letzte Raum der Kette wieder dem ersten Raum entspricht, denn wir wollen es auch unserem Gespenst nicht erlauben, durch Wände von Raum zu Raum zu gelangen.

Das Gespenst läuft also immer wieder die gleiche Route ab. Dies hört sich zwar primitiv an, aber ich kann Ihnen versichern, daß dem Spieler kaum auffallen wird, daß das Gespenst sich immer nach dem gleichen Schema fortbewegt. Nun gut, bei unserem Mini-Adventure ist es vielleicht nicht sehr schwer, die Taktik des Gespenstes zu durchschauen, aber bei Spielen mit 100 und mehr Räumen, was natürlich mit längeren Routen verbunden ist, besteht kaum eine Chance, die Route eines Nichtspielercharakters herauszufinden — vorausgesetzt, man hat sie nicht selbst programmiert.

Ein weiterer Vorteil der Routenprogrammierung liegt darin, daß man die Gebiete der einzelnen Figuren gut begrenzen kann. Die Route wird nun durch das Feld PE(1) bis PE(11) festgelegt.

52920 DATA1,3,4,3,1,2,5,2,6,2,1

52935 DIM PE(11):FOR I=1 T0 11:READ PE(I): NEXT:MO=1

Die Steuerung des Gespenstes soll innerhalb des Actionmoduls ab Zeile 3000 beginnen:

3000 REM STEUERUNG DES GESPENSTES 
3001 PRINT "GESPENST= ";PE(MO)
3010 IF MO=0 THEN RETURN
3020 MO=MO+1:IF MO=12 THEN MO=1 
3025 IF PE(MO)<>ZN THEN 3100
3100 RETURN

Aufgerufen wird dieses Unterprogramm noch vor dem Aufruf der raumspezifischen Action in Zeile 2505:

2505 GOSUB 3000: REM GESPENST

Zeile 3001 dient lediglich zum Verfolgen des Gespenstes. Sie kann später nach Belieben wieder entfernt werden.

Die Variable MO läuft von 1 bis 11 durch und beginnt dann wieder von vorne: PE(MO) ist somit der Raum, in dem sich das Gespenst gerade befindet. Ist MO=0, dann ist das Gespenst abgeschaltet (durch Zeile 3010).

Nach jedem Spielzug des Spielers wird die Variable MO um 1 erhöht — das Gespenst bewegt sich.

Damit der Spieler auch bemerkt, wenn das Gespenst den Raum betritt, müssen wir noch folgende Zeile einfügen:

3030 PRINT "EIN RIESIGES GESPENST ERSCHEINT !"
 
Bisher ist unser Gespenst ja noch ziemlich harmlos. Wir wollen ihm deshalb folgende Aufgabe stellen:

Wenn das Gespenst einen Raum betritt, in dem ein Gegenstand liegt, so soll es diesen mitnehmen. Es darf jedoch immer nur einen Gegenstand transportieren, kann allerdings den Gegenstand auch jederzeit gegen einen anderen austauschen. Geben Sie zunächst folgende Ergänzung ein — die Erklärung dazu folgt anschließend:

3100 IC=0:FOR I=1 TO GZ:IF GE(I)=PE(MO) THEN IC= I
3105 NEXT
3110 IF IC=0 THEM 315O
3120 GE(GF)= PE(MO):GF=IC:GE(IC)=0
3150 RETURN

Auch diese Routine läßt sich leicht erklären.

Zunächst wird eine Schleife durchlaufen, in der geprüft wird, ob sich in dem Raum, in welchem sich das Gespenst gerade befindet, auch ein Gegenstand liegt. Trifft dies zu, so legt das Gespenst den Gegenstand, den es momentan bei sich trägt ab (GE(GF)=PE(MO)), und nimmt den neuen Gegenstand mit (GF=IC). Der Gegenstand, der im Besitz des Gespenstes ist, muß immer auf Null gesetzt werden (GE(lC)=0). Die Variable GF dient lediglich als Zwischenspeicher für die genommenen Gegenstände.

Das Gespenst kann nun also Gegenstände transportieren. Nun wollen wir noch einen weiteren Effekt einbauen:

3150 IF PE(MO)=5 AND ZN=7 AND TU(2)=0 THEN TU(2)=1:PRINT "JEMAND SCHLIESST DIE TRUHE" 
3160 RETURN

Wenn das Gespenst nun Raum 5 betritt und der Spieler sich gleichzeitig in der Truhe befindet, so schließt das Gespenst die Truhe, und der Spieler ist gefangen.

Auf den letzten Seiten sollten Sie anhand der Beispiele gelernt haben, wie man ein Adventure mit Action versieht. Im Prinzip besteht jede Actionhandlung nur aus einfachen IF THEN - Abfragen und einem anschließenden Spiel und Verändern von verschiedenen Variablen.

Sie sollten nun in der Lage sein, jede beliebige Actionszene zu programmieren. Es sollten hier nur die Prinzipien an einem einfachen Beispiel gezeigt werden. Welcher Art die Nichtspielcharakter sind, ihre Route und Fähigkeiten, liegt im Ermessen des jeweiligen Programmierers.

Als abschließende Übung zur Überprüfung Ihres Lernerfolgs empfehle ich diese Variante:

In Raum 6 befindet sich ein Schacht und ein Eisenring im Boden.
Programmieren Sie nun folgendes:

Durch den Schacht gelangt man zu Raum 8. Dazu muß man das Seil am Eisenring befestigen und anschließend hinabklettern. Wenn Sie dieses Problem gelöst haben, können Sie sich durchaus daran machen, eigene Probleme zu stellen, und diese dann in Programmroutinen umzusetzen Hier noch abschließend Listing 26, das Sie vorliegen haben sollten, wenn Sie bisher richtig mitgearbeitet haben.

### Noch ein Tip zum Schluß

Versuchen Sie die Wahl der Bildschirmfarben so zu treffen, daß sie auch angenehm gelesen werden können.

Es empfiehlt sich in jedem Fall für Hintergrund und Rahmen die Farbe Schwarz zu wählen. Als Schriftfarbe wäre dann Hellgrau, Weiß oder Grün geeignet. Viele Adventures, wie man sie von Zeitschriften her kennt, sind in einer unangenehmen Farbkombination gehalten (zum Beispiel schwarze Schrift auf braunem Hintergrund etc).

Wie störend eine grelle Farbgebung für den Spieler sein kann, erfahren Sie spätestens dann, wenn auch Ihnen die Augen tränen - entscheiden Sie sich deshalb gründlich, bevor Sie eine endgültige Auswahl der Farben treffen. Dies sind zwar nur Kleinigkeiten, aber gerade diese Kleinigkeiten werden oft vom Programmierer übersehen. Dies führt nicht zuletzt auch zu einer Qualitätsminderung des Spiels. Bisher haben wir außerdem kaum von Grafik in Adventures gesprochen. Für Datasettenanwender bietet sich lediglich die normale Zeichengrafik an, da hochauflösende Grafik zuviel Speicherplatz benötigt und auch nur schwer mittels Datasette zu bearbeiten ist.

Die Grafik sollte immer das letzte sein, woran Sie arbeiten - sie soll also erst dann eingebaut werden, wenn das eigentliche Adventure schon komplett ist. Es empfiehlt sich, für die Grafiken eine Größe von zirka 10 mal 20 Zeichen zu wählen, da ganze Bildschirmseiten wiederum zuviel Speicherplatz kosten. Das folgende Programm stellt einen Maskengenerator dar, der es ihnen ermöglicht, Bilder einfach zu erstellen.

Nachdem der Maskengenerator geladen ist, wird das Bild mittels Cursortasten auf den Bildschirm »gemalt«. Ist das Bild fertig, so wird es an jeder Ecke mit einem Klammeraffen­ Zeichen versehen. Die vier Klammeraffen müssen ein Rechteck bilden, beziehungsweise die Eckpunkte eines Rechtecks begrenzen, in dem das Bild steht.

Sodann wird der Maskengenerator mittels RUN 60000 gestartet. Von der Größe des Bildes hängt die Bearbeitungszeit ab. Nach einer Weile, erscheint das Bild in Form von PRINT­ Zeilen auf dem Bildschirm. Sie müssen nun nur noch die RETURN-Taste mehrmals drücken, um die PRINT-Zeilen zu übernehmen. Das Programm errechnet alle Steuerzeichen und Farben automatisch und setzt sie in PRINT-Zeilen um.

Das eigentlich mühselige Erstellen von Blockgrafiken wird so mit Listing 27 zum Kinderspiel.
 
TODO Listing 27

Ich hoffe, daß es mir mit dem vorliegenden Kurs gelungen ist, Sie für Abenteuerspiele und deren Programmierung zu interessieren. Dazu wünsche ich Ihnen viele gute Ideen und viel Spaß.

(Michael Nickles/rg)

# Zauberschloß  – ein Abenteuerspiel mit Tücken \[53]

> Abenteuerspiele haben ihren ganz besonderen Reiz. Gefragt sind weniger die motorischen Reaktionsfähigkeiten, sondern vielmehr die logische Vorgehensweise und viel Fantasie. In einem streng bewachten Schloß mit seinen vielfältigen Gefahren gilt es, dem Zauberer die Krone und damit die Regentschaft über das Volk zu entreißen. Doch es ist ein steiniger Weg.

Es ist uns klar, daß wir mit der Veröffentlichung des Listings vom Zauberschloß die Möglichkeit bieten, durch Analyse des Programms dem Lösungsweg auf die Spur zu kommen. Viel wichtiger erschien unsjedoch, einmal an einem kommentierten Listing zu zeigen, wie ein Abenteuerspiel aufgebaut ist. Nicht zuletzt, um vielleicht einige Leser anzuregen, sich selbst mit der Erstellung dieser Denkspiele zu befassen.

Worum geht es bei dem Abenteuerspiel Zauberschloß? Nach dem Starten des Programms sieht man zunächst den Wald vor lauter Bäumen nicht. Präzise gesagt, man befindet sich in einem Wald, der kein Ende zu nehmen scheint. In welche Richtung man auch läuft — nur Wald. Mit einem Trick gelangt man aber doch in das Zauberschloß.

An dieser Stelle sei kurz auf die Art der Befehlseingabe hingewiesen. Um die gestellte Aufgabe (die sich erst während des Spiels klarer herauskristallisiert) zu lösen, geben Sie dem Computer Anweisungen, die er dann ausführt. Diese Befehle bestehen in der Regel aus zwei Worten, die durch eine Leerstelle getrennt sein müssen. Das erste Wort ist ein Befehlswort, das aus dem vorhandenen Wortschatz (NIMM VERLIERE LIES ÖFFNE VERJAGE DREH BENUTZE TRINK) zu entnehmen ist. Das zweite Wort bezieht sich auf einen Gegenstand, der in denjeweiligen Situationsbildern zu sehen ist. Die Auswirkungen der Kommandos werden vom C64 auf dem Bildschirm als Nachricht angezeigt. Für die Richtungsangabe werden nur die Anfangsbuchstaben eingegeben. Die möglichen Himmelsrichtungen sind jeweils vorgegeben.

Das Schloß besteht aus mehreren Stockwerken einschließlich einem Kerker im Keller, der in keinem anständigen Schloß fehlen darf. In den verschiedenen Stockwerken lauern Kobolde, die Sie bei falscher Vorgehensweise in einen Zwerg verwandeln, öffnen sich bei Fehltritten Falltüren, liegen Tarnkappen, Gift- und Zaubergetränke, Messer, Speere und Zettel herum. All diese Gegenstände stehen in irgendeiner Beziehung zum weiteren Vorwärtskommen. Man muß sie in der entsprechenden Reihenfolge aufnehmen und wieder wegwerfen. Wegwerfen deshalb, weil man zu einem bestimmten Zeitpunkt nur vier Gegenstände gleichzeitig tragen kann. Ein wesentlicher Meilenstein ist das Buch. In diesem Buch stehen nämlich wichtige Informationen, wie man sich bei der letztlich eintretenden Konfrontation mit dem Zauberer zu verhalten hat. Aber Vorsicht, die Wache hat etwas gegen den verständlichen Wunsch, dieses Buch zu lesen. Als größtes Hindernis tritt Ihnen ein feuerspeiender Drache gegenüber, der den Eingang zum Thronsaal bewacht. Fürwahr, ein schwerer Brocken. Wenn Sie aber den richtigen Zauberspruch auf Lager haben, verwandelt der Zauberer sich in eine niedliche Maus, und Sie haben das Königreich von einem Tyrannen befreit. Es bleibt nur ein Problem: Wie kommt man mit der Krone wieder aus dem Schloß heraus?

Aber bis Sie soweit vorgedrungen sind, werden sicherlich einige Stunden vergangen sein, in denen Sie ein Wechselbad von Enttäuschungen und Hochgefühlen durchleben. Da bis zum endgültigen Ziel eine Menge Schritte einzugeben sind, und Sie sicherlich nicht beim ersten Versuch gleich die Lösung finden werden, bietet Ihnen das Programm die Möglichkeit, das Spiel mit dem Kommando SAVE abzuspeichern. So können Sie zu einem späteren Zeitpunkt genau bei der Stelle weitersuchen, an der Sie kurz vor einem Zusammenbruch aufgehört haben.

Noch eine kurze Bemerkung zum Listing: Um die oben angesprochene Analyse dennoch etwas zu erschweren, sind einige Daten verschlüsselt worden. Das Listing ist im Grafikmodus einzugeben.

Und nun viel Spaß bei einem Abenteuer im Zauberschloß.

(Dennis Merbach/aa)

# Neuer Checksummer 64 — blitzschnell und kürzer \[63]

> Der Checksummer überprüft jede eingegebene Basic-Zeile und erspart Ihnen deshalb eine langwierige Fehlersuche. Und neu ist der Checksummer, weil die Initialisierung zirka einhundertmal schneller ist als die alta

Der Checksummer 64 ist ein kleines Maschinenprogramm, das, wenn es aktiviert ist, Sie sofort davon unterrichtet, ob Sie die jeweilige Programmzeile korrekt eingegeben haben.

1.	Tippen Sie den Basic-Lader sorgfältig ein. Es gibt zwei Versionen: Eine für den Commodore 64 und eine für den VC 20.
2.	Bevor Sie »RUN« eingeben, speichern Sie den Basic-Lader bitte erst ab, denn wenn Sie zum Beispiel einen Fehler bei den eingetippten POKE-Anweisungen gemacht haben, ist es möglich, daß der Rechner aussteigt. Heben Sie sich den abgespeicherten Checksummer 64 auf — Sie werden ihn immer wieder brauchen, wenn Sie ein Basic-Programm aus dem 64’er eintippen wollen.
3.	Nach Initialisierung des Maschinenprogramms ist der Checksummer 64 aktiviert. Er steht innerhalb des Betriebssystems und verbraucht kein einziges Byte Speicherplatz. Es sei hier für Interessierte gesagt, daß selbst alle Sprungvektoren unverändert bleiben, das Programm also mit einer Vielzahl von Programmier-Spracherweiterungen problemlos zusammenarbeitet. Achten Sie aber darauf, daß bestimmte Spracherweiterungen das hinter dem ROM liegende RAM für Hires-Grafiken benutzen. Wird zum Beispiel eine Hires-Grafik von Simons Basic aus angesprochen, so wird der Checksummer 64 zerstört.
4.	Wenn Sie den Checksummer 64 zwischenzeitlich nicht benutzen, können Sie ihn jederzeit mit »POKE 1, 55« desaktivieren. Auch durch Drücken der Run-Stop- und der Restore-Taste wird der Checksummer 64 desaktiviert. Wollen Sie, daß der Checksummer 64 auch noch nach Drücken dieser Tastenkombination erhalten bleibt, so geben Sie bei aktiviertem Checksummer 64 »POKE64982,53« ein. Der Checksummer 64 ist dann nur durch »POKE1, 55« abschaltbar.<br>Wollen Sie den Checksummer 64 wieder einschalten, so geben Sie bitte »POKE 1, 53« ein.<br>Das Maschinenprogramm bleibt solange erhalten, bis der Computer ausgeschaltet, oder wenn von anderen Programmen auf das hinter dem ROM liegende RAM zugegriffen wird.
5.	Eine Checksumme wird nur dann ausgegeben, wenn der Commodore 64 (VC 20) eindeutig erkennt, daß Sie eine Zeile, bestehend aus der Zeilennummer und zumindestens einem alphanumerischen Zeichen, eingegeben haben. Ansonsten reagiert der Commodore 64 normal.

**Hinweis**: Wenn Sie bei aktivertem Checksummer 64 ein Programm mit »LOAD« in den Speicher holen, wird auch eine Checksumme ausgegeben. Dies liegtjedoch an rechnerinternen Routinen und hat keine weitere Bedeutung, stellt insbesondere keine Gefahr für das geladene Programm dar, da alle Pointer richtig gesetzt werden.

Nach Eingabe von RUN wird zunächst einmal das ROM in das RAM des Commodore 64 verschoben, wonach der Basic-lnterpreter modifiziert wird. Dadurch hat man den Vorteil, trotz einer zusätzlichen Routine das gesamte RAM des Rechners zurVerfügung zu haben. Nach ordnungsgemäßem Ablaufdes Programms können Sie sofort mit Eingaben beginnen. Für Maschinensprache-Spezialisten: die Einschaltmeldungen des Rechners werden nur nach einem Reset generiert. Der Textbereich, in dem die Meldung steht, wird von dem erzeugten Maschinenprogramm überschrieben.

Alle veröffentlichten Listings sind mit einer Checksumme versehen, die am Ende jeder Programmzeile steht. Diese Checksumme steht zwischen < und >. Sie wird beim Eintippen des Programms nicht mit eingegeben. Die Zahl zwischen den beiden Zeichen stellt lediglich eine Information für Sie dar. Wenn Sie diese Checksumme dennoch mit eintippen, werden Sie schnell bemerken, daß Sie etwas falsch gemacht haben. Bei aktiviertem Checksummer 64 wird nämlich nach Eingabe einer Basic-Zeile, die mit Return beendet wird, in die linke obere Bildschirmecke die Checksumme eingeblendet, die mit der Summe aus dem veröffentlichten Listing übereinstimmen muß. Ist das nicht der Fall, haben Sie die Zeile anders eingegeben, als sie im Listing dargestellt ist. Vergessen Sie also bitte nicht, daß die am Ende einer Zeile zwischen < und > stehende Prüfsumme nicht mit eingegeben werden darf.

Der Checksummer 64 ist so ausgelegt, daß er abhängig von der Zeilennummer und dem Text der Zeile eine Checksumme ausgibt. Beim Bilden dieser Checksumme werden Spaces (Leertaste) überlesen, was für Sie bedeutet, daß es egal ist, wieviel Leerzeichen Sie zwischen den Worten lassen, da sie für den Programmablauf ohnehin keine Bedeutung haben. Aber manchmal ist das richtige Setzen von Leerzeichen doch wichtig, besonders innerhalb von Strings (Zeichenketten), die gedruckt werden sollen. Seien Sie deshalb besonders genau bei Leerzeichen, die innerhalb von Anführungszeichen stehen, denn meistens ermöglichen nur die richtig gesetzten Spaces eine sinnvolle Textausgabe auf dem Bildschirm.

Beachten Sie auch, daß es durchaus erlaubt ist, Abkürzungen für die Commodore-Befehlswörter zu verwenden. So führt die Eingabe von »?« als Kurzschreibweise für »PRINT« nicht etwa zu einem Checksummen-Fehler, sondern wird korrekt verarbeitet und dementsprechend die Checksumme generiert. Zahlendreher werden allerdings nicht erkannt. Eine 320 in der DATA-Zeile ergibt also dieselbe Prüfsumme wie 230! Nachdem Sie ein Listing eingegeben haben, sollten Sie es aus Sicherheitsgründen vor dem Starten abspeichern. Sie brauchen hierfür jedoch nicht den Checksummer 64 zu desaktivieren.

## Wichtiger Hinweis für alle Listings in unseren Heften!

Um Ihnen die Eingabe unserer Listings zu erleichtern, gibt es weder Steuerzeichen noch andere Grafikzeichen. Sie werden ersetzt durch Klartext. In der Tabelle finden Sie die Erklärung der übersetzten Steuerzeichen.
Beispiel 1:

In einem Listing sehen Sie folgende Zeile:

TODO

Dann dürfen Sie weder die geschweiften Klammern eintippen (es gibt sie eh nicht auf der Tastatur) und auch nicht die Wörter CLEAR, 13SPACE, RVSON oder RVOFF, sondern Sie müssen die diesen Wörtern zugeordneten Tasten drücken. In der Tabelle sehen Sie zum Beispiel für
CLEAR = Shift-Taste und 2. Taste ganz rechts oben.

Gemeint ist also, daß Sie anstelle des Wortes CLEAR die Taste CLR/HOME drücken müssen, gefolgtvon 13maligem Betätigen der Leertaste (13SPACE) und so weiter. Auf Ihrem Bildschirm erscheint dann als erstes ein revers dargestelltes Herz. Entsprechendes gilt für alle anderen Wörter innerhalb der geschweiften Klammern.
Beispiel 2:

In manchen Listings tauchen ganz seltsame unterstrichene und manchmal auch überstrichene Zeichen auf, zum Beispiel:

TODO

Das unterstrichene U bedeutet, daß Sie die Shift-Taste und die Taste U drücken müssen.

Der überstrichene Stern bedeutet, daß Sie die Commodore-Taste und die Taste mit dem Stern drücken müssen. Das Zeichen davor ist nicht etwa ein unterstrichenes kleines f, sondern ein unterstrichenes Pfund-Zeichen (Sie drücken deshalb die Shift-Taste und die 3. Taste oben rechts).

Also, **unterstrichen** bedeutet **Shift-Taste** und den entsprechenden Buchstaben (oder Zeichen), **überstrichen** bedeutet die **Commodore-Taste** und den entsprechenden Buchstaben (oder Zeichen). Auf dem Bildschirm sollten Sie dann natürlich die zugehörigen Grafik-Zeichen sehen.

Die beiden Programm-Zeilen von oben sehen später (auf dem Drucker oder ähnlich auf dem Bildschirm) so aus:

TODO

(F. Lonczewski/gk)


# Adventure 2000 — Die Jagd nach der Rakete \[65]

> Vom Präsidenten der Vereinigten Staaten erhalten Sie den Auftrag, den dritten Weltkrieg zu verhindern.

Die Idee eines Adventures ist, mit dem Computer zu kommunizieren. Viele Adventures tun das mit Hilfe von Zwei-Wort-Befehlen. So hat »GEHE TUER« den Effekt vom Verlassen eines Raumes durch eine Tür.

Einige Adventures haben Mehr-Wort-Eingaben (The Hobbit), die ein komfortables »Gespräch« mit dem Computer ermöglichen.

Auch Adventure 2000 versteht Mehr-Wort-Eingaben. Man kann Begleiter, bestimmteSignal- und Bindewörteraufeinmal eingeben, ohne den Satz groß verstümmeln zu müssen. Zum Beispiel: »Nimm den Schlüssel dann stecke den Schlüssel in das Schlüsselloch dann öffne die Türe und gehe durch die Türe« wird von den in Adventure 2000 verwendeten Routinen rasch bearbeitet.

Durch Eingabe von »BEFEHLE« listet der Computer alle Verben auf, die er versteht.

Durch Kombination der Verben mit den verwendeten Nomen und Verkettung durch »und« oder »dann« kann man versuchen, der Lösung näher zu kommen.

Zugegeben — das scheint kompliziert. Man lernt jedoch den Umgang am besten, indem man einfach ausprobiert, was der Computer verarbeitet. Zudem braucht man von jedem Verb oder Nomen nur die ersten drei Buchstaben einzugeben, den Rest erledigt der Computer. Achtung! Signalwörter wie »dann« und »und« müssen immer ausgeschrieben werden.

### Was ist die Aufgabe beim Adventure 2000?

Die eigentliche Aufgabe wird erst im Verlauf des Spiels gestellt.

### Was passiert?

Nachdem das Programm mit »RUN« gestartet wurde, erscheint das Titelbild und der Computer liest Daten ein und setzt die Variablen fest. Dann wird der Bildschirm gelöscht und Sie finden sich im Raum wieder.

Beim Betreten eines Raumes wird in der ersten Zeile immer angegeben wo man sich befindet. Links wird die Grafik des entsprechenden Raumes gezeigt und rechts was sich im Raum befindet und welche direkten Ausgänge es gibt.

Sind keine direkten Ausgänge angegeben, so bleibt es dem Kombinationsvermögen des Spielers überlassen, andere zu finden. Unter der Grafik erscheint dann: Was gedenkst du zu tun? Darauf kann die Eingabe erfolgen, die — wie der Spieler denkt — zum Erfolg führt.

### Wie »antwortet« der Computer auf die Eingabe?

Der Computer überprüft die Eingabe und gibt — falls erforderlich — aus, daß er nicht weiß, wovon die Rede ist (wenn falsche Worte verwendet wurden).

Wenn der Computer in der Lage ist, die Eingabe auszuführen, erscheint das Ergebnis auf dem Bildschirm.

Zum Beispiel führt »NIMM MAPPE« zur Meldung »IN ORDNUNG, WIR TRAGEN NUN EINE MAPPE BEI UNS«.

### Was tun, wenn der Computer »abstürzt«?

Sollte man alle erlaubten 100 Zeichen der Eingabe mit Mühe gefüllt haben und dann mit Schrecken feststellen, daß der Computer nur noch ausgibt: »Wovon sprichst du?« oder »Ich verstehe dich nicht!«, dann kann man ihn mit der F1-Taste wieder zum »Was gedenkst du zu tun?« zurückholen.

(Frank Schmelzer/rg)

# Quasimodo, Herrscher der Kartanen \[76]

> Dieses Abenteuer führt Sie in die Welt der Fantasia 31 Räume stehen Ihnen auf der Suche nach Quasimodo zur Verfügung. Finden und vernichten Sie ihn.

Sie wurden vom Volk der Kartanen bestimmt, den Herrscher des Landes aufzuspüren und zu vernichten. Sie wissen von ihm nur, daß er Quasimodo heißt und Hexenmeister ist. Als Sie sich bereit erklärten, diese schwere Aufgabe zu übernehmen, brachten Sie ihre Landsleute durch einen Geheimgang in dessen Gewölbe. Nun müssen Sie allerlei Gefahren, wie Monster, Leichen und Fallgruben überstehen, um zu Quasimodo vorzudringen.

Das Programm Quasimodo ist ein Abenteuerspiel, bei dem es darauf ankommt, durch Eingabe von Befehlen eine bestimmte Aufgabe zu lösen. Diese Kommandos bestehen meist aus einem Verb und einem Hauptwort. Hier nun eine Zusammenstellung aller möglichen Kommandos:

NIMM, GIB, GEH, LISTE, HOCH, ZUENDE, SPRING, TRINK, DRUECKE, BEFEHLE und OEFFNE.

Richtungsänderungen können durch Eingabe der Abkürzungen N, S, W, 0 für Nord, Süd, West und Ost vorgenommen werden. Diese werden neben den sichtbaren Gegenständen immer auf dem Bildschirm angezeigt. Zum Ablauf des Programms wäre noch zu sagen, daß der Computer wichtige Spielpassagen akustisch untermalt.

(Roland Selzer/rg)

# Mario, die unheimliche Mine \[80]

> Im Land der Fantasie liegt die Mine »Mario«. Finden sie den richtigen Weg durch das ausgedehnte Gangsystem.

Mario ist ein Grafik-Adventure für den C 64. Das Spiel ist in normalem C 64-Basic geschrieberr und füllt fast den gesamten Basic-Speicherplatz des Computers. Es finden 24 Sprites Verwendung, deren Daten bei Bedarf eingeschaltet werden. Deshalb muß der Spieler zu Beginn eine knappe viertel Minute warten, während dessen er Gelegenheit hat, die Anleitung zu lesen. Lesern von J. R. Tolkien werden gewisse Parallelen zu dem Buch »Der Herr der Ringe« auffallen. Das ist nicht ganz zufällig, denn die verlassene Mine namens Mario ist in gewissem Sinne der Zwergenmine Moria aus diesem Buch nachempfunden. Wer überhaupt nicht mehr weiter weiß, sollte sich dieses Buch ausleihen. Dort kann er einige Hilfen für das Adventure finden.

Das Spiel versteht 19 Befehle. Diese lauten:

NIMM, VERLIERE, HEBE, ENTLEERE, WIRF, LIES (diese Befehle werden von einem Gegenstand gefolgt)

OEFFNE (eine Tür oder ein Tor)

BRINGE ... UM (dazwischen steht ein Lebewesen)

SPEICHERE, LADE (für das Speichern und Laden eines Spielstandes, um nicht immer wieder von vorn anfangen zu müssen). Diese Befehle können erst eingegeben werden, wenn man in die Mine eingedrungen ist. Besitzer einer Diskettenstation müssen die Zeilen 16520 (Öffnen der Datei für Speichern) und 16620 (Öffnen der Datei für Laden) entsprechend ändern.

SAGE (wird von beliebigen Worten gefolgt, die aber nicht in normalen Anführungszeichen stehen sollten).

HILF (hier gibt der Computer Hilfen oder Erklärungen, denen man aber nicht immer trauen sollte)

LIST (zeigt die getragenen Gegenstände auf)

N, S, O, W, H (hoch), R (runter).

Man kann höchstens drei Gegenstände auf einmal tragen. Wenn das Anfangsbild erstellt ist, muß eine Taste gedrückt werden, da danach soviel Text erscheint, daß eine vernünftige Grafik zusammen mit dem Text nicht möglich wäre. Vorsicht mit der Rechtschreibung! Der Computer achtet genau auf die richtige Schreibweise der Befehle.

Zu jedem Raum, in dem man sich befindet, wird ein Bild gezeigt, das die Spielsituation verdeutlicht. Insgesamt gibt es sechs voneinander völlig verschiedene Bilder. Es gibt jedoch wesentlich mehr Räume, da die Bilder manchmal nur leicht ab-gewandeltwerden, wenn man in einen anderen Raum kommt.

Bei dem Weg durch die Mine wird man unter anderem von Orks, einer Riesenspinne und einem schrecklichen Feuerwesen behindert. Mehr soll hier nicht verraten werden. Aufpassen muß man auch bei den Himmelsrichtungen. Der Spieler sieht die Räume so, daß Osten immer in Blickrichtung liegt. 

### Erläuterungen zum Ablaufschema des Programms

Zunächst springt das Programm in Zeile 9000, wo die Erläuterungen für den Spieler am Bildschirm ausgegeben werden, danach liest es die Daten der Sprites und wartet auf einen Tastendruck. Es zeichnet das Anfangsbild und geht zu Zeile 6000, wo mittels eines GET-Befehls das Kommando eingegeben wird. Sobald »Return« gedrückt wird, erfolgt die Auswertung. Hat man das Tor geöffnet und den Befehl »0« eingegeben, wird das nächste Bild gezeichnet und es folgt der Sprung in Zeile 15030, wo für alle Räume, außer dem Anfangsbild, das Kommando mittels INPUT-Befehl eingelesen wird. In den darauffolgenden Zeilen wird fürjeden möglichen Befehl geprüft, ob er identisch mit dem eingegebenen Kommando ist und die entsprechende Reaktion auslöst Wenn man einen neuen Raum betritt, geht das Programm zu Zeile 10200, von wo aus dann in die Unterprogramme zum Zeichnen der Räume verteilt wird. Von diesen werden die UnterprogrammeabZeile10000,1O1OO, 10300und11000ange-sprochen:

TODO TABLE

10000 berechnet mittels C(X,Y) die Gegenstände, stellt sie mittels einer Verzweigung in die Unterprogramme ab 5000 dar
10100 berechnet mittels D(X,Y) die Ausgänge aus den Räumen, besetzt eventuell die Merker B(1) bis B(6)
10300 sucht nach Besonderheiten (E(X,Y)), verzweigtin die Unterprogramme zu ihrer Darstellung
11000 stellt fest, ob wegen irgendwelcher Besonderheiten der Tod des Spielers eingetreten ist. Wenn ja, dann gibt es zu dem Unterprogramm ab Zeile 8000, das das Spiel beendet und auf Wunsch des Spielers neu startet. Wenn nein, erfolgt ein Rücksprung.

Sonder-Unterprogramme (Inhalt der Schriftrolle, des Buches, Flucht der Spinne etc.) werden von den Auswertungszeilen zum INPUT-Befehl direkt aufgerufen.

Das Feuer in einem Raum besteht aus 4 Sprites, die nacheinander erscheinen und deshalb eine Bewegung vortäuschen.

Obwohl die Mine mehrere Ebenen hat, gibt es zur Bestimmung der Position des Spielers nur zwei Variablen, X und Y Dies geschah aus Speicherplatzgründen. Wenn man in die nächste Ebene kommt, dann wird einfach der Y-Wert auf einen Wert gebracht, der in der vorhergehenden Ebene gar nicht vorkommen kann. So wurde die Positionsbestimmung mit nur zwei Variablen möglich.

(Frank Leggewie/Harald Bornfleth/rg)

# Zeittunnel — Flucht in die Gegenwart \[93]

> Durch einen Zeittunnel in die Zukunft. Finden Sie den Weg zurück.

Das Spiel beginnt im heimischen Wohnzimmer. Die Kommandos müssen ausgeschrieben und durch eine Leerstelle getrennt werden. Zum Beispiel »NEHME BILD«. Die Syntax ist: Imperativ, Leerstelle, Objekt. Für die Richtungen werden Anfangsbuchstaben benutzt. Die Eingabe wird mit »Return« abgeschlossen. Mit der gleichen Taste gelangt man vom Grafik- in den Textmodus. Vom Text- in den Grafikmodus kommt man mit dem Befehl »BILD«.

(Jens Schürbs/Arndt Meiswinkel/rg)

# Crantor — Bedrohung aus dem All \[102]

> Hier müssen Sie sich auf die Reise durch das Ali begeben. Crantor ist ein Beispiel, wie man ein Geschicklichkeitsspiel mit einem Adventure verbinden kann.

Es geschah einst in ferner Zukunft, als ein garstiger Möchtegern-Imperator namens Eusebius Crantor die Andromeda-Galaxis erobern wollte, indem er sämtliche Imbißstuben zerstören ließ. Das hypergalaktische Imbißdepot beauftragte daraufhin den Jäger des verlorenen Hamburgers (den Spieler) den garstigen Imperator mitsamt seiner Wochenendbasis in handliche Einheiten zu zerlegen.

Alsdann schwang sich unser Held in seine supramoderne Aegriventre-Untertasse, um Crantors Basis zu erreichen. Nach einer problematischen Landung gelangte der Jäger in das Innere der Basis.

Dort mußte er sich gegen Eusebius Crantor und dessen Wachen, den Crames, zur Wehr setzen.

Nachdem er, unter mannigfachen Problemen leidend, zur Energiezentrale der Basis vorgedrungen war, und dort eine Sprengladung mit Zeitzünder angebracht hatte, eilte er in Windeseile zu seinem U-Boot, um die Explosion der Basis aus der sicheren Entfernung einer Pommesbudeam Rande dervierten Astralaxe mitsamt einem Hamburger zwischen den Zähnen zu betrachten.

Die Befehle mit denen unser Held geleitet wird, werden wie üblich in zwei Worten eingegeben:

Zum Beispiel »NIMM SCHWERT«, »TOETE CRANTOR« oder »LIST« (gibt eine Liste aller Gegenstände aus, die der Jäger gerade besitzt).

Mit »SAVE« und »LOAD« kann eine Spielsituation gespeichert, beziehungsweise wieder geladen werden.

Die Aegriventre-Untertasse wird durch einen Joystick an Control-Port 1 gesteuert.

(Andreas Lüning/rg)

# Odyssee — Kampf der Bruderschaft \[111]

> Eine abenteuerliche Reise durch das Land des bösen Zauberers Saruman.

Bei Odyssee handelt es sich um eine Kombination aus Abenteuer- und Rollenspiel.

Als Auserwählter einer Bruderschaft erhalten Sie den Auftrag, das Land vom Zauberer zu befreien. Sie begeben sich auf die Reise, den Zauberer zu suchen und zu vernichten; dabei werden Sie gefährliche Situationen zu meistern haben, Feinden, aber auch Freunden begegnen.

Vor 20 Jahren hat der mächtige Zauberer Saruman die Herrschaft über das Land Sosaria an sich gerissen. Ihre Bruderschaft ist jedoch nicht länger gewillt, seine Tyrannei noch länger zu erdulden und hat Ihnen den Auftrag gegeben, den Zauberer zu suchen und zu vernichten. Auf Ihrer Reise begegnen Sie vielen Feinden und einigen Ordensbrüdern, aber auch unter diesen gibt es Verräter. Ausgerüstet sind Sie mit 400 Einheiten Kraft, 350 goldenen Münzen und 50 Vorratseinheiten. Sie werden schnell feststellen, daß Sie noch sehr schwach sind, aber es gibt in Dörfern und Städten Kleider, Waffen und Vorräte zu kaufen. Geld bekommen Sie in zahlreichen Kämpfen.

### Eingabe und Speicherung

Zuerst muß man den »Creater« eingeben und speichern. Nach dem Starten prüft das Programm, ob alle DATA-Zeilen richtig eingegeben worden sind. Ist dies nicht der Fall, so erscheint eine Fehlermeldung. Stimmen die DATAs, dauert es noch etwa 3,5 Minuten, bis das Programm »World« auf Diskette gespeichert ist. »World« beinhaltet einen neuen Zeichensatz, eine Maschinensprache-Routine zum waagerechten Scrollen des Bildschirms und zirka 16 KByte, die die Landschaft der Odyssee ausmachen.

Die Odyssee ist das Hauptprogramm. Nach Eintippen und Speichern startet man es mit RUN. Zuerst gilt es, sich einen Spieler zu erstellen. Hier kann man 100 Punkte auf Stärke (Strength), Widerstandskraft (Stamina), Intelligenz (Intelligence) und Wissen (Wisdom) verteilen. Die Eingabe der Punkte muß immer zwei Ziffern lang sein. Falls man einmal zuviel Punkte (100) eingegeben hat, werden alle Kriterien wieder auf Null gesetzt, und man beginnt von vorne. Nun entschließt man sich noch zu einem fantasievollen Namen und muß jetzt erst einmal Geduld aufbringen, da man noch ungefähr eine Minute zu warten hat. Diese Wartezeit braucht jedoch nur beim 1. Spiel in Kauf genommen zu werden. Nun erscheint das Titelbild mit dem Hinweis darauf, daß der 2.Teil geladen wird. Ist der Ladevorgang abgeschlossen, kann das Spiel begonnen werden.

### Änderungen für Kassette:

1.	CREATER; Zeile 265 SYS(57812)»WORLD«,1
2.	ODYSSEE:Die Änderungen stehen im Listing von Zeile 9299—9320

## Bewegung der Spielfigur

Die Spielfigur wird ausschließlich über die Tastatur gesteuert. Hier die Belegung der einzelnen Tasten:
@ = Die Spielfigur bewegt sich nach Norden
/ = Die Spielfigur geht nach Süden
; = Die Spielfigur läuft nach Westen
: = Die Spielfigur schreitet nach Osten

A = angreifen (ATTACK)
Im unteren Fenster erscheint ATTACK —. Nun muß man eine Richtungstaste drücken (siehe oben), um dem Computer zu zeigen, in welche Richtung der Befehl zielen soll. Das Programm gibt daraufhin an, ob getroffen worden ist. Dies hängt von der Stärke des Spielers und von seinen Waffen ab. Ist ein Feind besiegt, so erhält man eine Anzahl von Goldstücken und, wenn man Glück hat, einen Matrosenanzug (BLUE TASSLE).
T = verhandeln (TRANSACT)
Nach Eingabe der Richtung, in die verhandelt werden soll, erscheint die Antwort im Textfenster. Falls sich in der angegebenen Richtung niemand aufhält, erscheint die Meldung: »NO RESPONSE«
E = betreten (ENTER)
Mit diesem Befehl kann man in Dörfer und Städte gelangen.
B = Schiff betreten (BOARD SHIP)
Um auf ein Schiff zu gelangen, muß man diesen Befehl benutzen. Man braucht aber einen Matrosenanzug (BLUE TASS-LE), damit man von der Besatzung an Bord gelassen wird. Ausnahme ist, wenn man das Schiff in einem Dorf kauft.
X = Das vorher betretene Schiff wird verlassen.
Z = Inventar
Hier wird der Name des Spielers, seine Waffen, seine Kleidung, seine Eigenschaften, seine Kraft und die Sachen (TOOLS), die er bei sich trägt, auf dem Bildschirm angezeigt. Drückt man eine Taste, so dauert es noch einen Moment, bis das Spiel fortgesetzt werden kann.
U =Tür aufschließen (UNLOCK DOOR)
Eine Tür kann geöffnet werden, wenn man den Schlüssel zu ihr besitzt.
G = Zeigt an, wieviel Goldstücke man besitzt.
H = Gibt an, wieviel Kraft (POWER) man noch hat.
F = Zeigt die verbleibenden FOOD-Einheiten.
M = MAGIC MISSILE auslösen
Ein weißes Quadrat läuft über den Bildschirm und tötet alle Feinde und Freunde. Fürjedes Lebewesen erhält man 5 Goldstücke. Man kann es nur einmal benutzen.
R = Neues Spiel (RESTART GAME)
Hiermit kann ein neues Spiel begonnen werden, falls man in einer aussichtslosen Lage ist. Der Computer fragt, ob man sich sicher ist, daß man ein neues Spiel starten möchte. Antwortet man mit »Y«, so kann man sich eine neue Spielfigur erstellen.

### Dörfer und Städte

In den Dörfern und Städten des Landes erhält man viele Gegenstände, die zur Lösung der Aufgabe beitragen. In jeder Stadt kann man Waffen und Kleider kaufen. Um seine Vorräte aufzufüllen oder seine Spielsucht zu befriedigen, muß man sich schon in die Dörfer bequemen.

Kauf einer Waffe: Man betritt eine Stadt und geht in den WEAPONSHOP, indem man eine 1 drückt. Ausdenvierange-botenen Waffen wählt man sich eine aus, indem man die Ziffer der Waffe drückt. Der Ladeninhaber sagt den Preis, und man kann sich entscheiden, ob man die Waffe kaufen oder lieber seinen Geldbeutel schonen möchte.

Der Kauf eines Kleidungsstücks vollzieht sich genauso, wie der Erwerb einer Waffe.

Kaufen von Nahrung: In einem Dorf betritt man mit 1 den FOODSHOP und erfährt den Preis für 100 FOOD-Einheiten. Der Preisschwanktzwischen 32 und 52 Goldstücken und ist bei jedem Versuch anders. Scheint der Preis annehmbar, so beantwortet man die Frage ob man kaufen möchte mit »Y«, und der Computer zeigt an, wieviel Einheiten FOOD man besitzt.

Hat man einmal nichtgenug Geld, um den geforderten Preis zu bezahlen, erscheint die Fehlermeldung »YOU HAVE NOT ENOUGH MONEY«.

### Freunde und Feinde

Zu Ihrem Unglück gibt es viele Ihnen feindlich gesonnene Krieger, die im Dienste des Zauberers stehen, jedoch nur wenige Ordensbrüder, die Ihnen aber wertvolle Dinge geben können. Manche dieser Ordensbrüder stehen Ihnen aber auch mißtrauisch gegenüber, so daß Sie von Ihnen Geheimwörterwissen wollen oder Sie nach Ihrer Intelligenz (INTELLIGENCE) oder nach Ihrem Wissen (WISDOM) beurteilen.

Werden Sie in einen Kampf mit den Feinden verstrickt, so erscheint im Textfenster immer HIT und MISS. HIT bedeutet, daß der Gegner Sie getroffen hat; MISS, daß er verfehlt hat. Wie oft Sie getroffen werden, hängt von der Dauer des Kampfes, IhrerWiderstandsfähigkeit (STAMINA) und Ihrer Kleidung ab.

Sie haben das Spiel verloren, wenn Sie keine Nahrung (FOOD) oder keine Kraft (POWER) mehr haben. FOOD verlieren Sie, wenn Sie durch das Land gehen (pro Schritt 0,2 Einheiten). Kraft verlieren Sie in den Kämpfen, wenn Sie getroffen werden.

### Hilfsmittel

Die Hilfsmittel braucht man, um die gestellte Aufgabe zu lösen. Man erhält sie in Kämpfen, Dörfern und Städten und von den Ordensbrüdern. Wenn man »Z« drückt, werden sie unter TOOLS aufgelistet.

BLUE TASSLE: Matrosenanzug

Hat man keinen Matrosenanzug, läßt einen die Besatzung eines Schiffes nicht an Bord. Es erscheint die Meldung »THE CREW DOES NOT ALLOW THIS«.

MAGIC MISSILE: magische Waffe

Mit ihr vernichtet man alle Feinde, leider aber auch alle Freunde, die auf dem Bildschirm zu sehen sind. Für jeden Freund oder Feind erhält man durch diese Tötungsaktion 5 Goldstücke. Man kann sie also dazu benutzen, sich Geld zu verschaffen odereine ÜbermaChtvon Feindenzuvernichten.

KEY: Schlüssel

Braucht man um Türen zu öffnen.

GOLDEN KEY: goldener Schlüssel

Erklärt sich im Spielverlauf

SWIM-WEST: Schwimmweste

Hat man die Schwimmweste, kann man 12 Felder weit schwimmen. Danach löst sie sich in Luft auf.

BOOTS: Schuhe

Trägt man Schuhe, so kann man 2 Felder über felsigen Grund laufen. Danach sind sie verschlissen.

MARK OF FIRE:

Mit MARK OF FIRE kann man durch LAVA gehen.

### Verschiedenes

Wie Sie vielleicht bemerkt haben, habe ich drei Einzeiler aus der Ausgabe 11/84 des 64’er Magazins in mein Programm übernommen. Im »Creater« istes die SAVE-Routine für Maschinenspracheprogramme und in der »Odyssee« der Einzeiler zum Kopieren des Basic ins RAM. Der Einzeiler, der die »Odyssee« überhaupt erst ermöglicht hat, ist der zum Feststellen eines Bildschirmbereiches von Peter Eckart.

(Jan Geißelmann/rg)

# Ring of Power \[118]

Vorbei an Drachen und Hausmäusen sollen Sie den Thronsaal finden, in dem der »Ring of Power« liegt. Ihr Weg führt Sie durch ein großes Schloß, einen Schloßgarten und über unterirdische Quellen.

Für alle, die diesen Weg noch nicht gefunden haben, der Lösungsweg:

takelamp, lampon, north, takekey, south, east, north, north, east, take can, north, west, west, south, west, west, north, take key, south, south, south, take bottle, east, east, east, north, east, open chest, take sword, take armour, east, north, north, takecreditcard, south, south, south, open door, south, south, take honey, south, west, west, west, take cork, west, west, north, drop key, take bottle, south, east, east, east, east, east, fill bottle, north, north, north, west, west, south, west, north, up, pay, east, drop cork, take boat, east, east, east, east, drop credit card, take ball, west, west, north, north, north, empty bottle, drop boat, up, kill dragon, west, west, open door, west, drop bottle, take coins, north, west, west, negotiate customs, drop coins, east, east, south, open door, south, east, open door, east, east, take rope, north, west, take guide, east, south, west, west, north, take note, inve (Zahl notieren), drop note, west, west, west, west, south, drop key, take coins, east, up, pay, west, north, drop rum, north, north, drop honey, east, south, south, east, down, pay, west, take key, take plank, east, up, pay, west, north, drop key, south, take key, north, north, east, open door, drop key, east, take key, west, south, south, south, drop plank, north, north, north, take key, south, south, south, south, east, north, open door, drop key, north, open chest, take jewel, south, drop armour, take key, west, open clam, north, north, east, up, pay, east, east, drop ball, drop can, drop rope, drop treasure key, west, down, pay, west, north, take key, west, north, north, east, east, take crown, west, west, south, south, south, south, south, dial ... (notierte Zahl), take orb, north, west, south, west, west, north, north, drop guide, north, east, east, take pulley, west, west, south, south, east, east, north, east, north, north, east, south, south, south, take pearl, north, north, east, up, pay, east, drop pulley, west, down, pay, take cage, up, pay, east, drop crown, drop orp, take pulley, take rope, south, south, drop pulley, drop rope, take jigsaw, north, north, take can, east, east, north, drop cage, north, open door, oil door, open door, drop can, south, west, drop key, west, take crown, take key, take orb, east, east, north, north, west, south (Postertext notieren), west, west, west, north, north, west, south, south, south, east, south, say ... (Postertext), south, south, west, north, take ring.

(Rüdiger Ihlo/rg)

# So löse ich Ultima III \[119]

> Viele Abenteurer werden beim Versuch Ultima III zu lösen sicherlich schon auf Schwierigkeiten gestoßen sein. Um diese Schwierigkeiten zu beseitigen, haben wir die wichtigsten Lösungstips für dieses Spiel niedergeschrieben.

Wichtig, wenn auch im Anleitungsbuch leicht übersehbar, ist die Tatsache, daß ein Spieler, der im Level gestiegen ist, mit Lord British reden muß. Erst dadurch kann er die gewonnene Erfahrung in Hit-Points (Lebenskraft-Punkte) umsetzen.

Hit-Points kann man außerdem aufbessern, indem man zum Dungeon des Feuers geht. Dort befindet sich in der zweiten Etage eine Quelle, von der man trinken sollte.

Sie tun gut daran, wenn Sie bei der Zusammenstellung der Gruppe nicht nur gleiche Charaktere nehmen. Als ideale Kombination erwies sich die Zusammenstellung der Gruppe aus einem »Cleric«, einem »Wizard«, einem »Fighter« und einem »Thief«. Statt des Klerikers und des Kämpfers können Sie allerdings auch einen Paladin nehmen, der Klerikersprüche benutzen kann und auch im Kampf stark ist.

Der Dieb hat den Vorteil, daß er in den Dungeons (Höhlenlabyrinthen) Fallen aufspüren kann. Auch beim Umgang mit »Powders« stellt er sich geschickter an, als die anderen Charaktere. Die positive Eigenschaft des Zauberers und des Klerikers ist das Zaubern; die Sprüche des Klerikers haben mehr eine friedfertige Natur (Heilen, Schatzkisten öffnen etc.), wogegen der Zauberer seine Fähigkeiten besser im Kampf mit Gegnern einsetzen kann. Kämpfer sind besondersstark, wenn es darum geht, einem Feind zu widerstehen.

Dies waren ein paar allgemeine Tips, doch nun zur Lösung. Alle in diesem Artikel angegebenen Koordinatenangaben beziehen sich übrigens auf das Schloß des Lord British. Sind beispielsweise die Koordinaten 8W und 35S angegeben, dann müssen Sie von Lord British’s Castle aus 8 Schritte nach links (Westen) und 35 Schritte nach unten (Süden) gehen.

### Kämpfe

Kämpfen ist in diesem Spiel unerläßlich, denn durch das Töten von Monstern erhalten Sie Erfahrungspunkte, durch die Sie später in Ihrem Level aufsteigen.

Gegen sehr starke Gegner wie zum Beispiel Drachen, Balrons oder größere Ansammlungen von Wachen, empfiehlt es sich, Powders einzusetzen. Powders verlangsamen den Bewegungsablauf der Gegner.

Gegen die sehr häufig auftretenden Skelette sollten Sie mit dem Klerikerspruch A (Pontori) kämpfen. Vor Benutzung dieses Spruches solltejedoch nicht angegriffen werden, da er sonst fast immer mißlingt. Das gleiche gilt auch für den Zauberspruch A (Repond), dergegen Orcs und Orc-ähnliche Monster verwendet werden kann.

Bei den Kämpfen gegen den Fußboden sollten Sie alle Spieler in der untersten Reihe postieren. Attackieren Sie dann immer nur mit Hilfe von Schuß-, Schleuder- oder Wurfwaffen nach Norden (Oben).

### Waffen

Es gibt Unmengen verschiedenerWaffentypen. Davon sind die Nahkampfwaffen am uneffektivsten. Schuß-, Wurf- und Schleuderwaffen sind also ganz klar zu bevorzugen.

Wenn Sie noch nicht genügend Geld haben, sich bessere Waffen zu kaufen, wählen Sie Slings; Slings sind die billigsten auf Entfernung wirkenden Waffen. Sollte Ihr Geld ausreichen, dann gehen Sie zur Stadt Dawn. Dort gibt es alle Waffen, die man haben möchte.

Wenn Sie mit Hilfe dieser Waffen sehr stark und gewandt sind, lassen sich die Gegner vernichten, ohne überhaupt mit ihnen in Berührung zu kommen.

### Gold

Sobald Sie einen Gegner besiegt haben, können Sie all sein Gold und sonstige Besitztümer nehmen. Wenn Ihre Charaktere genügend Kraft besitzen, können Sie ganze Städte entvölkern. Das bringt Ihnen neben großem Geldreichtum noch eine Menge Erfahrungspunkte.

Wenn Sie die Schatztruhen öffnen, sollten Sie das unbedingt mit dem dafür vorgesehenen Klerikerspruch B (Appar unem) tun. So vermeiden Sie hinterlistige Fallen, die an den Truhen befestigt sein können. In den Höhlen ist außerdem eine Unmenge Gold zu finden. Dessen habhaft zu werden erfordert allerdings viel Geduld.

### Dawn

Dawn ist eine Stadt, in der man so ziemlich alles bekommen kann, was man sich wünscht. Dort gibt es Powders, Gems, bessere Rüstungen und bessere Waffen als in allen anderen Städten. Dawn hat die Koordinaten 8 West, 35 Süd, und erscheint nur zu Mondstellung (0/0).

### Schiffe

Um ein Schiff zu bekommen, müssen Sie erst einmal die Mannschaft des Piratenschiffs vernichtet haben. Wenn Sie beim Kampf taktisch klug vorgehen und den richtigen Weg einschlagen, werden Sie kein einziges Mal von der Kanone getroffen. Falls mal kein Schiff kommen sollte, brauchen Sie nicht gleich die Geduld zu verlieren. Manchmal kann es sehr lange dauern, bis sich eines zeigt.

Wenn Sie Ihr Boot abstellen, sollten Sie übrigens darauf achten, daß es an einer Stelle steht, an die der Strudel nicht so schnell herankommen kann. Abgestellte Schiffe können vom Strudel zerstört werden. Wenn Sie sich gerade dann auf einer Insel befinden, auf der es keine Mondtore gibt, haben Sie eben Pech gehabt.

### Dungeons

Unter Dungeon versteht man unterirdische Höhlensysteme. Die Etage, in der sie sich befinden, wird dabei als Dungeon-Level bezeichnet, was aber nichts mit dem Level zu tun hat, in dem sich Ihre Charaktere jeweils befinden.

Bevor Sie die Höhlen erforschen, sollten Sie sich ein paar Gems (Juwelen) besorgen. Davon brauchen Sie mindestens acht Stück; bekommen kann man sie in den Städten Dawn, Devil Guard oder Grey. Mit Hilfe von Gems lassen sich die einzelnen Dungeon-Levels kartographieren. Außerdem benötigen Sie Fackeln, die es in den oben genannten Städten zu kaufen gibt, in denen es auch Gems gibt.

### Marks

Insgesamt gibt es vier Marks, die sich in Dungeons zumeist im 8. Level befinden. Jeder der Spieler muß jede der Marks besitzen. Das betrifft auch die Toten, also müssen Verstorbene vor dem Suchen nach Marks wieder zum Leben erweckt werden. Das kostet zwar viel Geld, ist aber unbedingt notwendig.

* Mark of Force: Diese ist in der Höhle des Feuers im achten Level zu finden. Die Koordinaten sind 19 Süd, 3 Ost, 1 Nord, 1 Ost, 2 Nord. Mit Hilfe der Mark of Force kann man unbeschadet durch Kraftfelder gehen.
* Mark of Fire: Sie befindet sich in der Höhle im Nordwesten, ebenfalls im 8. Level. Die Koordinaten sind 2 Süd, 12 Ost, 1 West, 2 Nord. Die Mark of Fire ermöglicht es, ungehindert Lava zu durchqueren.
* Mark of Kings: Die Mark of Kings ist im selben Dungeon wie die Markof Fire, aberschon im 1. Level. Mitihrer Hilfe kann man ein bestimmtes Schloß betreten.
* Mark of Snake: Sie ist auf einer Insel zu finden, die man sowohl per Schiff, als auch auf schnellerem Weg durch ein Mondtor erreichen kann. Die Koordinaten des Mondtores sind 6 West, 41 Süd, 3 West, 1 Nord. Das Tor erscheint zu Mondstellung (3/1). Verlassen kann man die Insel bei (1/3). Über diese Markjedoch später mehr.

### Ambrosia

In dieses »längst vergessene Land« gelangen Sie, indem Sie mit dem Schiff in den Strudel fahren. Sie werden dabei nur sterben, wenn nichtjeder der 4 Charaktere alle Marks besitzt. Ziehen Sie also nicht die Disk heraus, auch wenn es so aussieht, als ob Sie sterben würden.

Kartographieren Sie das Land mit der Hilfe eines Gems, da man sehr leicht die Übersicht verlieren kann. Ambrosia ist schließlich ein ziemlich dunkles Land, Sie sehen dort fast nichts.

An den vier »Shrines« (Altäre) die dort zu finden sind, kann man die Persönlichkeitsattribute derCharaktere (Intelligence, Magic Points etc.) erheblich verbessern. Dafür müssen Sie allerdings tief in die Tasche greifen.

Wenn Sie die Insel verlassen wollen, finden Sie im Südwesten ein Schiff.

### Cards

Geben Sie auf jedem der Altäre in Ambrosia »Other Cmd: Search« ein. Sie erhalten dann insgesamt vier Karten, die Sie zur Lösung des Abenteuers unbedingt benötigen.

### Wachen

Wachen lassen sich nicht nur verlangsamen (Powders), sondern auch bestechen. Das geht mit »Other Cmd: Bribe« oder »Other Cmd: Suite«. Sie werden dabei lediglich 100 Goldstücke los.

### Exotics

Exotic-Rüstungen und Exotic-Waffen benötigt man unbe-dingtfür den Kampf im Schloß des bösen Exodus. Vergessen Sie nicht, die Exotic-Rüstungen vor dem Betreten des Schloßes anzulegen und sich mit den Exotic-Waffen auszurüsten.

Exotics können Sie auf kleinen Inseln finden, auf den Sie »Other Cmd: Dig« eingeben müssen. Denken Sie daran, daß jeder der 4 Charaktere Exotics braucht.

### Silversnake

Am Eingang der Insel, auf der das Schloß von Exodus steht, befindet sich eine Schlange; sie bewacht den Eingang. Um an ihr vorbeizukommen, müssen Sie die Mark of Snake besitzen. Stellen Sie sich mit Ihrem Schiff direkt unter die Schlange und geben jetzt »Yell evocare« ein. Um aus der Bucht wieder herauszukommen, müssen Sie genau das gleiche tun.

### Das SchloB des bösen Exodus

Für den gefährlichen Weg durch das Schloß sollten Sie sich erst Pferde besorgen. Wenn Sie auf Exodus’ Insel sind und noch kein Pferd haben, verlassen Sie die Insel durch das Mondtor unten rechts. So auf das Festland gelangt, können Sie sich jetzt Pferde kaufen und durch Mondtore wieder die Insel betreten.

Mit dem Pferd haben Sie den Vorteil, daß Sie sich doppelt so schnell bewegen können wie ein Fußgänger, und deswegen einigen Kämpfen entgehen.

Wenn Sie das Schloß betreten haben, halten Sie sich links. Da Ihnen nun einiges entgegenkommt, finden die Powders jetzt gezielte Verwendung. Folgen Sie dem langen Gang bis ganz nach oben, dann biegen Sie rechts ein. In der Mitte des Schloßes gehen Sie wieder nach oben. Nach vier Kämpfen gegen den Fußboden (Sie haben richtig gelesen, der Fußboden greift Sie an) stehen Sie vor Exodus.

### Die Vernichtung von Exodus

Treten Sie an den ersten Slot von links. Dort muß die »Card of Love« eingesteckt werden. Tun Sie das mit dem Befehl »Other Cmd: Insert«, nach der Eingabe der Richtung und »L« für Card of Love. Vor dem zweiten Schlitz tun Sie das gleiche, diesmal allerdings mit einem »S« für Card of Sol. In den dritten Kartenschlitz stecken Sie die Card of Moon (»M«). Zum krönenden Abschluß des ganzen Abenteuers können Sie jetzt siegessicher Exodus’ Tod belächeln: Schieben Sie ihm mit einem hämischen Grinsen die Card of Death (»D«) in den vierten Schlitz.

(Holger Ocken/M. Kohlen/rg)

# Mask of the Sun \[122]

Sie sollen die Sonnenmaske der Azteken finden. Behindert werden Sievon Ihrem Rivalen »Roboff«, einem Leoparden und anderen Schwierigkeiten.

Für alle, die bis jetzt am Spiel verzweifelt sind, hier der Lösungsweg.

### Diskette Seite A:

Leave plane, get all, in jeep, NW, W, SE, put gun, put match, putamulet, putmap, putknife, outjeep, gethead, puthead on statue, in jeep, getfood, getamulet, get lamp, get match, S, E, out jeep, in hut, give food, out hut, in jeep, W, W, W, NW, F.

### Diskette Seite B:

W, out jeep, down vine, light match, light lamp, F, F.

An dieser Stelle den Spielstand durch Eingabe von SAVE GAME unter einem beliebigen Namen abspeichern!

SW, jetzt den Lavafluß überqueren, wenn dies beim erstenmal nicht gelingt, den abgespeicherten Spielstand mit RESTORE GAME und Angabe des Filenamens wieder einladen und nochmal versuchen.

Wenn man drüber ist, weiter mit FORWARD, auf die Fragen der Gesichter mit dem Wort XOTZIL antworten.

Weiter mit: F, F, F, put amulet in hole, get mask, search altar, get mask, return, wear mask, go door, F

Auf die Frage der Sonne antwortet man: A coffin

Jetztkommtderlrrgarten, gehen SieR, L, F, L, R, R, go door

Von hier ab müssen Sie den Irrgarten solange durchsuchen, bis Sie in einem Raum auf einen Ganoven stoßen, der von Ihnen mit vorgehaltenem Revolver die Maske der Sonne verlangt.

Leider kann ich dorthin keine genaue Wegbeschreibung mehr liefern, da es mir nur einmal gelungen ist, dorthin zu gelangen, aber eine bißchen Suchen machtja auch Spaß.

Geben Sie dem Mann die Maske durch: GIVE MASK

Wenn der Leopard sich Ihnen zuwendet weiter mit: PLAY FLUTE

Herzlichen Glückwunsch, YOU HAVE WON THE GAME!!!

(Frank Schneider/rg)

# Critical Mass \[122]

In fünf großen Städten hat ein Größenwahnsinniger, der die Weltherrschaft übernehmen möchte, Zeitbomben versteckt. In einem Wettlauf gegen die Zeit haben Sie als Agent die Aufgabe, alle Bomben zu finden und zu entschärfen.

Sollte Ihnen dies bisher nicht gelungen sein, wird Ihnen unsere Lösung bestimmt weiterhelfen.

Vorbemerkung: Da dieses Programm mit einer laufenden Uhr arbeitet, darf die Eingabe der einzelnen Befehle nicht zu langsam erfolgen.

Get envelope, open envelope, read sign, get flowers, W, push button, D, jump (erst mit RETURN abschließen, wenn Sie den 4. Stock erreichen), W, go zoo, N, W, buy peanuts, E, feed peanuts, E, get bomb, throw bomb, E, read sign, get paper, use broom, read paper, W, W, S, S, go un, E, go alley, get bottle, S, E, read sign, W, (falls nötig RETURN drücken, bis die Uhr 10:00 anzeigt), go deli, buy chicken soup, W, W, go airport, go london, E, S, buy newspaper, read newspaper, N, go telex, kicktelex, leave telex, getinstrument, E, give flower, W, W, W, go bridge, N, say lithium, S, W, go airport, go rome, S, go ruins, E, N, look door, read note, E, E, getflashlight, W, W, S, E, go airport, go paris, S, go laundry, go laundry, ring bell, give receipt, W, S, W, S, E, E, S, S, E, get key, W, N, N, W, W, N, N, eat soup, E, S, S, go airport, go new york, go miami, E, go beach, N, N, read sign, S, S, S, S, read sign, save game (1), call gid-get, (falls Sie kein TOWEL gewonnen haben, RESTORE (1), sonstweiter), N, N, W, goairport, gosanjuan, W, godocks, get gas, clean deck, W, push button, S, 8x E, go house, knock door, major, clue, stuportino, N, W, W, S, push button, 14x S, 6x E, N, W, E, E, N, N, E, N, N, look corner, saysneezer, N, U, U, S, duck (sofort!), S, insert key, N, D, N, N, save game (2), (Raketen mit IJKM & SPACE abschießen; falls es nicht klappt, RESTORE (2) eingeben.)

(Thomas R.A. Wolf/rg)

# Voodoo Castle \[122]

Voodoo Castle von Scott Adams ist schon ein relativ betagtes Adventure, das den Spieler aber vor eine Vielzahl von Problemen stellt.

Ein Problem sind die vielen unnützen Dinge, die überall herumliegen. Man versucht soviel wie möglich mitzuschleppen und läßt dabei wichtige Sachen liegen.

Die folgende Anleitung führt zur vollständigen Lösung des Adventures. Richtungen wie North, West, etc. sind in der Anleitung ausgeschrieben, können beim Eintippen aber mit dem Anfangsbuchstaben abgekürzt werden.

Für die, die das Adventure lieber selber lösen wollen, aber irgendwo steckengeblieben sind, noch drei kleine Hinweise:

* Die Plakette können Sie nur in dem Loch unter dem Kessel lesen. Zum Lesen benötigen Sie die Glasscherben.
* Die Tierköpfe kann man mit »pull heads« von der Wand nehmen, wenn man das Schwert dabei hat.
* In Medium Maegen’s Mad Room können Sie das Medium erscheinen lassen (say medium). Es gibt Ihnen einen kostbaren Hinweis, den Sie nur richtig deuten müssen. Beachten Sie vor allem das Wort zwischen den Gedankenstrichen.

Für die Ungeduldigen jetzt die genaue Anleitung:

open coffin, get ring, east, wave ring, go chute, get plaque, go hole, examine ball, get knife, west, drop knife, south, get glass, west, south, east, get sword, get shield, west, north, east, north, west, gofireplace, getidol, clean idol, south, east, south, east, move kettle, go hole, read plaque, get foot, drop plaque, drop glass, up, north, pull heads, turn 38, turn 33, get hammer, drop heads, drop sword, east, east, get chems, west, mixchems, drinkchems, west, south, west, west, south, go door, get saw, exam graves, get clover, east, north, east, north, drop foot (daraufhin kommt die Frage des Computers: »ON WHAT?« Tippen Sie ein: on man), north, go window, get doll, south, south, drop doll, south, climb stairs, get statue, down, north, west, go fireplace, open flue, go flue, pull nails, drop nails, get boards, drop boards, saw grating, drop grating, press button, push sweep, read paper (diese Eingabe dient nur zum Verständnis des folgenden und kann, wie alle »Read...«-Eingaben, weggelassen werden), drop paper, down, down, south, east, south, east, north, east, east, drop statue, sayzap, getbag, west, dropshield, getbook, getstick, read book, west, south, west, north, drop ring, drop hammer, east, go chute, wave bag, go crack, get page, south, read pa-ge, go hole, examine ball, west, get knife, get doll, circle coffin, wave stick, yell chant —

Jetzt haben Sie es tatsächlich geschafft. Wenn Sie sich die Beschreibung der Kapelle genau ansehen, werden Sie lesen, daß ein lächelnder Graf Christo im Raum steht. Das ist aber auch alles. Ansonsten steht da nur das wohlbekannte »ADVENTURE OVER! HIT -Y«.

(Stephan Keller/rg)

# Pirate Adventure \[123]

> Hier ist die Lösung des »Pirate Adventure« von Scott Adams.

Das Pirate Adventure ist mit seinen zirka 20 Räumen ein relativ »kleines« Adventure. In der Lösungsanleitung sind die Richtungsbefehle (North, East, etc.) ausgeschrieben. Bei der Eingabe können sie jedoch abgekürzt werden. Das Programm sagt dem Spieler meist nicht, wo man sich gerade befindet. Wer sich also die Gegend anschauen will, muß erst »look« eingeben.

Hinter »say yoho« ist der Zielort in Klammern angegeben. Die Anweisung muß so oft wiederholt werden, bis man sich am angegebenen Ort befindet. Nun die Schritt-für-Schritt-Lösung:

get rum, get sack, climb stairs, get book, read book, go passage, east, get torch, get bag, say yoho (sandy beach), open bag, drop bag, get matches, east, go shack, give rum, get chest (wenn der Pirat sie nicht hergeben will, dann versuchen Sie es noch einmal), get parrot, west, west, drop chest, drop crackers, drop parrot, drop book, east, east, go path, go crack, light torch, go shed, get hammer, get wings, north, go crack, unlight torch, down, west, west, drop wings, get book, drop torch, drop matches, say yoho (outside building), climb window, down, pull nails, get nails, get rug, drop rug, get keys, climb stairs, go passage, east, get bottle, say yoho (sandy beach), drop keys, drop hammer, drop nails, get wings, go lagoon, north, get water, get fish, south, west, drop wings, drop book, get torch, get matches, get keys, east, east, go cave, light torch, down, give fish, unlock door, go hall, east, get sails, get lumber, drop bottle, go shed, get shovel, north, west, go pit, up, west, drop torch, drop matches, west, west, drop sails, drop lumber, get wings, go lagoon, dig anchor (solange bis die Meldung OK kommt, bei »I don’t find anything« die Eingabe wiederholen), get anchor, west, unlock chest, exam chest, get plans, build ship, drop plans, exam chest, get map, drop keys, drop wings, get book, say yoho (outside building), climb window, go passage, east, wake pirate, say yoho (sandy beach), drop book, get crackers, get parrot, go ship, set sails, (wenn der Pirat Einwände wegen der Gezeiten macht, dann wiederholen Sie den Befehl, bis er ablegt) go shore, dig, get bottle, south, east, go monastery, drop parrot, get dubleons, read map, west, go 30, dig, get box, west, north, giverum, south, wakepirate, north, goship, setsails, go shore, get hammer, open box, drop box, drop hammer, get stamp, get book, say yoho (outside building) climb window, down, drop stamps, drop dubleons, score

Wer jetzt glaubt, von Scott Adams zu hören, daß man ein guter Abenteurer sei, wird enttäuscht. Man muß schon sehr genau hinsehen, um die zwei Worte »YOU WON!« zu entdecken. Alles was bleibt, ist die Befriedigung ein Adventure gelöst zu haben. Die hält mindestens bis zum nächsten frustrierten Enttäuschungsschrei vor dem Computer an.

(Stephan Keller/rg)

# Gruds in Space \[123]

> Die Schritt-für-Schritt-Lösung, Lagepläne, eine Hilfsliste und die benötigten Koordinaten werden Sie der Lösung von »Gruds in Space« näherbringen.

Das Ziel des Spiels »Gruds in Space« ist es, den Treibstoff »Heliotropanite« zu finden und zu einem gestrandeten Schiff auf dem Pluto zu bringen. Dazu muß man jedoch vorher umfangreiche Aufgaben und Probleme bewältigen, die einen oft zurVerzweiflung bringen können. Die Handlung spieltaufver-schiedenen Planeten und Raumschiffen, so daß man nicht darum herumkommt, Lagepläne anzufertigen, da das Spiel über 100 verschiedene Stationen besitzt (übrigensjede mit Grafik).

Nun zur Lösung.

Ich habe meine Lösung in vier Teile aufgegliedert:

* für die Verzweifelten: Eine Schritt-für-Schritt-Lösung, die die Eingaben der Reihe nach auflistet.
* eine Liste, die für den anspruchsvolleren Abenteurer ge-eignetist, dernichtweiterkommt, abertrotzdemnichtdie fertige Lösung präsentiert haben möchte. Sie gibt nur an, welche Schritte zu unternehmen sind.
* für die Könner, diefaulsind, Pläneanzulegen, aberauch für die Anfänger ist der dritte Teil sehr wichtig: die Lagepläne. Sie geben die örtlichen Verhältnisse auf den verschiedenen Planeten beziehungsweise in den Raumschiffen wieder.
* dann schließlich eine Übersicht über die verschiedenen Koordinaten, die benutzt werden müssen, um bestimmte Orte anzufliegen und um zu teleportieren.

Zu den Plänen ist noch zu sagen, daß sie vielleicht an manchen Stellen etwas unübersichtlich erscheinen könnten, da das Spiel oft auch in der Vertikalen verläuft, was nur sehr schwer grafisch dargestellt werden kann. Ich habe mich für folgendes System entschieden:

Die Stellen, an denen nach oben oder unten gegangen wird, sind auf den Plänen durch gestrichelte Pfeile dargestellt, bei denen die Richtungen (U/D) angegeben sind.

Der Plan des außerirdischen Raumschiffes hat noch eine Besonderheit an sich: Die Übergänge zu anderen Räumen bestehen oft aus Türen, die nur durch das Einfügen einer bestimmten Kugel in einen Rahmen an der Tür geöffnet werden können. Solche Übergänge sind durch dickere, gestrichelte Trennwände gekennzeichnet. Ferner ist in jedem Raum aufgeführt, welche Rahmen (...sq.) beziehungsweise Kugeln (...orb) sich in diesem befinden.

Einige allgemeine Tips:

Vor allem nicht verzweifeln, wenn es mal nicht so recht klappt. Es ist ratsam, das Spiel zwischendurch öfter mal auf einer leeren Diskette abzuspeichern, da der Tod des Spielers möglich ist.

Auch bei diesem Adventure heißt das Motto: Es darf gelaufen (geflogen) werden. Also keine Mühen scheuen.

Ein Wort zum Schluß:

Die Lösungswege von Hilfsliste und Schritt-für-Schritt-Lösung stimmen nicht völlig überein, sind aber beide möglich. Man hat also zwei verschiedene Lösungswege zur Auswahl.

(Joachim Conrads/rg)

TODO ASIDE

## Die Hilfsliste

Diese Hilfsliste gibt Hinweise auf die einzelnen Schritte, die zu unternehmen sind. Ausführung und Lösung einiger Probleme bleiben dadurch dem Spieler noch erhalten, so daß der Reiz des Adventures nicht vollständig zerstört wird.

* Empfangen eines Funkspruchs
* Flug zum Saturn
* Seil und Münze suchen und nehmen
* »Lord Deebo« aufsuchen (Tip: Butler < = > Trinkgeld)
* Flug zur Venus
* Pistole suchen
* Mr. Green aufsuchen (Tip: eine Station vorher »HELP«)
* »Note« übergeben
* Flug zum Saturn
* Von Mr. Green erhaltenen Gegenstand bei Deebo abgeben
* In den Höhlen den versteckten Schlüssel suchen
* Den zweiten versteckten Schlüssel suchen (Tip: BAT)
* »Gate« öffnen und Tempel aufsuchen
* Grüne Kugel nehmen
* In den Höhlen blaue Kugel suchen (Tip: Square)
* Flug zur Venus, ins außerirdische Raumschiff teleportieren
* Durch geschicktes Vorgehen (Türen, Squares, Orbs) schwarze Kugel finden (Lageplan; dieser Teil ist sehr schwierig)
* Flug zum Saturn
* »Hill« aufsuchen und den Arier verjagen
* Höhle des Ariers betreten (Tip: Black Orb)
* Höhle verlassen und nochmals betreten
* Lord Deebo
* Flug zur Venus
* Mr. Green aufsuchen (Tip: Trees, Gun)
* Mit »Card« die Wohnung betreten
* Flug zum Saturn
* »Supply Building« aufsuchen, einen Gegenstand (Tip: der in den Höhlen zum Einsatz kommt) fallen lassen und dafür »02-Mask« kaufen (Container können nützlich sein)
* Cafeteria aufsuchen
* Tischbein nehmen
* »Arier Cave« aufsuchen (Tip: erinnern Sie sich an den Felsen nördlich der Höhle)
* Heliotropanite nehmen
* Flug zur Venus
* Mr. Green wiederbeleben
* Flug zum Titan
* Gegenstände nehmen
* Funkspruch
* Flug zum Pluto
* Sprengen des feindlichen Schiffes
* Teleportieren zum Pluto
* Aufsuchen des Schiffes
* Übergeben des Helitropanite
* Funkspruch
* Flug zur Erde
* Teleportieren
* »HELP« eingeben
* SPIELENDE


TODO ASIDE

## Schritt-für-Schritt-Lösung

w, s, pressgreen, pressgreen, pressgreen, n, d, d, w, set 64-18-52, w, set 77-34-40, go window, n, n, n, n, steal rope, s, w, take coin, e, s, e, s, s, e, knock, say yes, give coin, e, give rope, say yes, e, help, ta-ke all, w, w, w, n, w, s, go window, e, set 96-17-14, w, set 82-13-64, go window, e, tie rope to tree, e, d, take gun, u, w, loosen rope, take rope, n, e, n, shoot venusian, n, drop gun, w, give note, take money maker, e, takegun, s, shootvenusian, s, w, s, w, gowindow, e, set 64-18-52, w, set 77-34-40, gowindow, n, e, s, e, knock, e, e, givemoneymaker, take rock, w, w, w, n, w, s, w, n, w, w, s, s, w, tie rope to stalagmite, d, n, e, s, d, n, w, take key, e, s, u, n, w, s, u, e, u, e, n, shoot bat, u, open chest, d, drop key, u, look chest, take key, d, s, u, n, e, s, e, e, n, n, e, s, e, n, n, n, w, n, open gate, n, n, n, w, n, n, take green, s, s, e, s, s, s, s, e, s, s, s, w, n, w, s, w, n, w, w, s, s, u, n, w, drop green, take all, e, s, d, n, n, e, e, s, e, go window, e, set 96-17-14, w, set 66-12-15, go window, e, n, drop green, take green, w, drop key, take orange, drop green, take green, e, s, w, drop light, e, drop green, take green, e, e, drop orange, take orange, e, take purple, drop blue, take blue, w, w, drop purple, take purple, w, w, w, drop purple, take purple, w, drop gun, take white, drop orange, take gun, e, e, drop gun, drop rock, e, drop green, take green, e, e, s, drop white, take white, w, take yellow, drop purple, take purple, e, n, w, drop purple, take purple, w, w, w, drop purple, take purple, w, take orange, s, drop white, take white, e, e, drop yellow, take brown, e, e, drop purple, take purple, e, n, n, drop brown, e, take black, drop white, w, s, w, drop purple, w, w, drop all, take rock, take light, take gun, take black, go window, e, set 64-18-52, w, set 77-34-40, gowindow, n, e, s, e, n, n, n, w, n, n, n, n, e, s, e, shootarler, u, e, drop black, e, look screen, w, e, take note, w, d, w, n, w, s, s, s, s, e, s, s, s, knock, e, e, give note, take card, w, w, w, n, w, s, go window, e, set 96-17-14, w, set 82-13-64, go window, e, n, e, n, shoot tree, drop gun, n, w, insert card, press blue, e, s, s, w, s, w, go window, e, set 64-18-52, w, set 77-34-40, go window, n, n, e, e, drop light, look sign, buy mask, take mask, take coin, buy container, take container, w, w, s, s, go window, e, set 96-17-14, w, set 82-13-64, gowindow, e, n, e, n, n, w, insert card, revive green, press blue, e, s, s, w, s, w, go window, e, set 70-10-24, w, set 14-93-96, go window, n ,w, drop card, drop note, take bomb, e, s, e, take box, w, go window, e, look box, set 64-18-52, w, set 77-34-40, gowindow, n, w, breaktable, take leg, e, e, s, e, n, n, n, w, n, n, n, n, e, s, e, u, n, lift rock, look hole, take heliotropanite, s, d, w, n, w, s, s, s, s, e, s, s, s, w, n, w, s, go window, e, e, u, u, s, press green, n, d, d, w, set 18-98-32, w, set 34-76-21, set 36-24-35, go window, drop bomb, go window, press red, set 34-76-21, go window, e, u, pull lever, n, give container, s, d, w, go window, e, e, u, u, s, press green, n ,d, d, w, set 53-42-75, w, set 66-43-44, go window, help

# Die Lösung von Hobbit \[126]

> Lange haben die Abenteuerspielfreunde auf die Lösung von Hobbit warten müssen. Einen der möglichen Lösungswege, der sogar ein Ergebnis von 101,5 % zuläßt, wollen wir Ihnen hier vorstellen.

The Hobbit ist ein Grafikadventure bei dem es darauf ankommt einen Schatz zu finden.

Eine Standard-Lösung dazu ist nicht möglich, da sich durch umherirrende Gestatten ständig neue Spieteituationen ergeben.

### Befehlsliste:

Die in Klammem angegebenen Hinweise brauchen nicht mit eingegeben zu werden. Richtungsangaben, wie zum Beispiel »East«, können durch die Anfangsbuchstaben abgekürzt werden.
START
OPEN DOOR, EAST, NORTH, NORTH, WAIT (bis »DAY DAWNS«), SOUTH, GET KEY, NORTH, UNLOCK, OPEN, GO DOOR (Rocky door), GET ROPE, GET SWORD, SOUTH, SOUTH, SOUTHEAST, TALK, SAY ELROND »READ MAP« (bis ersie liest), EAST, NORTH, NORTHEAST, NORTH, SOUTHEAST, DOWN, DOWN, DOWN, DOWN, EAST, GET KEY, UP, NORTH, WEST, SOUTH, EAST,
NORTH, (nun warten Sie, bis ein Goblin Sie gefangen nimmt, achten Sie aber darauf, daß Gandatt oder Thorin bei ihnen sind), DIG SAND (in »Goblins dungeon«), BREAK TRAP WITH SWORD, GET KEY, SAY THORIN »CARRY, ME« (oder zu Gandatt), SAY THORIN »OPEN WINDOW«, SAY THORIN »GO WINDOW«, SOUTHWEST, (als nächstes müssen Sie in dem Verlies der Goblins einen Ring suchen, der von Gollum bewacht wird. Haben Sie diesen, begeben sie sich zum Ausgang »GOBUNS BACKDOOR«), EAST, EAST, OPEN CURTAIN, OPEN CUPBOARD, GET, NORTHEAST EAST, EAST, WEST, WEST WATT (bis »Wooden Ett« kommt und Sie in einem roten Kerker einsperrt) (Sie befinden sich nun im Kerker), WAIT (bis »SOMEONE OPEN RED DOOR«), GO DOOR, NORTH, WAIT, SOUTH, (diese »NORTH-WAIT-
SOUTH«-Kombination so lange bis »BUTLER DRINK SOME WINE«, dann weiter bis »BUTLER OPEN TRAP DOOR«, wenn »BUTLER THROWS BARREL THROUGH TRAP DOOR«, »JUMP BARREL« eingeben), EAST SAY BARD »CAREFULLY, GO NORTH«, NORTH, NORTH, WAIT (bis »RED DRAGON« erscheint), SAY BARD »SHOOT DRAGON«, UP, NORTH, NORTH, NORTH, GETTREASURE, SOUTH, SOUTH, SOUTH, DOWN, SOUTH, SOUTH, (am »WATERFALL« warten Sie bis Wooden-Ett kommt) so kommt man in das Ettenverlies), WAIT (auf »SOMEONE OPEN RED DOOR«), GO DOOR, NORTH, WAIT, WEAR RING, READ MAGIC DOOR, LOOK DOOR, WAIT (irgendwann öffnet sich das magische Tor), WEST, (ein Spinnennetz behindert nun den Weg, dieses Hindemis kann durch Eingabe von SMASH WEB beseitigt werden), (nun versuchen Sie an Hand der Lagekarte zum LONELAND zurückzukehren), GO DOOR, OPEN CHEST, PUT TREASURE.
ENDE

Mit Hitte dieser Lösung sollte es möglich sein mindestens 85% des Adventures zu lösen. VVenn man alle Räume durchtaufen hat, sind sogar 101,5% drin. Übrigens der Punktestand kann mit »SCORE« abgefragt werden.

Und nun viel Erfolg!

(Roland Selzer/rg)

# Enchanter ist jetzt gelöst! \[126]

TODO BILD 2

SE, SE, NE, S, READ SCROLL, GNUSTO REZROV, LEARN REZROV, SW, NW, NW, NE, N ,OPEN OVEN, GET BREAD, GET JUG, S, NE ,SE, NE, FILL JUG, SW, SE, E, E, REZROV GATE, E, FROTZ BOOK, N, N, E, E, E, E, E, LEARN REZROV, REZROV GATE, N, (GET SCROLL, READ IT), GNUSTO KREBF, E, LOOK UNDER LILY PAD, READ SCROLL, GNUSTO CLEESH, W, S, W, W, W, W, W, S, S, S, S, E, D, OPEN DOOR, N, PULL BLOCK, E, (GET SCROLL, READ IT), GNUSTO EXEX, W, S, U, DROP BOOK, E, GET LIGHTED PORTRAIT, GET SCROLL, W, GET BOOK, READ SCROLL, GNUSTO OZMOO, EAT BREAD, N, GET BOX, S, W, U, GET IN BED, SLEEP, GET UP, EXAMINE BEDPOST, PUSH BUTTON, (GET SCROLL, READ IT), GNUSTO VAXUM, D, N, N, N, N, U, GET EGG, LEARN REZROV, LEARN KREBF, REZROV EGG, GET SCROLL, KREBF SCROLL, READ SCROLL, GNUSTO ZIFMIA, D, S, S, S, S, E, E, E, S, LEARN NITFOL, LEARN EXEX, EXEX TURTLE, NITFOL TURTLE, (TURTLE, FOLLOW ME), NW, N, E, U, (TURTLE, SE GET SCROLL, NW, DROPSCROLL, (TURTLE, THANKS), GETSCROLL, D, W, W, W, N, N, E, LEARN OZMOO, OZMOO ME, DROP ALL, E, WAIT, D, W, GET ALL, CUT ROPE, OPEN BOX, GET VELLUM SCROLL, READ VELLUM SCROLL, GNUSTO MELBOR, DROP BOX, LEARN MELBOR, MELBOR ME, E, E, E, N, EXAMINE TRACKS, READ FRAYED SCROLL, GNUSTO GONDAR, N, SLEEP, LEARN ZIFMIA, LEARN VAXUM, (JETZT IN DEN SPIEGELSÄLEN AUF UND AB GEHEN BIS DER ADVENTURER ERSCHEINT, DANN...), ZIFMIA ADVENTURER, VAXUM ADVENTURER, (JETZT NACH OSTEN BIS ZUR GUARDED DOOR), POINT AT DOOR, LEARN CLEESH, CLEESH ADVENTURER, N, DROP DAGGER, GET PENCIL, GET PURPLE SCROLL, S, W, W, W, W, W, W, S, S, S, S, E, D, D, READ MAP, D, S, E, NE, SE, LEARN MELBOR, MELBOR ME, DRAW FROM F TO P, SW, SW, RUB FROM V TO M, RUB FROM B TO R, DRAW FROM J TO B, DROP PENCIL, DROP MAP, GET SCROLL, NE, NW, NW, W, DRINK WATER, DROP JUG, U, U, E, E, E, W, N, N, LEARN MELBOR, MELBOR ME, N, E, LEARN GONDAR, LEARN CLEESH, DROP BREAD, DROP, PURPLE SCROLL, E, KUL-CAD STAIR, IZYUK ME, E, GONDAR DRAGON, CLEESH MONSTER, GUNCHO KRILL !!!!!!

# So löse ich Abenteuerspiele \[128]

> Es gibt einige grundlegende Methoden, um an die Lösungen von Abenteuerspielen heranzugehen.

Abenteuerspiele zu lösen bereitete schon immer Schwierigkeiten, besondersjemandem, der vorher noch nie mit dieser Art von Spielen in Berührung kam. Wir helfen bei den ersten Schritten. Die Tips, die wir hier geben, gelten nur für die sogenannten Text-Adventures beziehungsweise Text/Grafik-Abenteuer. Joystick-Abenteuer beziehungsweise Rollenspiele sind in der Regel ganz anders zu spielen.

## Ein kurzes Wort zu Lösungsbüchern

Wer sich ein Abenteuerspiel gekauft hat und absolut nicht damit zurecht kommt, sollte erst einmal Freunde mitspielen lassen, bevor er zu Lösungsbüchern greift. So macht das Ganze mehr Spaß. Wer dann schließlich doch zur Hilfsliteratur greifen muß, sollte erst einmal zwischen Lösungsbüchern und sogenannten »Hint Books« unterscheiden. Hints sind nur Tips und keine festen Lösungen. Die Hersteller verschiedener Adventures bieten zu ihren Spielen des öfteren solche Lösungshinweise an, aber auch Buch- und Zeitschriftenverlage haben ihre Adventure-Hacker, die dann Lösungs- beziehungsweise Hint Books anbieten.

Telarium (vorher Trillium) legt zum Beispiel zu ihren Spielen verschlüsselte Lösungshinweise als Beigabe dazu, die man — um nicht »aus Versehen« zu schummeln — erst mit Hilfe einer Tabelle decodieren muß.

## Wie finde ich den Wortschatz heraus

Bei Infocom-Abenteuerspielen, wiezum Beispiel, Suspect, Zork III oder Deadline kann man »Hint Books« bestellen, in denen Lösungshinweise mit einer Geheimtinte abgedruckt sind. Diese werden erst nach Überstreichen mit einem mitgeliefertem Spezialfilzstift sichtbar. So ist gewährleistet, daß man immer nur die Informationen erhält, die man tatsächlich haben möchte.

Wer von der Herstellerfirma bestimmter Adventures keine Lösungshinweise erhalten kann, der sollte sich auch in deutschen und amerikanischen Zeitschriften und Büchern umsehen; dort sind öfters Lösungen und Tips zu finden.

Adventurespiele haben eines gemeinsam: Alle verstehen ihren Wortschatz mit Hilfe eines »Parsers«. Der Parser ist die Sprachinterpretationsroutine, die überprüft, wie der Satz aufgebaut ist (Unterscheidung von Verben, Substantiven und Präpositionen, die in einer einprogrammierten Wortschatzliste enthalten sein müssen).

Bei den Infocom-Adventures ist fast alles möglich — tippen Sie einfach ein, was Sie denken. Wenn Ihr benutztes Wort nicht im 800 Worte großen Wortschatz enthalten ist, probieren Sie eben ein Synonym, das geht fast immer.

Bei Abenteuerspielen von Telarium-Software und Windham Classics liegt jeweils eine Wortschatzliste bei; der Chef von Telarium ist selbst leidenschaftlicher Adventure-Spieler und haßt (nach eigenen Worten) das »Guess what word the parser wants to have«-Spielchen.

Bei anderen Adventures gilt: Grundsätzlich sollte man erst einmal alles ausprobieren und eventuell auch in einem Englisch-Wörterbuch nachsehen. Wenn das nicht mehr geht, dann kann man noch immer mit Hilfe eines guten Maschinen-sprachen-Monitors oder Disk-Doktors entsprechende Wissenslücken ausfüllen. Sehr gut geht das bei den Abenteuerspielen von Sirius-Software; andere Abenteuer sind als Schutz vor solch unfairem Verhalten manchmal sehr geschickt codiert. In diesem Fall kann Ihnen dann nur noch ein gutes Vokabel-Gedächtnis helfen.

Außerdem sollte man in der Anleitung nachsehen, ob das Spiel ganze Sätze oder nur Zweiwort- beziehungsweise Einwort-Kommandos annimmt.

## Was man beim Spielen von Adventures grundsätzlich beachten soll

Wenn man in einem Raum steht, erfährt man in vielen Adventures immer nur das, was man auf den ersten Blick sieht. Geben Sie in diesem Fall unbedingt noch den Befehl LOOK ein. Erst dann erfahren Sie, was bei genauerem Hinsehen zu entdecken ist. Gegenstände, die herumliegen, oder irgendwelche Öffnungen, Türen oder Spalten sollten Sie immer genauer untersuchen. Das geht meistens mit Hilfe der Befehle EXAMINEOBJECTbeziehungsweise INSPECT OBJECT. Um etwas zu durchsuchen, sollte man SEARCH IN »Gegenstand« oder SEARCH AT »Gegenstand« oder auch nur (je nach Parser des Spiels) SEARCH »Gegenstand« eintippen.

Bei einigen Abenteuern erlaubt die Zeit oft nicht, alle vorhandenen Dinge zu untersuchen. Tun Sie das trotzdem. Im Lauf der Zeit werden Sie erfahren, welche Gegenstände unnütz sind und welche Sie gebrauchen können. Sie können nach Ablauf der Zeit noch immer neu starten und dieses Mal das Untersuchen auslassen — Sie wissen ja schon vom vorherigen Durchlauf, wie die Gegenstände aussehen und was sich dahinter verbirgt.

Nehmen Sie immer nur das mit, von dem Sie glauben, daß Sie es brauchen. Wenn Sie später einen Gegenstand brauchen, den Sie vorher nicht mitgenommen haben, und sich eventuell nicht mehr daran erinnern können, ist das natürlich nicht besonders vorteilhaft. Sie sollten sich deshalb alle Gegenstände, die Sie irgendwo sehen, aufschreiben. Auch in den Umgebungsbeschreibungen sind oft nützliche Hinweise versteckt. Wenn Sie meinen, daß das der Fall ist: Auch aufschreiben.

Die Umgebung sollte außerdem ständig kartographiert werden; darüberjedoch später mehr.

Vor schwierigen Stellen ist es ratsam, das Spiel abzuspeichern. Die meisten Adventures benutzen dazu den Befehl SAVE oder SAVE GAME, manchmal kommt man auch mit QUIT in ein Menü, von dem aus man sein Spiel abspeichern kann. Auch sonst sollte man regelmäßig seinen Spielstand abspeichern (je nach Umfang und Schwierigkeitsgrad immer nach einem Fünftel bis einem Zehntel des Abenteuers). Bei extrem schweren Spielen (zum Beispiel »Sorcerer«) sollte man ständig abspeichern.

In verschiedenen Abenteuerspielen sind auch ziemlich heimtückische Fallen eingebaut. Probieren Sie also alles, was Ihnen als möglich erscheint, auch wenn es noch so unlogisch oder abnormal ist. Beispiel: lm Adventure »The Hitchhikers Guide to the Galaxy« heißt es an einer Stelle, man könne nicht zum Ausgang hinaus. Nach dem dritten Versuch zeigt sich aber, daß es doch geht: Das Spiel (beziehungsweise der Programmierer) gibt zu, daß gelogen wurde. Wenn Sie also meinen, daß Ihre Idee die einzig richtige ist, dann versuchen Sie es ruhig mehrmals.

Bei zeitabhängigen Abenteuern sollten Sie außerdem nicht immer blind lostippen, um den Computer zu veranlassen dies und jenes und sonstnochwas zu tun. Sie können ja auch mal abwarten (WAIT-Befehl), das hilft Ihnen oft sehr weiter (zum Beispiel bei Hitchhikers Guide vor dem Bulldozer).

Auch wenn das Abenteuerspiel, das Sie vielleicht gerade spielen, ganze Sätze versteht, können Sie sich durch Abkürzungen eine Menge Zeit ersparen. Tippen Sie als Abkürzungen für die Himmelsrichtungen also immer nur S, W, E, N, SW, SO, NW, NO und für aufwärts und abwärts U und D. Arbeiten Sie mit einem Ganz-Satz-Adventure genau so, als ob es einen Zweiwort-Parser hätte.

Beachten Sie, daß Gegenstände manipuliert werden können oder einen bestimmten Inhalt haben. Sie können außerdem spezielle Eigenschaften haben. Das Schwert aus Zork leuchtet zum Beispiel blau, wenn Gefahr droht, und rot, wenn der Träger des Schwertes wütend ist. Tatsachen wie diese sollte man immer ausnützen, sie helfen oft enorm bei der Lösung einiger hart zu knackender Nüsse.

Es ist sehr selten, daß es mehrere Wege gibt, ein Problem zu lösen. Wenn Sie beispielsweise einen Gegenstand an einer Stelle benutzen, an der es auch anders geht und später einen Punkt erreichen, an dem dieser Gegenstand unbedingt benötigt wird, aber schon von der vorherigen Benutzung abgenutzt, verbraucht oder kaputt ist, dann können Sie sich (im Adventure) begraben. Denken Sie also immer logisch nach, was Sie wo brauchen und wie Sie es sinnvoll einsetzen. Bei den meisten Abenteuerspielen ist ein sinnvoller Einsatz eines Gegenstandes immer nur einmal möglich (abgesehen von ständig benutzbaren Dingen wie Schlüssel oder Kerzen). Wenn nur eine bestimmte Zahl von Gegenständen zu tragen erlaubt ist, sollten Sie die schon sinnvoll genutzten Dinge wieder ablegen. Speichern Sie allerdings davor den Spielstand ab, daesinseltenen Fällen möglich sein kann, daßderGegen-stand doch noch einmal zum Einsatz kommen kann.

Die meisten Abenteuer haben übrigens ihre spezielle »Art des Hauses«. Das heißt: Je nach Herstellerfirma muß man mehr oder weniger logisch denken. Falls Sie beispielsweise mal ein Exemplar eines Adventures von Screenplay in die Hände bekommen, müssen Sie sich zu dessen Lösung in die chaotischen Gehirnwindungen eines Verrückten hineindenken und immer das Gegenteil von dem tun, was Sie eigentlich tun wollten.

Bei Adventures von tellarium kommen Sie nur weiter, wenn Sie ein Feingefühl für Eihzelsituationen besitzen.

Abenteuer von Sirius-Software sind extrem logisch aufgebaut, Infocom-Adventures dagegen bestehen aus einer idealen Mischung von Intuition und Logik (etwa 80% logische Gesichtspunkte).

Soweit einige allgemein wichtige Gesichtspunkte.

## Das Kartographieren

In jedem Abenteuer sollten Sie mitzeichnen, auch wenn Ihnen die beschriebene Umgebung noch so gut im Gedächtnis bleibt — irgendwann kommen Sieja doch durcheinander.

Es gibt verschiedene Verfahren, sich Karten und Umgebungspläne zu machen (eine ist ausführlich im Kurs für Abenteuerspiele beschrieben). Wenn Sie ein Abenteuer haben, das keine schrägen Richtungen wie Südwest oder Nordost besitzt (beispielsweise in einem Haus mit viereckigen Räumen), ist es am einfachsten und am platzsparendsten, wenn Sie sich ein kariertes Blatt Papier nehmen. Nehmen Sie einfach immer ein vier Karo großes Quadrat als Raum und setzen Sie diese Räume direkt nebeneinander. Verbindungen zwischen Räumen kann man mit einfachen Strichen zwischen den Quadraten illustrieren. Beschreibungen des Raumes sind nicht unbedingt für die Karte notwendig, wichtige Einzelheiten und vorkommende Gegenstände sollten Sie aber in die Quadrate einschreiben. Wenn in den Quadraten nicht ausreichend Platz für solch elementare Dinge ist, brauchen Sie die Räume einfach nur durchzunumerieren und sich die Gegenstände auf ein extra Blatt zu notieren.

Wenn Richtungen wie Nordost oder Südwest im Abenteuer möglich sind, sollte man zwischen den einzelnen Quadraten, die die Räume darstellen sollen, ein wenig Platz lassen, um eventuelle Schrägrichtungen oder Wegbiegungen besser eintragen zu können. Wie Sie Möbel, Fenster und Türen einzeichnen, bleibt Ihnen überlassen. Diese Art des Kartographierens ist beispielsweise in dem Markt & Technik-Buch »Im Land der Abenteuer« enthalten (Adventuretips für die gängigsten Grafikabenteuer).

Eine dritte, wenn auch anspruchsvollere Art des Kartographierens istdie Frei-Hand-Zeichnung, wie sie beispielsweise in der Lösung zu Enchanter (März-Ausgabe von 64’er) enthalten ist. Hier ist sehr viel künstlerisches Geschick notwendig. Lange Säle können hier auch wirklich lang dargestellt werden und nicht nur als Vierecke mit langen Verbindungsstrichen. Landschaften lassen sich wenn Sie wollen, dort auch auf künstlerischem Wege eintragen.

Diese Darstellungsart wird allerdings im Lauf der Zeit sehr unübersichtlich, wenn Sie keine genauen Daten über die Länge einzelner Gänge oder ähnlichem vom Adventure erhalten.

Als idealste Methode für Profi-Abenteuerer erweisen sich Mischformen der oben genannten Kartographierungsarten, wie sie auch in den Hint Books von Infocom verwendet werden.

## Happy Adventuring

Wenn Sie auch schnell an Abenteuerspielen verzweifeln mögen, üben Sie sich in Geduld. Wer keine Adventures spielt, der hat seinen naturgegebenen Forscherdrang vermutlich schon verloren.

Sterben können Sie inAdventures relativ oft (Sorcerer hat beispielsweise 70 verschiedene Todesarten), aber Leben haben Sie unendlich viele. Nutzen Sie alles hier Gesagte aus, auch wenn es noch so unwichtig oder selbstverständlich erscheint.

(M. Kohlen/rg)

# Impressum \[130]

Herausgeber: Carl-Franz von Quadt, Otmar Weber

---

**Redaktion**: Albert Absmeier, Volker Everts, Georg Klinge, Harald Meyer, Christian Rogge.
Fremdautoren:
Nickles, Lonczewski, Schmelzer, Selzer, Leggewie, Bornfleth, Schürks, Meiswinkel, Lüning, Geißelmann, lhlo, Ocken, Kohlen, Schneider, Keller, Conrads, Pither, Merbach.

---

**Layout**: Leo Eder (Ltg.)

---

**Zeichnungen**: Rene Nestler

---

**Auslandsrepräsentation**:
Schweiz: Markt & Technik Vertriebs AG, Alpenstr. 14, CH-6300 Zug, Tel. 042-22 31 55, Telex: 862329
USA:	M&T Publishing lnc.; 2464 Embarcadero Way, Palo Alto, CA 94303

---

**Vertriebsieitung**: Hans Hörl

---

**Anzeigen-Verkaufsleitung**: Ralph Peter Rauchfuss

---

**Anzeigenleitung**: Christian Schlottau

---

**Anzeigenverwaltung und Disposition**: Michaela Hörl

---

**Verlagsleiter M&T-Buchverlag**: Günther Frank

---

**Druck**: St. Otto-Verlag GmbH, 8600 Bamberg, Laubanger 23
Auch Anschrift für Beihefter und Beilagen.

---

**Preis**: Das Einzelheft kostet DM 14,—

---

**Vertrieb Handelsauflage**: Inland (Groß-, Einzel- und Bahnhofsbuchhandel) sowie Österreich und Schweiz: Pegasus Buch- und Zeitschriften-Vertriebs GmbH, Hauptstätter Straße 96, 7000 Stuttgart 1, Telefon (0711) 7 6 48 30

---

**Urheberrecht**: Alle in diesem Heft erschienenen Beiträge sind urheberrechtlich geschützt. Alle Rechte, auch Übersetzungen, vorbehalten. Reproduktionen gleich welcher Art, ob Fotokopie, Mikrofilm oder Erfas-sung in Datenverarbeitungsanlagen, nur mit schriftlicher Genehmigung des Verlages. Anfragen sind an Hans Hörl zu richten. Für die in der Übersicht gemachten Angaben können wir weder Gewähr noch irgendwelche Haftung übernehmen.

---

**© 1985 Markt & Technik Verlag Aktiengesellschaft**

---

**Verantwortlich**: Für redaktionellen Teil:
Albert Absmeier
Für Anzeigen: Christian Schlottau

---

**Vorstand**: Carl-Franz von Quadt, Otmar Weber

---

**Anschrift für Verlag, Redaktion, Vertrieb, Anzeigenverwaltung und alle Verantwortlichen:**
Markt & Technik Verlag Aktiengesellschaft, Hans-Pinsel-Straße 2,
8013 Haar bei München, Telefon (089) 4613-0, Telex 5-22052

---

Aktionäre, die mehrals 25% des Kapitals halten: Otmar Weber, Ingenieur, München; Carl-Franz von Quadt, Betriebswirt, München. Aufsichtsrat: Dr. Robert Dissmann (Vorsitzender), Karl-Heinz Fanselow, Eduard Heilmayr



















































