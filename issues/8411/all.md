
# Zuviel Programme, keine Ideen?

In Amerika stöhnen die Propheten (und vor allem die, die sich auf die Voraussagen verließen): Sie haben sich offenbar geirrt. Nach den Schätzungen von Future Computing dürften die Softwareumsätze in diesem Jahr nicht um 100 sondern »nur« um 60 Prozent wachsen. Ein anderes Marktforschungsunternehmen, Creative Strategies, schätzt bei Business Software sogar nur 40 (statt vorher über 50) Prozent — und ist bei Heimcomputer-Software noch skeptischer: Die schlechten Umsätze in diesem Sommer könnten zwar saisonbedingt sein — wahrscheinlich fehle es aber an der richtigen Art von Programmen. Ein Mitarbeiter des Verlags Prentice-Hall wurde noch deutlicher: »Es wird ein Haufen Mist angeboten« erklärte kürzlich Lynn Lumsden »Und so etwas kauft der Kunde einfach nicht mehr«. Es gebe, so meinen die Amerikaner, zu viele schlechte und unter den brauchbaren zu viele »me too«-Programme — an der xten Textverarbeitung oder der yten Dateiverwaltung bestehe kein Bedarf; sie drückten höchstens die Preise. Es fehle an guten und innovativen Produkten.

Ein kleines Beispiel dafür, daß sich der Markt anders entwickelte, als viele dachten, bietet Commodore: Mit Handbüchern wird mehr Umsatz gemacht als mit Spiel-Programmen.

Bei Heimcomputersoftware stimmt leider in vielen Fällen das Verhältnis von Nutzen und Kaufpreis nicht — zumal sich Arbeiten von Hobbyprogrammierern häufig mit dem messen können, was kommerziell vermarktet wird. Der Erfolg unseres Einzeiler-Wettbewerbs zeigt, daß es an Ideen ebensowenig mangelt, wie an der Bereitschaft, Anregungen aufzugreifen. Vielleicht sind die Anwender auf dem richtigen Weg — und nur manche Marketing-Profis auf dem Holzweg.

Michael Pauly, Chefredakteur

# Informationen zur Datenfernübertragung

> Die DFÜ steckt in Deutschland mehr oder weniger noch in den Kinderschuhen. Dennoch oder gerade deshalb halten wir Sie über die neuesten Entwicklungen auf dem laufenden.

## Vertrag zwischen IMCA und Radio Austria steht

Der Vertrag zwischen IMCA, die ein professionelles System in der Nähe von Frankfurt betreiben, und dem österreichischen Staat ist vor kurzem abgeschlossen worden. Das Endprodukt, was sich dann DADAUS-Mailbox nennt, hat dann die inzwischen allgemein üblichen Fähigkeiten: Messages schicken und empfangen, ein Schwarzes Brett, Telex-Zugang und natürlich mehrere Datex-P-Anschlüsse.

## Preiswerter Akustikkoppler für den C 64

Für den C 64 und den VC 20 wird derzeit der billigste 300 Baud-Akustikkoppler überhaupt angeboten. Dieses »Modul« wird unter Umgehung einer V.24-Schnittstelle direkt an den Userport des Rechners angesteckt und ist dann sofort betriebsbereit. Es bietet die für Akustikkoppler üblichen Fähigkeiten, wie CALL- und ANSWER-Modus, sowie eine zusätzliche Testfunktion, die ja nicht jeder Akustikkoppler besitzt. Das Gerät wird ohne jedes Gehäuse geliefert, es fehlen auch die »Gummimuffen«, das heißt Lautsprecher und Mikrofon hängen im Rohzustand von der Platine weg. Mit dem Gerät erhält man noch ein kleines Kommunikationsprogramm in Form eines Listings, mit dem die Sache einwandfrei betrieben werden kann. Der Preis ist wirklich fast schon sensationell: Für das »Modul« 138 oder das Ganze als Bausatz für 88 Mark. Zusätzlich werden noch angeboten: Ein Terminalprogramm mit Up- und Downloading inklusive Diskette für 25 Mark und ein kleines Interface, das dann die automatische Telefonwahl ermöglicht für 39 Mark. Das Gerät hat keine FTZ-Zulassung und darf nicht am Telefonnetz der Deutschen Bundespost betrieben werden. Die Adresse: Fotoelektronik Dipl.-Ing. Immo Drust, Landwehrstr. 5, 6100 Darmstadt.

Der Vertrieb läuft nur über den Versand, Bezahlung wie üblich per Nachnahme oder V-Scheck. Der Computertyp muß angegeben werden (C 64 oder VC 20). Noch ein Tip: brauchbare »Gummimuffen« erhält man in Sanitärfachgeschäften, die dort als Installationszubehör für die Toilette geführt werden.

## RMI und Software Express arbeiten zusammen

Die RMI-Nachrichten GmbH in Aachen wird für die Firma Software-Express in Duisburg und Bocholt jeweils acht Mailboxen einrichten. Auch ist der Datex-P-Antrag für einen Hauptanschluß bereits gestellt. Diese Systeme sollen dann hauptsächlich für die Produkte des Software-Express werben. Damit wäre dann langsam die Mailbox als Werbemedium interessant geworden, da man auch als »Fremdfirma« dort Platz mieten kann.

## RMI expandiert und verlangt Gebühren

Seit neuestem kann man die RMI-Mailbox in Aachen, erreichbar über Datex-P-NUA 44241040341, nur noch vernünftig nutzen, wenn man monatlich 10 Mark von seinem Konto abbuchen läßt. Dazu hat Sysop Rupert Mohr einen Verein gegründet, der sich AMDAT e.V. nennt. Zahlende Mitglieder heißen dann assoziierte Benutzer. Begründet wird die Gebühr von 10 Mark mit steigenden Kosten. So hat man dann Zugang auf das Telex-Netz und längerfristig sind mehrere Datex-P Anschlüsse geplant. Im Großen und Ganzen ist dann das RMI-Netz eine preiswerte Möglichkeit von Hobby-DFÜlern ein semiprofessionelles System zu benutzen.

## Btx und Datenschutz

Btx wird (hoffentlich) bald auch für die C 64 Anwender interessant, da das Btx-Steckmodul für den C 64 allmählich auf den Markt kommen soll. Dieses Modul soll dann für zirka 150 Mark erhältlich sein. Um letztendlich Btx-Benutzer über den C 64 zu sein, ist aber noch ein Loewe oder Blaupunkt-Fernseher mit CEPT-Dekoder notwendig. Worum es bei Btx im Groben geht dürfte inzwischen fast jedem bekannt sein: Die Anbieter bieten ihre »Seiten« an, das heißt sie stellen eine bestimmte Information, mit Grafik und Farbe versteht sich, gegen Gebühren zur Verfügung.

Diese Seiten können alles mögliche beinhalten, zum Beispiel den Wetterbericht, lokale Informationen (Veranstaltungen etc.) oder auch aktuelle Nachrichten einer Zeitungsredaktion. Der Benutzer, also der, der dann mit seinem C 64 und Btx-Fernseher daheim sitzt und gebührenpflichtige Seiten abruft, muß auch dafür zahlen. Diese Gebühren werden dann praktisch auf die normale Telefonrechnung mit aufgeschlagen. Jetzt kommt — in Bezug auf den Datenschutz — der Haken an der Sache: Wer wann welche Seiten sich wie lange angeschaut hat, muß — aus Abrechnungsgründen — erfaßt werden, ganz klar. Nun ist es aber nicht nur theoretisch möglich Persönlichkeitsprofile zu erstellen, das heißt man kann aufgrund der im Btx-Rechner gespeicherten Daten ziemlich genau feststellen, welche Vorliebe und welche Abneigungen ein bestimmter Benutzer hat. Bei der Benutzung einer »Telezeitung« etwa würde auch die Zeit abrufbar sein, die sich ein Benutzer zum Beispiel im Wirtschaftsteil aufgehalten hat, und daraus könnte man auf die Verständnisfähigkeit der Person in bestimmten Gebieten schließen. Das »Bild« oder Persönlichkeitsprofil, das so von jedem Btx-Benutzer gemacht werden kann, könnte theoretisch irgendwie ausgenutzt werden. Das alles wäre überhaupt kein Problem, wenn die Abrechnungsdaten unter Aufsicht regelmäßig gelöscht würden, und genau das wird bis jetzt — obwohl vorher vereinbart — von der Bundespost abgelehnt. Klar, daß die Datenschutzbeauftragten der Länder ihre Kritik äußern. Es bleibt nur noch die Frage nach dem Grund dieser Verweigerung.

## Elektronische Mitfahrerzentrale in Hamburg

Der Chaos Computer Club in Hamburg will seine elektronische Mitfahrerzentrale auf einen C 64 mit Floppy realisieren. Bei diesem System, dessen Benutzung absolut gebührenfrei sein soll, kann dann jeder, der eine Autofahrt plant, sich — natürlich nach Städten sortiert — unter Angabe seiner Telefonnummer und Adresse eintragen. Genauso können dann die Mitfahrer die Angebote abrufen und sich dann mit den Fahrern telefonisch in Verbindung setzen. Die Wahl eines C 64 bei diesem System macht das günstige Preis-Leistungs-Verhältnis des C 64 deutlich. Übrigens: Der Chaos Computer Club hofft noch auf Spenden, die die finzianziellen Aufwendungen etwas mildern sollen. Die Adresse: CCC c/o Schwarzmarkt Bundesstr. 9, 2000 Hamburg 13

(Thomas Obermair/aa)

## C 64 Interface für Centronics-Drucker

Rolf Rocke Computer bietet mit dem »Print 64« ein prozessorgesteuertes Drucker-Interface für Anspruchsvolle. Nachahmenswert ist ein auf der mitgelieferten Diskette befindlicher Druckerkurs, der den Umgang mit der Schnittstelle und den gängigsten Matrixdruckern wie Epson, Star oder Sekonic für den Anfänger anschaulich erläutert.

Außergewöhnlich ist auch die Möglichkeit der Darstellung von Farben (auf Schwarz-Weiß-Druckern) durch geeignete Wahl von zugeordneten Graustufen beim Druck von Mehrfarbgrafiken. Mit fünf unterschiedlichen Tönungen bleiben bei Mehrfarbbildern (die vom Koalapainter oder Paint Magic erstellt sein können) die Nuancen des Bildes in der Hardcopy erhalten. »Print 64» soll alle gängigen Textverarbeitungsprogramme für den C 64 unterstützen. Das heißt, auch Umlaute, Fettschrift oder Unterstreichen werden getreu wiedergegeben. Programmlistings werden mit allen Grafik- und Steuerzeichen in Grafik- oder Groß/Kleinschrift-Modus ausgeben. Der Ausdruck des Bildschirms ist in verschiedenen Varianten möglich. Der Textbildschirm kann in einfacher oder doppelter Dichte ausgegeben werden. Bilder in hochauflösender Grafik benötigen für die Übertragung sowohl in normaler als auch in doppelter Dichte nur zirka 70 Sekunden (FX 80). Durch die Wahl der Bildbreite über das gesamte A4-Format ergibt sich ein Verhältnis von Höhe zu Breite die auch die Darstellung von Kreisen orginalgetreu zuläßt. Die Sekundäradressen 3, 4, 6, 8 und 9 wurden für selbst zu erstellende Hardcopy-Routinen reserviert. Das Centronics-Interface mit der Diskette wird voraussichtlich 300 Mark kosten. (aa)

Info: Rolf Rocke Computer, Auestraße 1, 5090 Leverkusen 3, Tel.: 0 2171-26 24

## Deutscher Zeichensatz für 1526 und MPS 802

Das Ingenieurbüro Hollmann in Hamburg bietet für die Commodore-Drucker 1526 und MPS 802 deutsche Zeichensätze im EPROM an. Die Zeichensätze sind auf mehrere zum C 64 erhältliche professionelle Textprogramme abgestimmt.

Zur Zeit sind deutsche Zeichensätze für SM-Text und Vizawrite verfügbar. In Vorbereitung sind Zeichensätze für Vizawrite-Benutzer in der Schweiz sowie C 64-DIN-Zeichensatz und andere Spezialzeichensätze. Die Zeichensätze können direkt im Drucker betrieben werden. Allerdings ist erst durch die Verwendung einer Umschaltplatine (Multifont, vom selben Hersteller) volle Kompatibilität gewährleistet (Textverarbeitung und Basic/Grafik-Listings). Auf der Einbauplatine lassen sich bis zu vier Zeichensätze/Betriebssysteme (im EPROM) unterbringen, die von zwei außenliegenden Schaltern ausgewählt werden. Die Zeichensätze kosten jeweils 79 Mark, die Umschaltplatine 90 Mark.

# Commodore Fachausstellung

> Commodore ist wohl der einzige Computer-Hersteller der in Deutschland eine eigene Fachmesse veranstaltet. Auf der diesjährigen vierten internationalen Commodore Fachausteilung (CFA) in Frankfurt, gab es neben Altbewährtem einige Überraschungen. Software für den Plus/4, grafisch gestaltete Diskettenhüllen, Video-Digitizer, ein Joystick ohne Boden, Musikprogramme und Keyboards, Lernsoftware oder eine schnellere 1541 sind nur einige Beispiele. Doch eins war besonders klar zu erkennen: Der C 64 dominierte an allen Ecken und Enden.

Weniger die Software, sondern mehr die Datenträger erregten großes Interesse auf der CFA in Frankfurt. Bunte Disketten waren »in«, in jeder erdenklichen Farbe oder Farbkombination. Da diese Disketten auch nicht sehr viel teurer waren als normale Disketten, fanden sie natürlich reißenden Absatz. Besonders gefragt waren Memron-Disketten, die es mit allen möglichen abgebildeten Motiven gab: Weintrauben, golden mit schwarzen Streifen, bunte Schrift »Memo«, undsoweiter. Einen besonderen Leckerbissen für Händler und private Großabnehemer bietet Lucius-Computer-Programme: Bei einer Abnahme von über 1000 Stück kann man sich sein eigenes Motiv auf die Diskettenhüllen drucken lassen.

## Absteiger und Renner

Der VC 20 scheint nun endgültig auf dem absteigenden Ast zu sein. Ein Vertreter einer englischen Softwarefirma wunderte sich, warum in Deutschland überhaupt noch Software für den VC 20 angeboten wird. Selbst Commodore verzichtete darauf, irgend etwas zu zeigen, das mit dem VC 20 zu tun gehabt hätte — kein Wunder, denn der C 16 soll ja schließlich als Nachfolger für den VC 20 dessen Rolle übernehmen. Der Plus/4, jetzt mit vier fest eingebauten Programmen, war ebenfalls von Menschentrauben umlagert. Bei Commodore hieß es, man könne gegen Ende des Jahres mit der Auslieferung des C 16 und des Plus/4 rechnen.

Die größeren Commodore-Computer waren hauptsächlich mit Steuerungssoftware, Textverarbeitungs- und Anwendungsprogrammen vertreten. Besonders zu erwähnen ist die Textverarbeitung mit vollautomatischer Silbentrennung für die Commodore Serie 600/700 und 8000 von Hard + Soft in Bayreuth.

Auch der neue Commodore PC, der kompatibel zum IBM PC ist, wurde sehr intensiv auf dem Commodore-Stand vorgeführt.

Der eigentliche Favorit aber war — wie immer — der C 64.

Das Hauptangebot bei der Software bestand in Spielen, bei denen es einige Neuvorstellungen gab.

Ariola führte das Ballerspiel »River Raid« vor. Obwohl Ariolasoft gute neue Programme hat (Seven Cities of Gold, Archon II, Realm of Impossibility), konnten diese leider nicht gezeigt werden. Sie waren wohl aus Versehen von der Hifi-Video-Messe nicht zur Commodore Fachausstellung (CFA) nach Frankfurt, sondern zurück zu Ariola nach München geschickt worden.

Kingsoft stellte zwei neue Spiele vor: »Tom« und »Zaga«, beide durch gute Grafik und günstigen Preis (39 Mark auf Diskette) überzeugend. »Tom« ist ein Spiel, das man zu den intelligenten »Irrgarten-Hüpf-und-Kletterspielen« rechnen kann. »Zaga« ist ein Hubschrauberspiel, das sehr viel Ähnlichkeit zum bekannten »Zaxxon« aufzeigt. Beide Spiele sind voraussichtlich bei Erscheinen dieser Ausgabe schon lieferbar.

Die englische Softwarefirma Anirog brachte gleich drei neue Spiele auf den Markt: »The Soul Gem of Martek«, »PG Fuzz« und »The Catacombs«, die ebenfalls durch Leistung und einem Preis von weniger als 40 Mark beeindrucken und ab Oktober über Kingsoft und Micro-Händler beziehbar sein werden. Bei diesen Spielen zeigte sich schon deutlich der Trend weg von den Schießspielen hin zu den intelligenteren Programmen.

Anspruchslos aber billig waren die Spiele von Bubble Bus: Messepreis 20 Mark das Stück, und das war für die Qualität der Spiele noch zu hoch.

PSS-Software aus England stellte das neue Taktikspiel »Battle for Midway« vor, das aus 90% Taktik und 10% Action (Kampf nur bei Konfrontation mit feindlichen Truppen) besteht.

Bei Lucius-Computer-Programme waren zwei Keyboards zu bewundern: Das Colortone-Sensortasten-Keyboard und das Colortone-Professional-Keyboard. Mit dem Sensortasten-Keyboard wird eine ausgezeichnete Musiksoftware geliefert, die wegen Ihrer einfachen Handhabung speziell für Musikanfänger geeignet ist. Zum Professional-Keyboard wird entsprechende Professional-Software geliefert, die von den musikalischen Möglichkeiten her fast mit Musicalc konkurrieren kann. Beide Keyboards sind außerdem noch passend zum Synthesizer-Softwarepaket »Musicalc«, welches ebenfalls von Lucius vertrieben wird.

Das Wersi-Keyboard wurde bereits in der letzen Ausgabe vorgestellt. Wersi setzt mittlerweile den C 64 auch zur Steuerung ihrer großen Heimorgeln ein.

Interface Age zeigte das »Extended Graphik System«, ein gutes Grafik-Utility, über das wir in diesem Heft auch näher berichten.

Handic-Software bot keine neuen Produkte für den C 64, zeigte aber überraschenderweise schon Spiele für den Plus/4: Drei Textadventures, die an die Abenteuerspiele von Scott Adams angelehnt sind, sowie ein einfaches Datenverwaltungsprogramm.

Auch an Hardware wurden einige interessante Neuigkeiten gezeigt, wenn auch die Erwartungen etwas höher ausgefallen waren. Hallberg Elektronik stellte eine 128 KByte-EPROM-Platine für den C 64 vor. Sie ist per Software ein- und ausschaltbar. Damit ist es nun möglich, eine ganze Reihe von verschiedenen Programmen auf EPROM zu brennen und zu nutzen, ohne jedesmal von Diskette zu laden. Sofort beim Einschalten des C 64 stehen alle Programme zur Verfügung. Durch einen POKE-Befehl oder mit den Funktionstasten können Sie das gewünschte Programm aktivieren. Wenn die Karte ausgeschaltet ist, belegt sie weder Speicherplatz noch stört sonst irgendwie. Es können EPROM-Typen von 4 bis 16 KByte eingesteckt werden. Sehr interessant war ein völlig neuartiger Joystick, ebenfalls von Hallberg. Bei diesem Joystick scheint der untere Teil zu fehlen. Er besteht also nur aus dem Griff mit den Feuerknöpfen. Das Prinzip ist einfach und genial zugleich: es wird nach den Gesetzen der Trägheit mit Quecksilber gearbeitet. Zur Steuerung benötigt man nur eine Hand, die andere bleibt frei.

Es wird aber bereits an einer Version gearbeitet, die ähnlich Navigationsinstrumenten in der Schiff- und Luftfahrt mit Kreisel arbeiten, so daß auch Relativ-Bewegungen möglich sind. Das heißt, daß die Bewegung des Cursors (des Sprites, etc.) aufhört, wenn auch der Joystick still steht.

Michael Lamm, ein Hardware-Entwickler, stellte einen neuen IEEE-Bus vor. Durch dessen externes, erweitertes Betriebssystem wird kein Speicherplatz verbraucht. Im Gegensatz zu vielen herkömmlichen IEEE-Bussen sind die RS232-Routinen noch voll erhalten. Die serielle Schnittstelle des C 64 kann ebenfalls benutzt werden. Die Karte wird von Jann-Datentechnik Berlin vertrieben.

Print-Technik und Roland Köhler stellten einen Digitizer vor. Mit Ihnen kann ein von einem Video-Recorder beziehungsweise einer Video-Kamera aufgenommenes Bild in digitale Informationen umgewandelt werden. Diese Bilder lassen sich auf Diskette speichern und von Grafikdruckern ausgeben. Auch Schwingungen, zum Beispiel Töne über ein Mikrofon aufgenommen, können digitalisiert und als grafische Darstellung der Schwingungen verarbeitet werden.

International Computing aus Holland präsentierte eine wesentlich schnellere VC 1541, bei der alle Datenübertragungen beschleunigt werden. Zu diesem Zweck sind einige Umbauten am C 64 und an der Floppy notwendig. Die Kompatibilität bleibt jedoch voll erhalten. Es wird zusätzlich zu dem seriellen Port eine parallele Datenübertragung installiert. Mit einem Schalter kann umgeschaltet werden. Es ist auch möglich, ein EPROM mit Btx-Software zu integrieren. Ein weiterer Schalter läßt auch die Benutzung der Diskettenrückseite zu, ohne eine zusätzliche Kerbe in die Diskette zu stanzen. Die junge Firma steht gerade in Verhandlungen mit deutschen Firmen, die den Vertrieb und den Service übernehmen sollen. Die 64’er Redaktion fand die Demonstration so interessant, daß ein ausführlicher Test vorbereitet wird.

Wer seinen SX 64 mit einem Doppellaufwerk ausstatten will, kann dies bei RMC für 2 500 Mark machen lassen. Dort wird die Micropower 2000 zerlegt und in den SX 64 eingebaut.

## Datenfernübertragung

Am Stand von Software Express wurde DFÜ »zum Anfassen« präsentiert. Über einige Telefonleitungen konnten die Messebesucher Akustikkoppler und Treibersoftware (Teleterm für 198 Mark) ausprobieren. Für diejenigen, die keinen Platz am Computer erreichten, wurde das, was auf einem Monitor zu sehen war, auf eine 2 x 3 Meter große Leuchtdiodenwand übertragen.

Als Renner stellte sich der Akustikkoppler AK 300 (Vertrieb Software Express: Preis 548 Mark) heraus. Er war nach kurzer Zeit vergriffen.

Auch Roboter waren auf diesem Stand zu sehen. Einer von ihnen machte aus einem Akustikkoppler ein »Modem«, in dem er das automatische Abheben des Telefonhörers übernahm.

Sehr interessant war der Workshop vom »Commodore-Guru« Jim Butterfield über die neuen Computer Plus/4, C 16 und C116. Ein Interview mit Jim Butterfield zu diesem und noch anderen Themen wird in der nächsten Ausgabe folgen.

Nach langer Zeit haben die deutschen Softwarehersteller endlich die Lernsoftware entdeckt. Die ersten Ergebnisse, die auf der Messe vorgestellt wurden, konnten uns aber nicht in jedem Fall überzeugen. Man wird noch lernen müssen, daß schnelles Reagieren auf einen neuen Markt, nicht auf Kosten der Qualität gehen darf.

Das Produktspektrum konnte sich allerdings schon sehen lassen.

An die Jüngsten unter den Computer-Benutzern wendet sich der Otto Maier Verlag (Ravensburger) mit Spielen, die das gestalterische Denken entwickeln und fördern sollen. Die Altersgruppen, auf die diese Programme abgestimmt sind, liegen zwischen fünf und zehn Jahren. Die Preise für die neuen Produkte liegen zwischen 88 und 98 Mark.

Mathematikprogramme wurden von zwei Anbietern vorgestellt. DerWestermann Verlag beschäftigte sich hauptsächlich mit den Grundrechenarten. Weiterhin wird ein Programm zum Rechtschreibtraining angeboten. Die Produktpalette umfaßt zur Zeit elf Programme, soll aber in Kürze auf 28 Programme erweitert werden. Die Preise hierfür liegen zwischen 39 und 89 Mark. Das Mathematikprogramm ALI von Heureka-Software ist auf die Schüler der Klasse fünf bis hin zur Oberstufe abgestimmt.

Das größte Angebot ist bei den Vokabellernprogrammen zu finden.

Die Langenscheidt Verlagsgruppe bietet zur Zeit vier Programme für die englische Sprache für je 80 Mark. Die Produktpalette soll in Zukunft erheblich erweitert werden. Also nach dem reinen Übersetzungscomputer von Langenscheidt nun auch Sprachprogramme für Heimcomputer. SM Software hat in seinem Angebot drei Englisch-, zwei Französisch-, einen Spanisch- und einen Italienischkurs. Diese Kurse kosten je 198 Mark. Ein Vokabelprogramm für Latein wird vom Markt&Technik Verlag angeboten.

Einige der Vokabellernprogramme enthalten kleine Spiele. Hat man eine bestimmte Anzahl von Vokabeln gewußt, so darf man als Belohnung einmal spielen.

Ein Lernprogramm ganz anderer Art wurde von Homesoft vorgestellt. Diese Kurse sollen die Computerhändler in die Lage versetzen, ihren Kunden ausreichend Hilfestellung zu geben. Der Einsteigerkurs von 4 x 2 Stunden kostet 98 Mark, der Preis des Basic-Fortgeschrittenenkurses liegt bei 198 Mark. Beide Preise sind inklusive komplettem Unterrichtsmaterials.

(aa/gk/rg/M. Kohlen)

# Leserforum

## MPS 801: Verständnis für den Handel

**Zum Artikel MPS 801 in Ausgabe 8/84**

Ich arbeite als Verkaufsberater und Filialleiter in einem Computershop einer Spezialfirma in einem Warenhaus (eingemietet).

Zu dem »...ist bestellt« und »...ist momentan nicht vorrätig« möchte ich Ihnen folgendes mitteilen:

1) Stimmt, kommt vor.
2) Sobald etwas angekündigt ist, wird es bestellt!
3) Die Auslieferung eines Artikels erfolgt meist einige Monate später als die Werbung dafür!
4) Wir können nicht hexen!
5) Die Nachlieferfrist beträgt je nach Hersteller und Artikel ebenfalls bis zu 2 Monaten! (Wenn überhaupt lieferbar!)
6) Suchen Sie den Fehler bezüglich Liefersituation nicht immer im Handel; reklamieren Sie einmal beim Hersteller oder Importeur!
7) Beim momentanen Preissturz kann es sich keine (Klein-) Firma mehr leisten, ein großes Lager zu halten, will sie überleben!
8) Ein wirkliches Fachgeschäft kann bald nicht mehr bestehen, weil die Billigdiscounter die Preise zerstören! (Gutes Personal aus der Computerbranche ist teuer und selten!) Bei uns sagt man »den Bazen und das Weggli kann man nicht haben!« dies heißt: Das Geld und das Brötchen kann man nicht haben! Übrigens: Software wie div. Spiele können wir wegen Raubkopien meistens nur noch auf Bestellung liefern. Bei uns kauft beinahe niemand mehr Software (Anwenderprogramme und Spiele).

Das Beste: Kommt doch einer und fragt: »Haben Sie auch Spiele?« Ich: »Ja, dieses Regal ist nur für den C 64.« Er: »Nein nein, nicht zum Kaufen, gratis, zum Tauschen!«

Ich hoffe, Sie haben nun auch ein wenig Verständnis für die Seite des Handels gefunden.

Alfred Theiler

## Fragen Sie doch!

Selbst bei sorgfältiger Lektüre von Handbüchern und
Programmbeschreibungen bleiben beim Anwender immer wieder Fragen offen. Viel mehr Fragen ergeben sich bei Computer-Interessenten, die noch keine festen Kontakte zu Händlern, Herstellern oder Computerclubs haben. Sie können der Redaktion Ihre Fragen schreiben oder Probleme schildern (am einfachsten auf der beigehefteten Karte). Wir veranlassen, daß die Fragen von einem Fachmann beantwortet werden. Allgemein interessierende Fragen und Antworten werden veröffentlicht.

## Ziemlich übertrieben!

Im Bericht über die Customer Electronics Show in Chicago in Ausgabe 8/84, Seite 13 steht:

»Diese Musikprogramme sind mittlerweile so ausgereift, daß fast kein Unterschied mehr zu einem digitalen Synthesizer bemerkbar ist.«

Ich halte diesen Absatz für ziemlich übertrieben, ja eigentlich ist dieser sogar falsch! Denn keine noch so ausgefeilte Programmierung macht aus dem digital gesteuerten, aber ansonsten analogen SID des C 64 einen digitalen Sythesizer à la Emulator, Fairlight oder PPG.

Als einziger Vergleichsmaßstab käme eventuell die Bedienungsfreundlichkeit in Frage, mehr aber auch nicht. Auch hier gilt: Hardware kann nicht durch noch so gute Software ersetzt werden.

Abgesehen vom Einsatz als preiswerter Sprachgenerator oder der Eignung zum Heranführen an eine einfache Synthesizer-Programmierung, sollte der SID das bleiben, was er ist, nämlich eine nicht unerhebliche Aufwertung von Computerspielen.

Es ist schade, daß die Begriffe analoge und digitale Synthesizer in einen Topf geworfen werden, obwohl sich beide Systeme doch ziemlich unterscheiden. Ich möchte kurz folgende Unterscheidungsmöglichkeit aufzeigen:

Bei analogen Synthesizern wird zunächst eine Grundschwingung erzeugt (VCO, DCO). Diese wird über einen steuerbaren Filter (VCF) geleitet und steht hinter einem ebenfalls steuerbaren Verstärker (VCA) zur Verfügung. Anders bei digitalen Synthezisern. Hier wird das Ausgangssignal direkt erzeugt und über D-A-Wandler ausgegeben. So ist es sicherlich zu verstehen, daß Naturklangspeicher-, FM-Synthese- oder rechnende Klang-Parameter-Systeme nicht mit dem Synthesizer-Chip im C 64 zu vergleichen sind. Meiner Ansicht nach wird der SID gelegentlich überbewertet. Es soll allerdings nicht unerwähnt bleiben, daß dieser Baustein einen zunehmenden Kreis von Home-Computer-Anwendern spielerisch an die Musik heranführen kann.

Markus Cohnen
Mitglied im Arbeitskreis Musikelektronik (AME)

## VC 20 als 64’er?

Kann man auf dem VC 20 mit 64 KByte Erweiterung auch Programme für den C 64 laufen lassen?

Jan Wilbert

Leider nein, die Hardware beider Computer ist völlig unterschiedlich. Nur Programme ohne PEEK, POKE, SYS und USR laufen einwandfrei.

## Modulprogramme laden?

Kann man beim VC 20 Modulprogramme von Diskette laden?

Andreas Hübert

Ja, mit LOAD »NAME«, 8.1. Sie benötigen allerdings RAM im Bereich $A000-$BFFF.

## Nochmal MPS 801: Es geht auch einfacher

In bezug auf den Artikel über den MPS 801-Drucker in Ausgabe 8/84 möchte ich Ihnen mitteilen, daß man sich bloß kein komplett neues Farbband kaufen sollte. Den Farbtank kann man auf einfachste Weise mit schwarzer Stempelfarbe nachfüllen! Erst bei starker mechanischer Abnutzung des Farbbandes würde ich ein neues Band empfehlen, da dieses recht teuer ist (25 Mark).

Etwaige Bedenken einer Verstopfung des Druckkopfes sind unbegründet. Ich habe den Tank schon öfter nachgefüllt — ohne Probleme.
Übrigens:
Sperrschrift und Reversschrift sind auch im Direktmodus möglich:
OPEN 1,4
PRINT#1, CHR$(14) (bzw. 18 für rvs)
CMD 1
LIST
PRINT#1, CHR$(15) (Normalschrift)
CLOSE 1

Hartmut Wenzel

## Wollen Sie antworten?

Wir veröffentlichen auf dieser Seite auch Fragen, die sich nicht ohne weiteres anhand eines gutes Archivs oder aufgrund der Sachkunde eines Herstellers beziehungsweise Programmierers beantworten lassen. Das ist vor allem der Fall, wenn es um bestimmte Erfahrungen* geht oder um die Suche nach speziellen Programmen beziehungsweise Produkten. Wenn Sie eine Antwort auf eine hier veröffentlichte Frage wissen - oder eine andere, bessere Antwort als die hier gelesene - dann schreiben Sie uns doch. Die Antworten werden wir in einer der nächsten Ausgaben publizieren. Bei Bedarf stellen wir auch den Kontakt zwischen Lesern her.

# MSD-Super-Drisk-Drive

> Bei den Commodore-kompatiblen Einzellaufwerken gibt es inzwischen einige Alternativen. Jetzt gerät allmählich auch der Markt für Doppellaufwerke in Bewegung.

Das »MSD Super Disk Drive«, kurz SD-2, kommt aus den USA und wird durchaus höheren Ansprüchen gerecht.

Das SD-2 kann zwischen dem C-1541-Laufwerk und dem CBM 4040 angesiedelt werden.

Denn die 1541 bietet für eine ganze Menge Anwender zu wenig Leistung, die großen CBM-Floppys der 8000er-Serie sind ganz und gar nicht kompatibel, und das CBM 4040-Doppellaufwerk ist viel zu teuer (neu 2500 bis 3000 Mark).

## Komfort-Laufwerk mit guter Optik

Das Gerät überrascht angenehm: Statt einer grauen 1541-Plastik findet man ein sehr solides weißes Metallgehäuse vor, in dem zwei Laufwerke platzsparend verteilt sind. Das MSD-SD-2 nimmt mit beiden Laufwerken nicht sehr viel mehr Platz weg als die C 1541.

Die Disketten werden senkrecht in die Laufwerke eingeführt. Für jedes Laufwerk wird der Betriebszustand einzeln angezeigt. Pro Laufwerk existiert ein Fehlerlämpchen und ein Betriebslämpchen.

Auf der Rückseite des Gerätes befinden sich zwei serielle Anschlüsse und ein paralleler IEEE-488-Bus, der Netzanschluß, ein Ein/Aus-Schalter sowie eine gut zugängliche Sicherung.

## Nicht schnell wie der Wind, aber flink wie ein Wiesel

Ein gutes Argument für den Kauf des MSD-Doppellaufwerks ist die Geschwindigkeit, die sich je nach Schnittstelle richtet.

Wählt man die serielle Schnittstelle, so ist die Geschwindigkeit annähernd die gleiche wie bei der 1541 (sofern man hier von Geschwindigkeit reden kann), sogar minimal langsamer.

Lohnender ist allerdings der Anschluß über den IEC-Bus, zu dem man allerdings ein spezielles Interface kaufen muß. Das Laufwerk wurde mit den IEEE-488-Interfaces von Telesys, Dynamics und RMC-Systems getestet.

Die Geschwindigkeitsvergleichstests wurden anhand eines 153 Block langen Files durchgeführt (siehe Tabelle).

Das Kopieren einer ganzen Disk benötigt auf dem MSD-Floppy nur etwa knapp 2 Minuten: Einfach Original- und Zieldiskette in die Drives und Backup-Befehl ans Floppy senden. Schade, daß man mit einem Einzellaufwerk wie der 1541 nicht so einfache Befehle wie Backup (”Dl = 0”) oder Copy ("C0 = l”) benutzen kann.

## Kompatibel muß es sein

Obwohl die MSD-Floppy also nicht die gleiche Geschwindigkeit herzaubert wie das CBM-4040-Doppellaufwerk (über IEC-Bus zirka fünfmal schneller), ist das SD-2 mit dem Geschwindigkeitsfaktor 2,3 mal schneller und im Hinblick auf die Kompatibilität der Software mehr zu empfehlen.

Diese Unterschiede lassen sich mit den Eigenarten der Floppy-Betriebssysteme erklären, die mit der 1541 natürlich nicht identisch sind und aus Copyright-Gründen auch gar nicht sein dürfen.

Das MSD-Laufwerk ist mit seriellem Kabel zu zirka 90% der Software kompatibel, sogar der doch etwas kompliziertere Disketten-Kopierschutz von Synapse-Software lief darauf. Bei der Wahl der parallelen Schnittstelle sieht die Sache leider etwas düsterer aus:
Nur etwa 75% der kommerziellen, kopiergeschützten Software lief darauf.
Hätte MSD nicht aus den Fehlern der alten CBM-4040-Floppy gelernt, wäre die Kompatibilität zum C-1541-Einzellaufwerk gänzlich in den Wind zu schreiben gewesen. Bei vielen Software-Produkten wird keine Laufwerksnummer 0 oder 1 angegeben. Das 4040-Floppy hat die Angewohnheit, dabei immer auf beide Laufwerke zuzugreifen und Programme wie zum Beispiel die Adventurespiele von Infocom nur zu starten, wenn in beiden Laufwerken die gleiche Disk vorhanden ist. Das MSD-Laufwerk greift automatisch auf Laufwerk O zu, um die Kompatibilität zum Einzellaufwerk stärker zu gewährleisten.

## Solide Hardware bis ins letzte Detail

Bei der Verarbeitung zeigt das MSD Super-Disk-Drive große Vorteile gegenüber dem C-1541-Laufwerk. Zum einen ist es bei weitem nicht so überhitzungsgefährdet wie das Commodore-1541, zum anderen ist es sehr stabil gebaut. Nach einem Härtetest (25 Disketten hintereinander formatieren) hatte sich der Schreib/Lesekopf nicht einmal um Bruchteile von Millimetern verschoben — der Schreib/Lesekopf des 1541 wäre längst dejustiert gewesen. Bemerkenswert ist auch, daß bei auftretenden Lesefehlern kein lautes Rattern wie am 1541 oder 4040 zu hören ist. Das SD-2 schont sich also praktisch selbst.

## Die besondere Fähigkeit

Laut englischer Anleitung weist das MSD-Super-Disk-Drive einen besonderen Gag auf: Nachdem die Datendiskette im einen Laufwerk voll ist, wird einfach auf eine Diskette im 2. Laufwerk umgeschaltet. Dies würde natürlich für den kommerziellen Anwender bei vollen 340 KByte Speicherkapazität sehr von Nutzen sein. Leider lag uns zum Test noch keine Version des MSD-Doppel-Disk-Drives vor, das diese Umschaltung geboten hätte.

Alles in allem gesehen, kann man das SD-2 als hervorragendes Gerät bezeichnen, das sich besonders durch seine stabile Verarbeitung auszeichnet. 1998 Mark für dieses Diskettenlaufwerk (ohne IEC-Bus) sind kein besonders billiges Vergnügen. Es lohnt sich aber trotzdem für die kommerziellen Anwender und Viel-Kopierer.

## Für Profis geeignet

Insbesondere die üblichen Reparaturkosten, die man sich mit dem Kauf des 1541 früher oder später aufhalst, sprechen für den Kauf des MSD-Laufwerks.
Dem einfachen Hobby-Benutzer, der seinen C 64 (plus Floppy) nicht länger als drei Stunden pro Tag angeschaltet hat (echte Dauerbenutzer haben mindestens ein Pensum von fünf Stunden täglich), ist jedoch weiterhin der Kauf der sehr viel billigeren C 1541 anzuraten, besonders im Hinblick auf die Kompatibilität der Software.

(M. Kohlen)

Höhe 15,7 cm
Breite 15 cm
Tiefe 33,8 cm
Anschlüsse: wahlweise IEEE-Bus parallel oder seriell.
Diskformat: 5,25-Zoll-Disketten
Single Density Speicherkapazität: pro Laufwerk wie 1541: sequentiell 168 656 Byte relativ 176 132 Byte

# Monitor kontra Fernseher

> Nur wenige Computer haben einen eingebauten Monitor. Weil auch ein vorhandener Fernsehapparat angeschlossen werden kann, können die Preise eines Computers auch relativ niedrig gehalten werden. Doch wenn man es leid ist, das Wohnzimmer mit einer undekorativen Computeranlage zu verunstalten, wird der Kauf eines zweiten Fernsehers erwogen. Oder sollte es vielleicht besser ein spezieller Monitor sein?

Bildschirmgeräte stehen heute in fast allen Haushalten — in Form eines Fernsehgerätes. Kein Wunder also, wenn viele Hersteller von Heimcomputern auf das vorhandene Reservoir zurückgreifen und für ihre Geräte ein solches Fernsehgerät als Ausgabeeinheit vorsehen. In manchem Heimcomputer-Besitzer mag aber — nach langen Abenden vor dem zweckentfremdeten Fernseher — der Wunsch entstanden sein, auch einmal vor einem scharfen Monitorbildschirm sitzen zu dürfen.

Wir haben uns fünf Geräte ausgesucht und von jedem Bildschirm einige Aufnahmen gemacht. Wir wählten zwei Farbmonitore aus (das Modell 1701 von Commodore (zirka 900 Mark) und den Taxan Vision Ex (zirka 1000 Mark)), zwei Farbfernseher mit Video-Eingang (Panasonic TC 1637 DR (zirka 1000 bis 1100 Mark) und Sharp DV-1400 G,S,N (zirka 900 Mark)) sowie einen monochromen Monitor (Zenith ZVM-123-E (zirka 350 Mark), Bilder 1 bis 3). Wir wollten wissen, ob es lohnend ist, sich einen Farbmonitor anzuschaffen, der sich lediglich zum Anschluß an einen Computer eignet und ob der Unterschied zu einem guten Farbfernseher mit Videoeingang sich wirklich stark bemerkbar macht. Den monochromen Monitor brauchten wir, um die Qualität einer 80-Zeichen-Karte zu dokumentieren.

Von jedem Bildschirm wurden zwei Aufnahmen gemacht, je eine mit einer Grafik und mit einem Text (Bilder 4 bis 14). Die beiden Farbmonitore und der monochrome Monitor mußten sich zusätzlich noch mit der 80-Zeichen-Karte quälen lassen (Bilder 15 bis 17). Sie stammt von der Firma Decam electronic aus Ettlingen. Bei den Aufnahmen muß man berücksichtigen, daß die Einstellungen von Farbe, Helligkeit und Kontrast sich verändern lassen, daß auch foto- und drucktechnische Gegebenheiten das Ergebnis etwas verfälschen können. Doch lassen sich einige grundsätzliche Unterschiede schon feststellen.

Um die Unterschiede noch etwas klarer herauszustellen, haben wir zu jedem Bildschirm eine Ausschnittsvergrößerung der Grafik (Bild 4) und des Textes gewählt. Hier wird auch die Struktur des Bildschirmes sichtbar.

Da die Sehgewohnheiten sehr unterschiedlich sind, haben wir auf eine Bewertung verzichtet. Dieser Artikel ist auch kein Vergleichstest, sondern soll Ihnen die Unterschiede zwischen Fernseher und Monitoren demonstrieren.

## »Zeichen pro Zeile« ist Unsinn

Viele Anwender interessieren sich im Zusammenhang mit Textverarbeitung mit den Problemen bei der Darstellung von einer bestimmten Anzahl von Zeichen pro Zeile.

Die Angabe »Zeichen pro Zeile« hat sich eigentlich erst verbreitet, als sich zunehmend technisch Unbedarfte im Computerbereich zu interessieren begannen. Sie scheint so schön anschaulich und unkompliziert zu sein. Dabei ist sie Ursache einer großen Verwirrung in diesem Bereich. Sie suggeriert nämlich, daß es im Monitor irgendeine Stelle gäbe, die entweder 40 oder 80 Zeichen akzeptieren würde, aber nicht beides und nichts zwischendrin. In einigen Anzeigen wird dieses Mißverständnis noch gefördert, indem sie von »umschaltbar auf 40 oder 80 Zeichen« sprechen!

Der Monitor erkennt Zeichen schon aus technischen Gründen überhaupt nicht als solche, da er ja immer nur die auf einer Bildzeile nebeneinanderliegenden Matrixzeilen einer ganzen Textzeile schreibt. Jede Punktmenge, die kleiner ist als die maximal mögliche, wird selbstverständlich auch abgebildet. Ein Monitor, der 400 Punkte pro Zeile abbilden kann, kann auch 200 abbilden, oder 360 oder irgendeine andere Anzahl, ohne Umschaltung. Ob diese Punkte zu 22, 40 oder 80 Zeichen gehören, ist ihm, schlicht gesagt, egal.

Die Umschaltmöglichkeit, die manche Hersteller anbieten, hat einen anderen Grund: Wenn nämlich ein Monitor, der 800 Punkte pro Bildzeile noch scharf abbildet, aber von einem Computer nur 400 angeboten bekommt, kann die Auflösung zu gut sein. Dann sind die Punkte durch deutliche Zwischenräume getrennt. Das ist unter Umständen für den Betrachter unangenehm. Mit dem Umschalter wird die Bandbreite deshalb absichtlich soweit eingeschränkt, daß die Punkte etwas verschliffen werden. Das Auge nimmt sie breiter gezeichnet wahr, die Zeichen erscheinen im Bild geschlossener und die Arbeit mit ihnen ermüdet weniger. Alle diese Ausführungen treffen in vollem Maße auch auf Farbmonitore zu.

Welches Bildschirmgerät ist aber am geeignetsten? Nun, das kommt ganz auf den Verwendungszweck an. Für Textverarbeitung und alle Anwendungen, die auf die Darstellung großer Datenmengen pro Bildschirmzeile beruhen, erst recht bei 80-Zeichen-Karten, ist ein monochromer Bildschirm am besten geeignet, es sei denn, daß die Farbe ein wesentlicher Bestandteil der Bildinformation ist. Selbst gute Farbmonitore haben aber nur eine Auflösung, die derjenigen billiger monochromer Monitore entspricht. Absolut ungeeignet ist ein Farb- oder Schwarzweiß-Fernseher für diesen Zweck. Für grafische Anwendungen bietet sich ein Farbmonitor ab mittlerer Preislage an. Eventuell geht auch ein Farbfernseher mit Video-Eingang; die Farben sind zwar dann brillant, an der Auflösung mangelt es jedoch. Die Domäne normaler Farbfernsehgeräte sind eigentlich nur Anwendungen im Bereich der Videospiele. Hierbei ist zum einen der Tonteil von Bedeutung und andererseits keine übermäßige Schärfe nötig.

Insgesamt betrachtet, erscheint ein Farbfernseher mit Videoeingang ein guter Kompromiß zu sein. Man sollte dann jedoch darauf achten, daß die Bildschirmgröße bei 20 bis 35 cm Schirmdiagonale liegt. Dann kann man in einem optimalen Abstand zwischen 0.5 und 1.5 Metern vom Bildschirm sitzen (schon deshalb ist ein großer Farbfernseher ungeeignet). Verbindliche Werte gibt es jedoch nicht. (gk)

Bezugsquellen: siehe Marktübersicht auf Seite 22. Die beiden Farbfernseher sind im Fachhandel erhältlich.

# Marktübersicht Schwarzweiß- und Farbmonitore

> Ob wegen Textverarbeitung oder Familienprotest — immer mehr Computerbesitzer ersetzen den Fernseher durch einen Monitor. Diese Marktübersicht soll eine kleine Hilfe im Vorfeld der Kaufentscheidung sein.

Wir haben uns dabei auf die Monitore beschränkt, die vom Preis her in ein C 64-System passen. Das bedeutet im Klartext, daß wir monochrome Monitore oberhalb von etwa 600 Mark ebensowenig berücksichtigt haben wie Farbmonitore, die wesentlich mehr als etwa 1600 Mark kosten.

Die angegebenen Preise verstehen sich als ungefähre Richtwerte; Preisvergleiche bei verschiedenen Händlern lohnen sich in der Regel.

Die meisten Monitore werden über den Fachhandel oder über Kaufhäuser vertrieben. Die folgende Anbieterliste enthält für den Interessierten die Adressen der Vertriebsfirmen, bei denen Datenblätter und nähere Informationen zu bekommen sind.

(ev)

Anbieter:
Apple Computer, Freischützstr. 92, 8000 München 81
Commodore Deutschland, Lyoner Str. 38, 6000 Frankfurt 71
Feltron Elektronik, Auf dem Schnellerod 22, 5210 Troisdorf
Gerb Elektronik, Roedernallee 174-176, 1000 Berlin 51
Hantarex Deutschland, Siegener Str. 23,5230 Altenkirchen
ITT/SEL, Frankstr. 60, 7530 Pforzheim
Loewe Opta, Industriestr. 11, 8640 Kronach
C Melchers & Co., Schlachte 39/40, 2800 Bremen 1
Microscan, Postfach 601705, 2000 Hamburg 60
Mirwald Electronic, Fasanenstr. 8b, 8025 Unterhaching
National Panasonic, Winsbergring 15, 2000 Hamburg
Philips Data Systems, Weidenauer Str. 211-213, 59 Siegen 21
Sanyo Deutschland, Widenmeyerstr. 25, 8000 München 22
Unitronic, Münsterstr. 338, 4000 Düsseldorf 30
Zenith Data Systems, Robert-Bosch-Str. 32-38, 6072 Dreieich-Sprendlingen

# Marktübersicht Drucker – Teil 2

> Hier ist der zweite Teil unserer aktuellen Marktübersicht über das Angebot an Druckern und Plottern für den Commodore 64 und den VC 20.

Wie bereits im ersten Teil, so fehlen auch diesmal zwei Kategorien von Druckern und Plottern. Zum einen nämlich Geräte aus Preisklassen, die für den C 64/ VC 20-Anwender nicht mehr interessant sind, also beispielsweise Superdrucker für 5000 Mark oder DIN A3-Plotter im fünfstelligen Preisbereich. Zum anderen wurden auch diesmal Drucker nicht berücksichtigt, die nur mit unvertretbar großem Aufwand an den C 64 / VC 20 angeschlossen werden können.
Sie können also davon ausgehen, daß alle in dieser Marktübersicht vertretenen Drucker und Plotter ohne große Probleme mit dem C 64/ VC 20 arbeiten. Bei Geräten, die direkt über den seriellen Bus anschließbar sind, ist in der Rubrik »Interface« »C 64/VC 20« vermerkt.
Die Liste der an den C 64/VC 20 anschließbaren Drucker soll auch zukünftig weiter aktualisiert werden. An dieser Stelle sind daher auch die Anbieter entsprechender Drucker oder Plotter aufgefordert, uns entsprechende Informationen zukommen zu lassen.
Alle Preisangaben sind nur ungefähre Werte. Wer sich bei verschiedenen Anbietern informiert, kann unter Umständen günstiger einkaufen.

### Anbieter-Liste Drucker & Plotter (Teil 2)

Die hier aufgeführten Adressen sind in der Regel keine direkten Bezugsquellen. Sie erhalten hier jedoch Datenblatt und Händlernachweis für den von Ihnen ins Auge gefaßten Drucker oder Plotter. (ev)

Ascalon-Vertrieb Mayon Elektronik GmbH, Postfach 1925, 8034 Germering
Brother International GmbH, Im Rosengarten 14, 6368 Bad Vilbel
Centronics System Elektronik Vertriebs GmbH, Heesfeld 4, 3300 Braunschweig
DEC Transtec Computervertriebsges. mbH, Schaffhausenstr. 113, 7400 Tübingen
Dyneer Vertrieb Technitron GmbH, Charles-de-Gaulle-Str. 4, 8000 München 83
Facit-Ericson, Niederheider Str. 3, 4000 Düsseldorf 13
Honeywell-Fachhandel Lackner GmbH, Willstr. 2, 8500 Nürnberg
C. Itoh Deutschland GmbH, Königsallee 21, 4000 Düsseldorf 1
Macrotron, Stahlgruberring 28, 8000 München 82
Mannesmann-Tally GmbH, Postfach 2969, 7900 Ulm
G. Melchers & Co., Schlachte 39/40, 2800 Bremen 1
Mitsui-Vertrieb Technitron GmbH, Charles-de-Gauile-Str. 4, 8000 München 83
NEC Europa, Wiesenstr. 148, 4040 Neuss 1
Olivetti-Fachhandel, Ingenieurbüro Jörg Michael, St. Katharinen-Weg 6, 7750 Konstanz 16
Roland GmbH, Postfach 1905, 2000 Norderstedt
Siemens Vertrieb PAV, Gerzener Str. 5, 8311 Dietelskirchen
Star Europe GmbH, Frankfurter Allee 1-3, 6236 Eschborn

TODO

# Ein starkes Stück

> Die beiden Matrixdrucker Itoh 8510 und 1550B unterscheiden sich hauptsächlich durch ihre Druckbreite. Enorm leistungsfähig sind sie beide.

Der optische Unterschied ist auffällig, denn der Itoh 8510 (Bild 1) ist im Gegensatz zum 1550B ein fast zierlicher Drucker. Dabei haben beide Drucker viele Gemeinsamkeiten. Sie arbeiten nach dem Punktmatrixprinzip mit einer Zeichenmatrix von maximal 8x8 Zeichen. Auch ist ihnen die Fähigkeit sowohl Einzelblatt als auch Endlospapier zu verarbeiten gemeinsam. Der Unterschied liegt in der Papierbreite. Der Itoh 1550B druckt mit einer Breite bis zu 15 Inch, der Itoh 8510 bis zu 10 Inch. Ein weiterer Unterschied ist die Schreibgeschwindigkeit, denn der 1550B schafft 120, der 8510 aber 180 Zeichen pro Sekunde.

Wesentlich vielfältiger als die Unterschiede sind die gemeinsamen Fähigkeiten dieser beiden Druckertypen. Dem Konzept nach wurden die beiden Hauptfunktionen eines Punktmatrixdruckers, nämlich die Textausgabe und die Grafikausgabe optimiert. Das Schriftbild ist bereits in der schnellen Normalschrift sehr klar und die Buchstaben wohlgeformt. Einzelne Punkte sind kaum noch wahrzunehmen, nur an den Kanten der Buchstaben sind kleine Ecken sichtbar. Etwas größer als die Normalschrift ist die Picaschrift, bei der allerdings wieder mehr einzelstehende Punkte erkennbar sind. Ausgeglichen wird dieser Nachteil in der Fettschrift, die besonders deutlich, aber auch merklich langsamer ist. Die Krönung der verfügbaren Schriften aber ist die Proportionalschrift. Sie gleicht nicht nur die Zeichenabstände optimal aus, sondern verwendet auch eine andere Zeichendefinition. Der Probeausdruck (Bild 2) zeigt, daß diese Schrift den Anforderungen der täglichen privaten, aber auch der geschäftlichen Korrespondenz gerecht wird. Der Programmiervorgang ist relativ einfach, denn er wird mit den üblichen ESC-Sequenzen vorgenommen.

## Matrixdrucker mit Schreibmaschinenqualität

Damit diese Druckfunktionen aber auch richtig aufs Papier kommen, bedarf es der richtigen Verbindung zum Computer. Für die Besitzer des C 64/VC 20 ist dies eine relativ problemlose Angelegenheit, denn beide Drucker haben in der Regel eine Centronics-kompatible Schnittstelle. Die Commodore-Grafik- und Cursorsteuerzeichen sind im Zeichensatz der Itoh-Drucker nicht vorhandenen. Erst die Verwendung eines speziellen Soft- oder Hardwareinterfaces mit entsprechender Programmierung, macht diese Zeichen verfügbar. Die zweite Anschlußmöglichkeit der Itoh Drucker besteht im Einbau einer seriellen Schnittstelle.

Sehr erfreulich verlief der Praxistest mit einem Textverarbeitungsprogramm (Vizawrite 64). Außer einem Verbindungskabel für knapp 50 Mark waren keine zusätzlichen Maßnahmen notwendig. Der Ausdruck funktionierte auf Anhieb mit der eingebauten Treibersoftware des Textverarbeitungsprogramms. Die zweite Frage galt der Grafikfähigkeit der Itoh Drucker. Aber auch hier hatten »Die Zwei« eine Überraschung parat. Je nach der eingestellten Schriftart (Pitchsetting) sind Punktdichten von 1088 bis zu 2176 Punkten pro Zeile beim 1550B möglich. Diese Auflösung wird vom Commodore natürlich bei weitem nicht erreicht. Die Deutlichkeit der Grafik steigt aber mit zunehmender Punktdichte und es sind auch mehrere Farbschattierungen (Graustufen) als Farbersatz programmierbar. Die zweite Methode, andere Zeichen als die vom Zeichengenerator vorgegebenen auszudrucken, ist der ladbare Zeichensatz. Die eingebauten 2-KByte-Pufferspeicher sind auch dazu verwendbar, einen eigenen Zeichensatz zu programmieren. In Verbindung mit dem ebenfalls möglichen Rückwärtstransport des Papiers, kann ähnlich wie mit einem Plotter gearbeitet werden.

Alles in allem stellen die beiden Itoh Drucker 1550B und 8510 ein sehr leistungsfähiges Druckerpaar dar. Die verfügbaren Schriften haben ein überdurchschnittlich gutes Druckbild. Einzig eine gedehnte Schrift, wie von den Commodore- und Epson-Druckern bekannt, fehlt. Bei einem Preis von 2 400 Mark für den 1550B und 1800 Mark für den 8510 stellen die Itoh-Drucker eine kostengünstige Alternative dar.

(Arnd Wängler)

# Der Petal MA20 – kleiner Name, großer Drucker

> Obwohl das Schriftbild der Matrixdrucker ständig besser wird, sind Typenrad-Drucker in diesem Bereich bislang ungeschlagen. Ein auch für den C 64 bestens geeigneter und preisgünstiger Typenraddrucker ist der Petal MA20.

Leider waren Typenraddrucker bislang immer relativ teuer. Nicht so der Petal MA20 (Bild 1), er ist baugleich mit dem bekannten Juki 6100 Typenraddrucker, unterscheidet sich von diesem aber im Preis. Der Juki hat einen empfohlenen Verkaufspreis von zirka 1798 Mark. Der Petal MA 20 soll laut Liste 1498 Mark kosten. Er ist aber unserer Erfahrung nach noch um einiges günstiger zu haben. Der Petal MA20 ist ein Typenraddrucker, das heißt er besitzt im Gegensatz zu einer Schreibmaschine keine eigene Tastatur. Die Texteingabe und Drucksteuerung muß von einem Computer übernommen werden. Mit diesem Konzept sind natürlich Vor- und Nachteile verbunden. Hauptnachteil ist für den Commodore 64-Besitzer, daß keine Grafik- und Commodore-eigene Schriftzeichen ausdruckbar sind. Außerdem sind Typenraddrucker oft relativ langsam und laut (beim Petal zirka 62dBA). Der Vorteil des exzellenten Schriftbildes überwiegt diesen Nachteil aber dann bei weitem, wenn hauptsächlich Texte ausgedruckt werden. Durch Auswechseln der Triumph-Adler-kompatiblen Typenräder (100 Zeichen) steht eine enorme Anzahl der verschiedensten Schriftarten zur Verfügung. Wissenschaftliche Sonderzeichen, Schreibschrift und fremdsprachliche Schriften sind so innerhalb von Sekunden verfügbar. Aber auch das zum Drucker mitgelieferte Typenrad Caroll-Pica erlaubt schon einige Variationen der Schrift (Bild 2). Nicht vergessen wurde dabei die Unterstreichfunktion und die Fettschrift. Der Haupteinsatzbereich eines Druckers wie dem Petal MA20 ist sicherlich die Textverarbeitung. Mit einem guten Textverarbeitungsprogramm, wie dem Vizawrite 64 (das eine eigene Druckoption für den Petal/Juki hat), verwandelt sich die gute Stube in ein kleines Büro. Der Petal MA20 kann sowohl Einzelblatt-, als auch Endlospapier verarbeiten. Für unbeaufsichtigtes Drucken sind zusätzlich ein automatischer Einzelblatteinzug und ein Traktoraufsatz erhältlich. Für den normalen Betrieb genügt aber die Standard-Ausrüstung. Die aber kann sich sehen lassen: Die Druckgeschwindigkeit beträgt 18 Zeichen pro Sekunde bei bidirektionalem Druck. Sehr praktisch ist der sowohl hard- als auch softwaremäßig bestimmbare Zeichenabstand. Er beträgt entweder 10, 12 oder 15 Zeichen pro Zoll. In der Standardschrift können so bis zu 165 Zeichen in einer Zeile untergebracht werden. In der ebenfalls verfügbaren Proportionalschrift (automatischer Ausgleich der Zeichenabstände) sind sogar 220 Zeichen pro Zeile verfügbar. Damit ist auch gesagt, daß die Papierbreite bis zu 13 Inches (= 33 cm) betragen kann. Der Petal MA20 verarbeitet somit auch DIN-A4-Papier im Querformat.

Die unumgängliche Wartezeit auf das fertige Schriftstück wird durch den eingebauten Pufferspeicher von 2 KByte (erweiterbar auf 8 KByte) angenehm verkürzt. Angeschlossen wird der Petal MA20 an den C 64/VC20 wie jeder andere Drucker mit Centronics-kompatibler Schnittstelle.

(Arnd Wängler/aa)

Bezugsquelle: WeberComputertechnik, Eulenspiegelstraße 86, 8000 München 83, Tel. 089/6012554

# Drucksympathie

> Nicht nur die gute Optik, sondern auch sehr gute Leistungen kennzeichnen den BMC BX100. Dabei ist dieser Matrixdrucker auch noch sehr preisgünstig.

Ein guter Matrixdrucker kostete vor etwas mehr als einem Jahr noch ein halbes Vermögen. Das hat sich geändert. Der BMC BX100 (Bild 1) kann als Paradebeispiel dieser Entwicklung bezeichnet werden. Er bietet für relativ wenig Geld (anschlußfertig 1200 Mark) Leistungen, die auch im professionellen Einsatz kaum Wünsche offen lassen.

Schon nach dem ersten Augenschein wirkt er sympathisch, ja man kann sogar von einem hübschen Gerät sprechen. Der Drucker ist kompakt aufgebaut. Das wurde vor allem durch den im Gehäuse versenkten Antriebsmechanismus für Einzelblätter und Endlospapier möglich. Der Vorteil dieses Konstruktionsprinzips liegt in dem auch für die beachtliche Druckgeschwindigkeit von 100 Zeichen pro Sekunde angenehmen Geräuschpegel. Der BMC BX100 wird in der Regel mit einer Centronics-kompatiblen Schnittstelle ausgeliefert. Es sind aber auch eine serielle Schnittstelle und, besonders interessant, eine Version zum direkten Anschluß an den Commodore 64/VC 20 erhältlich. Zum Test stand die Commodore-Version mit externem Interface zur Verfügung. Die ohnehin umfangreichen Druckfunktionen des BX100 werden durch das Commodore-Interface noch um einige Varianten erweitert. Dazu gehört auch der gesamte Commodore-Zeichensatz und die Cursor-Steuerzeichen. Sogar reverse Buchstaben sind enthalten. Die für jeden Programmierer besonders wichtigen Programmlistings werden komplett mit allen Grafikzeichen und den reversen Steuercodes ausgegeben. Der Drucker wird dabei kaum langsamer. Aber auch die Standardfunktionen des BX100 brauchen den Vergleich mit anderen Druckern nicht zu scheuen: Kursiv-Proportional-, Elite-, Schmal-, und Breitschrift sind mit einfachen ESC-Befehlen zu aktivieren (Bild 2).

Befehle zur Formatierung des Textes, wie sie von jedem guten Textverarbeitungsprogramm vorausgesetzt werden, sind dem BX100 nicht unbekannt. Dazu gehören Funktionen wie das Anspringen bestimmter Tab-Positionen, das Setzen des linken und rechten Randes oder die Festlegung der Seitenlänge. Man kann sogar das Papier rückwärts transportieren. Das Druckbild kann zwar nicht mit einem Typenraddrucker verglichen werden, ist aber mit das Beste, was wir bei einem Matrixdrucker dieser Preisklasse bisher gesehen haben. Verglichen mit einem Epson FX80 ist das Schriftbild des BX100 sogar noch etwas besser. Verantwortlich für diese sehr guten Druckeigenschaften ist der Druckkopf, der mit seiner 9x11 + 3sp Nadelmatrix üppig ausgestattet ist.

Mit seinen zwei verschiedenen Nadeldichten kann der BX100 als voll grafikfähig bezeichnet werden, zumal das verwendete Interface diese Funktionen voll unterstützt. Zum Ausdruck des Textes oder der Grafik beträgt die einstellbare Papierbreite zwischen 4,5 und 10 Inches (11,43 bis 25,40 Zentimeter). Die Handgriffe für die Justage des Traktors sind einfach und als durchaus fingerfreundlich zu bezeichnen. Ebenso das Einlegen der Farbbandkassette. Das Eindrehen eines einzelnen Blattes ist Dank des leichtgängigen Drehknopfes und der sinnvollen Papierführung problemlos.

Mit 100 Zeichen pro Sekunde liegt die Druckgeschwindigkeit des BX100 etwas über dem Durchschnitt dieser Klasse. Der Druckkopf schreibt dabei in beiden Richtungen (bidirektional) mit Druckwegoptimierung. Beim Grafikausdruck wird unidirektional geschrieben. Diese weit über den Standard hinausgehende Druckfunktionen machen den BMC BX100 zur idealen Ergänzung des Commodore 64/VC 20.

Bis auf das zwar ausführliche, aber leider noch englische Handbuch, ist der BMC BX100 in dieser Preisklasse nur schwer zu überbieten.

(Arnd Wängler/aa)

Bezugsquelle: Weber Computertechnik, Eulenspiegelstr. 56, 8000 München 83, %1. 0 89/ 6 0125 54

# Wie super ist die Supergrafik?

> Supergraphik 64 ist ein Programm, dessen Befehle sich nicht nur auf die Grafik beziehen.

Nun, gehen wir den Befehlssatz von »Supergraphik 64« mal Schritt für Schritt durch. Da wäre als erstes der GMODE-Befehl zu nennen. Er ist die Schaltzentrale der Supergraphik, denn mit ihm bestimmen Sie, was angezeigt, und was befehligt wird. Denn zusätzlich zu den beiden hochauflösenden Seiten kann in der Textseite eine 80 x 50-Blockgrafik erstellt werden, und zwar mit genau denselben Befehlen. Es ist möglich, die Grafikseite 1 anzuzeigen, während Seite 2 oder die Textseite bearbeitet wird. Natürlich wird auch der Multicolormodus unterstützt. Allerdings ist es aus syntaktischen Gründen nicht möglich, eine Seite »normal« anzuzeigen und die andere in Multicolor zu bearbeiten. Mit diesem Befehl kann auch ein Textfenster in der Grafik definiert werden, allerdings nur im Normal-, nicht im Multicolormodus. Zum Textfenster ist zu sagen, daß die obere Kante nicht ganz flimmerfrei ist, was durch die zahlreichen Umschaltungen im VIC bedingt wird.

Hat man erst einmal eine Moduswahl vorgenommen, so kann man mit dem PLOT-Befehl fleißig Punkte setzen und löschen. Hier ergeben sich zusätzlich noch die Möglichkeiten, Punkte zu invertieren, wie auch einen Grafikcursor an die entsprechende Stelle zu setzen. Dieser Grafikcursor kann dann bei weiteren Befehlen als Ausgangspunkt benutzt werden. Ebenfalls mit dem PLOT-Befehl können Linien und sogar Linienzüge gezeichnet werden. Zu den Optionen »Setzen«, »Löschen«, »Invertieren«, »Grafikcursor Bewegen«, treten nun noch »Punktieren« und »Zählen«. Beim »Zählen« wird in eine beliebige Variable die Anzahl der abgefahrenen Punkte übergeben. Auch können zwei Linien, die nirgends im selben 8 x 8-Kästchen verlaufen, verschiedene Farben haben, obwohl Sie sich im »normalen« Modus befinden. Eine Option bewirkt, daß gleichzeitig mit der Linie die entsprechenden Bytes im Farb-RAM gesetzt werden.

Nun gibt es aber nicht nur Linien, auch Kreise wollen gezeichnet sein. Der zuständige Befehl heißt (natürlich) CIRCLE. Aber CIRCLE kann noch mehr. Auch Ellipsen und Vielecke sind kein Problem, es können sogar ein Anfangs- und ein Endwinkel für das Zeichen mitgegeben werden. Natürlich funktioniert CIRCLE auch mit allen schon bei PLOT angegebenen Optionen.

Weitere Befehle sind FRAME, mit dem ein beliebig dicker, rechteckiger Rahmen gemalt werden kann, sowie FILL, das allerdings nur ausgefüllte Rechtecke zeichnen kann. Das Ausfüllen beliebiger umrandeter Flächen ist mit Supergraphik nicht möglich.

Mit TEXT kann ein Text aus einem String an eine beliebige Stelle in eine Grafik hineinkopiert werden. Im 80 x 50 Modus erhalten Sie so vierfach vergrößerte Buchstaben. Natürlich kann die so entstandene Grafik auch wieder gelöscht werden; der Befehl lautet GCLEAR.

Mit dem INVERS-Befehl kann man die beiden Grafikseiten invertieren. Hier ist die Angabe einer Bitmaske möglich, um gestreift zu invertieren. Leider ist es weder möglich, bereichsweise zu invertieren, noch kann die Textseite invertiert werden.

Mit GCOMB lassen sich die beiden Grafikseiten verknüpfen; neben dem einfachen Kopieren einer Seite in die andere kann wahlweise eine UND-, ODER- oder EXKLUSIV-ODER-Verknüpfung durchgeführt werden.

Mit dem TRANS-Befehl wird die Textseite in eine der beiden Grafikseiten kopiert. Daraus ergeben sich völlig neue Dimensionen, wenn Sie einen Sieben-Nadel-Drucker, beispielsweise den MPS 801 besitzen. Dann können Sie nämlich über den HCOPY-Befehl die original 8 x 8-Matrix der Bildschirmzeichen ausdrucken!

In dieser Übersicht der allgemeinen Befehle fehlt nur noch GMOVE. Damit ist ein Verschieben oder Scrollen von Bildschirmzeilen nach links oder rechts möglich. Welche Zeilen verschoben oder gescrollt werden sollen, kann angegeben werden. Allerdings können auch im hochauflösenden Modus nur 8 x 8-Blöcke gescrollt werden.

Kommen wir als nächstes zu den selbstdefinierbaren Figuren. In einem Definitions-String muß angegeben sein, in welcher Richtung der Grafikcursor weiterbewegt, beziehungsweise wann ein Punkt gesetzt werden soll. Die so definierte Figur kann mit dem DRAW-Befehl an jeder Stelle des Bildschirms gezeichnet werden. Auch hier dürfen sämtliche oben angesprochene Optionen verwendet werden. Mit SCALE= können Sie vorher noch übergeben, mit welchem Vergrößerungsfaktor und um welchen Winkel gedreht ihre Figur erscheinen soll. Eine Anwendung sehen Sie in der Bildschirmaufnahme.

Die nächste Gruppe von Befehlen sind die Farbbefehle. Mit COLOR = können, für jeden der drei Bildschirme einzeln, Hintergrund- und Rahmenfarbe gesetzt werden. SCOL = bestimmt die Zeichenfarbe auf der gesamten entsprechenden Seite; sie kann mit PCOL= für einzelne Bildelemente abgeändert werden, um mehrfarbige Grafiken zu erhalten. Im Multicolor-Modus werden mit SCOL= auch die zwei zusätzlichen Farben angewählt.

Dem Speichern und Laden von Grafiken dienen die Befehle GSAVE und GLOAD. Da das Format, in dem ihre Grafiken geladen oder gespeichert werden, frei wählbar ist, können Bilder der verschiedensten Malprogramme geladen und weiterverarbeitet werden. Dummerweise scheint es kein Einheitsformat zu geben, so daß Sie beim Speichern oder Laden immer eine Formatangabe machen müssen, was auf die Dauer ziemlich lästig ist.

Mit HCOPY lassen sich Grafiken zu Papier bringen. Supergraphik unterstützt hierbei die verschiedensten Druckertypen, sogar den Farbdrucker Seikosha GP-700. Um nicht zuviel Speicherplatz für die Hardcopy-Routinen in Anspruch nehmen zu müssen, werden Sie beim Laden der Erweiterung nach Ihrem Druckertyp gefragt. Sie haben die Wahl zwischen den Commodore-Druckern 1525, 1526, MPS801, den Seikosha-Druckern GP 100-VC und GP 700A sowie Epson-Druckern mit Data Becker-Interface. Die entsprechende Routine wird dann nachgeladen.

Kommen wir nun zu den Sprites. Hier liegen einige Schwachpunkte. Denn bevor Sie mit den Spritebefehlen arbeiten können, müssen Sie erst einmal ein paar Sprites haben, und zwar in Form von 63 DATAs, wie in den guten alten Zeiten, in denen Sie noch keine Supergraphik hatten. Um diesem Mißstand abzuhelfen, hat Data Becker der Supergraphik-Diskette einen relativ komfortablen Sprite-Editor beigefügt. Dieser hat allerdings drei Mängel: Er mag keine Multicolor-Sprites; er ist aufgrund von eigenen Maschinenroutinen nur dann lauffähig, wenn Supergraphik nicht geladen ist; die von ihm erzeugten Disketten-Files können immer noch nicht von Ihnen und der Supergrafik verwendet werden. Ein kleines abgedrucktes Programm liest angeblich die Files von der Diskette und gibt die entsprechenden Zahlenwerte aus. Aber: Das abgedruckte Programm funktioniert nicht! Deswegen geben wir mit dem Listing 1 allen Supergraphik-Besitzern eine Routine in die Hand, mit der Sie sehr einfach DA-TA-Zeilen aus SPRITEFORMER-Files erzeugen können. Alles, was Sie jetzt zu tun haben ist: Startzeilennummer und Filename eintippen, 15 Sekunden warten, HOME und 21x RETURN drücken. Haben Sie alle Sprites im Speicher, einfach die Zeilen 0 bis 9 löschen und den Rest auf Disk speichern. Wenn Sie die Sprites später brauchen, einfach mit MERGE nachladen.

Mit SREAD können die 63 Daten einer Sprite-Definition in einen String eingelesen werden. Das geht wesentlich schneller als mit einer FOR-NEXT-Schleife. Mit SDEFINE können Sie dann einem der Sprites eine der Stringdefinitionen zuteilen. Dies hat den Vorteil, daß Sie die Definition für ein einzelnes Sprite schnell wechseln und somit Spriteinterne Bewegungsabläufe auch in Basic programmieren können. Mit SMODE legen Sie die übrigen Eigenschaften eines Sprite wie Multicolor, Farben, Größe und Priorität gegenüber dem Hintergrund fest.

Und wie kriegen Sie das nun auf ihre Mattscheibe? Dazu dient der Befehl SSET. Sie können damit nicht nur Sprites setzen, sondern auch bewegen, indem Sie Start- und Zielkoordinaten sowie die Geschwindigkeit angeben. Das Sprite läuft dann von selbst, und Ihr Programm etwas langsamer, das sich das ganze interruptgesteuert abspielt. Wenn Sie auf das Eintreffen eines Sprites am Ziel warten wollen, so hilft ihnen der SWAIT-Befehl weiter.

Und nun zu den in der Werbung angekündigten 16 Sprites, die gleichzeitig auf dem Schirm erscheinen sollen. Ich halte diese Formulierung für ein wenig übertrieben, 2 mal 8 Sprites wäre wohl richtiger. Denn mit dem SPOWER-Befehl können sie ein Bildschirmfenster definieren, in dem 8 andere Sprites erscheinen können, also auf dem restlichen Bildschirm. Sie haben beispielsweise oben 8 Sprites und unten 8 Sprites.

Aber die Supergraphik bietet nicht nur Grafik-Befehle, auch die Tongeneratoren des SID können per Basic angesteuert werden. Mit VOLUME = , legen Sie erst einmal die Lautstärke fest. SOUND dient der Einstellung von Wellenform und Hüllkurve der drei Stimmen. Mit FILTER kann der Filter des SID gesteuert werden. Und als letztes gibt es TUNE, das nach Voreinstellung der oben genannten Parameter einen Ton spielt.

Supergraphik benötigt eine Menge Speicherplatz, Ihnen gehen 10 KByte Ihres Basic-Speichers und sämtliche RAM-Bereiche in der ROM-Gegend, auch der $C-Bereich verloren. Deshalb wird die Supergraphik wohl kaum mit irgendeiner anderen Basic-Erweiterung zusammenarbeiten können. Aus diesen Gründen wurden die »wichtigsten« Programmierhilfen in das Programm mit eingebaut. So bringt der Befehl DIRECTORY selbiges ohne Programmverlust auf den Bildschirm. Mit MERGE können Programme angehängt werden; so ist zum Beispiel ein komfortables Nachladen der Spritedaten möglich. RENUM ist ein Zeilennumerierungs-Befehl; er gleicht auch alle Sprungadressen hinter GOTO, GOSUB an. Ihre Funktionstasten können Sie mit KEY belegen. Sie sind relativ sinnvoll vorbelegt; so ist mit F5/F7 eine Umschaltung zwischen Textseite und Grafikseite möglich. DTASET ist ein gezieltes RESTORE; da hier auch arithmetische Ausdrücke vorkommen dürfen, ist eine Angleichung beim RENUM-Befehl nicht implementiert. Neben der Joystickabfrage ist auch eine Paddleabfrage über PADDLE realisiert worden. Als letztes noch der Befehl POS = ; mit ihm kann im Textmodus der Cursor einfach auf beliebige Spalten und Zeilen gesetzt werden.

Ein anderes Detail, das mir allerdings sehr gut gefallen hat: Bei etwaigen Fehlermeldungen wird von der Grafikseite wieder automatisch auf die Textseite umgeschaltet. Das hält Sie beim Austesten eines Programms immer auf dem Laufenden.

Supergraphik 64 ist ein Programm von Data Becker für 99 Mark, das einerseits durch seine Befehlsvielfalt, andererseits durch einige kleine Details beeindruckt. Einige Mängel schwächen den positiven Eindruck allerdings ein wenig ab. Man sollte aber auf jeden Fall beim Kauf einer Grafikerweiterung Supergraphik 64 in Erwägung ziehen, insbesondere, wenn man es nicht so sehr auf komfortables Sprite-Handling, sondern eher auf ein gutes Werkzeug für hochauflösende Grafiken abgesehen hat.

(Boris Schneider/aa)

# Viel zu schade, um nur damit zu kalkulieren

> Ufer bisher gemeint hat, Multiplan läuft nicht auf dem C 64, erfährt es hier besser. Dieses Tabellenkalkulationsprogramm ist schon seit Jahren für Personal Computer auf dem Markt. Wer aber immer noch glaubt, Multiplan sei nur zum Rechnen und Kalkulieren da, sollte ganz aufmerksam weiterlesen.

Multiplan wurde vor Jahren von der amerikanischen Softwarefirma Micro-Soft für 16-Bit-Computer entwickelt und entpuppte sich vom Start weg als der Renner auf dem Software-Markt.

Seit geraumer Zeit nun findet sich Multiplan 64 mit deutscher Benutzerführung und ebensolchem Handbuch im Handel. Jedem, der jetzt befürchtet, daß dies eine stark abgemagerte Version ist, sei gleich der Wind aus den Skeptikersegeln genommen: Mit häufigem, aber den Arbeitsablauf kaum störenden Nachladen einzelner Systemdateien arbeitet Multiplan auf dem C 64 befriedigend schnell und mit voller Leistung.

Doch gerade diese Leistung und hier besonders wiederum ihre Vielseitigkeit ist wohl für viele der Stolperstein bei Multiplan, obwohl gerade diese Fülle an Möglichkeiten bei Multiplan dieses Programm immer noch interessant macht — besonders dann, wenn man mit einem neidischen Auge auf die jüngste Generation von integrierter Software bei den »Großen« schielt.

Denn gerade wer sich ernsthaft mit seinem C 64 beschäftigt, das soll heißen, wer mit ihm seine Briefe oder Manuskripte schreibt und sein Haus oder seine Wohnungen verwaltet, oder wer mit ihm seinen kleinen Betrieb auf Trab bringt, wird sich schon oft über das häufige Programmwechseln-Müssen geärgert haben. Und nicht jeder kauft sich deshalb gleich einen neuen Computer. Und genau dort liegt der Casus-Knacksus in der Anwendung von Multiplan Richtig in den Griff bekommen und mit ein paar Kunstgriffen und Tricks liefert es uns auf dem C 64 fast schon die gleichen Features wie wesentlich aufwendigere und teurere Programme für große PCs. Doch dazu später und ausführlicher mehr. Kurz noch mal Generelles: Multiplan ist ein sogenanntes Spreadsheet. Ein aus 63 Spalten und 255 Zeilen bestehendes Arbeitsblatt. Jede der Spalten kann in ihrer Breite variiert, und sowohl Spalten wie Zeilen, also jedes einzelne Feld kann mit Daten, Formeln, Funktionen oder Texten gefüllt werden. Hat man sich erst einmal so eine Tabelle nach eigenen Wünschen aufgebaut, reagiert Multiplan auf die geringsten Veränderungen und berechnet getreu den Anweisungen alle betreffenden Positionen neu.

Dies setzten wir einmal als mittlerweile hinreichend bekannt voraus und ersparen uns so die trockenen Erklärungen der Wie und Warums und der einzelnen, über 120 Befehle, Funktionen, mathematischen Kürzel und zahlreichen Fehlermeldungen. (Die Nur-Multiplan-Interessierten mögen trotzdem hier noch nicht aufhören weiterzulesen.)

Diese Vielzahl an frei benutzbaren Möglichkeiten macht Multiplan schon fast zu einer eigenen Programmiersprache. Und sie erklärt, warum diese Software so gleichermaßen beliebt und unverstanden geblieben ist.

Doch kommen wir zum Wesentlichen, zum Programm selber. Jeder Neuerwerber wird erstmal positiv überrascht sein. Denn für seine knapp dreihundert Mark, die er für die C 64-Version von Multiplan dem Händler auf die Theke blättern muß, bekommt er genau 1,56 K. Diesmal handelt es sich aber ausnahmsweise nicht um die Meßlatte für Computerleistung oder Softwarelänge, sondern um die guten alten Kilogrämmer der Marktfrauen. Genausoviel wiegt nämlich das in einer Acrylbox verpackte Handbuch samt Systemdiskette.

## Vorbildliche Dokumentation

Und zu diesem, selbstverständlich ebenfalls deutschen Handbuch, fallen einem eigentlich nur höchstlöbliche Worte ein. Es ist eines, das diesen Namen wirklich verdient. Microsoft hat hier nicht nur ein Nachschlagwerk geschaffen, sie liefern auch gleich ein komplettes und gut aufgemachtes Lehrbuch mit. Alles in allem zeigt dieses 432 Seiten starke Ringbuch, wie gut und auführlich man Bedienungsanleitungen machen kann. Und man fragt sich, warum es dennoch so viele zusätzliche Bücher, auch noch für jeden Computer ein eigenes, über dieses Programm auf dem Markt gibt.

Doch was bietet nun das Multiplan 64 dem Anwender, außer der Möglichkeit, die Auswirkung einer 5prozentigen Preiserhöhung auf seinen Energie- oder Wirtschaftshaushalt zu kalkulieren? Kann es mehr, als nur ausrechnen, ob nun 6,78% Zinsen auf 35 Jahre oder 7,86% Zinsen auf 5 Jahre günstiger sind? Und lohnen sich die drei Blauen für die meistverkaufte Software der Welt in einem Handwerksbetrieb oder Kleinversand, damit der Inhaber dann elektronisch weiß, daß er bei 3,5% mehr Spanne tatsächlich auch mehr verdient? Um es gleich vorwegzunehmen: JA. Man muß nur wissen wie ...

Wer sich durch die Befehlsvielfalt von Multiplan 64 durchgewühlt hat, wird vielleicht schnell feststellen, daß sich dieses Programm ganz ausgezeichnet in einzelne, immer wieder aufrufbare Module unterteilen läßt. Ein etwas größeres für zum Beispiel die Rechnungsstellung oder das Angebotswesen mit wiederum kleineren Modulen für die jeweiligen Posten und Kosten. Durch die Option der Formeln hat man bei der Gelegenheit auch gleich noch einen Überblick über den augenblicklichen Stand der geschriebenen Angebote, Kosten, Einnahmen oder was auch immer gewünscht wird.

Für eine kleine und natürlich nur eingeschränkt komfortable Textverarbeitung reicht es schon aus, die Spaltenbreite entsprechend zu vergrößern und die Felder mit dem Befehl »Zusamm(en)« zu kennzeichnen (Bild 1). Schon schreibt Mulitplan brav den eingetippten Text Zeile für Zeile ins Arbeitsblatt. Der Ausdruck des Geschriebenen erfolgt mit dem Befehl >>Z(eilen)/S(palten)-Nummern: Ja (Nein)« auch ohne die, bei Briefen unangebrachten, Numerierungen.

Noch besser geeignet ist Multiplan für das Angebots- und Rechnungswesen (Bild 2). Hier zeigt es seine wahren Stärken, wenn man mal von dem Nur-Kalkulieren absieht. Da Angebots- und Rechnungstexte meist gleichlautend sind, bedarf es hierfür nur je eines Moduls. In diesem sind Text, Artikeldaten und natürlich die Formeln (Artikel mal Stückpreis gleich Angebot plus Mehrwertsteuer) »programmiert«. Bei Anfrage und noch besser nach Lieferung holt man sich das Modul als Datei in den Rechner, braucht nur noch die gelieferten Waren einzugeben und ab die Post.

Auch eine Hausverwaltung ist kein Problem. Einmal programmiert, liefert die Datei die Vorgaben, und die Mieter haben ihre Nebenkostenabrechnung wenig später auf dem Tisch (Bild 3). Den Anwendungen sind praktisch keine Grenzen gesetzt. Der kleine Betrieb spart sich zum einen den permanenten Programmwechsel und zum anderen auch Geld für teure Einzel-Software. In Kauf nehmen muß er dafür nur einige Stunden Anpassungsarbeit und die, allerdings rechnerbedingte, manchmal und bei ziemlich vollem Arbeitsplatz etwas langsame Geschwindigkeit, hat dafür aber eben alles in einem.

Wem diese Arbeit dennoch zuviel ist, kann sein Multiplan 64 auch weiterhin nur für seine Kalkulationen unterbelasten. Was allerdings schade wäre.

(Klaus Koch/aa)

# David und Goliath

> Für den C 64 sind inzwischen diverse Zeichenprogramme auf dem Markt. Sie werden mit dem Lichtgriffel, dem Joystick oder mit Paddles gesteuert. Interessant sind in diesem Zusammenhang auch Grafik-Tabletts.

Das Grafik-Tablett »Super Sketch« von PPI (Personal Peripherals, Inc) ist fast vier mal so groß als das »Koala Pad« von Koala Ware. Dem »Koala Pad« liegt eine Diskette mit dem dazugehörigen Programm »Koalapainter« und einigen Beispielbildern bei. Bei PPI wurde das Programm »Graphics-Master« für den »Super Sketch« in ein Steckmodul gepackt. Auf der mitgelieferten Diskette befindet sich lediglich ein Demo-Programm, um die Fähigkeiten des »Graphics-Master« aufzuzeigen. Die Kabel beider Tabletts werden in den Control Port 1 des C 64 gesteckt.

Das »Koala Pad« besitzt eine dunkelgraue druckempfindliche Zeichenfläche, die es erlaubt, mit einen mitgelieferten Stift oder mit dem Fingernagel am Bildschirm zu zeichnen (natürlich nur mit dem dazugehörigem Programm). Über der Zeichenfläche befinden sich zwei Tasten, die jedoch beide die gleiche Funktion haben. Sie werden zur Auswahl im Menü und zum Zeichnen benötigt.

Das Zeichnen mit dem »Super Sketch« ist leider nicht so komfortabel wie mit dem »Koala Pad«. Hier wurde ein Zeiger über einen Kontrollarm mit zwei Paddles verbunden. Diese Version ist in der Herstellung billiger, hat jedoch den großen Nachteil, daß beim Zeichnen immer der ganze Arm mitbewegt werden muß. Dies führt zu recht zackigen Bewegungen. Trotz der größeren Zeichenfläche des »Super Sketch«,.werden oft feinere Bewegungen des Kontrollarms nicht wahrgenommen, da die Paddles diese Bewegungen kaum registrieren. So ist exaktes Zeichnen recht schwierig.

Mit dem »Koala Pad« ist das Zeichnen von kleinen Details trotz der kleineren Zeichenfläche einfacher, da jede kleinste Bewegung auf der druckempfindlichen Membrane an den Computer weitergegeben wird. Das »Super Sketch«- Tablett besitzt fünf Tasten. Der große »RELEASE«- Taster in der Mitte der Tastenreihe hat nur mechanische Funktion. Er hebt die Papierhalter auf beiden Seiten des Tabletts, an denen man Vorlagen befestigen kann.

Damit das Tablett sowohl von Links- als auch von Rechtshändern bequem bedient werden kann, wurden jeweils am linken und am rechten Rand der Tastenreihe eine »LIFT«-Taste angebracht. Wenn eine dieser Tasten gedrückt ist, kann der Kontrollarm bewegt werden, ohne daß der »Graphics-Master« am Bildschirm zeichnet. Beim »Koala Pad« ist dies umgekehrt, denn hier muß beim Zeichnen eine der beiden Tasten gedrückt werden. Die »LIFT«-Taste hat weiterhin die Aufgabe, das Menü des »Graphics-Master« zu verlassen und auf Zeichenbetrieb umzuschalten. Weiterhin befinden sich noch eine »MENÜ«-Taste und eine »SELECT«-Taste auf dem Tablett. Mit der »MENÜ«-Taste wird der Zeichenmodus unterbrochen, und am linken Bildschirmrand erscheint das Hauptmenü. Mit dem Kontrollarm kann nun auf die gewünschte Option gezeigt und mit der »SELECT«-Taste ausgewählt werden.

## Software im Steckmodul

Beide Programme (Koalapainter und Graphics-Master) besitzen fast die selben Fähigkeiten. Wie schon erwähnt muß der »Koalapainter« im Gegensatz zum »Graphics-Master« erst von der Diskette geladen werden. Nach dem beeindruckendem Titelbild erscheint das sehr übersichtliche Menü. Hier kann zunächst die Pinselform ausgewählt werden. Es stehen acht verschiedene Stärken zur Verfügung. Das Auswählen ist denkbar einfach. Man drückt zunächst mit dem Stift oder dem Finger auf die Oberfläche des Zeichentabletts, und es erscheint ein Cursor, den man nun durch Stift- oder Fingerbewegung auf das gewünschte Symbol führt und eine der beiden Tasten drückt. Genauso kann mit dem Cursor eine Farbe aus der Farbpalette ausgesucht werden. Zum Zeichnen wählt man mit dem Cursor das Symbol »Draw« an, und schaltet auf den Zeichenbildschirm um. Dies geschieht, in dem man mit den Stift an das untere Ende des Zeichentabletts fährt, so daß der Cursor nicht mehr sichtbar ist, und eine der oberen Tasten betätigt. Das Umschalten zum Menü erfolgt auf die gleiche Weise. Zum Zeichnen benötigt man nun beide Hände, da der Pinselstrich erst angenommen wird, sobald eine der beiden Tasten gedrückt ist. Läßt man die Taste los, fährt der Cursor über das Bild, ohne einen Spur zu hinterlassen. Doch »Draw« ist nur eine von 17 verschiedenen Optionen des »Koalapainters«.

So können mit »Frame« beliebig große Vierecke ins Bild gesetzt werden. Mit »Box« füllt man diese gleich mit der gewählten Farbe. Die Option »Circle« generiert Kreise. Mit »Disk« werden diese ebenfalls farbig ausgefüllt. Hier sei erwähnt, daß leider nur die Größe der Kreise und nicht deren Form beeinflußbar ist, so daß diese nicht rund sondern oval auf dem Bildschirm erscheinen. Durch »Xcolor« kann eine Farbe durch eine andere ersetzt werden. Die Option »Mirror« teilt den Bildschirm durch vertikale und horizontale Teilung in vier gleich große Teile. Zeichnet man nun in einem der vier »Quadranten« so wird dies an der X- und Y-Achse gespiegelt und erscheint auch in den angrenzenden »Quadranten«, natürlich spiegelverkehrt. »Line« verbindet zwei Punkte durch eine Linie miteinander. Die Option »Lines« beschränkt dies nicht auf zwei Punkte. Es können also beliebig viele Punkte mit einer Linie verbunden werden. Mit »Rays« läßt sich ein Strahlenbündel erzeugen. Die Option »Fill« füllt eine begrenzte Fläche mit einer bestimmten Farbe auf.

Sehr interessant ist »Zoom«. Mit ihr kann ein bestimmter Bildschirmausschnitt vergrößert und herangeholt werden (Bild 2). Außerdem erscheinen am unteren Rand des »Zoom«-Fensters alle 16 Farben, so daß Details sehr genau gezeichnet werden können. Zu Beachten ist allerdings, daß in einer 8x8-Matrix nicht mehr als vier Farben vorkommen dürfen. »Copy« dupliziert einen beliebigen Bildausschnitt. Hier sind auch Überlagerungen möglich. »Swap« schaltet zwischen ersten und zweiten Zeichenbildschirm um. Hat man einen entscheidenden Fehler gemacht, zum Beispiel eine falsche Fläche ausgefüllt, so kann dies durch den Befehl »Oops« rückgängig gemacht werden. Das Bild erscheint dann wie vor dem letzten Wechsel zum Menü. Mit »Erase« kann die Zeichnung wieder gelöscht werden. Die 17te und letzte Option »Storage« schaltet auf das Disk-Menü um. Hier können Bilder geladen, abgespeichert und Disketten formatiert werden. Auf der Diskette befinden sich einige Kunstwerke wie zum Beispiel das Bild »Jungle« (Bild 1).

## Super Sketch

Das Programm »Graphics-Master« befindet sich auf einem Steckmodul. Wird die Menü-Taste gedrückt, erscheint eine leere Zeichenfläche, an deren linken Seite sich das Hauptmenü befindet — leider nicht so übersichtlich wie bei »Koalapainter«. Im Gegensatz zu »Koalapainter« kann hier aber die Pinselform selbst kreiert werden. Hierfür wählt man mit dem Kontrollarm die Option »brush« an. Zum Zeichnen stehen natürlich auch alle 16 Farben zur Verfügung. Hier funktioniert das Zeichnen jedoch anders. Das Zeichenbrett registriert jede Bewegung und hinterläßt, wenn die »LIFT«-Taste nicht gedrückt wurde, ungewollte Spuren in der Zeichnung.

Nun zu den einzelnen Befehlen: »clear« löscht logischerweise den Bildschirm. Die Befehle »swap«, »fill« und »draw« haben gleiche Funktionen wie bei »Koalapainter«. Die Option »eraser« simuliert einen Radiergummi. Mit »undo« können (wie mit »Oops« beim »Koalapainter«) Fehler rückgängig gemacht werden. Auch der »Graphics-Master« besitzt zwei Zeichenflächen, zwischen denen mit »page« umgeschaltet werden kann. Beim »Koalapainter« werden bei »Fill«, »Box« und »Disk« nur begrenzte Flächen mit Farbe aufgefüllt. Beim »Graphics-Master« bieten sich mit »design« weitere Möglichkeiten, Flächen auszufüllen. So kann ein Zeichenmuster entworfen werden, mit dem eine Fläche aufgefüllt wird.

Mit der letzten Option im Hauptmenü »expert« wird auf das »Expert-Menü« umgeschaltet. Hier finden sich die Befehle »lines«, »rays«, »circle«, »box«, »copy« und »zoom« wieder, die auch dieselbe Bedeutung wie beim »Koalapainter« haben. Hier sei jedoch erwähnt, daß es mit »circle« möglich ist, wirklich runde aber auch ovale Kreise (Ellipsen) darzustellen.

Kommt man mit einem Kreis über den Bildschirmrand hinaus, so wird dieser im Gegensatz zum »Koalapainter« nicht hinausgeschoben sondern »staut« sich am Bildschirmrand. Das »zoom«-Fenster ist leider nicht so komfortabel, da keine Farbänderung vorgenommen werden kann. Das Fenster erscheint am linken unteren Eck der Zeichenfläche und ist nicht annähernd so groß wie beim »Koalapainter« (Bild 4). Mit der Option »h or v« können nur horizontale oder vertikale Linien gezeichnet werden, »window« erlaubt es, daß sich bestimmte Befehle wie »clear« oder »fill« nur auf den durch »window« gekennzeichneten Bereich, beschränken.

Die Option »copy 1/2« kopiert Bildausschnitte von der ersten zur zweiten Zeichenfläche oder umgekehrt. »quad« hat die gleiche Funktion wie »Mirror« beim Koalapainter, während »mirror« beim »Graphics-Master« den Bildschirm nur vertikal trennt. Die Option »flip« spiegelt jede Tätigkeit an einer horizontalen Trennlinie des Bildschirms. Mit »show« können Sie Ihr Meisterwerk bewundern, ohne daß ein flackernder Cursor Sie ablenkt. Die Option »reset« schaltet »window«, »quad«, »mirror«, »flip« und »zoom« wieder aus. »files« hat die selbe Bedeutung wie »Storage« beim Koalapainter. Nur kann hier auch mit Kassette gearbeitet werden. Es bleibt hier noch zu erwähnen, daß mit »Super Sketch« und »Graphics-Master« auch die Bilder vom »Koalapainter« geladen und bearbeitet werden können. Künstlerisch gelungen ist der Pelikan (Bild 5).

Beide Handbücher sind recht ausführlich. Jedoch muß man seine Englischkenntnisse wieder hervorkramen, da beide Bedienungsanleitungen englisch abgefaßt sind. Dem »Super Sketch« liegen außerdem einige Vorlagen bei, die auf dem Tablett befestigt werden können. Beim Nachzeichnen braucht man einiges Geschick, um mit dem Kontrollarm exakt der Vorlage zu folgen.

Da die Hardware von PPI dem »Koala Pad« unterlegen ist, versucht man mit zusätzlichen Funktionen im »Graphics-Master« wieder an Boden zu gewinnen. Ob dies gelingt ist Ansichtssache.

(Christian Quirin Spitzner/rg)

# Grafik hoch zwei – das Extended Graphik System

> Eine der interessantesten, aber auch schwierigsten Anwendungen des Commodore 64 ist die Grafikprogrammierung. Mit dem Extended Graphik System geht es einfacher.

Mit dem Extended Graphik System hat Interface Age ihre bekannte Ex-(tended-)Produktreihe fortgesetzt und dem Programmierer ein taugliches Werkzeug in die Hand gegeben. Die Konzeption dieses Programmpaketes beruht auf der Philosophie, dem Grafikinteressierten im Handbuch Kenntnisse zu vermitteln, die dieser dann sofort in der Praxis erproben kann. Das umfangreiche deutsche Handbuch hat deshalb auch den Charakter eines gut gemachten Lehrbuches. Angefangen mit der Darstellung des VIC 6567 (Video Interface Chip) über die Erklärung der Speicheraufteilung bis zum Anwendungsbeispiel wird Schritt für Schritt vorgegangen.

Für die praktischen Übungen wird nicht nur das Standard-Basic eingesetzt, sondern das von Diskette ladbare Extended Graphik System. Diese Erweiterung verändert den Speicher des Commodore 64. So werden beispielsweise neue Befehle implementiert, und der Videobereich verlegt. Nach dem Start des Graphik Systems beginnt der Basic-Speicher beispielsweise bei Speicherstelle 1024 (früher lag da der Bildschirm). Insgesamt bleiben dem Anwender 15,5 KByte für seine Programme. Das ist allerdings mehr, als die Zahl andeutet. Weder für einen neuen Zeichensatz noch für bis zu 175 Spritedaten geht etwas vom Basic-Speicher verloren. Weiterer Vorteil des Grafik-Systems ist es, daß der Bereich für Autostartmodule weiterhin verfügbar ist. Das bekannte Extended Basic Level II kann zur gleichen Zeit eingesetzt werden. Das Grafik System ersetzt die im Extended Basic weitgehend fehlenden Grafikbefehle.

Die Leistungsfähigkeit der neuen Grafikbefehle, die übrigens alle mit dem Vorsatz »CALL« aufgerufen werden, zeigen die mitgelieferten Hilfsprogramme. Dazu gehören Zeicheneditor, ein Spritegenerator und ein Grafikeditor. Mit dem Zeicheneditor ist es eine Leichtigkeit den Zeichensatz den persönlichen Wünschen anzupassen. Der Spriteeditor dient dem schnellen Entwerfen von Single- und Multicolor Sprites. Am leistungsfähigsten ist aber der Grafikeditor, mit dem eigene Hires-Grafiken hergestellt, beziehungsweise bestehende verändert werden können. Zum Befehlsvorrat des Grafikeditors gehören Funktionen zum Zeichnen von Kreisen, Linien, Rechtecken sowie die Einblendung von Texten in die hochauflösende Grafik. DerVorteil dieses Konzeptes ist die Flexibilität, denn eine Anpassung und Erweiterung der Hilfsprogramme ist jederzeit möglich.

Der fortgeschrittene Programmierer wird aber wahrscheinlich mehr am Graphik System interessert sein. Seine Erwartungen werden nicht enttäuscht, denn der Befehlsvorrat ist umfangreich und den gewachsenen Kenntnissen angepaßt. Die Schwerpunkte liegen bei der Farbgebung (Hires und Text), der Spriteverwaltung und -Bewegung (Single- und Multicolor) sowie der Unterstützung hochauflösender Grafik. Bis auf den Befehl zum Ausfüllen bestimmter Flächen (Fill) ist der Befehlsumfang komplett. Für ein flexibles Werkzeug wie das Extended Graphik System ist es fast schon eine Selbstverständlichkeit, daß Bilder von anderen Grafikprogrammen (Micropainter, Koala, Doodle) eingeladen und verarbeitet werden können. Zur Verarbeitung gehören alle Manipulationen am Bild einschließlich der Hardcopys auf einem grafikfähigen Drucker. Besonders sinnvoll ist die Fähigkeit auch Spriteformen auf allen Druckern auszugeben.

Nicht nur der Anfänger wird es schätzen, daß alle wichtigen Programme im umfangreichen Handbuch abgedruckt sind. Sinnvoller wäre es allerdings, diese Programme auf der ohnehin vorhanden Diskette mitzuliefern, zumal die Listings nicht immer fehlerfrei sind. Auf die vielen Beispielbilder für hochauflösende Grafik hätte statt dessen verzichtet werden können. Auch fehlt der Hinweis, daß Programme, die mit dem Graphik System entworfen wurden, auch nur mit diesem wieder gestartet werden können. Ein kleines Ladeprogramm schafft hier Abhilfe, indem das Graphik System jedesmal vor das betreffende Programm geladen wird. Weitergeben darf man diese Programme allerdings nicht, denn damit wäre das Urheberrecht verletzt.

Das Extended Graphik System ist auch für den fortgeschrittenen Programmierer ein sinnvolles Hilfsmittel. Zusammen mit Exbasic Level II ist es zwar nicht ganz billig, aber fast unschlagbar. Besonders lobenswert ist das Handbuch, das schrittweise in die Grafikprogrammierung einweist und noch nach mehrmaligem Lesen bei wichtigen Fragen herangezogen werden kann.

(Arnd Wängler/aa)

Bezugsquelle: Interface Age, Josephsburgstraße 6, 8000 München 80. Preis: 138 Mark.

# Viza Star – Ein Stern wird geboren – der Commodore 64

> Als erstes deutsches Computermagazin testeten wir Vizastar, die neue Datenbank-Tabellenkalkulations- und Geschäftsgrafiksoftware für den C 64.

In unserer letzten Ausgabe haben wir Vizawrite 64 vorgestellt, eines der leistungsfähigsten Textverarbeitungsprogramme für den C 64, wenn nicht sogar das leistungsfähigste überhaupt. Der Commodore 64 stößt damit in die Klasse der kleinen (aber vor allem preiswerten) Personal Computer vor. Zu den Fähigkeiten eines Personal Computer gehört aber mehr, als nur die Textverarbeitung. Drei der meistgebrauchten PC-Anwendungen sind die Datenverwaltung, die Tabellenkalkulation und die Geschäftsgrafik. Oft werden diese Funktionen in einem Programmpaket (zum Beispiel Lotus 1 2 3) kombiniert angeboten. So auch Vizastar 64. Bis auf die Textverarbeitung sind alle anderen Komponenten in Vizastar 64 vereinigt. Obwohl natürlich die Datenübertragung von einer Funktion in die andere (auch in die Textverarbeitung) möglich ist, soll hier zunächst auf die Leistungsmerkmale der einzelnen Funktionen eingegangen werden.

Vorab aber ein paar allgemeine Worte zu Vizastar 64 an sich. Geliefert wird das Programmpaket auf zwei Datenträgern, einem Modul und einer Diskette. Das Modul beinhaltet einen wesentlichen Teil des Steuerprogramms und lädt automatisch die restlichen Programmteile von der Diskette nach. Nach dem Laden kann die Programmdiskette weggelegt werden. Das gesamte Steuerprogramm (reine Maschinensprache) befindet sich im Speicher. Ab da wird nur noch mit Datendisketten gearbeitet. Die von Vizawrite 64 bekannten Einstellmöglichkeiten auf verschiedene Laufwerkskonfigurationen, die Farbgebung und den angeschlossenen Drucker sind auch in Vizastar 64 enthalten. Ein Centronics-kompatibler Drucker kann mit einem einfachen Userport-Kabel direkt angeschlossen werden, die Centronics-Treibersoftware wird immer mitgeladen. Vizastar 64 unterstützt eine große Anzahl von Druckermodellen wie beispielsweise CBM, Epson, Juki und Brother. Zum Lieferumfang gehört ebenfalls ein 90-seitiges ausgezeichnetes deutsches Handbuch. Ein zusätzliches Übungsbuch, ist nach Auskunft des Herstellers, in Kürze erhältlich. Die getestete Vorab-Version verfügte über keinen deutschen Zeichensatz, in der endgültigen Version soll er aber enthalten sein. Auch die Benutzerführung von Vizastar 64 ist noch englisch, die Kommandos sind allerdings einfach und einprägsam.

## Die Tabellenkalkulation

Nach dem zirka 115 Sekunden dauernden Laden erscheint das Arbeitsblatt (Bild 1). Es ist wie ein richtiges Stück grafisches Papier aufgebaut. In den oberen drei Zeilen befinden sich die Menü- und Kommandohinweise. Die jeweils geltende Funktion wird revers. dargestellt. Durch Druck auf die »Space«-Taste wird von Menüpunkt zu Menüpunkt gesprungen. Die jeweiligen Unterfunktionen erscheinen in Zeile 2 und 3. Ein Arbeitsblatt besteht aus Zeilen (0 bis 999) und aus Spalten (A bis BL). Jede Spalte kann eine beliebige Breite zwischen 3 und 36 Bildschirmspalten haben. Das Arbeitsblatt ist natürlich viel zu groß um als Ganzes auf dem Bildschirm zu erscheinen. Deshalb ist immer nur ein Teil abgebildet. Mit den Cursortasten wird der Arbeitsblattausschnitt über den Bildschirm verschoben. Ein direkter Sprung an eine Adresse ist natürlich auch möglich. Manchmal wird es notwendig, an verschiedenen Punkten des Arbeitsblattes auf einmal zu arbeiten. Vizastar 64 bietet deshalb eine »Window«-Funktion (Bild 2) an, mit der beliebige Teile des Arbeitsblattes auf dem Bildschirm eingeblendet werden (bis zu acht Windows). Die »optisch« darunter liegenden Informationen gehen natürlich nicht verloren, sondern bleiben weiterhin im Berechnungsprozeß eingebunden. Die Schnittpunkte zwischen den Zeilen und Spalten nennt man Zellen (insgesamt 64000). Jede Zelle hat ihre eigene »Adresse«, so heißt beispielsweise die erste Zelle A0, die rechts daneben liegende B0. Die Zellen sind der kleinste Informationsträger. Hier werden Texte und Zahlen gespeichert. Da aber jede Zelle ihre eigene Adresse hat, sind die verschiedensten Verknüpfungen zwischen den einzelnen Zellen möglich. Das Ergebnis einzelner Berechnungen wird wiederum in vorher definierten Zellen abgelegt, beziehungsweise beeinflußt alle von diesem Ergebnis abhängigen Zellen. Ein Beispiel soll dies verdeutlichen: Nehmen wir an, Sie wollen die jährlichen Kosten Ihres Autos berechnen. Aber Sie wollen auch wissen, was passiert, wenn der Benzinpreis steigt, oder wenn Sie mehr Kilometer fahren. Diesen Sachverhalt nennt man in der Betriebswirtschaft »Entscheidungsfindung«. Sie erhalten Auskünfte über die Auswirkungen einzelner Maßnahmen in Abhänigkeit von vorgegebenen Werten und Bedingungen.

Bild 3 zeigt, wie so ein Kalkulationsblatt aussehen könnte. Feste Werte sind Anschaffung, Reparaturen und Zubehör. Alle anderen Werten werden von Vizastar 64 anhand von Verknüpfungsbedingungen errechnet. Der Wertverlust wurde im Jahr 1982 mit 15% vom Anschaffungspreis angegeben. Der Anschaffungspreis von 1983 ist natürlich der Restwert von 1982. Die Benzinkosten werden in Abhängigkeit von den gefahrenen Kilometern und dem Benzinpreis berechnet. Ändert man nun auf dem Arbeitsblatt eine der unabhängigen Zahlen, zum Beispiel die gefahrenen Kilometer verändern sich sofort die Benzinkosten, und die Gesamtkosten pro Jahr. In Bild 4 sieht man was geschieht, wenn der Benzinpreis auf 2 Mark und die gefahrenen Kilometer auf 15000 ansteigen. Vizastar 64 bietet eine große Anzahl von Verknüpfungsfunktionen (Bild 5), die für optimale Geschwindigkeit sorgen. Damit aber auch die Eingabe der Werte und Formeln einfach zu handhaben ist, stehen dem Benutzer umfangreiche Editierbefehle zur Verfügung. Sie reichen vom Einfügen und Löschen einzelner Zeilen/Spalten über das Sortieren von Reihen bis zum Kopieren und Verschieben ganzer Blöcke.

Ganz besonders leistungsfähige Funktionen sind die sogenannten EXEC-Befehle. Dieser Operationsmodus verwendet den Inhalt des Arbeitsblattes um die Tastatur zu simulieren. Sich wiederholende Befehlssequenzen (ähnlich einem Basic-Unterprogramm) können in Spalten innerhalb des Blattes eingetippt und zu jedem Zeitpunkt wiederholt ausgeführt werden. Zusätzliche EXEC-Befehle erlauben das bedingte Überspringen zu anderen Zellen. Imposantestes Beispiel für die EXEC-Befehle ist das auf der Systemdiskette mitgelieferte Demo-File, das einen kompletten Arbeitsablauf inklusive bewegter Grafik simuliert. Alle diese Funktionen werden mit unglaublicher Geschwindigkeit ausgeführt (man glaubt gar nicht wie schnell der C 64 sein kann). Das Abspeichern einzelner Arbeitsblätter zur späteren Verwendung ist für Vizastar 64 eine Selbstverständlichkeit. Damit sind die Anwendungsmöglichkeiten des Arbeitblattes natürlich bei weitem noch nicht ausgeschöpft. Aber gerade dank der Flexibilität der Arbeitsblattfunktionen ist es für jeden Anwender möglich, sich seine eigene Problemlösung zu kreieren. Vizastar 64 unterstützt ihn dabei mit seiner Leistungsfähigkeit und der sinnvollen Benutzerführung.

## Die Datenbank

Der zweite Bestandteil von Vizastar 64 ist die Datenbankfunktion. Die Operationen dieser Datenbank werden aufgerufen, als ob sie Teile des Kalkulationsprogrammes wären — was sie eigentlich auch sind. Vom Kalkulationsprogramm kann, ohne daß etwas nachgeladen werden muß, direkt in die Datenverwaltung und zurückgesprungen werden (inklusive Datentransfer). Das Arbeitsblatt verwandelt sich dabei zur frei definierbaren Karteikarte. Wie eine solche Karteikarte aufgeteilt aussehen könnte, zeigt Bild 5. Spezielle Zeichenbefehle ermöglichen den Einsatz des gesamten Commodore-Zeichensatzes. Die Eingabemaske kann somit extrem individuell gestaltet werden. Der Anwender ist nicht an eine Karteikarte gebunden, sondern kann einen einzelnen Eintrag über mehrere Karten ausdehnen. Auch ist die spätere Umgestaltung (Einfügen, Löschen) der einzelnen Karteikarten jederzeit möglich. Der grundsätzliche Aufbau der Datenbank ist mit dem Superbase 64 zu vergleichen. Grundsätzlich kann eine Vizastar 64-Datenbank aus bis zu 15 Einzeldateien bestehen. Ein Datensatz (Record) besteht aus bis zu 1000 Zeichen (Superbase 1108). Pro Satz sind 64 verschiedene Felder mit maximal 128 Zeichen pro Feld möglich (Superbase 127 Felder/255 Zeichen). Bei jedem Feld muß ein Indexschlüssel definiert werden, damit jeder einzelne Eintrag schnell aufgerufen werden kann. Ein Feld, das als Index-Schlüssel dient, hat eine maximale Länge von 30 Zeichen (Superbase 30). Da die Daten gemäß dem Schlüssel in alphabethischer oder numerischer Reihenfolge auf der Diskette geordnet sind, ermöglicht dieser Schlüssel beinahe den sofortigen Zugang zu jedem Datensatz innerhalb des Files. Die Zugriffszeit beträgt dabei im Durchschnitt nur 4 Sekunden pro Record. Die Anzahl der Datensätze (Records) findet bei Vizastar 64 ihre einzige Beschränkung in der vorhandenen Disketten-Speicherkapazität. Beim 1541-Laufwerk kann beispielsweise eine Kundenkartei (Name, Adresse, Tel. Ansprechpartner, Datum) über 500 Datensätze enthalten. Sind zwei Laufwerke angeschlossen, oder die SFD 1002, erhöht sich die Anzahl der Datensätze. Hierbei sei angemerkt, daß der Anschluß der SFD 1001 nicht problemlos ist, da das Commodore IEEE-Interface den Einsatz eines zusätzlichen Moduls mit Autostart nicht zuläßt. Der Zugriff auf die einzelnen Daten eines Files wird mit dem ACCESS-Befehl ausgeführt. Dieser Befehl erlaubt es, jeden Eintrag nach Wünschen einzugeben, abzurufen zu ändern oder zu löschen. Die Auswahlkriterien können definiert werden, so daß nur die gewünschten Einträge ausgewählt werden.

Mit etwas Übung und Geschick dauert es mit Vizastar 64 nicht lange, eine Buchhaltung oder eine Lagerbestandskartei aufzubauen. Im privaten Sektor ist an Anwendungen wie eine Bücher- oder Adreßdatei zu denken. Alle Daten, auch die des Arbeitsblattes, können mit Vizastar 64 auch ausgedruckt werden. Dazu dienen zwei Funktionen. Wenn ein grafikfähiger Drucker angeschlossen ist genügen zwei Tasten um eine entweder 1:1 oder 1:2 Hardcopy auf dem Drucker auszugeben. Nicht grafikfähige Drucker tun das zwar auch, haben aber keine reversen Zeichen beim Ausdruck. Datensätze können in beliebiger Form, zum Beispiel als Adreßaufkleber auf fast jedem Drucker oder Schreibmaschine zu Papier gebracht werden.

Der dritte Bestandteil von Vizastar 64 ist die Geschäftsgrafik. Der Anwender hat hier die Wahl zwischen Balken- oder Liniendiagrammen (Bild 6 und 7). Die abzubildenden Werte lassen sich aus beliebigen Bereichen des Arbeitsblattes entnehmen. Mit Hilfe der. EXEC-Funktion sind sogar Änderungen bestimmter Werte im Zeitverlauf darstellbar. Die Trendanalyse (ein wichtiges betriebswirtschaftliches Instrument) wird somit ungemein erleichtert. Durch die oben besprochene Window-Technik ist auch eine optisch ansprechende Abbildung bestimmter Werte denkbar. Grafik, Zahlen und Kommentare können beliebig gemischt werden.

Fazit: Es gibt keinen Zweifel, Vizastar 64 ist eines der leistungsfähigsten Programme, — aus dem Bereich Datenbank und Tabellenkalkulation —, das bisher in unserer Redaktion getestet wurde. Es zeichnet sich nun auch bei den Heimcomputern — wie bereits bei den PCs seit einem Jahre — der Trend zur integrierten Software ab. Die genaue Beschreibung aller Befehle von Vizastar 64 würde den Rahmen bei weitem sprengen. Zusammen mit Vizawrite 64 ist Vizastar 64 die optimale Programmausstattung für den Commodore 64. Nicht nur der Privatmann, sondern gerade der kleine Unternehmer wird viele seiner täglichen Entscheidungen mit Vizastar 64 leichter und genauer beurteilen können. Der einzige Nachteil dürfte die geringe Kapazität von zirka 9 KByte für Daten sein.

Wie eine Commodore 64-»PC«-Konfiguration aussehen könnte, haben wir in Bild 8 darzustellen versucht. Es besteht aus dem C 64, einem Floppy-Laufwerk, einem Farbmonitor, einem Matrix- und Typenraddrucker sowie aus dem Viza-Paket. Der Preis für das gesamte System liegt bei zirka 6500 Mark (mit den beiden Druckern), wobei Vizawrite 64 und Vizastar 64 mit etwa 700 Mark beteiligt sind. Man könnte in Anbetracht der Leistungsfähigkeit schon fast von »billig« reden.

(Arnd Wängler/aa)

Deutschland: Interface Age, Josephsburgstr. 6, 8000 München 80
Bezugsquellen: Microton, Postfach 40, CH-2542 Pieterlen, Preis: 398,—

# Exodus – Ultima III

> Exodus, auch als Ultima III bekannt, ist die Fortsetzung zum vorhergehenden Verkaufshit »Ultima II«. Exodus ist ein Spiel, an dem man entweder ewig spielt oder verzweifelt: Zum Lösen des Spiels benötigt man zirka fünf Wochen — ein Tagespensum von 10 Stunden vorausgesetzt.

Ultima III ist zwar die Fortsetzung zu Ultima II, das man aber zum Spielen von Exodus nicht benötigt. Um die Handlung von Ultima III zu begreifen, muß jedoch auf die Geschichte des zweiten Teils zurückgegriffen werden:

Das Ziel des C-64-Spiels Ultima II war, den bösen »Minax« zu eliminieren. Als dieser schließlich starb (nachdem der Spieler Ultima II gelöst hat), herrschte im Lande schließlich 20Jahre lang Frieden. Doch die Horden des Bösen kamen wieder. Exodus, der Sohn des toten Minax, wählte den richtigen Augenblick, um das Land »Sosaria« erneut mit Tod und Verderben heimzusuchen. Ihre Aufgabe ist es nun, mit einer Gruppe von vier Abenteurern, das Land Sosaria vom Bösen zu befreien.

Sie sehen sich der Aufgabe gestellt, das Land zu erkunden und das Böse wo es auftritt zu zerstören. Das Endziel ist, Exodus zu finden und zu vernichten.

Zunächst wählt man unter seinen Charakteren vier »Adventurer« aus, mit denen man in eine Welt der Gefahren aufbricht. Zur Wahl stehen zehn verschiedene Charakterklassen (»Fighter, Paladin, Ranger, Barbar, Alchemist, Druid, Cleric, Wizard, Illusionist, Thief«), die man mit fünf verschiedenen Rassen kombinieren kann (»Human, Elf, Dwarf, Fuzzy, Bobbit«). Jede dieser Charakterklassen hat bestimmte Attributwerte: Ein Kämpfer hat seine Stärke, ein Zauberer seine Intelligenz, ein Dieb seine Geschicklichkeit, etc. Die Rasse ist mitentscheidend für die Maximalverteilung der Werte: Ein Zwerg kann seine Stärke auf bis zu 95 Punkte bringen, seine Geschicklichkeit jedoch höchstens auf 50. Die Maximalwerte für Menschen sind für alle Werte 75 Punkte. Zusätzlich steht Ihnen noch die Wahl des Geschlechts Ihrer Spielfiguren offen: Männlich, weiblich oder »other« (was das ist, dürfen Sie sich selbst überlegen).

Durch die geeignete Zusammenstellung Ihrer Charaktere und deren Attributwerte, sichern Sie sich also Ihr Überleben und den eventuellen Erfolg. Bei unglücklicher Auswahl der Charaktere, zum Beispiel lauter schwache Zauberer und nichts anderes, werden Sie sehr bald auch große Mißerfolge erleben müssen.

Wenn Sie in die weite Welt hinausziehen, begegnen Ihnen viele verschiedene Kreaturen, einige gut und viele böse. Sind die Kreaturen Ihnen freundlich gesinnt, so haben Sie die Möglichkeit, mit ihnen zu reden. Dabei können Sie oftmals nützliche Hinweise zur Lösung des Rätsels erfahren. Im Falle, daß Sie auf feindliche Monster stoßen, steht Ihnen meistens ein schwerer Kampf bevor.

Sie sind in diesem Kampf nicht nur auf Nahkampfwaffen oder Weitschußwaffen (zum Beispiel Pfeil und Bogen) beschränkt: Wenn Sie Ihre Spielcharaktere sorgfältig ausgewählt haben, können Ihre »Wizards« oder »Clerics« den Tod der Feinde mit machttollen Zaubersprüchen auch ein bißchen beschleunigen.

Im Verlauf des Spiels treffen Sie auf Städte, Dungeons (unterirdische Labyrinthe, in Exodus acht Stockwerke tief), Burgen und sogar ein »längst vergessenes Land«. Zusätzlich gibt es noch versteckte Städte, die man nur bei genau der richtigen Stellung des Mondes und durch Gehen in den richtigen Teleporter erreicht.

## Geduld ist nötig, aber es lohnt sich

In den Städten und Burgen gibt es fast sämtliche Ausrüstung zu kaufen, die man zur Bewältigung des Abenteuers benötigt (Rüstungen, Waffen, Essen, Pferde). Außerdem gibt es noch besondere magische und exotische Gegenstände.

Um den Schluß des Abenteuers erreichen zu können, benötigt man noch viele Hilfsmittel, die man im Laufe des Spiels ergattern muß, beispielsweise die »Mark of Fire«, mit der man ungeschoren durch Lava gehen kann.

Wer Ultima III lösen will, der benötigt viel Zeit und Geduld. Wer beides aufbringen kann, für den lohnt sich dieses Spiel, auch bei einem Preis von zirka 170 Mark.

Außerdem sollte man beachten, daß im Preis nicht nur die Spielediskette enthalten ist, sondern auch eine luxuriös aufgemachte Verpackung, in der sich einige Besonderheiten befinden: Eine auf Stoff gedruckte farbige Landkarte, Zauberspruchbücher für »Clerics« und »Wizards«, ein Heft mit der Geschichte der Entstehung des Landes und Informationen über Fauna und Flora (Monstercharakteristiken, Zeichnungen und Erläuterungen, Beschreibung der Städte etc.), und natürlich eine genaue Spielanleitung.

Exodus ist ein durchaus empfehlenswertes Spiel, das den Spieler auch über längere Zeit hinweg beschäftigen kann (außer er verzweifelt daran) und nicht so schnell langweilig wird.

(Manfred Kohlen/F.Wlodarczyk/aa)

PS: Wir werden auch weiterhin über interessante Fantasy- und Abenteuerspiele berichten, sowie Lösungshinweise zu besonders schwierigen Abenteuern bieten. Im Augenblick arbeiten wir an einer Lösung zu Encharter, die wir voraussichtlich in der Februar-Ausgabe veröffentlichen werden.Weitere Lösungsvorschläge zu besonders guten und besonders schwierigen Abenteuerspielen sind jederzeit willkommen.

# Abenteuer selbst gemacht

> Der »Adventure Creator« von Spinnaker macht es möglich: Der Abenteuer-Spieler kann in selbstprogrammierte Fallen tappen. Oder Freunde ganz schön ins Schwitzen bringen.

Den Begriff »Abenteuer-Spiel« beziehungsweise »Adventure« sollte man in Zusammenhang mit diesem Programm nicht falsch verstehen: Hier ist kein Spiel gemeint, bei dem man Kommandos wie »Go north« oder »Open door« eingibt. Bei »Adventure Creator« handelt es sich um einen sogenannten Abenteuerspiel-Generator, bei dem man sich verschiedene Szenen selbst aufbauen muß, durch die man sich dann mit Hilfe seines Joysticks durchkämpft.
Ganz Faule können den Marsch durch die Gänge und Zimmer natürlich auch dem Zufall überlassen. Der Computer bestimmt dann, auf welche Tücken der Spieler trifft. Das Programm wurde jedoch eigentlich dazu entwickelt, um sich eigene Abenteuerszenen aufzubauen. In diese Abenteuer kann man die verschiedensten Gegenstände einbauen: Geheimtüren, Fallen, Schatztruhen, heiße Wände,. . .
Von Schildern über Fackeln bis hin zu sogenannten »Hobbles« und »Nippers« kann man alles auflesen und mitschleppen.
In einem richtigen Abenteuerspiel sind natürlich auch die Feinde und Freunde nicht weit: Im Kreaturen-Laboratorium (frei übersetzt nach der englischen Anleitung) entwickelt man die Persönlichkeit und Eigenschaften der Monster. Zur Wahl stehen Kreaturen, die einem etwas geben oder etwas haben wollen, handeltreibende und als Teleporter fungierende, sowie Angreifer.
Bei Angriffen fließt übrigens überhaupt kein Blut. Das einzige, was passieren kann, ist der Verlust von Energie, aber auch Schlaffheit kann zum (friedlichen) Tod führen.
Wenn auf der Packung »ab 8 Jahren« steht, so ist dies durchaus richtig. Spinnaker Software ist bekannt dafür, Lernspiele für Kinder auf den Markt zu bringen. Das soll natürlich nicht heißen, daß Erwachsene nicht genauso viel Spaß daran haben können. Das Spiel fördert die Kreativität des Kindes, indem es ihm erlaubt, eigene Szenen des Adventures auf dem Bildschirm aufzubauen. Der Schwierigkeitsgrad des Adventures ist in einem Maße angelegt, das es auch Kindern ermöglicht, das Abenteuer erfolgreich durchzustehen. Allerdings bedeutet die natürlich, daß der geringe Umfang der Abenteuer Erwachsene schnell langweilt. Die Kinderfreundlichkeit des Programms geht also auf Kosten der älteren Computerfans.
Hier hätte Spinnaker ruhig mehr Fantasie aufbringen können, so daß auch Erwachsene nicht so schnell das Interesse verlieren. Das Spiel kostet schließlich 130 Mark. Eltern von acht- bis zwölfjährigen Kindern kann man dieses Spiel durchaus empfehlen — sofern sie die (einfache) englische Anleitung verstehen und ihren Kindern das Spiel erklären.
(M. Kohlen/F. Wlodarczyk/aa)

# Comal – eine Einführung – Teil 1

> Ist Ihnen Basic zu wenig leistungsfähig, Pascal zu ermüdend, Assembler zu primitiv und Forth zu merkwürdig ? Dann wird es Zeit für Comal.

Die Programmiersprache Comal ist keine ganz neue Sprache, wenngleich sie auch — ähnlich wie Forth — erst seit relativ kurzer Zeit in Europa kursiert. Comal (COMmon Algorithmic Language) wurde bereits 1973 von Borge R. Christensen und Benedict Loefstedt in Dänemark entwickelt, fand aber, wie viele andere Programmiersprachen, zunächst kein großes Echo. Ähnlich wie bei Forth bildeten sich aber bald in vielen Ländern nationale User-Groups, die sich für die Verbreitung und kontinuierliche Verbesserung der Sprache einsetzten.

Das im 64'er Magazin, Ausgabe 8/84, besprochene Comal ist die Version 0.14, das auch als Grundlage für diesen Einführungskurs dient. Comal 2.0 ist um einiges schneller und ist ein 52 KByte langes Programm. Dabei sind mehr als 30 KByte frei für eigene Programme. Das Modul selbst enthält 64 KByte ROM. In Dänemark wird es für umgerechnet 600 Mark angeboten und ist dort fast an allen Schulen im Einsatz. Ältere Comal-Versionen als 0.14 (zum Beispiel 0.12) verfügen unter Umständen über eine Reihe von Befehlen nicht. Umgekehrt ist die Version 0.14 gegenüber der kommerziellen Version 2.0 mit einigen Nachteilenbehaftet, zu denen vor allem der mit exakt 9902 Bytes nicht gerade üppig bemessene Speicherplatz gehört. Die Comal-Versionen 0.xx sind sogenannte »Public Domain Software«, das heißt sie dürfen kopiert und weitergegeben, allerdings nicht kommerziell vertrieben werden. Der Sinn dieser auf den ersten Blick verblüffenden Freizügigkeit liegt in der gewünschten möglichst umfassenden Verbreitung der Sprache.

In letzter Zeit gewinnt Comal zunehmende Bedeutung als Alternative zur vergleichsweise primitiven Basic-Programmierung. Der Benutzer von Comal hat dabei gegenüber der Verwendung anderer Programmiersprachen den entscheidenden Vorteil, daß die Sprache stark an Basic angelehnt ist, daß aber die vielen Schwachpunkte von Basic überwunden wurden. Hinsichtlich des Konzeptes der strukturierten Programmierung wurden viele Anleihen bei Pascal gemacht, ohne jedoch dessen oft unnötig komplizierte und langatmige Sprachstruktur zu kopieren.

Doch damit noch nicht genüg. Jetzt wird es für den Besitzer eines C 64 erst richtig interessant (für den VC 20 ist Comal leider nicht erhältlich). Comal hat nämlich noch bei einer dritten Programmiersprache Anleihen gemacht, und zwar bei Logo. Damit stehen eine ganze Anzahl von sehr stark an Logo angelehnten Befehlen für hochauflösende Grafik zur Verfügung. Der große Vorteil dieser Befehle ist ihre einfache und übersichtliche Struktur. Es sind kaum Koordinatenangaben nötig, sondern es wird mit einer sogenannten »Turtle« gearbeitet.

Turtle ist die englische Bezeichnung für »Schildkröte«. Dieser etwas ungewöhnliche Name stammt aus Logo, das ursprünglich als grafische Programmiersprache für Kinder entwickelt wurde. Die »Schildkröte« ist dabei ein Grafik-Cursor (bei Comal durch ein Dreieck dargestellt), der auf den gerade aktuellen Punkt im Grafik-Bildschirm zeigt. Die Turtle kann nun mit verschiedenen einfachen Befehlen bewegt werden. FORWARD n bewegt die Turtle um n Grafikpunkte vorwärts, BACK n bewegt sie rückwärts. LEFT w und RIGHT w drehen die Turtle um den Winkel w (in Grad) nach links oder rechts. HOME setzt die Turtle wieder auf ihre Ausgangsposition in der Bildschirmmitte.

Es existieren natürlich noch eine ganze Reihe weiterer Grafikbefehle und sogar etliche Befehle zur Spritesteuerung. Das kleine Demo-Programm (siehe Listing) zeichnet einige Quadrate mit zunehmender Seitenlänge auf den Bildschirm. An diesem Programm sind schon einige grundsätzliche Eigenschaften von Comal erkennbar, zum Beispiel die Programmstrukturierung und das Arbeiten mit Prozeduren. Wenn Sie Comal bereits zur Verfügung haben, dann geben Sie doch dieses kleine Programm einfach einmal ein und lassen sich überraschen.

Wir wollen uns an dieser Stelle jedoch noch nicht weiter mit Einzelheiten wie Prozeduren oder Funktionen beschäftigen, sondern uns dieses sehr umfassende Thema für später aufheben. Auch Comal-Grafik und Sprites werden wir ausführlich in einer der nächsten Folgen behandeln. Wir wollen stattdessen ganz am Anfang beginnen und uns etwas genauer damit beschäftigen, wie man denn nun Comal dazu bekommt, die grundlegenden Dinge wie Programm editieren, laden, speichern und drucken für uns zu erledigen.

## Das Arbeiten mit Comal

Kommen Sie mit Basic zurecht? Dann wird Ihnen auch das Arbeiten mit Comal keine Schwierigkeiten bereiten. Genau wie Basic ist auch Comal eine interaktive Sprache. Die meisten Befehle lassen sich auch im Direktmodus ausführen. Soll jedoch eine Programmzeile gespeichert werden, so setzt man einfach — wie von Basic bekannt — eine Zeilennummer davor.

Doch Vorsicht! Einige Unterschiede zu Basic gibt es schon beim Editieren eines Programms. Zum Beispiel dürfen in einer Comal-Zeile nicht mehrere Befehle stehen (der Doppelpunkt fungiert in Comal nicht als Trennzeichen zwischen zwei Befehlen, sondern hat verschiedene andere Funktionen). Auch ist es zum Löschen einer Programmzeile nicht ausreichend, nur die Zeilennummer einzugeben. Dafür gibt es den »DEL«-Befehl, mit dem man nicht nur einzelne Zeilen, sondern auch ganze Zeilenbereiche löschenkann. Die Syntax ist die gleiche wie bei »LIST«. »DEL 50-150« löscht also beispielsweise die Zeilen 50 bis 150. Der »LIST«-Befehl ist in Comal übrigens sehr komfortabel. Das Listen eines Programms läßt sich nämlich durch Drücken der Space-Taste anhalten. Ein zweiter Tastendruck, und das Listen wird fortgesetzt.

Zu beachten ist auch, daß Zeilennummern in Comal maximal vierstellig sein dürfen, sonst wird ein Syntax-Fehler angezeigt. Auch die Null ist als Zeilennummer nicht erlaubt.

Bei der Programmeingabe wird man sehr schnell eine wesentliche Eigenschaft von Comal kennen- und schätzenlernen, nämlich den sofortigen Syntax-Check. Alle fehlerhaften Programmzeilen werden bereits bei der Eingabe mit einer entsprechenden Fehlermeldung zurückgewiesen. Der Cursor blinkt dabei genau an der Stelle, an welcher der Fehler aufgetreten ist.

## Interpreter oder Compiler?

Comal führt die meisten Befehle im Direktmodus aus, die Programme werden einfach mit »RUN« gestartet —wie bei einem typischen Interpreter. Andererseits müssen Strings dimensioniert und Variablen vor dem ersten Aufruf einen definierten Wert besitzen — wie bei einem typischen Compiler.

In Wirklichkeit ist Comal keins von beiden — oder beides zur Hälfte, je nach Standpunkt. Das Handbuch spricht von einem »Three Pass Interpreter«, was möglicherweise der Wahrheit am nächsten kommt. Jedenfalls arbeitet Comal tatsächlich in drei Phasen. Die erste Phase kennen Sie bereits, wenn Sie schon Programmierversuche in Comal hinter sich haben. Es ist der Syntax-Check, der unmittelbar nach Eingabe einer Zeile ausgeführt wird. In dieser Phase wird die Programmzeile — ähnlich wie bei Basic — in eine kompakte Form umgewandelt, indem die Schlüsselwörter in Ein-Byte-Abkürzungen, sogenannte Token, umgewandelt werden.

Der Syntax-Check funktioniert im Prinzip recht einfach. Bei jeder eingegebenen Zeile wird zunächst überprüft, ob die Zeilennummer im erlaubten Bereich von 1 bis 9999 liegt. Anschließend wird getestet, ob eine Kommentarzeile vorliegt. Ein Kommentar wird in Comal allerdings nicht mit »REM« eingeleitet, sondern mit zwei Schrägstrichen. Jede Zeile, die mit »//« beginnt, wird daher nicht weiter beachtet. Alle anderen Zeilen durchlaufen jedoch die Routine »Text in Token wandeln«. Dabei wird ganz einfach überprüft, ob das erste Zeichen in der so codierten Zeile ein Token ist. Ein Token erkennt das Comal-System daran, daß in dem betreffenden Byte Bit 7 gesetzt ist; das funktioniert also völlig analog zu Basic.

Ist das erste Zeichen einer Zeile also weder das Kommentarsymbol noch ein Token, dann wird ein Syntax-Fehler gemeldet. Des weiteren wird einfach die Anzahl der öffnenden und schließenden Klammern einer Zeile gezählt. Ergibt sich eine Ungleichheit, dann resultiert das in einer Fehlermeldung. Eine kontextabhängige Syntaxprüfung findet jedoch nicht statt, das heißt, daß die Eingabezeile in dieser ersten Phase ohne Bezug zum Rest des Programms überprüft wird.

Sie können das Prinzip leicht selbst testen, indem Sie beispielsweise die folgende Zeile eintippen:
100 print sqr(2)

Wie zu erwarten, wird die Zeile widerspruchslos angenommen. Ändern Sie die Zeile jetzt doch einmal in
100 print xyz(2)

## So funktioniert der Syntax-Check

Auch diese Zeile wird widerspruchslos angenommen, da sie mit einem zulässigen Schlüsselwort (print) beginnt und die gleiche Anzahl öffnende wie schließende Klammern enthält. Warum erfolgt hier keine Fehlermeldung ? Es gibt doch gar keine Funktion »xyz(2)«. Wirklich nicht? Was wäre, wenn Sie vor dem Eintippen der Zeile kein »NEW« gegeben hätten, um ein eventuell vorher vorhandenes Programm zu löschen? Woher wollten Sie dann mit Bestimmtheit sagen können, daß es eine Funktion xyz nicht gibt? Außerdem handelt es sich möglicherweise gar nicht um eine Funktion, sondern um ein eindimensionales Feld. Sie merken schon, solange Sie nur diese eine Zeile kennen und vom eventuell vorhandenen übrigen Programm keine Ahnung haben, sind Sie in der gleichen Situation wie der Comal-Interpreter. Der behandelt nämlich bei einer Eingabe auch nur diese eine Zeile und beachtet den Rest des Programms nicht weiter. Daher gibt er in so einem Fall auch lieber keine Fehlermeldung aus, denn möglicherweise wurde vorher im Programm eine Funktion xyz definiert oder ein Feld xyz dimensioniert. Die eingegebene Zeile ist also in Wahrheit tatsächlich syntaktisch korrekt, denn auf eine Print-Anweisung kann ein beliebiger Ausdruck folgen, es muß nicht unbedingt eine der Standardfunktionen oder eine Konstante sein.

Die Überprüfung, ob alle Programmzeilen zusammen auch tatsächlich ein vernünftiges Programm bilden, erfolgt in einer zweiten Phase. Diese Phase wird mit dem Befehl »RUN« gestartet. Im Gegensatz zu Basic beginnt Comal nämlich nach »RUN« nicht unmittelbar mit dem Abarbeiten des Programms, sondern führt zunächst eine Überprüfung der Programmstruktur durch. Dabei wird zum Beispiel festgestellt, ob Schleifen richtig geschachtelt sind und beendet werden, ob jede aufgerufene Funktion und Prozedur auch tatsächlich definiert wurde und so fort. Bei der Gelegenheit werden gleich alle Sprungadressen berechnet und in eine parallel zum Programmtext angelegte Tabelle eingetragen.

Der Begriff »Sprungadresse« ist hier im weiteren Sinn zu verstehen, denn obwohl Comal über ein GO-TO-Statement verfügt, sollte dieses im Sinne einer übersichtlichen Programmstruktur nur in Ausnahmefällen verwendet werden. Mit Sprungadressen sind hier also auch »interne« Sprünge gemeint, zum Beispiel auf den Anfang einer Prozedur, wenn diese aufgerufen wird. Damit braucht der Comal-Interpreter beim späteren eigentlichen Programmlauf beispielsweise nicht mehr den gesamten Programmtext nach der Definition einer Prozedur oder Funktion zu durchsuchen, sondern findet die entsprechende Adresse viel schneller durch »Nachschlagen« in einer Tabelle.

## Fehlerhafte Programme werden gar nicht ausgeführt

Dieser Vorgang der Ersetzung von symbolischen Adressen (Prozedur-, Funktions-, Variablen- und Labelnamen) durch die tatsächlichen Adressen dieser Objekte im Speicher ist eine der wesentlichen Aufgaben eines Compilers. Insofern hat Comal also tatsächlich Compiler-Eigenschaften. Allerdings werden zum Beispiel arithmetische Ausdrücke nicht in eine andere, maschinennahe Form übersetzt, wie das bei einem »richtigen« Compiler der Fall wäre. Auch findet keinerlei Übersetzung in Maschinensprache statt, so daß es tatsächlich falsch wäre, von einem Compiler zu sprechen.

Nachdem alle Überprüfungen und Übersetzungen abgeschlossen sind, beginnt schließlich die dritte und letzte Phase der Interpretation, nämlich der eigentliche Programmlauf. Diese Phase wird automatisch eingeleitet, wenn in Phase zwei kein Fehler aufgetreten ist. Für den Benutzer sind die Phasen zwei und drei daher in der Regel nicht zu unterscheiden. Daß es sie aber wirklich gibt, kann man mit einem kleinen Testprogramm sehr einfach feststellen:
10 print "hier ist Zeile 10"
20 //
30 // es folgt ein Fehler
40 // in der Programmstruktur
50 //
60 endif

In Zeile 60 steht das Schlüsselwort für das Ende eines If-Blocks, aber nirgends vorher taucht ein »if... then« auf.

Ein reiner Interpreter — wie Basic — würde nach »RUN« die Meldung »hier ist Zeile 10« auf den Bildschirm schreiben und erst anschließend feststellen, daß hier ein endif ohne if vorliegt. Lassen Sie aber dieses kleine Programm einmal in Comal laufen und sehen Sie selbst, was passiert. Nach »RUN« wird die Print-Anweisung in Zeile 10 nicht ausgeführt, sondern erst einmal Phase zwei gestartet und das Programm überprüft. Dabei wird der Fehler gefunden, und es erscheint eine entsprechende Meldung. Phase drei, nämlich die eigentliche Programmausführung, wird wegen dieses Fehlers gar nicht erst erreicht.

Phase drei wird überhaupt nur gestartet, wenn ein Hauptprogramm vorhanden ist. Besteht der gesamte Programmtext nur aus Funktionsoder Prozedurdefinitionen, dann wird nach »RUN« ebenfalls nichts ausgeführt. Allerdings können nun — und das ist ganz wesentlich — alle im Programm definierten Funktionen und Prozeduren im Direktmodus aufgerufen werden.

Das ist eine Eigenschaft von Comal, die für den Benutzer von großer Wichtigkeit ist. Denn damit kann, wie sonst in dieser Form nur bei Forth, Logo oder Lisp möglich, der Sprachumfang fast beliebig erweitert werden. Benötigen Sie zum Beispiel eine Funktion, ähnlich wie PEEK, die aber nicht nur ein Byte, sondern ein 16-Bit-Wort aus dem Speicher liest? Kein Problem. Geben Sie im Direktmodus NEW ein und danach die folgenden Programmzeilen (Sie können sich das Tippen der Zeilennummern sparen, wenn Sie zuvor den Befehl »AUTO« eingeben):
10 func deek(x)
20 wert := peek(x) + 256*peek(x +1)
30 return(wert)
40 endfunc deek

Bei diesem Vierzeiler handelt es sich um die Definition einer Funktion »DEEK« mit einem Parameter. In Zeile 20 werden die nötigen Berechnungen ausgeführt. Das Schlüsselwort »RETURN« in Zeile 30 hat eine andere Bedeutung als in Basic. Es besagt, daß die Funktion als Ergebnis des Funktionsaufrufes den Wert der Variablen »WERT« zurückliefern soll. Mit »ENDFUNC DEEK« schließlich wird dem Comal-Interpreter das Ende der Funktionsdefinition angezeigt. Nach »RUN« erfolgt sofort die Meldung »END AT 0040«, und der Comal-Sprachschatz ist um die Funktion »DEEK« erweitert. »PRINT DEEK(209)« zeigt beispielsweise die Speicheradresse des Beginns der aktuellen Bildschirmzeile an.

Doch damit zunächst einmal genug über die Arbeitsweise des Comal-Interpreters. Wenden wir uns nun einigen wichtigen Kommandos zu, die das Arbeiten mit Diskette, Kassette und Drucker ermöglichen.

## Wie kommt das Programm auf die Diskette?

Nehmen wir einmal an, wir hätten gerade unser erstes kleines Testprogramm in Comal geschrieben. Natürlich wollen wir unser Erstlingswerk gerne der Nachwelt erhalten. Doch wie bekommen wir das Programm auf die Diskette (oder auch auf die Kassette)? Etwa mit SAVE, wie in Basic? Ja, genauso.

Wie bereits zu Anfang erwähnt, ist Comal stark an Basic angelehnt (siehe Tabelle 1). Die Befehle »LOAD« und »SAVE« dienen zum Laden und Speichern von Programmen. »VERI-FY« steht leider in der Comal Version 0.14 noch nicht zur Verfügung. Dafür gibt es aber zusätzlich den »CHAIN«-Befehl, der ein Programm von Diskette lädt und automatisch startet. Im Unterschied zu Basic ist Comal allerdings diskettenorientiert, das heißt Sie können sich das lästige »,8« sparen. Soll allerdings statt auf Diskette auf ein Kassettenlaufwerk zugegriffen werden, so muß die Sekundäradresse 1 angegeben werden.

Zur einfacheren Bedienung der Floppy ist in Comal der Befehl »PASS« vorgesehen, der einen Kommandostring an die Floppy sendet. Soll zum Beispiel eine Diskette neu initialisiert werden, dann braucht nicht erst umständlich der Kommandokanal geöffnet werden, sondern es reicht der Befehl »PASS "I"«. Die Systemvariable »STATUS$« enthält immer den Fehlerstatus der Floppy, und zwar im Klartext. Wem das Eintippen von »PRINT STATUS$« noch zu mühselig ist, der kann auch nur »STATUS« eintippen. Comal versteht dann schon, was gemeint ist.

Erheblich komfortabler als in Basic ist auch das Laden des Directory. Einfach »CAT« (für catalog) eingeben, und das Inhaltsverzeichnis der Diskette wird angezeigt, und zwar ohne das Programm zu zerstören.

Neben »LOAD« und »SAVE« gibt es noch zwei weitere Lade- und Speicherbefehle. »LIST "name”« legt ein Comal-Programm als sequentielles File auf Diskette ab. Mit »ENTER "name” «wird ein solches sequentielles File wieder als Comal-Programm eingelesen.

Was ist der Unterschied zwischen diesen beiden Formen des Abspeicherns? Die Antwort darauf mag der eine oder andere schon von Basic her kennen. Der Comal-Befehl »LIST "name"« hat die gleiche Wirkung wie die Basic-Befehlsfolge »OPEN 1,8,1, "name,s,w"« : CMD 1 : LIST : CLOSE 1«. Anschließend existiert in beiden Fällen auf der Diskette ein sequentielles File, das das entsprechende Basic- oder Comal-Programm als reine ASCII-Zeichenfolge, also ohne Token, enthält.

Das kann durchaus nützlich sein, weil man ein solcherart gespeichertes Programm sehr leicht und ohne Kenntnis der speziellen Befehlstoken weiter bearbeiten kann. Auf der Comal-Diskette befindet sich zum Beispiel ein Demo-Programm »FOR-MATTER.COM«, mit dessen Hilfe sich solche sequentiellen Files formatiert auf dem Drucker listen lassen, wobei alle wichtigen Parameter eingestellt werden können.

Zum Laden mit »ENTER« gibt es kein einfaches Basic-Äquivalent, sondern dort muß man schon ein kleines Programm schreiben. In Comal dient der »ENTER«-Befehl dazu, ein sequentielles File zu lesen und dabei wieder in »normalen« Comal-Text mit Token-Codierung umzuwandeln.

Natürlich wäre es einigermaßen lästig, wenn man Programmlistings nur auf solchen verschlungenen Pfaden auf dem Drucker ausgeben könnte. Aber Comal wäre nicht Comal, wenn nicht alles etwas einfacher ginge als in anderen Sprachen. Da ein Umschalten zwischen Bildschirm- und Druckerausgabe oft gebraucht wird, gibt es in Comal einen speziellen Befehl dafür: Mit »SELECT OUTPUT "gerät" « kann das gewünschte Ausgabegerät gewählt werden. Die Angabe des Schlüsselwortes »OUTPUT« ist dabei nicht unbedingt notwendig. Für »gerät« gibt es zwei Möglichkeiten: »LP:« (Line Printer) für Druckerausgabe, »DS:« (Data Screen) für Ausgabe auf den Bildschirm.

Um also ein Listing auf den Drucker auszugeben, gibt man nacheinander die beiden folgenden Befehle ein:
SELECT "LP:”
LIST

Nach dem LISTen wird übrigens automatisch wieder auf Bildschirmausgabe umgeschaltet.

Damit sind alle wichtigen Befehle behandelt worden, um Comal-Programme vernünftig editieren zu können. In der nächsten Folge werden wir uns (endlich) dem eigentlichen Programmieren in Comal zuwenden.

(ev)

# Turtle-Grafik – Die schnelle Schildkröte

> Turtle-Grafik ist eine Spracherweiterung, die es in sich hat. Vollständig in Maschinensprache geschrieben stellt sie einige Befehle zur Verfügung, mit denen Sie komfortabel sehr schnell Bilder erzeugen können.

Wenn Sie dieses Programm abtippen, werden Sie keinen Ärger mit den vielen DATAs bekommen. Haben Sie einen falschen Wert eingegeben, weist Sie die eingebaute Prüfsummenroutine auf die fehlerhafte Zeile hin und listet sie am Bildschirm. Bitte halten Sie sich daher an die Zeilennumerierung. Nach der Eingabe sollten Sie das Programm speichern und erst dann starten. Wenn alles ok ist, empfehle ich Ihnen, das Demoprogramm (Listing 2) einzugeben. Es vermittelt Ihnen einen sehr guten Eindruck von den Fähigkeiten der Grafikerweiterung. Doch nun zur Turtle-Grafik selbst.
Das Programm ermöglicht die Programmierung von hochauflösender Grafik in Basic mit neuen leistungsfähigen Befehlen. Wird das Programm gestartet, meldet es sich mit: TURTLE GRAPHICS
BY PETER MENKE
38911 BASIC BYTES FREE

Nun sind alle Funktionen und Befehle des Programms fest in Basic eingebettet und bleiben bis zum Ausschalten erhalten.
Das Programm unterstützt die Programmierung zweier voneinander völlig unabhängiger Bildschirme:

1.	Den normalen Textbildschirm
2.	Den Grafikbildschirm auf dem die hochauflösende Grafik erscheint.

Zwischen den beiden Bildschirmen können Sie mit der Funktionstaste F1 hin- und herschalten. Der neue Befehl HIRES1 schaltet den Grafik-Bildschirm ein (HIRES 0 = ausschalten).

Im folgenden die Befehle im Einzelnen

### HIRES1 hi, ra

hi = Hintergrundfarbe (0-15)
ra = Randfarbe (0-15)
Die Angaben für Hintergrund und/oder Randfarbe sind nicht unbedingt notwendig, die alten Farben werden dann beibehalten.

### CLEAR

Dieser Befehl löscht den gesamten Grafikbildschirm.

### REVERS

Dieser Befehl invertiert den gesamten Grafikbildschirm.

### COLOR pu, hi, ra

Die Farben der hochauflösenden Grafik werden neu definiert (pu = Punktfarbe). Wie beim HIRES-Befehl können auch hier die Angaben für hi und/oder ra entfallen.

### GSAVE »Name«, Gerätenummer

Speichert eine erzeugte Grafik ab.

### GLOAD »Name«, Gerätenummer

Lädt eine vorher gespeicherte Grafik in den Computer.

Wenn Sie den Grafikbildschirm einschalten, sehen Sie in der Mitte des Bildschirms einen blinkenden Punkt: Den Grafikcursor (oder »Turtle«, zu deutsch »Schildkröte«),

Durch Bewegen dieses Grafikcursors können Sie Linien auf dem Bildschirm zeichnen.

### DEG wi

Bestimmt die Bewegungsrichtung der Turtle. Acht Richtungen sind möglich (»wi« kann Werte zwischen 0 und 7 annehmen).

TODO
2
3	1
4	* 0
5	7
6

### MOVEx

Move bewegt die Schildkröte um x Punkte.

Der HIRES-Befehl positioniert den Grafikcursor automatisch auf die Bildschirmmitte. Der eingestellte Winkel ist 0. Außerdem wird Modus 0 eingeschaltet (siehe MODE).

### LTURNx(x max.=255)

Dreht den Grafikcursor um x Einheiten nach links.

### RTURN x (x max.=255)

Dreht den Grafikcursor um x Einheiten nach rechts.

### PLOT x-cor, y-cor

Setzt den Grafikcursor auf eine bestimmte Bildschirmposition. Die obere linke Ecke des Bildschirms hat die Koordinaten 0,0; die rechte untere 319,199.

### MODE m (m max 4)

Bei den Befehlen MOVE und PLOT kennt das Programm 4 Modi.
0 = Punkt setzen
1 = Punkt löschen
2 = Punkt invertieren
3 = nichts verändern Normalerweise ist Modus 0 eingeschaltet. Mit dem MODE-Befehl läßt sich dies ändern.

## Gleichzeitige Darstellung von Text und Grafik

Das Programm teilt den Bildschirm in einen Text- und in einen Grafikteil.

Betätigt man bei eingeschaltetem Grafikbildschirm die F3-Taste, so wird im unteren Teil des Bildschirms der untere Teil des normalen Textbildschirms eingeblendet.

Bei nochmaligem Betätigen dieser Taste wird das »Textfenster« wieder ausgeblendet.

### WINDOW 1

Schaltet Textfenster ein.

### WINDOW 0

Schaltet Textfenster aus.

Mit der Taste F5 wird der Cursor (der normale) in die obere linke Ecke des Textfensters gebracht. Dies entspricht der HOME-Taste für den gesamten Bildschirm. Die F5-Taste läßt sich ebenso programmieren wie die HOME-Taste, das heißt mit PRINT ”(F5)” (auf dem Bildschirm erscheint ein reverses Grafikzeichen) läßt sich der Cursor in die obere linke Ecke des Textfensters bringen.

### JOYSTICK ve

(ve=Verzögerung. Mit ve = 0 malt man am schnellsten, mit ve = 255 am langsamsten.)

Dieser Befehl erlaubt das Zeichnen von Bildern mit dem Joystick (Port 2). Mit dem Joystick kann der Grafikcursor bewegt werden. Druckt man gleichzeitig den Feuerknopf, wird entsprechend dem eingestellten Modus ein Punkt gesetzt, gelöscht etc. Nun können beliebige Bilder gezeichnet werden, solange, bis mit der F7-Taste mit der Programmabarbeitung fortgefahren wird.

### LPEN

Dieser Befehl erlaubt das Zeichnen von Bildern mit dem Lightpen (Port 1). Ini Prinzip gilt das gleiche wie beim JOYSTICK-Befehl, nur daß hier statt des Feuerknopfes die CTRL-Taste beziehungsweise der Knopf am Lightpen benutzt wird. Man verläßt den Lightpenmodus mit F7.

Alle Befehle können unabhängig vom Einschaltzustand des Grafikbildschirms angewendet werden. Sie lassen sich auch wie normale Basic-Befehle abkürzen.

Die Funktionen und Anwendungen des Programms und seiner Befehle sind sehr gut in dem Programm »TURTLE DEMO« demonstriert (Listing 2).

(Peter Menke/gk)

## Der Programmierer der Schildkröte

Geboren wurde ich am 3.1.1968 in Lüneburg. Meine erste Begegnung mit dem Computer fand am dortigen Gymnasium statt. Än einem heute schon fast fossilen CBM 4016 lernte ich Basic. Kurz nachdem der Commodore 64 auf den Markt kam, erstand ich ein Gerät für sage und schreibe 1298 Mark (Wucher!!). Wegen seines schwachen Basics lernte ich bald Maschinensprache. Doch das bloße Programmieren von Videospielen befriedigte bald nicht mehr. So stürzte ich mich in die Tiefen des Basic- und Betriebssystem-ROMs, um eine Basic-Befehlserweiterung zu schreiben. Eins der besten und umfangreichsten Ergebnisse: Diese Turtle-Grafik.

(Peter Menke/gk)

---
TODO

Das Programm beginnt mit Titel und Autorenanschrift. Das GOSUB in Zeile 260 dient nur zur Suche von Syntax-Fehlern in den DATA-Zeilen. Im Programmteil »Variable« ab Zeilennummer 290 wird der Variablen AN die Startadresse des Maschinenprogramms zugewiesen, der Variable ZI die Endadresse. In NA$ steht der Programmname. Die eigentliche Einleseroutine (ab Zeile 350) funktioniert folgendermaßen: Es werden in einer Schleife die ersten 16 Zahlen aus einer jeden DATA-Zeile gelesen und in den Speicher gePOKEt. Gleichzeitig wird aus den gelesenen Daten eine Prüfsumme gebildet. Diese Summe wird mit der letzten Zahl in der DATA-Zeile verglichen, dies ist die richtige Prüfsumme. Unterscheiden sich die beiden Zahlen, so wurde ein Tippfehler gemacht und die fehlerhafte Zeile wird vom Programm automatisch geLI-STet. Außerdem wird geprüft, ob eine Zeile vergessen wurde (Zeile 517-520) und ob die Anzahl der Daten richtig ist (Zeile 530-537). Zusätzlich wird noch getestet, ob die gelesene Zahl auch zwischen 0-255 liegt (Zeile 391). Ist dies nicht der Fall, wird eine Fehlermeldung ausgegeben (Zeile 503-505). Ursache ist wahrscheinlich ein Kommafehler. Wurde kein Fehler gefunden, so fragt das Programm, ob es sich selbst abspeichern soll (davon sollte bei der ersten Benutzung des Programms unbedingt Gebrauch gemacht werden, Zeile 546-580). Danach wird das Maschinenprogramm gestartet (Zeile 590-610). Trotz der Prüfsummen ist ein Fehler in den DATAs nicht völlig ausgeschlossen. Vertauschungen werden zum Beispiel nicht bemerkt. Solche Fehler sind jedoch sehr unwahrscheinlich.

Diese Art der Überprüfung von DATA-Werten sollten Sie sich genau ansehen. Sie erleichtert der Redaktion und vor allem den Lesern die Eingabe und Überprüfung großer Zahlenkolonnen. Falls Sie uns Programme einschicken wollen, dann nehmen Sie sich doch auch bitte etwas Zeit und fügen eine komfortable Prüfroutine in Ihre Programme ein.

### Programmierung

a) Speicheraufteilung:
Das Video-RAM steht ab $0400. Der Hires-Speicher wurde hinter $ CC00 gelegt, das Hires-Farb-RAM nach C800. Das Programm selbst beginnt bei $C000 und endet bei $C88B. Programmvariable liegen im Bereich vor $CC00.
b) Die Belegung der Funktionstasten wird durch ein »Anzapfen« des Interrupt ermöglicht. Die Funktion PRINT ”(fs)” wird durch Verändern der BSOUT-Routine erreicht.
c) Das Textfenster:
Wie Sie wissen, wird das Bild auf dem Fernseher (Monitor) durch einen Elektronenstrahl erzeugt, der den Bildschirm zeilenweise von oben nach unten abfährt. Der VIC bietet nun die Möglichkeit bei einer bestimmten Zeilenposition einen Interrupt auszulösen. Diese Fähigkeit des VIC wird ausgenutzt. In der dann ausgeführten Interruptroutine wird zwischen Hires- und Textmodus hin und her geschaltet, so daß der Bildschirm in ein Text und ein Grafikfenster eingeteilt wird.
d) Die neuen Befehle:
Es gibt zahlreiche Möglichkeiten, neue Basic-Befehle zu implementieren. Anzapfen der

1. CHRGET-Routme (DOS 5.1)
2. Eingabe-Warteschleife (Toolkits)
3. Interpreterschleife (beschrieben im 64 Intern)

Die drei <!-- auf Seite 49 genannten --> Möglichkeiten haben jedoch alle große Nachteile: Sie sind alle entweder zu langsam (1. und 3.), die Befehle lassen sich nur im Direktmodus anwenden (2.) oder sie können nicht abgekürzt werden. Deshalb wurden die Befehle mit sehr komplexen Routinen voll als Tokens integriert. Aus diesem Grund wurde die Interpreterschleife, die Routine zur Umwandlung in Interpretercode und die Routine zur Rückumwandlung in Klartext verändert. Die Vorteile dieser Arbeitsweise sind, daß sich die neuen Befehle wie normale Basic-Befehle anwenden lassen und daß nur minimale Geschwindigkeitsverluste bei der Ausführung von Basic-Programmen in Kauf genommen werden müssen. Ähnliche Methoden verwenden übrigens auch professionelle Basic-Erweiterungen, wie zum Beispiel Simons Basic.
Ein solches »Anzapfen« von Betriebssystem- und Basic-Routinen wird beim C 64 durch zahlreiche Sprungvektoren ermöglicht, die verändert werden können. Dies ist leider nicht bei allen Computern so gut möglich. Die hier benutzten Vektoren sind:

TODO

Das Wissen über die Programmierung des Programms ist für dessen Anwendung nicht nötig. Doch nun viel Spaß mit Turtle Grafik.

(Peter Menke/gk)

# Schachmeister

> Viele Schachspieler zeichnen ihre Partien auf und überprüfen sie hinterher. Oder sie spielen berühmte Partien nach. Der C64 übernimmt nicht nur die Rolle des Protokollanten — er splelt mit Hilfe dieses Programms gespeicherte Partien mit guter grafischer Darstellung nach.

Nach dem Start dös Programms muß man einen Augenblick warten, bis der Computer die neuen Multicolor-Zeichen definiert hat und diverse Felder und Listen aufgestellt hat (zirka 20 Sekunden). Darauf kann man eine der gespeicherten Partien auswählen und das Schachbrett baut sich auf.

Am rechten Rand werden die Namen der Spieler, das Jahr, die Zugnummer und der Zug sowie verschiedene Meldungen wie »Schach«, »Matt«, »Rochade« ... ausgegeben. Das Schachbrett nimmt zirka % des Bildschirms ein.

Durch Drücken der F7-Taste nach einem Zug wird das Bild bis zu einem erneuten Tastendruck »eingefroren«. Durch Drücken einer anderen Taste nach einem Zug wird der Ablauf beschleunigt. Durch anhaltendes Drücken der Space-Taste kann man so eine Art »Blitzschach« erreichen. Nach Spielende führt ein Tastendruck wieder zum Auswahlmenü.

Eingeben eigener Schachpartien:
1.	Zuerst werden die Namen der Spieler und das Jahr eingegeben:
10000 DATA SPIELER 1', SPIELER 2, 1984.
2.	Die Eingabe der Züge: Beispiel für einen normalen Zug: 10010 DATA E2E4, E7E5, G1F3 ...
Wenn eine Figur eine gegnerische schlägt, braucht man das nicht anzugeben; der Computer erkennt das von selbst.
3.	Sonderregeln:
■ Aufgabe eines Spielers: 10020 DATA ...,SA (Schwarz gibt auf) 10020 DATA WA (Weiß gibt auf)
■ Rochaden: 10020 DATA KR (kurze Rochade) 10020 DATA LR (lange Rochade)
Es braucht nicht angegeben zu werden, welcher der beiden Spieler rochiert.
■ Schach, Matt, Remis:
Um dem Computer einen dieser drei Zustände anzuzeigen, muß ein S (Schach), ein M (Matt) oder ein R (Remis) dem jeweiligen Zug angehängt werden:
10020 DATA ..., D6E6S (Schach wird geboten) 10030 DATA ..., F6E6M (Schachmatt)
10020 DATA ..., E5E6R (Remis)
■ Dametausch:
Wenn ein Bauer in eine Dame umgetauscht wird, so ist dem jeweiligen Zug ein D anzufügen:
10020 DATA .... A7A8D (weißer Bauer wird in Dame getauscht)
Wichtig:
Nach Ende jeder Partie muß unbedingt ein E angefügt werden, damit der Computer eine Liste der Partien aufstellt. Nach der letzten Partie ist statt dem E ein X anzufügen:
19999 DATA ...,F6E6M,E
19999 DATA ...,F6E6M,X

Die Programmlänge ohne gespeicherte Partien beträgt zirka 7,5 KByte pro gespeicherter Partie werden zusätzlich zirka 0,5 KByte benötigt.
Da der Bildschirmspeicher verschoben wird, muß nach einem RUN STOP-RESTORE blind RUN eingetippt werden, um das Programm wieder auflisten zu lassen.

(Thomas Behrend/rg)

## Der Schachmeister und sein Programm

Ich bin 16 Jahre alt und gehe in die 11. Klasse eines Ulmer Gymnasiums. Seit Weihnachten '83 besitze ich einen Commodore 64; sein Vorgänger war ein ZX81.
Das Programm:

Der Computer spielt berühmte oder weniger berühmte Schachpartien vor, die man leicht selbst einprogrammieren kann, so daß man sich mit der Zeit eine richtige Sammlung aufbaut. Besonderer Wert wurde auf eine gute Multicolor-Grafik gelegt.
Entstehungsgeschichte:

Das Programm entstand aus einer spontanen Idee heraus. In Büchereien findet man unzählige Bücher mit aufgeschriebenen Schachpartien, die manauf einem Brett nachspielen kann, was aber nicht unbedingt jedermanns Sache ist, und außerdem ist die Gefahr groß, daß man sich verschaut und einen Fehler macht. Da müßte es doch viel einfacher sein, wenn der Computer dies übernehmen würde. In zirka einwöchiger Arbeit entstand so das vorliegende Programm.

Wesentlich Merkmale und Vorzüge des Programms:
– Multicolorgrafik, die sich zum Beispiel hinter »Grandmaster« nicht zu verstecken braucht.
— alle wichtigen Schachregeln sind berücksichtigt (zum Beispiel Rochaden, Dametausch, Matt, Remis ...) — jeder Benutzer kann seine eigenen Partien eingeben und mit dem Programm speichern (maximal 20)
— das Bild kann jederzeit »eingefroren« werden
— der Programmablauf kann beschleunigt weiden.

(Thomas Behrend)

# Ohne gutes Werkzeug geht es nicht: SMON – Teil 1

> In mehreren Teilen möchten wir Ihnen einen Maschinensprachmonitor vorstellen. Parallel zum Kursus über Assembler-Programmierung wird Schritt für Schritt ein Programm entstehen, das sich durchaus mit kommerziellen Monitoren messen kann.

Ich kann mich noch gut an unsere ersten Schritte in die Maschinensprache erinnern. Ausgerüstet mit einer Befehlsliste für den 6502 und einem in Basic geschriebenen »Mini-Monitor« entstanden Programme, die 3 und 5 addieren und das Ergebnis im Speicher ablegen konnten. Dazu mußten wir die Befehlcodes aus der Liste heraussuchen und dann in den Speicher »POKEn«. Jeder Sprung mußte von Hand ausgerechnet werden, jeder falsch herausgesuchte Befehl führte zum Programmabsturz. Der erste Disassembler — ein Programm zur Anzeige der Maschinenbefehle in Assemblersprache — war für uns die Offenbarung. Von nun an konnten wir Maschinenprogramme analysieren und daraus lernen. Zum Verständnis der Maschinensprache ist es nämlich noch weit mehr als bei anderen Sprachen wichtig, vorhandene Programme zu verstehen und sich dabei die wichtigsten Techniken anzueignen.

Mit der Zeit wuchsen unsere Ansprüche, ein Assembler mußte her, um die neugewonnenen Erkenntnisse auch auszuprobieren. Das war zuerst wieder ein Basic-Programm, langsam und wenig komfortabel, aber immerhin. Wir schrieben unsere ersten kleinen Routinen, vor allem, um vorhandene Maschinenprogramme unseren eigenen Wünschen anzupassen. Mit dem AMON für den VC 20 bekamen wir dann einen Monitor, der (fast) alle unsere Wünsche erfüllte. Als wir jedoch auf den C 64 umstiegen, mußten wir feststellen, daß es für diesen Computer nichts gab, das uns zufriedenstellen konnte. Der einzige Ausweg: Selbst programmieren. So entstand im Laufe eines Jahres SMON. Ursprünglich hatten wir nur vor, die Funktionen von AMON für den C 64 zu programmieren, aber dabei blieb es nicht. Immer neue Befehle und Routinen kamen hinzu, bis wir endlich zufrieden waren.

## Was bietet SMON?

Zunächst ist alles enthalten, was zum »Standard« gehört: Memory-Dump, also die Anzeige des Speicherinhalts in Hexbytes, mit Änderungsmöglichkeiten, ein Disassembler mit Änderungsmöglichkeit sowie Routinen zum Laden, Abspeichern und Starten von Maschinenprogrammen. Darüber hinaus gibt es einen kleinen Direktassembler, der sogar Labels verarbeitet, Befehle zum Verschieben im Speicher mit und ohne Umrechnen der Adressen und Routinen zum Umrechnen von Hex-, Dezimal- und Binärzahlen. Der besondere Clou von SMON liegt aber zweifellos in seinen leistungsfähigen Suchroutinen und vor allem im Trace-Modus. Damit lassen sich Maschinenprogramme Schritt für Schritt abarbeiten und kontrollieren.

Dieser erste Teil umfaßt sämtliche Eingabe- und Ausgaberoutinen, die Registeranzeige, den Memory-Dump sowie Disassembler und Assembler. Damit steht Ihnen bereits ein lauffähiges Monitorprogramm mit den unten aufgeführten Befehlen zur Verfügung.

Der Monitor benötigt für alle Eingaben die hexadezimale Schreibweise, das heißt zu den Zahlen 1 bis 9 kommen noch die Buchstaben A (für dez. 10) bis F (für dez. 15) hinzu.

Bei der Eingabe von Adressen ist folgendes zu beachten: [ANFADR] bedeutet exakt die Startadresse, [ENDADR] bedeutet hierbei die erste Adresse hinter dem gewählten Bereich. Im Normalfall ist die Eingabe mit und ohne Leerzeichen zulässig. Beim Abweichen von dieser Regel wird darauf besonders verwiesen.

### Assemblieren

A [ANFADR]
Assemblierung beginnt bei angegebener Adresse Beispiel:
A 4000 Beginn bei Startadresse $4000

Nach Eingabe von »RETURN« erscheint auf dem Bildschirm die gewählte Adresse mit einem blinkenden Cursor. Die Befehle werden so eingegeben, wie sie der Disassembler zeigt: LDY #00 oder LDA 400E,Y und so weiter. »RETURN« schließt die Eingabe der Zeile ab. Bei fehlerhafter Eingabe springt der Cursor wieder in die Anfangsposition zurück. Ansonsten wird der Befehl disassembliert und nach Ausgabe der Hex-Bytes gelistet. Zur Korrektur vorhergehender Zeilen gehen Sie mit dem Cursor zur Anfangsposition (hinter die Adresse) zurück, schreiben den Befehl neu und gehen nach »RETURN« mit dem Cursor wieder in die letzte Zeile. Falls Ihnen bei Sprüngen (Branch-Befehl, JSR und JMP) die Zieladressen noch nicht bekannt sind, geben Sie einfach sogenannte »Label« ein.

Ein Label besteht aus dem Buchstaben »M« (für Marke) und einer zweistelligen Hex-Zahl von 01 bis 30.
Zum Beispiel: BCC M01

Wenn Sie die Zieladresse für diesen Sprung erreicht haben, dann kennzeichnen Sie diese mit eben dieser »Marke«.
Zum Beispiel: M01 LDY #00

Einzelne Bytes nimmt der Assembler an, indem Sie diese mit einem Punkt kennzeichnen: .00 oder .AB. In diesem Modus werden die Eingaben natürlich nicht disassembliert.

Nach Beendigung des Assemblierens geben Sie »F« ein. Danach sehen Sie alle Ihre Eingaben noch einmal aufgelistet und korrigieren bei Bedarf wie beim Disassembler (!) angegeben.

Probieren Sie einmal das folgende Beispiel:
A4000

Der Assembler meldet sich mit: »4000« und einem blinkenden Cursor. Geben Sie nun ein (die Adressen erscheinen automatisch):

<pre>4000 LDY #00
4002 LDA 400E,Y
4005 JSR FFD2
4008 INY
4009 CPY #12
400B BCC 4002
400D BRK</pre>

Die folgenden Bytes werden wie beschrieben mit einem Punkt eingegeben. Sie werden nicht disassembliert.

<pre>400E .0D
400F .0D
4010 .53
4011 .4D
4012 .4F
4013 .4E
4014 .20
4015 .49
4016 .53
4017 .54
4018 .20
4019 .53
401A .55
401B .50
401C .45
401D .52
401E .0D
401F .0D</pre>

Drücken Sie anschließend »F«. Ihr Programm wird nochmal aufgelistet. Starten Sie es nun mit »G 4000«. Es erscheint ein Text auf dem Bildschirm — lassen Sie sich überraschen.

## Disassemblieren

D[ANFADR,ENDADR]
disassembliert den Bereich von ANFADR bis ENDADR, wobei ENDADR nicht eingegeben werden muß. Wird keine Endadresse eingegeben, erscheint zunächst nur eine Zeile:
ADR	HEXBYTES	BEFEHL
4000	A000	LDY #00
TODO

Mit der SPACE-Taste wird der jeweils nächste Befehl in der gleichen Art und Weise gezeigt. Wünschen Sie eine fortlaufende Ausgabe, drücken Sie »RETURN«. Die Ausgabe wird dann so lange fortgesetzt, bis eine weitere Taste gedrückt wird oder bis ENDADR erreicht ist.Mit »RUN/STOP« springen Sie jederzeit in den Eingabemodus zurück.

Das Komma, das vor der Adresse auf dem Bildschirm erscheint, ist ein »hidden command« (verstecktes Kommando). Es braucht nicht eingegeben zu werden, da es automatisch beim Disassemblieren angezeigt wird. So ermöglicht es ein einfaches Ändern des Programms. Fahren Sie mit dem Cursor auf den zu ändernden Befehl und überschreiben Sie ihn mit dem neuen. Wenn Sie jetzt »RETURN« drücken, erkennt SMON das Komma als Befehl und führt ihn im Speicher aus. Achten Sie aber darauf, daß der neue Befehl die gleiche Länge (in Bytes) hat und füllen Sie gegebenenfalls mit »NOPs« auf. Zur Kontrolle können Sie den geänderten Bereich noch einmal disassemblieren.

Lassen Sie als Beispiel einmal das Programm (siehe Befehl »A«) ab 4000 disassemblieren (»D 4000 4011«). Ändern Sie nun den ersten Befehl auf LDY #01. Die Änderung zeigt sich daran, daß die HEX-Bytes automatisch den neuen Wert annehmen. Starten Sie nun das Programm nochmals mit »G 4000«. Jetzt erscheint der Text mit nur einer Zeile Abstand auf dem Bildschirm.

### Starten eines Maschinenprogramms (Go)

G [ADRESSE]
startet ein Maschinenprogramm, das bei ADRESSE beginnt. Das Programm muß mit einem BRK-Befehl abgeschlossen werden, damit ein Rücksprung in SMON erfolgen kann. Wird nach »G« keine Adresse eingegeben, benutzt SMON die, die mit dem letzten BRK erreicht worden ist und bei der Register-Ausgabe als PC auftaucht. Mit dem »R«-Befehl (siehe unten) werden die Register vorher auf gewünschte Werte gesetzt.

### Memory-Dump

M [ANFADR ENDADR]
gibt die HEX-Werte des Speichers sowie die zugehörigen ASCII-Zeichen aus. Auch hier kann auf die Eingabe einer Endadresse verzichtet werden. Die Steuerung der Ausgabe entspricht der beim Disassemblieren.
Beispiel:

M 4000 gibt die Inhalte der Speicherstellen $4000 bis $4007 aus. Weiter geht es wie beim Disassemblieren mit SPACE oder RETURN. Die Bytes können ebenfalls durch Überschreiben geändert werden, allerdings nicht die ASCII-Zeichen. Verantwortlich dafür ist der Doppelpunkt, der am Anfang jeder Zeile ausgegeben wird, ein weiterer »hidden command«. Wenn Ihre Änderung nicht durchgeführt werden kann, weil Sie zum Beispiel versuchen, ins ROM zu schreiben, wird ein »?« als Fehlermeldung ausgegeben.

### Registeranzeige

R zeigt den gegenwärtigen Stand der wichtigsten 6510-Register an: Programmzähler (PC), Status-Register (SR), Akkumulator (AC), X-Register (XR), Y-Register (YR), Stackpointer (SP). Außerdem werden die einzelnen Flags des Status-Registers mit 1 für »gesetzt« und O für »nicht gesetzt« angezeigt. Durch Überschreiben werden die Inhalte auf einen gewünschten Wert gesetzt. Die Flags können allerdings nicht einzeln verändert werden, sondern nur durch Überschreiben des Wertes von SR.

### Exit

X springt ins Basic zurück. Alle Basic-Pointer bleiben erhalten. Sie können also zum Beispiel direkt im Programm fortfahren, wenn Sie zwischendurch mit SMON einige Speicherstellen kontrolliert haben.

Probieren Sie alle bisher beschriebenen Befehle in Ruhe aus und machen Sie sich mit SMON vertraut. Arbeiten Sie auch parallel den Kurs über Assemblerprogrammierung in dieser Ausgabe durch. Alle Beispiele dort sind auf SMON abgestimmt.

Wir wollen jetzt einen Blick auf das Programm selbst werfen. Natürlich ist es unmöglich, den gesamten Quelltext umfassend zu beschreiben. Andererseits enthält SMON aber eine Reihe von Routinen, die in jedem Maschinenprogramm vorkommen. Wir werden im Rahmen dieser Serie versuchen, die wichtigsten zu erklären, damit Sie sie später in eigene Programme einbauen können.

Zum besseren Verständnis werden solche Routinen so abgedruckt, wie wir sie im Assembler-Quelltext geschrieben haben. Sie enthalten daher anstelle absoluter Adressen Labels, deren Name — hoffentlich — etwas über den Sinn und Zweck aussagt. Parallel dazu sollten Sie sich diese Routinen von SMON disassemblieren lassen, damit Sie sehen, wie es denn nun fertig im Speicher aussieht.

Beginnen wir mit der Routine GETCHRERR. Das soll soviel bedeuten wie »Hole ein Zeichen und erzeuge eine Fehlermeldung, wenn keins eingegeben wurde«. Leider wäre so ein Label auch für den geduldigsten Assembler viel zu lang, daher die merkwürdige Abkürzung. Mit dieser Routine holen wir ein Zeichen von der Tastatur. Das erledigt die Betriebssystemroutine CHRIN. Um zu prüfen, ob überhaupt etwas eingegeben wurde, untersuchen wir das Zeichen. Handelt es sich um die »RETURN«-Taste ($0D), hat der Benutzer gar kein Zeichen eingegeben. Dies quittiert SMON mit einem »?« und dem Rücksprung in den Eingabemodus. So läßt sich — in gewissen Grenzen — kontrollieren, ob zu einem Befehl die richtigen Eingaben gemacht wurden. Geben Sie einmal den »D«-Befehl ohne Angabe einer Adresse ein, dann sehen Sie, was gemeint ist.

Alle Eingaberoutinen benutzen GETCHRERR, um Falscheingaben zu prüfen. Nehmen wir als Beispiel GETBYT. Diese soll ein Byte, also zwei ASCII-Zeichen 0 - F von der Tastatur holen und in ein Byte umwandeln. Das erste Zeichen wird darauf überprüft, ob es sich um ein »Space« oder ein Komma handelt. Trifft das zu, wird es einfach übergangen und das nächste Zeichen geholt. Der Benutzer kann also Leerzeichen und Komma benutzen, um seine Eingaben übersichtlicher zu machen, er muß aber nicht! Ist das Zeichen aber gültig, wird es von ASCHEX in eine Hexzahl gewandelt.
Dazu ein Beispiel:

Auf der Tastatur wurde 5B eingetippt. Zuerst wird jetzt die 5 (ASCII $35) mit $3A verglichen, um festzustellen, ob es sich um eine Zahl (0 - 9) oder einen Buchstaben (A - F) handelt. ASCII $35 ist eine Zahl, also wird nur die linke Hälfte ausmaskiert (AND #$0F). Ergebnis ist $05. Jetzt wird viermal nach links geschoben und das Ergebnis ($50) in $B4 zwischengespeichert. Nun ist das B (ASCII $42) an der Reihe. Da $42 größer ist als $3A werden diesmal 8 und das gesetzte Carry-Flag, also 9 addiert. Ergebnis ist $5B. Linke Hälfte ausmaskieren wie gehabt und eine OR-Verknüpfung mit dem gemerkten $50 ergibt $5B. Das war’s.

Meistens aber braucht SMON zwei Bytes als Eingabe, zum Beispiel für Adressen. Mit dem, was wir schon haben, kein Problem: GETADR ruft einfach GETBYT zweimal hintereinander auf und legt das Ergebnis in zwei Speicherstellen in der Zeropage ab, die mit dem X-Register ausgewählt werden können. Brauchen wir mehr als eine Adreßeingabe, rufen wir einfach GETADR mehrmals auf. So etwas machen GET3ADR und GET2ADR. Bisweilen aber, zum Beispiel beim G-Befehl, darf eine Adresse eingegeben werden, es muß aber nicht sein. Deswegen prüft GETSTART, ob direkt nach dem »G« »RETURN« gedrückt wurde. Dies erledigt GETRET. Wenn ja, wird die Adresse benutzt, die in PCL und PCH steht. Das sind SMONs interne Programm-Counter. Ansonsten wird die eingetippte Adresse benutzt.

Sie sehen, wie aus einfachen Routinen immer kompliziertere Befehle zusammengesetzt werden. Und das ist das ganze Geheimnis, wenn Sie umfangreiche Programme schreiben: Gliedern Sie sich das Problem (hier eine benutzerfreundliche Eingabe) in kleine und kleinste Schritte auf, die Sie dann jeden für sich programmieren und austesten.

Werfen wir noch einen Blick auf die Art und Weise, wie SMON Befehle verarbeitet. In EXECUTE setzen wir zunächst den Stackpointer auf den Wert, den er beim letzten BRK erreicht hatte. Dann werden als erstes die »hidden commands« abgeprüft. Wir lesen dazu direkt vom Bildschirm. D3 enthält die Anfangsadresse der aktuellen Zeile im Speicher. Übrigens gibt es neben den bereits erwähnten noch weitere »hidden commands«, die in den späteren Folgen noch auftauchen werden. Liegt kein verstecktes Kommando vor, holen wir mit GETCHRERR ein Zeichen und merken es uns in COMMAND. Jetzt untersuchen wir, ob dieses Zeichen in der Befehlsliste (CMDTBL) steht. CMDTBL steht übrigens ab $C00B ganz oben im Speicher. Sie endet mit fünf Nullen für spätere Erweiterungen. Direkt dahinter stehen die Anfangsadressen der zugehörigen Routinen in der für den 6502 typischen Reihenfolge, Low-Byte zuerst, dann High-Byte. Sehen Sie sich das mit M C00B einmal an. Am Ende dieser Tabelle stehen nochmals 10 Nullen, denn zu jedem Byte in CMDTBL gehören ja zwei Adreßbytes in der Liste (CMDS). Wenn nun ein Kommando in CMDSEARCH gefunden wurde, wird CMDEXEC als Subroutine aufgerufen. CMDEXEC legt nun die zugehörigen Adreßbytes auf den Stack und führt dann einen RTS aus, der jetzt — nach der Stackmanipulation — zu dem gewünschten Befehl führt. Beachten Sie, daß RTS immer auf die um eins erhöhte Adresse springt, daher müssen Sie zu den Adressen in CMDS immer 1 addieren, wenn Sie den Anfang einer Routine suchen.

Alle Befehle in SMON enden mit einem RTS, springen also auf den JMP EXECUTE hinter CMDFOUND. Damit ist eine Endlosschleife geschlossen, die immer einen Befehl ausführt und anschließend wieder in die Eingabe zurückspringt. Beim nächsten Mal erfahren Sie etwas über LOAD, SAVE und die Umrechnung verschiedener Zahlensysteme.

(Dietrich Weineck/N. Mann/gk)

### Hinweise zum Abtippen

Es ist mal wieder eine DATA-Wüste, die wir Ihnen zumuten, aber wenn Sie die erfolgreich hinter sich brachten, haben Sie schon mehr als die Hälfte vom gesamten SMON geschafft. Um Ihnen das Abtippen beziehungsweise die anschließende — fast unvermeidliche — Fehlersuche so einfach wie möglich zu machen, unterteilten wir das Gesamtprogramm in Blöcke zu je 256 Bytes, die jeweils eine eigene Prüfsumme haben. Wenn Sie sich vertippt haben, erscheint eine Fehlermeldung mit Angabe des Blocks, in dem sich der Fehler — höchstwahrscheinlich — befindet.

Vor dem ersten »RUN« sollten Sie aber unbedingt das Programm speichern, sonst kann Ihnen bei Fehlern der Computer abstürzen, und alle Mühe war umsonst.

Eins findet die Prüfsummenmethode allerdings nicht, nämlich zuviel eingegebene Nullen oder Kommas. Erhalten Sie aber keine Fehlermeldung und das Programm läuft trotzdem nicht, kontrollieren Sie als erstes, ob wirklich alle DATAs »aufgebraucht« sind. Dazu tippen Sie im Direktmodus PRINT A ein. Jetzt muß die letzte Zahl, also 197 erscheinen. Wenn nicht, haben Sie eine 0 oder ein Komma zu viel.

Wenn das Ladeprogramm endlich ohne Fehler bis zum READY durchläuft, können Sie SMON mit SYS 49152 starten. Die Bildschirmfarben ändern sich und es erscheint die Registeranzeige und in der nächsten Zeile ein Punkt mit blinkendem Cursor. Probieren Sie jetzt alle Kommandos durch. Hüten Sie sich aber vor allen anderen Kommandos. Die Fehlermeldung bei falschen Kommandos funktioniert noch nicht richtig!! Deshalb führen Falscheingaben in den meisten Fällen zum Programmabsturz. Das wird sich im Verlauf dieser Serie allerdings noch ändern.

Bevor Sie Ihren Computer aus dem Fenster werfen, noch ein Hinweis: Von der nächsten Folge ab wird SMON auch fix und fertig im Leserservice zu erhalten sein.

Und noch ein letzter Tip: Das Wichtigste, was ein angehender Maschinenprogrammierer braucht, ist ein Reset-Taster. (Bauanleitungen oder fertige Taster wurden schon oft im 64’er vorgestellt.) Sie werden es merken, wenn Sie mit sorgenzerfurchter Stirn, den Tränen nahe, vor Ihrem Bildschirm sitzen, kein freundlich blinkender Cursor weit und breit und RUN/STOP RESTORE auch dann nichts mehr bringt, wenn Sie die Tasten durch das Gehäuse durchdrücken. Verzweifeln Sie nicht, drücken Sie RESET, starten Sie SMON neu mit SYS 49152 und schon können Sie bis zum nächsten Absturz weiterarbeiten......

# Get Koala Pic

> Wenn Sie sowohl einen C 64 als auch das Koala Pad besitzen, dann können Sie Jetzt Koala-Bilder in ganz »normale« Basic-Programme einbeziehen.

Sie möchten Koala-Bilder auch ohne Koala laden und zeigen können. Wahrscheinlich haben Sie das Programm am Ende der Anleitung abgetippt, wie ich. Aber dann dachten Sie vielleicht auch, wie schön es wäre, wenn es möglich wäre, die Bilder der Reihe nach, wie eine Dia-Show abzurufen. Dann müßte man nicht mehr STOP-RETURN drücken, und unser Basic-Programm könnte weitergehen. Somit hätte man vielfältige Möglichkeit, Koala-Bilder anzuwenden! Zum Beispiel könnte man:

1.	...mit Koala ein Titelbild machen
2.	...mit Koala ein Abenteuer-Programm schreiben; denn: Wenn der Anwender einen Text lesen muß, während das Bild geladen wird, ergibt sich praktisch keine »Wartezeit« für ihn!
3.	...mit Koala ein Lernprogramm schreiben.

Tja, so ähnlich waren meine Gedankengänge. Aber meine Programmierkenntnisse in Basic nützen nichts; so ein Programm muß in Maschinensprache geschrieben werden! Also telefonierte ich mit einigen C 64-Besitzer-Kollegen herum und wurde fündig: Michael M. Meiszl war schon dabei, an so einem Programm zu basteln. Er paßte es meinen Wünschen an und stellte es in Rekordzeit fertig. Und nun können Sie alles oben Erwähnte tatsächlich tun, und noch viel mehr.

Listing 1 ist das Hauptprogramm. Es wird als erstes geladen. Listing 2 ist ein kleines Anwenderbeispiel, damit Sie sehen, wie die SYS-Befehle in ein normales Basic-Programm eingebaut werden. Bild 1 ist eine Übersicht, welcher SYS-Befehl nun was bewirkt. Falls Sie zwei Laufwerke besitzen, dann können Sie wahlweise 8 oder 9 eingeben.

Das Hauptprogramm ist sehr anwenderfreundlich: Es geht kein Basic-Speicherplatz verloren. Da jedes Bild einzeln geladen und danach alle Zeiger auf Null gesetzt werden, kann man, der Reihe nach, praktisch unzählige Bilder hintereinander im selben Basic-Programm zeigen. Hierzu muß der Anwender nur die Bilder-Diskette einlegen. Sollten Sie mehrere Bild-Disketten benützen wollen, so genügt ein PRINT-Hinweis auf dem Bildschirm, welche Diskette jetzt eingelegt werden muß. Da die Bilder per Leertaste »beendet« werden, kann das Programm nach einem Bild ganz normal weiterlaufen. Ein SYS-Befehl ermöglicht das Nochmalzeigen des letzten Bildes. Dies kann bei Lernprogrammen von Vorteil sein. Ein anderer SYS-Befehl ermöglicht das Laden ohne Zeigen, so daß dieses Bild dann blitzschnell abgerufen werden kann, da es »unsichtbar« bereits »besteht«. Wenn Sie die Tabelle griffbereit neben sich legen, haben Sie die SYS-Befehle bald im Griff.

## Noch ein paar Koala-Tips

1.	Im Menü finden Sie »INIT DISK«. Damit ist nicht »initialisieren« sondern formatieren gemeint. Trotzdem: Bei Disketten, die mit Koala formatiert wurden, ging jeder zweite Versuch, ein Bild zu laden schief: Dabei stieg dann jedesmal der Computer aus, so daß nicht nur das Bild verloren war, sondern man Koala neu laden mußte, und so weiter.
2.	Ich habe bereits des öfteren gelesen, daß die Handhabung im ZOOM-Modus so schwierig sein soll. Mein Vorschlag: Setzen Sie den Pfeil an die richtige Stelle und drücken Sie dann kurz auf die Taste oben. Auf diese Weise kann man punktweise (ebenfalls sehr schnell in lauter Einzelpunkt-Aktionen) und extrem akkurat arbeiten!
3.	Wenn Sie ein größeres Stück sauber »radieren« wollen (was durch DRAW mit Hintergrundfarbe leicht ist), dann hilft Ihnen ZOOM ebenfalls: »Radieren« Sie mit ZOOM erst die Ränder mit dem feinsten »Pinsel«, dann können Sie mit einem breiten »Pinselstrich« den Mittelteil schnell wegmalen!
4.	Wenn Sie etwas Riskantes ausprobieren wollen, was möglicherweise Ihr Bild kaputtmachen müßte (erst »radieren«, dann das Neue zeichnen, dann erst sehen, ob es Ihnen gefällt), dann rate ich Ihnen: Kopieren Sie das gesamte Bild per COPY (dem ein SWAP vorausgehen muß) auf den zweiten Bildschirm. Jetzt können Sie nach Herzenslust experimentieren, denn Ihr Bild existiert ja noch »im Original« auf der anderen Grafikseite.

So, jetzt hoffe ich nur noch, daß Sie in Zukunft noch mehr Spaß mit Koala haben werden.

(Vera F. Birkenbihl/aa)

# Der VC 20 als Laterna Magica

> Laterna Magica macht Spiele beweglicher und professioneller. Man kann Zeichen und zusammengesetzte Bilder nicht nur entwickeln, sondern auch bewegen, pulsieren, rotieren oder explodieren lassen und in eigene Programme einbauen.

»Laterna Magica« ist für jeden VC 20 gedacht, sei er erweitert oder nicht. Als Peripherie wird ein Floppy-Disk-Laufwerk VC-1541 vorausgesetzt. Das Programm kann aber für die Datasette umgeschrieben werden, indem die Gerätenummer 8 in Zeile 60 des DATA-Laders in eine 1 umgewandelt wird. Außerdem muß es dann im Hauptprogramm heißen: 490 PRINT”SAVE”CHR$(34)” ”CHR$(34)”,1,1”

Das Programm (Listing 1) ist nicht mehr zu erweitern, es können also auch keine REM-Zeilen mehr eingefügt werden. Es sieht zwar als Listing nicht sehr umfangreich aus, jedoch mußte das Basic-Ende heruntergesetzt werden, um das Maschinenprogramm, den neuen Zeichengenerator und den Speicherplatz, in dem wir später unsere Ersatzbilder speichern, vor Überschreibung zu schützen. Die Erzeugung von Grafik beim VC 20 beruht ja darauf, die Zeichen auf dem Bildschirm, die aus 88 Punkten aufgebaut sind, in ihrem Aufbau zu ändern. Bei einem Zeichen hieße es, 8 Byte gegen 8 andere auszutauschen. Bei 9 Zeichen (das ist die Zeichenanzahl, mit der »Lanterna Magica« arbeitet) werden es 7 2 Byte. Versuchte man das Problem mit Basic zu lösen, müßte man bei jedem Tauschvorgang eine Zählschleife von 1 bis 72 mit einigen POKEs dazwischen in Kauf nehmen. So etwas kann Action-Spiele ganz schön langsam machen. Ich habe diese Routine daher in Maschinensprache geschrieben. So genügt ein SYS-Aufruf, und 9 Zeichen auf dem Bildschirm ändern sofort ihre Form.

Ausgeführt werden kann der Tausch nur, wenn der Zeichengenerator nicht wie üblich im ROM liegt. Das ist also die erste Aufgabe des Maschinenprogramms. Es legt den Zeichengenerator ins RAM ab $1COO(entspricht dezimal 7168). Danach holt es sich aus dem Reserve-Bildschirmspeicher ($1A00 bis $1BFF, dezimal 6656 bis 7167) die ersten 72 Byte und legt sie im Bildschirmspeicher ab. Das ist zunächst alles. Beim nächsten Aufruf verfährt es mit den folgenden 72 Byte in gleicher Weise. Das geht siebenmal so, danach werden wieder die ersten 72 Byte geholt und so weiter.

Wichtig ist, daß vor jedem Aufruf in die Speicher $FB und $FC (dezimal 251 und 252) ein Wert von maximal 7 gePOKEt wird. An diesem Wert erkennt das Maschinenprogramm, wievielmal es die Bilder austauschen soll, bis es wieder beim ersten beginnt. Das bedeutet, daß man auch »Filme« mit nur drei Bildern laufen lassen kann, indem man den Wert 3 in diese Speicher POKEt.

## Der Bildeditor

Um diese besprochenen Bilder zu entwickeln, wären langwierige Berechnungen und viel Tastaturarbeit zum Eingeben der bis zu 504 Werte notwendig. Deswegen habe ich ein Programm geschrieben, das diese Arbeit übernimmt. (Listing 2).

Der Umgang mit dem Bildeditor ist recht einfach. Nach RUN erscheint in der oberen Hälfte des Bildschirmes eine Maske, in der die Zeichen aufgebaut werden und in der unteren Hälfte das Menü (siehe Bild).

Das Feld rechts oben zeigt das erste Bild. Man sieht zwar zunächst nur ein abstraktes Gebilde, das liegt aber nur daran, daß noch keine Zeichen entwickelt wurden. Links daneben stehen die gleichen Zeichen in Klarschrift. In beiden Feldern sind die gleichen Zeichen in der linken oberen Ecke schwarz, um herauszustellen, daß dieses Zeichen bearbeitet werden kann.

Mit F1 kann man nun ein Zeichen auswählen, das verändert werden soll. Dabei wandert das schwarze Feld jeweils eine Ziffer weiter.

Weiterhin kann man über den beiden Feldern die Bildnummer ablesen. Mit F3 können wir zwischen sieben Bildern wählen. Die Bilder werden jeweils im rechten Feld gezeigt. Es entsteht so schon ein Zeichentrickeffekt.

Hat man nun seine Wahl getroffen, kann man mit F7 in den Entwicklungsmodus wechseln. Der Cursor steht nun in der linken oberen Ecke des großen Entwicklungsfeldes. Er läßt sich voll steuern, jedoch nicht über den Feldrand hinaus. Tippt man nun, mehr oder weniger willkürlich, Buchstaben oder Zeichen in das Feld, sieht man gleichzeitig an der vorgewählten Ziffer im rechten Feld das Ergebnis. Man sollte nur nicht den Fehler machen, CLR/HOME oder INST/DEL zu drücken. Das kann den Bildschirmaufbau durcheinander bringen.

Mit RETURN kommt man ins Menü zurück.

Ist eine Bild- oder Zeichenfolge fertiggestellt, kann man den Trickfilm mit F5 ausprobieren. Im Menüfeld wird die Geschwindigkeit des Ablaufes erfragt. Eine gute Geschwindigkeit von 100 ist vorgegeben. Ein Wert von Null ergibt die größte Geschwindigkeit. In der anderen Richtung wird man selbst merken, wenn es langweilig wird. Mit RETURN wird gestartet, und mit der SPACE-Taste kann der Vorgang abgebrochen werden.

Es bleibt noch die F2-Funktion zu erklären. Bei Druck auf F2 erscheinen ein paar im ersten Augenblick wirr anmutende Befehle und die Bitte, den Namen der Bildfolge einzutragen. Das bedeutet, daß in der ersten Zeile (mit den vielen POKEs und dem SAVE) in die Lücke ein Name eingetragen werden soll. Es ist auch angebracht, das zweite Anführungszeichen an den Namen heranzuziehen. Dann drückt man RETURN, und alles geht wieder automatisch. Die Bildfolge wird als Maschinenprogramm geSAVEt und das Programm startet von neuem.

Zur Eingabe des Programmes: Bei Verwendung der Datasette muß zunächst der DATA-Lader (Listing 1) abgetippt und abgespeichert werden und danach Listing 2, weil der DATA-Lader selbständig das nächste Programm nachlädt. Verwendet man ein Floppy-Laufwerk, ist die Reihenfolge unerheblich.

Will man mit dem Programm arbeiten, muß erst der DATA-Lader geladen werden. »RUN« startet den Lader, der das Hauptprogramm lädt.

## Bildfolgen in eigenen Programmen

Will man die Trickfolge im selbstgemachten Programm anwenden, muß natürlich das Machinenprogramm im Speicher vorhanden sein. Dazu lädt man den DATA-Lader, löscht die Zeilen 60-75, setzt in Zeile 60 ein NEW und startet den Lader. Damit ist das Maschinenprogramm im Bereich dezimal 6400 bis 6640 abgelegt und vor Überschreibung geschützt. Der Lader löscht sich selbst. Außerdem ist auch der Bereich geschützt, in den nun die selbstgemachte Bildfolge mit »LOAD ”Name”,8,1« oder »LOAD ”Name”,1,1« geladen werden kann.

Damit keine Fehlermeldungen auftreten, gibt man jetzt noch den Befehl NEW ein und drückt die Return-Taste. Jetzt kann man das eigene Programm laden oder eintippen.

Das Maschinenprogramm wird übrigens mit SYS6400 aufgerufen.

Und noch einmal: Am Anfang des Programmes, vor dem ersten SYS6400 muß unbedingt eine Zahl zwischen 1 und 7 in 251 und 252 gePOKEt werden, eben die Anzahl der Bilder des Trickfilms. Alle kleineren Zahlen als 1 und alle größeren als 7 richten zwar keinen Schaden an, jedoch bewirken sie eine Einschränkung der Funktion.

Sollte man dies einmal vergessen haben, ist es angebracht, das Maschinenprogramm neu zu laden.

Zum Schluß noch zwei Tips.

1.	Bei erweitertem VC 20 sollte man für eigene Programme nicht das Basic-Ende herunter-, sondern den Basic-Beginn heraufsetzen. Damit hat man mehr Speicherplatz für seine Programme. (Zeile 20) des DATA-Laders: POKE44,32:POKE8192,0:CLR).
2.	Da bei der Arbeit mit diesem Programm nicht der Original-Zeichensatz vorhanden ist, kann man ihn, wenn gebraucht, über die RVS-ON-Taste darstellen. Dieses Verfahren habe ich selbst im Listing 1 verwendet.

(Bernd Schrödter/ev)

# Grafik leicht gemacht

> Mit einigen neuen Befehlen macht dieses Programm das Plotten von Funktionen zum Kinderspiel. Das mühsame Arbeiten mit den Commodore-Grafikbefehlen ist vorbei, wenn man die neuen Befehleeinsetzt.

Das Programm stellt eine Basic-Erweiterung dar, die im Bereich von $0800-$4000 angesiedelt ist. Dieser Bereich enthält das Maschinenspracheprogramm sowie den Grafikbildschirm. Die neuen Befehle und ihre Bedeutung:
**HIRES**: Dieser Befehl schaltet die hochauflösende Grafik ein. SCNCLR: Hiermit wird der Grafikbildschirm gelöscht.
**TEXT**: Um die Grafik wieder auszuschalten wird dieser Befehl benutzt. Am Programmende schaltet die hochauflösende Grafik automatisch ab.
**REGION a**: Die Cursor- beziehungsweise Plotfarbe wird festgelegt. Der Parameter a darf Werte von 0 bis 15 annehmen. COLOR a,b,c: Bestimmt die Hintergrundfarbe ( a ), die Rahmenfarbe (b) und die Zeichenfarbe (c ).
**PLOT x,y**: Dieser Befehl setzt einzelne Punkte auf dem Grafikbildschirm. Die Parameter x und y geben die Position des Punktes an. Der Ursprung des Koordinatensystems liegt in der linken oberen Bildschirmecke. X darf Werte von 0 bis 319, y Werte von 0 bis 199 annehmen. Bei Überschreiten dieser Bereiche gibt der Computer jedoch keine Fehlermeldung aus, wie es bei anderen Programmen meist der Fall ist. Für die Darstellung von Funktionen ist diese Einrichtung jedoch sehr nützlich.
**UNPLOT x,y**: Löscht einen gesetzten Punkt. Für die Parameter gelten die gleichen Grenzen wie beim Befehl PLOT.
**AXES x,y**: Zeichnet Koordinatenachsen auf den Grafikbildschirm. Die Parameter x und y bestimmen in diesem Fall den Ursprung des Koordinatensystems.

**ONERROR GOTO n**: Dieser Befehl fängt Definitionslücken von Funktionen ab, wenn nicht mit dem FPLOT-Befehl gearbeitet wird (siehe dort). Tritt während des Programmablaufs ein Fehler auf, der durch eine Definitionslücke verursacht wurde, wird zur Zeile n verzweigt. Dort wird das Programm ohne Unterbrechung weitergeführt. Die Fehlerausgabe wird sinnvollerweise jedoch nur bei den folgenden Fehlern unterdrückt:
ILLEGAL QUANTITY, DIVISION BY ZERO, OVERFLOW Bei anderen Fehlerursachen bricht das Programm wie üblich ab.
**FPLOT f(x) STEP n**: Dieser Befehl stellt das Kernstück des Programms dar. Er ermöglicht das Plotten einer beliebigen Funktion mit einem Befehl. Er setzt voraus, daß das Koordinatensystem seinen Ursprung in der Mitte des Bildschirms hat. Nach STEP kann noch angegeben werden, in welchen Intervallen Punkte für die Funktionsdarstellung berechnet werden sollen. Soll die Funktion sehr genau ausfallen, muß n klein gewählt werden. Reicht eine grobe Darstellung, so wählt man den Parameter n größer. Läßt man den STEP-Befehl aus, wird n=0.03 gesetzt, was sich meist als bester Wert erweist. Die Anwendung des FPLOT-Befehls an einem Beispiel: Die Funktion f(x)=SQR(X) soll ausgegeben werden.
10 HIRES
20 SCNCLR
30 AXES160,100
40 FPLOTSQR(X)
Das Programm schaltet die hochauflösende Grafik ein, löscht den Grafikbildschirm, zeichnet die Koordinatenachsen und plottet die Funktion. Alle neuen Befehle des Programms können übrigens wie die normalen Basic-Befehle über die Shift-Taste abgekürzt werden.

Zum Schluß noch ein Tip: Es gibt Funktionen, die in der Hauptsache in einem Bereich verlaufen, der nicht innerhalb der Koordinaten liegt, die für den FPLOT-Befehl vorgesehen sind. In diesem Fall wird einfach auf den PLOT-Befehl zurückgegriffen. Ein kleines Basic-Programm plottet unter Verwendung dieses Befehls auch solche Funktionen problemlos. In diesem Fall ist außerdem die Benutzung des ONERROR-Befehls sinnvoll.

Hier noch Hinweise zum Eintippen und Abspeichern beziehungsweise Laden des Programms. Vor dem Eingeben des Basic-Quellprogramms werden die folgenden Befehle eingegeben, die den Anfang des Basic-Speicherbereichs nach oben verschieben:
POKE44,16:POKE4096,0:NEW
Danach gibt man das Quellprogramm ein. Es enthält die DATAs für das Maschinenprogramm sowie eine Prüfsummenroutine. Nachdem das Maschinenprogramm erzeugt ist, wird es abgespeichert. In Zukunft muß nur noch das Maschinenprogramm geladen und gestartet werden.

(Uwe Seimet/rg)

# Supergrafik II

> Dieses Programm liefert eine Grafik-Auflösung von 200 mal 256 Punkten und nützt damit den Bildschirm vollständig aus, und dies in der Grundversion des VC 20.

Es handelt sich hier um eine Weiterentwicklung des im 64’er, Ausgabe Mai 1984, Seite 81 abgedruckten Programms. Nach Eingabe der Größe des Koordinatensystems generiert das Programm den Grafen einer Funktion und ihrer Ableitung in verschiedenen Farben. Es ist sicher für viele Besitzer des VC 20, insbesondere für Schüler und Lehrer interessant.

Die Funktionsgleichung wird in Zeile 1 definiert. Das Programm legt den Koordinatenursprung in die Bildschirmmitte und zeichnet den Grafen der Funktion (rot) und ihrer Ableitung (gelb). Nach dem Programmstart wird der Definitionsbereich der Funktion abgefragt (-XMAX^X^XMAX) und der Maßstab für die Hochwert-Achse gewählt (-YMAX^Y^YMAX). Das Programm kann aus Gründen des beschränkten Speicherplatzes zwar »nur« 159 Felder aus jeweils 8 mal 16 Punkten ansprechen, was aber für diese Anwendung vollkommen ausreicht. Um Speicherplatz zu sparen, wurde auf Kommentare im Programm und Grundsätze zur übersichtlichen Programmierung bewußt verzichtet.

(Rudolf Dörr/ev)

# Sprites ohne Esoterik

> Auch fortgeschrittenen Programmierern bleibt es meist rätselhaft, wie der C 64 die Sprites auf den Bildschirm zaubert. Wir wollen dieses Thema einmal ohne Geheimniskrämerei (Esoterik) angehen.

Noch vor fünf Jahren war alles ganz einfach. Im guten alten PET 2001 wurde das Bild durch ein mittleres TTL-Bergwerk erzeugt. In den Nachfolgern CBM 30xx und so weiter wird diese Aufgabe durch einigeTTL-ICs und den Bildschirmcontroller MC6845 erledigt. Bis dahin war alles überschaubar.

Da Commodore die Halbleiterfirma MOS Technology besitzt, liegt es nahe, eigene Video-Controller zu entwickeln. So treibt im VC 20 der noch relativ einfache VIC I (Video-Interface-Chip I) sein Unwesen. Im C 64 wirft der sehr komplexe VIC II die »Flammenschrift« auf den Bildschirm.

Die Funktionsweise dieses Video-Controllers soll dieser Bericht ein wenig enträtseln. Leider muß man es größtenteils durch Überlegung lösen.

Zunächst ein paar Worte zum Bildschirmformat: Es entspricht weitgehend der normalen Fernsehnorm. Je 312 Rasterzeilen ergeben fünfzig Bilder in der Sekunde. Jede Rasterzeile (Bild 1) ist 64 µs lang und beginnt mit einem Synchronisationsimpuls, der dem Monitor mitteilt, wann er mit der neuen Zeile beginnen soll. Ohne diese Synchronisation gäbe es nur Bildsalat und durchlaufende Bilder. Der Synchronisationsimpuls entspricht in der Helligkeitsskala der Videosignale einem Dunkelschwarz, so daß man den Strahlrücklauf nicht sehen kann. Es gibt übrigens nur fünf Helligkeitsstufen:

1.	Schwarz
2.	Rot, Blau, Braun, Grau 1
3.	Violett, Grün, Orange, Hellrot, Grau 2, Hellblau
4.	Türkis, Gelb, Hellgrün, Grau 3
5.	Weiß

Es ist empfehlenswert, für die Vorder- und Hintergrundfarbe Farben aus verschiedenen Helligkeitsstufen zu wählen, da man sonst auf farblosen Monitoren nicht viel sehen kann...

40 µs der Rasterzeile werden für das eigentliche Bild benützt. Bei der Taktfrequenz (desVIC) von zirka8MHz ergeben sich 512 Punkte auf der ganzen Rasterzeile, was mit der horizontalen Auflösung der Positionen der Sprites übereinstimmt. Aus den 64 µs ergibt sich eine Zeilenfrequenz von 15625 Hz, die für das unangenehme Pfeifen verantwortlich ist, das man bei jedem Bildschirm hören kann, sofern man noch gute Ohren hat. Das horizontale Scrolling ist übrigens sehr einfach zu verwirklichen. Statt dem ganzen Bild wird kurzerhand der Synchronisationsimpuls und das durch den Rand gebildete »Fenster« verschoben.

Das vertikale Format ist folgendermaßen aufgebaut:
4 Zeilen Schwarz, damit man den Strahlrücklauf nicht sieht
3 Zeilen Synchronisationsimpuls
4 Zeilen Schwarz
51 Zeilen Rand
200 Zeilen Bild
51 Zeilen Rand

Den aufmerksamen Lesern wird aufgefallen sein, daß ich hier von 312 Zeilen pro Bild rede und nicht von 625 Zeilen, wie es beim normalen Fernseher der Fall ist. Beim Fernseher werden nacheinander zwei »Halbbilder«, die zueinander um eine halbe Rasterzeile versetzt sind, geschrieben, so daß die Auflösung höher ist. Nachteilig ist bei diesem Verfahren die geringe Bildwiederholfrequenz von 25 Hz, bei der das Bild leicht flimmert. Beim C 64 sind beide Bilder identisch und nicht versetzt (non-interlace), die Bildwechselfrequenz beträt 50 Hz.

Um ein Zeichen darzustellen, muß der VIC in einer einzigen Mikrosekunde folgende Informationen lesen:

1. POKE-Wert des Zeichens aus der Videomatrix; zeigt in den Zeichengenerator
2. Farbe aus der Farbmatrix
3. Daten aus dem Zeichengenerator.

Das heißt, zusammen mit den Zugriffen der CPU müßte der Speicher mit einer Zyklusfrequenz von 4 MHz (!) betrieben werden. Das ist nicht möglich. Dieses Problem wird auf eine andere Weise gelöst.

Die CPU 6510 gibt an ihrem Ausgang Pin 2 einen Takt von zirka 1 MHz ab (Bild 2). Wenn Pin 2 Low ist, ist der Bus frei, wenn Pin 2 High ist, benötigt die CPU den Bus für ihre Speicherzugriffe.

Der VIC liest, während Pin 2 Low ist, die Daten aus dem Zeichengenerator oder aus der hochauflösenden Grafik.

Das Farb-RAM wird vom VIC parallel zum normalen RAM gelesen. Der VIC hat also einen 12-Bit-Datenbus.

Zum Lesen der Videomatrix ist keine Zeit mehr übrig. Deswegen muß der VIC regelmäßig die CPU anhalten, um die Daten lesen zu können. Durch dieses »Kaltstellen« wird der Prozessor natürlich verlangsamt. Damit die CPU nur um etwa zehn Prozent und nicht um die Hälfte verlangsamt wird, hat der VIC intern Puffer für die Video- und Farbdaten der aktuellen Zeile. Daraus ergibt sich die auf Bild 3 gezeigte Reihenfolge der Zugriffe:
a) Letzte Rasterzeile der vorherigen Zeile: Die CPU wird angehalten, in die Puffer werden die Daten für die neue Zeile gelesen.
b) Während den sieben ersten Rasterzeilen der neuen Zeile wird die CPU nicht angehalten.
a) Wieder von vorn.

Leider hat auch dieses Verfahren Nachteile. Erstens wird der Prozessor verlangsamt, zweitens geraten bei zeitkritischen Programmen durch das Anhalten des Prozessors die Zeitverhältnisse aus dem Lot. Deswegen wird zum Beispiel beim Laden von Programmen von Kassette der Bildschrim abgeschaltet!

Und nun zu den Sprites. Unbegrenztes Vertrauen in die Leistungsfähigkeit der CPU 6510 ist nicht angebracht. Im VIC ist kein Maschinenprogramm versteckt. Es wäre ganz einfach zu langsam. Statt dessen werden die Sprites durch aufwendige Hardware erzeugt. Dieser Aufwand macht aber nicht so viel aus, da eben alles in einem Chip versammelt ist. Schwierig wird die Entwicklung eines solchen Video-Controllers vor allem durch die notwendige hohe Geschwindigkeit: Der IC hat immerhin eine Taktfrequenz von 8 MHz zu verkraften. Deswegen wird der VIC gewaltig heiß und residiert in einem unter kühlendem Blech verborgenen Keramikgehäuse.

Trotz allem ist die Logik für die Sprites eigentlich verblüffend einfach und elegant. Da Digitalelektroniker auch beim Einschlafen noch Gatter zählen, die über Schafe springen, und auch sonst mit jedem Gatter geizen (einfache ICs sind billiger), kann man schließen, daß wahrscheinlich auch hier der einfachste Weg benützt wird.

Die Daten der Sprites müssen zuerst gelesen werden. Die Logik zur Errechnung der Adressen der Sprites soll hier nicht erklärt werden, da sie nicht besonders interessant ist. Es ist mir leider nicht bekannt, wann die Spritezeiger (am Ende der Videomatrix) gelesen werden.

In jeder Rasterzeile müssen die Daten aller Sprites gelesen werden, also 3 x 8 Byte, die nahtlos in das »gemütliche Eckchen« in der Austastlücke passen. Jetzt wissen wir auch, wieso die Sprites ein so unmögliches Format (24 x 21 Pixel) haben...

Ich möchte nun anhand von Bild 4 erklären, wie die Sprites dort angezeigt werden, wo sie hingehören. Im Schema ist nur die Schaltung für ein Sprite gezeichnet, die anderen Sprites sind gleichartig aufgebaut.

Die Spritedaten werden in einen Puffer gelesen. Ein Zähler gibt die Nummer der aktuellen Rasterspalte, also die X-Koordinate, an. Davon wird die X-Koordinate der Sprites abgezogen, und man erhält eine auf den »Ursprung« des Sprites bezogene Koordinate. Die Ausdehnung von Sprites in der X-Richtung ist sehr einfach: Die Koordinate wird einfach durch zwei geteilt (in Binärsystem sehr einfach: rechts schieben). Das gleiche geschieht übrigens auch bei der Ausdehnung von Sprites in der Y-Richtung. Ein Multiplexer gibt das, durch die so erhaltene Koordinate, gewählte Bit (oder Bitpaar bei mehrfarbigen Sprites) aus. Falls die Koordinate nicht im Bereich des Sprites liegt, gibt der Multiplexer einfach den Wert für »Sprite transparent« — also 0 — aus.

Wie werden die Sprites nach der Priorität geordnet und Kollisionen von Sprites mit anderen Sprites oder mit dem Vordergrund des normalen Bilds erkannt?

Jedes Sprite gibt ein Signal von sich, das angibt, ob das Sprite jetzt transparent oder »deckend« ist. Eine relativ einfache Schaltung (in TTL nur 28 Gatter: 74LS148) erzeugt die Nummer des Sprites mit der höchsten Priorität, das gerade deckend ist oder zeigt an, daß gar kein Sprite deckend ist.

Nun muß noch entschieden werden, wer jetzt Vorfahrt hat (in der Reihenfolge der Prioritäten): Der Rand, Sprites im Vordergrund, das normale Bild, Sprites im Hintergrund oder der Hintergrund. Entsprechend dieser Entscheidung wird der richtige Farbcode ausgewählt und an den PAL-Codierer weitergegeben, der das Helligkeitssignal (Videosignal) und das Farbsignal (Chroma) erzeugt.

Die Erkennung von Kollisionen ist keine schwierige Sache mehr. Wenn sowohl das Bild als auch ein oder mehrere Sprites nicht transparent sind, werden im Kollisionregister für Sprite-Bild-Kollisionen die Bits der nicht transparenten Sprites gesetzt.

Sprite-Sprite-Kollisionen sind etwas schwieriger auszuwerten, auch hier bleibt der Aufwand aber im Rahmen.

Ich hoffe, daß ich bei den Lesern mit diesem Artikel jeglichen Geisterglauben ausgetrieben habe.

(Pascal Dornier/aa)

# Pseudo-Sprites auf dem VC 20

> Der VC 20 kennt von Haus aus leider nicht die freibeweglichen Grafikobjekte des C 64, die sogenannten Sprites. Das bedeutet aber nicht, daß man auf die Vorteile der Sprites oder MOBs gänzlich verzichten muß.

Das Programm ist für den VC 20 mit 8 KByte Speichererweiterung konzipiert. Es läuft jedoch mit einigen Änderungen auch bei nur 3 KByte Speichererweiterung.

Vor dem Eintippen oder Laden muß man POKE 44,32:POKE 8192,0: NEW eingeben, womit der Basic-Anfang im Speicher auf die Adresse dezimal 8193 ($2001) erhöht wird. Somit ergibt sich folgende Speicheraufteilung:
4096 — 4607 Bildschirm
4608 — 8191 frei
8192 — 16383 (bei + 8 KByte) Basic-Programmspeicher
8192 — 24575 (bei + 16 KByte) Basic-Programmspeicher
8192 — 32767 (bei + 24 KByte) Basic-Programmspeicher

Der freie Bereich wird nun vollständig von dem Maschinenspracheprogramm gebraucht. Die Aufteilung des Speicherraums ist die folgende:

TODO

Die Pseudo-Sprites sollten eine Auflösung von 16 x 16 Punkten haben, das sind 256 Punkte oder 4 Zeichen im freidefinierbaren Zeichensatz (Bild 1). Damit aber ein 16 x 16 Punkte großes Zeichen jede Position auf dem Bildschirm einnehmen kann, braucht man eine 24 x 24 Punkte große Umdefinier-Matrix, in die das Zeichen hineinkopiert wird. Das Aussehen dieser Umdefinier-Matrix ist in Bild 2 zu sehen. Das Programm übernimmt nun die Aufgabe, das Zeichen in die Umdefinier-Matrix zu kopieren (Bild 3), in die richtige X-Position zu schieben (Bild 4), und dasselbe mit der Y-Position zu tun.

Außerdem werden die Zeichen, die später auf dem Bildschirm von den Sprites verdeckt werden, mit in die Umdefinier-Matrix hineinkopiert. So entsteht der Eindruck, daß die Sprites wirklich über die Zeichen wandern. Beim späteren Löschen werden die verdeckten Zeichen wieder hergestellt. Wie funktioniert das nun?

Im Speicher ab dezimal 4608 ist 9mal (für jedes Sprite einer) der sogenannte Sprite-Control-Block (SCB) eingerichtet. Er hat die Aufgabe, die momentane X- und Y-Position, die Farbe des Sprites, den Bildschirmmodus (gesetzt/gelöscht) des Sprites, die durch die Umdefinier-Matrixverdeckten 9 Zeichen und Farben zwischenzuspeichern:

TODO

Die Basisadresse des SCB errechnet sich somit aus der Formel Basisadresse = 4608 + Spritenummer x 22. Das Zwischenspeichern und die Auswertung der Parameter übernimmt natürlich das Maschinenprogramm. Über den SCB werden auch im nachfolgend beschriebenen Programm »Sprite-Definer« die Sprites initialisiert und deren Farbe festgelegt. Da nur die oberen 128 Zeichen des Zeichensatzes für die Sprites verwendet werden, hat man eine ausreichende Anzahl von noch frei definierbaren Zeichen, nämlich genau 128, zur Verfügung. Außerdem kommen jeweils 13 Zeichen, nämlich 4 für das Sprite und 9 für die Umdefinier-Matrix hinzu, wenn man auf ein Sprite verzichtet. Die Matrixen werden im Speicher so abgelegt:

TODO

Konkret wird das Programm (Listing 1) nun folgendermaßen bedient: Vor dem Laden oder Eingeben wird POKE 44,32:POKE 8192,0:NEW eingetippt. Ist nun das Maschinenspracheprogramm im Speicher, kann es mit einem Monitorprogramm auch noch einmal abgespeichert werden. Später muß man es nur noch mit LOAD »name«, 1,1 laden.

Die Bedienung:
Sind die Sprites definiert. muß dem Maschinenspracheprogramm mitgeteilt werden, wo der Zeichensatz liegt, den es verwalten soll. Das geschieht mit den Befehlen POKE 677, Lowbyte:POKE 678, Highbyte, in unserem Fall also POKE 677,0:POKE 678,20, da der Zeichensatz auf der Adresse 5120 beginnt.

Soll nun ein Sprite auf den Bildschirm, muß zuerst einmal in Adresse 683 die Spritenummer gePOKEt werden (Achtung, keine Zahl über 8 angeben, da sich das Programm dann selbst zerstören könnte). Schließlich werden in Adresse 673 die X-Koordinate (maximal 159) und 674 die Y-Koordinate (maximal 167) gesetzt. Dann kann das Programm mit SYS 8021 sofort aufgerufen und auf dem Bildschirm das Sprite betrachtet werden, vorausgesetzt man hat vorher mit POKE 36869,205 auf den freidefinierbaren Zeichensatz geschaltet.

Wird nun das Sprite auf eine andere Position gesetzt, so verschwindet es vollständig von der alten Position, und die Zeichen, die auf diesem Platz waren, erscheinen wieder mit ihrer alten Farbe. Will man aber das Sprite ganz vom Bildschirm löschen, POKEt man wieder in 683 die Spritenummer und ruft das Maschinenspracheprogramm diesmal mit SYS 8099 auf. PRINT »CLR/HOME« sollte man nicht verwenden, da im SCB noch die alten Bildschirmzeichen gespeichert sind und beim nächsten Setzen wieder auf ihren alten Plätzen auf dem Bildschirm erscheinen würden.

## Der Sprite-Generator

Nun zum Programm »Sprite-Definer« (Listing 2).

Dieses Programm ist ein Sprite-Generator in Basic, der bei der Erstellung von Sprites recht hilfreich sein kann. Das Programm verdeutlicht auch, wie die Definition der Sprites und die Bedienung des Maschinenspracheprogramms erfolgt.

Obwohl sich das Programm fast von selbst erklärt, hier doch einige kurze Erläuterungen:

Startet man das Programm mit RUN, erscheint als erstes die Begrüßung und die Aufforderung »Bitte warten!«. Das Programm kopiert nämlich jetzt den Zeichensatz aus dem ROM ins RAM, was in Basic naturgemäß etwas dauert.

Jedesmal, wenn man in einem Menüteil eine Eingabe gemacht hat, wird man »Richtig?« gefragt. Tippt man hier für N (Nein), so kann die Eingabe wiederholt werden. Drückt man aber den Linkspfeil, so kommt man wieder ins Hauptmenü.

Die Tastenbelegung im Editiermodus:

TODO

Bei der Funktion »Weiter« kommt man in ein zweites Menü, das weitere Funktionen zur Verfügung stellt. Aus diesem Menü gelangt man mit »zurück« wieder ins Hauptmenü. Beim Speichern werden die Sprites als reiner Speicherauszug auf Kassette gebracht, so daß das Laden im Prinzip auch mit LOAD »name«,1,1 möglich ist.

Sicherlich kann das Maschinenspracheprogramm noch weiter verbessert werden. So wäre zum Beispiel eine Spritesteuerung per Interrupt durchaus denkbar. Leider funktioniert das Maschinenprogramm nicht mit den üblichen Grafikmodulen, da diese den Bildschirminhalt auch mit dem freidefinierbaren Zeichensatz aufbauen. Sollen Sprites auch miteinander oder übereinander dargestellt werden, dann muß das Setzen und Löschen nach folgender Reihenfolge durchgeführt werden, da es sonst zu Schwierigkeiten mit dem SCB kommen kann:

Sprite 0 setzen, Sprite 1 setzen,..., Sprite n setzen. Hiernach die Berechnungen für die neuen Positionen durchführen.

Sprite n löschen,.Sprite n-1 löschen,..., Sprite 0 löschen. Danach Vorgang von oben wiederholen.

Noch eins zum »Sprite-Definer«: Die erste REM-Zeile muß auf jeden Fall mit 16 Sternchen eingegeben werden, da sich das Programm später mit POKEs selbst verändert und andernfalls, wäre die REM-Zeile kürzer, die folgende Zeile in Mitleidenschaft ziehen würde. Doch nun wünsche ich allen, die das Programm eintippen, viel Spaß und vielleicht ein bißchen C 64-Feeling.

(Markus Leberecht/ev)

# Hex-DATA-Automat

> Der Computer programmiert sich selbst — Maschinenprogramme werden automatisch in DATA-Statements mit Prüfsumme umgewandelt.

Ein Maschinenprogramm in ein korrektes Basic-Ladeprogramm umzusetzen, ist sicherlich eine sehr langweilige Programmieraufgabe, außerdem schleichen sich sehr schnell Fehler ein.

Soll diese Umsetzung automatisch erfolgen, müßte sich der Computer — salopp gesagt — selbst programmieren. Dies ist prinzipiell möglich; doch zuvor einige Grundlagen.

Geben Sie hierzu das nebenstehende kleine Testprogramm ein.

<pre>100 POKE 2,0
110 ZL=PEEK(2) : POKE 2,ZL+1
120 D$=STR$(ZL+1000)
130 D$=D$+"DATA ABCFDEF”
140 PRINTCHR$(147);D$
150 PRINT ”RUN 110”
160 :
180 END
</pre>

Die Programmzeile 100 setzt die Speicheradresse 2 auf Null. Anschließend wird der Wert dieser Adresse nach ZL geholt und die Adresse um eins erhöht. Der STR$-Befehl wandelt den WertZL+1000 in einen String, und die Zeile 130 erweitert den String mit »DATA ABCDEF«. Die CHR$-Anweisung löscht anschließend den Bildschirm und schreibt den String »1000 DATA ABCDEF« links oben auf den Bildschirm. Zuletzt wird in der zweiten Bildschirmzeile der Text »RUN 110« gedruckt.

Falls Sie nach RUN die Taste HOME drücken, steht der Cursor auf der Zeile »1000 DATA ABCDEF«. Drücken Sie nun die RETURN-Taste, dann wird die Zeile 1000 in das Programm aufgenommen. Der Cursor steht jetzt auf dem »RUN 110«. Drücken Sie jetzt erneut RETURN, so startet das Programm wieder, und es folgt der nächste Durchgang mit:
1001 DATAABCDEF
RUN 110

Da im ersten Durchlauf der Wert in der Speicherzelle 2 um eins erhöht wurde, lautet die nächste Zeilennummer 1001. Nun könnten Sie wieder (in Handarbeit) HOME/RETURN/RE-TURN eingeben, doch — und jetzt wird’s interessant — auch dies kann der Computer durchführen.
160 POKE 198,3
170 POKE 631,19:POKE 632,13:POKE 633,13

Geben Sie nun RUN ein. Das Programm erweitert sich nun automatisch — ab der Nummer 1000 — um DATA-Zeilen.

Dies ist möglich, da alle Commodore-Computer mit einem Tastaturpuffer arbeiten. In diesem Zwischenspeicher, der beim VC 20 und C 64 ab der Adresse 631 beginnt, kann sich der Computer bis zu neun Tastatureingaben merken. Die Anzahl der Zeichen in dem Puffer steht in der Adresse 198.

In der vorherigen Programmerweiterung wurde in der Zeile 160 der Wert 3 eingePOKEt. Der Computer meint anschließend, es seien drei Tastatureingaben erfolgt. Die POKE-Befehle in der Zeile 170 simulieren die Eingabesequenz HOME, RETURN, RETURN. Nach dem Programmende vergißt der Computer diese untergeschobenen Eingaben keineswegs, sondern führt sie nachträglich aus.

Aus der Zeit des legendären PET 2001 stammt noch die Bezeichnung »selbsterhaltendes Programm«. Naja, aber so hatte das Kind wenigstens einen Namen.

Leider hat das beschriebene Verfahren den Nachteil, daß der Computer, sobald er sich selbst die Zeile einprogrammiert, die Variablen löscht. Aus diesem Grund müssen Sie wichtige Werte vor dem Programmabbruch durch POKE sichern und beim Neustart mit PEEK zurückholen. In dem vorherigen Testprogramm wurde beispielsweise der Zähler für die Zeilennummer mit der Adresse 2 weiter gegeben.

Das Programm »HEX-DATA-Automatik« arbeitet im Prinzip genau nach dem zuvor beschriebenen Verfahren. Die Umwandlungsroutine wird mit RUN 200 gestartet. Das Programm fragt dann nach der Anfangs- und Endadresse des Maschinenprogramms und wandelt es anschließend in DATA-Zeilen um. Diese haben das folgende Format:
1000 DATA 01,02,03,04,05,...,20, 1234
1001 DATA 11,12,13,14,15,...,40, 5678
1002 DATA ...

Nach jeweils 20 Hexadezimal-Daten folgt immer eine Prüfsumme.

Anschließend müssen Sie die DATA-Routine (200—720) löschen und den Schleifenzähler in Zeile 30 anpassen. Falls das Programm veröffentlicht werden soll, können Sie zusätzlich ein Copyrightstatement hinzufügen.

Für diesen Zweck wurde diese Routine auch ursprünglich erstellt. Die Zeilen 10—90 wandeln die Hex-Zahlen wieder um und schreiben das Maschinenprogramm in den entsprechenden Speicherbereich zurück (Zeile 30 beachten).

Das Programm kann in dieser Form sehr leicht abgetippt werden, da Prüfsummenfehler wie folgt angezeigt werden:
ZEILE 1000
ZEILE 1001
ZEILE 1002
ZEILE 1003 PRÜFSUMMENFEHLER !
BREAK IN 80

Anschließend müssen nur 20 Daten überprüft werden, so daß auch längere Basic-Lader vergleichsweise schnell und fehlerfrei abgeschrieben werden können.

(Heino Velder/ev)

# Joystick-Abfrage in Theorie und Praxis

> Wenn der Joystickanschluß für Sie »ein Buch mit sieben Siegeln« ist, so wird Ihnen dieser Artikel für den VC 20 weiterhelfen. Doch auch die »Profis« werden einige wichtige Informationen finden.

Ein Joystick besteht aus vier Schaltern, die im rechten Winkel zueinander angeordnet sind. Der Handgriff erlaubt neun abfragbare Positionen:

— eine Position mit allen Schaltern offen: Griff in Ruhe
— vier Positionen mit je einem Schalter geschlossen: Griff in Nord, Süd, Ost, West
— vier Positionen mit zwei Schaltern geschlossen: Griff in Nordost, Südost, Südwest, Nordwest

Ein zusätzlicher »Feuerknopf« hat einen eigenen Schalter.

Grafisch sieht das so aus:

TODO

Jeder der fünf Schalter ist mit je einer Leitung von zwei speziellen integrierten Bausteinen mit dem Namen »VIA 6522« (Versatile Interface Adapter) verbunden. Diese sind, wie der Name andeutet, programmierbare Adapter für die Ein- und Ausgabe (also auch für den Joystick).

Leider sind die fünf Schalter etwas ungleichmäßig auf die beiden VIAs verteilt:

— Schalter 0,1, 2 und der Feuer-Schalter 4 verwenden VIA 1
— Schalter 3 verwendet VIA 2

Der Kontakt des Joysticks mit den VIAs und damit mit dem VC 20 wird durch zum Teil Ihnen schon bekannte Registerzellen geregelt, welche folgende Adressen haben:

— Ein-/Ausgabe-Register A des VIA 1: 37137
— Ein-/Ausgabe-Register B des VIA 2: 37152

Der Vollständigkeit halber sei erwähnt, daß jeder VIA noch ein zweites E/A-Register hat, nämlich:

— E/A-Register B des VIA 1: 37136
— E/A-Register A des VIA 2: 37153

Für den Joystick brauchen wir diese jedoch nicht.

Die einzelnen Leitungsanschlüsse der Joystick-Schalter sind:

— Schalter 0 ... Bit 2 von 37137
— Schalter 1 ... Bit 3 von 37137
— Schalter 2 ... Bit 4 von 37137
— Schalter 4 ... Bit 5 von 37137
— Schalter 3 ... Bit 7 von 37152

Ich habe gesagt, daß 37137 und 37152 Ein- und Ausgaberegister sind, das heißt wir können sie in beiden Richtungen benützen.

Die Entscheidung darüber liegt in je einem zugeordneten »Daten-Richtungs-Register«.

— Dem E/A-Register 37137 ist das DR-Register 37139 zugeordnet.
— Dem E/A-Register 37152 ist das DR-Register 37154 zugeordnet.

Dieses Arrangement erlaubt, jede einzelne Leitung eines E/A-Registers separat auf Ein- oder Ausgabe zu schalten, völlig unabhängig voneinander.

Das geht so:

Sobald in einem Bit des DR-Registers eine 1 steht, ist die entsprechende Leitung des E/A-Registers auf Ausgabe geschaltet, bei einer 0 auf Eingabe.

Im Bild unten habe ich die notwendigen Bitmuster in die beiden DR-Register eingezeichnet.

Im Register 37139, an dem ja vier Schalter hängen, wäre die hineinzuPOKEnde Zahl 195. Da aber während der Joystick-Abfrage dieses Register für nichts anderes verwendet wird, setzen wir ruhig das ganze Register auf 0.
10 POKE 37139,0

Beim Register 37154 ist die Lage anders, dadas zugehörige E/A-Register 37152 zur Tastaturabfrage verwendet wird. Da müssen wir die Auswahl der Leitung schon genau machen.
20 POKE 37154,127

Während der Joystick-Abfrage funktionieren die Tasten in der Spalte 127 der 8 x 8-Matrix nicht.

Zeile 10 und 20 »initialisieren« die Joystick-Abfrage.

Ein Experimentier-Programm zum Testen, was jetzt bei der Bewegung des Joysticks stattfindet, ist ganz einfach:
30 PRINT PEEK(37137);PEEK(37152)
40 GOTO 30

Am Ende empfiehlt es sich, die volle Tastatur wieder einzuschalten mit
POKE 37154,255

In einem Programm können Sie also einfach die Werte in den beiden Adressen der Zeile 30 (mit IF ... THEN) abfragen.

Zur Vermeidung von eventuellen Störungen durch die Mehrfachfunktionen der Register ist es aber empfehlenswert, die einzelnen Bits direkt abzufragen. Das sieht dann so aus:
10 POKE 37139,0
20 POKE 37154,127
30 IF PEEK(37137) AND 4 THEN...   (Schalter 0)
40 IF PEEK(37137) AND 8 THEN...   (Schalter 1)
50 IF PEEK(37137) AND 16 THEN...  (Schalter 2)
60 IF PEEK(37137) AND 32 THEN...  (Schalter 4 = Feuerknopf)
70 IF PEEK(37152) AND 128 THEN... (Schalter 3)
80 POKE37154,255

(Helmuth Hauck/rg)

# Unterbrechen Sie mich bitte!

> Im Gegensatz zum Bereich zwischenmenschlicher Beziehungen, wo jemanden zu unterbrechen als plumpe Unhöflichkeit eingestuft wird, ist dies einem Computer gegenüber nicht nur ein beliebtes, sondern sogar erwünschtes Verfahren effektvoller Programmgestaltung. Für die meisten Anwender aber sind solche, »Interrupt« genannte, Methoden — leider — mehr oder weniger »Böhmische Dörfer«.

Anhand der vielseitigen Hardware des Commodore 64 wollen wir nun einmal den Schleier des Geheimnisses ein wenig lüften, Ihnen mit einem Demonstrationsprogramm einige Anwendungsbeispiele zeigen und Sie auf Ihrem Bildschirm kein blaues, aber ein buntes Wunder erleben lassen.

Wenn Sie Ihren C 64 einschalten, und der Cursor blinkt, dann haben Sie bereits einen Interrupt erzeugt. Es handelt sich dabei um eine gezielte Programmunterbrechung, die auf ein bestimmtes Ereignis fixiert ist, so zum Beispiel den Inhalt einer Speicherstelle. Tritt der erwünschte Zustand ein, so räumt die Hardware diesem Vorgang Priorität vor allen anderen Aufgaben ein. Gleich was der Computer im Augenblick macht, er wird unverzüglich seine Tätigkeit einstellen und ein spezielles Unterprogramm abarbeiten, das ihm zuvor als Interruptroutine deklariert wurde. Im Betriebssystem-ROM befindet sie sich von Adresse $EA31 (dezimal 59953) bis $ECB8 (60600). Hier wird etwa 60mal in jeder Sekunde geprüft, ob eine — und falls ja, welche — Taste gedrückt wurde; hier wird das Blinken des Cursors erzeugt und der Motor der Datasette ein- oder ausgeschaltet. Wenn der Interrupt beendet ist, setzt der Computer die Bearbeitung des laufenden Programms exakt an der Stelle fort, an der er sich vor Eintritt des Interrupts gerade befand. Gewöhnlich merkt man von solchen Intermezzi nichts, weil der Prozessor eine ungeheure Geschwindigkeit entwickelt, deren Arbeitstakte sich bereits im Bereich von Mikrosekunden (millionstel Sekunden) bewegen.

Noch eine andere Einrichtung der von Ihnen benutzten Geräte ist mit extremer Schnelligkeit ausgestattet: Der Elektronenstrahl, der vor Ihren Augen 25mal in jeder Sekunde ein neues Bild auf die Mattscheibe zeichnet. Nach diesen grundsätzlichen Überlegungen wollen wir aus solchen Voraussetzungen einen Wettstreit der Systeme entwickeln und den Computer gegen den flotten Strahl antreten lassen. Unglaublich, werden Sie jetzt wahrscheinlich sagen, aber warten Sie ab! Möglich ist das nämlich, weil der für die Bildorganisation zuständige Video-Interface-Controller (VIC) stets genau darüber »im Bild« ist, welche Rasterzeile des Monitorbildes augenblicklich geschrieben wird. Das ist die Bedingung dafür, daß auf dem Schirm auch ein Bild im geordneten Zusammenhang wiedergegeben wird. Der VIC, dessen Register unter den Adressen 53248 ($D000) bis 53294 ($D02E) erreichbar sind, führtin der Speicherzelle 53266 ($D012) Buch über die jeweilige Zeilennummer. Darüber war schon einmal zu lesen, daß es unsinnig wäre, dort etwas hineinzuschreiben, weil man den Elektronenstrahl der Bildröhre gar nicht steuern könne. Und das ist nur zum Teil richtig, denn steuern können wir den Strahl nicht, wohl aber können wir ihn steuern lassen.

Dafür ist besagtes Register — wie übrigens viele andere auch — mit einer Doppelfunktion ausgerüstet. Abhängig von der jeweiligen Zugriffsart, Lesen oder Schreiben (PEEK oder POKE), erreicht man unter derselben Hausnummer verschiedene Adressaten. Wird das Register gelesen, so erfährt man die gerade bearbeitete Rasterzeile, wird es beschrieben, bleibt der übermittelte Wert gespeichert und dient dem internen Vergleich, ob er mit der aktuellen Zeile identisch ist. Wenn dieser Fall eintritt, so reagiert die Hardware selbständig darauf und erzeugt einen Interrupt — falls ein solcher vorgesehen war. Zuvor muß dem Computer nämlich noch mitgeteilt werden, daß dies ein Interruptauslöser sein soll. Die Anmeldestelle ist die Adresse 53274 ($D01A), das Interrupt-Masken-Register.

Diese Speicherstelle korrespondiert ständig mit ihrem Nachbarn 53273 ($D019), dem Interrupt-Request-Register. Ist die vorgewählte Rasterzeile erreicht, signalisiert 53266 dieses Ereignis durch Kippen des Bits 0 im Request-Register: Es nimmt den Wert 1 an. Ist Bit 0 auch in der Maske gesetzt, wird der Interrupt-Pin des VIC aktiv und löst die Unterbrechung aus. Im Demo-Programm schreiben wir zu diesem Zweck eine 1 in die Maske, und fortan gilt für uns die Gesetzmäßigkeit, daß Bildhintergrund und -rand unifarben dargestellt werden, nicht mehr. Wir ändern nämlich ab einer beliebigen Rasterzeile die Bildfarben, um sie einige Zeilen weiter abermals umzuschalten. Da das schneller vor sich geht, als das träge menschliche Auge es registrieren kann, resultiert daraus kein wirres Flackern, sondern ein konstantes mehrfarbiges Bild, das im Extremfall (siehe Beispiel »Regenbogen«) sogar alle 16 möglichen Farben des Randes und Hintergrunds gleichzeitig wiederzugeben in der Lage ist.

Noch aber funktioniert der neue Interrupt nicht, denn der C 64 weiß noch nichts von unserem Programmsegment, mit dem wir den Farbwechsel vornehmen wollen. Dazu müssen wir ihm die Adresse der Routine im Interrupt-Vektor ab Speicherstelle 788 ($0314) hinterlegen: Lowbyte in 788, Highbyte in 789. Aber auch jetzt wird das Ergebnis immer noch nicht unseren Erwartungen entsprechen, da uns laufend der immer noch aktivierte Systeminterrupt in die Quere kommt und nach der Vektorenänderung ebenfalls in der neuen Routine unkontrolliert arbeitet. Dieser Interrupt stammt aus einer ganz anderen Quelle, vom Complex-Interface-Adapter (CIA), auf den wir gleich noch zu sprechen kommen. Softwaremäßig können wir ihn durch Setzen der Interruptflagge (SEI) nicht unterbinden, weil damit auch der ebenfalls maskierbare Rasterzeilen-Interrupt abgeschaltet würde. Zwei Möglichkeiten gibt es, das Problem zu lösen: Der CIA-Interrupt wird belassen, muß dann aber zu Beginn der Interrupt-Routine abgefragt (zum Beispiel durch Prüfen des Bits 0 im Request-Register 53273) und gegebenenfalls durch eine Umleitung über Sprungbefehle unschädlich gemacht werden, oder er wird eliminiert durch Schreiben des Wertes 127 in die Speicherstelle 56333 ($DCOD). Weil wir in unserem Demo-Programm weder Cursor-Blinken noch die Tastaturabfrage benötigen, entscheiden wir uns für letztere und löschen gleich zu Programmbeginn (siehe Assembler-Listing) den CIA-Interrupt völlig.

Außerdem ist zu berücksichtigen, daß der Elektronenstrahl auf allen Seiten ein Stück über den Rand des auf dem Monitor sichtbaren Bildes hinausschreibt. Dadurch entstehen Zeilennummern bis 280, so daß von Register 53266 aus bei einem Überlauf ein Highbyte nach Bit 7 des Registers 53265 übertragen werden muß. In dieser als »SCREEN« definierten Speicherstelle liegen allerdings auch einige andere Funktionen, die gegebenenfalls durch eine logische OR-Verknüpfung berücksichtigt werden müssen. Das Demo-Programm verwendet diese Funktionen indem durch Löschen des Bits 4 der Bildschirm ausgeblendet wird, so daß auf dem Schirm nur noch ein ganzflächiger Rand erscheint, obwohl auch weiterhin Texte auf den jetzt unsichtbaren Hintergrund ausgegeben werden können. Beispiel: POKE 53265, PEEK (53265) AND 255-16 läßt den Hintergrund verschwinden, POKE 53265, PEEK(53265) OR 16 zaubert ihn dann wieder herbei.

Der Rasterzeilen-Interrupt ist eine Spezialität des C 64, die ihn zu einem äußerst vielseitigen Gerät macht. Die Programmier-Profis der Videospiel-Produzenten benutzen ihn nicht allein dafür, oben blauen Himmel und unten braune Erde darzustellen, sondern auch, um ein nur partielles Scrolling zu erzielen, um Text und hochauflösende Grafik zu mischen, um gleichzeitig normale und Multicolorzeichen zu benutzen und und und... Aber damit erschöpfen sich die Interruptmöglichkeiten des Commodore 64 noch nicht. Bit 1 (Wert = 2) der Maske in 53274 erzeugt einen Interrupt, wenn ein Sprite Berührung mit einem Zeichen hat, Bit 2 (Wert = 4) wenn Sprite mit Sprite zusammenstößt, Bit 3 (Wert = 8) wenn ein Impuls vom Lightpen kommt, oder der Feuerknopf eines am Controlport 1 angeschlossenen Joysticks gedrückt wird und schließlich Bit 7 (Wert = 128), wenn eines der genannten Ereignisse eingetreten ist

Und dann ist da noch der bereits genannte CIA-Interrupt, der von einem gleich doppelt vorhandenen Baustein stammt. Beiden sind jedoch im C 64 teilweise unterschiedliche Aufgaben zugewiesen. CIA 1 hat die Basisadresse 56320 ($DC00), CIA 2 eine solche von 56576 ($DD00). Hier erfolgt beispielsweise die Tastaturdekodierung, die Abfrage von Joysticks, Paddles und Lightpen, die serielle Datenübertragung zu einer Schnittstelle, hier befinden sich die Echtzeituhren und die Timer. Wenden wir uns letzteren in CIA 1 zu.

Der Timer ist ein 16-Bit-Zählregister, das nach dem Starten ohne weiteres Zutun mit einer konstanten Geschwindigkeit dekrementiert, das heißt jeweils um 1 abwärts gezählt wird. Durch die zuvor beim VIC schon erwähnte Doppelfunktion besteht die Möglichkeit, den Timer ab einem bestimmten Wert zählen zu lassen: Lesen der Adresse 56324 ($DC04) liefert den aktuellen Stand des Lowbytes, Hineinschreiben den Startwert des Timers, ebenso beim Highbyte unter der Adresse 56325. Auf diese Weise wird der Systeminterrupt erzeugt, da der Computer in der Initialisierungsphase den Timer mit dem Wert 16421 ( = 37 low und 64 high) lädt. Wenn derTimerüber Null hinauszählt und damit einen sogenannten Unterlauf erzeugt, wird das durch Setzen des Bits 0 im lnterrupt-Control-Register 56333 ($DC0D) signalisiert. Auch dieses arbeitet wieder doppelt: Lesen ergibt die Interruptanforderung, ein Schreibzugriff erzeugt die Maske, die darüber entscheidet, welches Ereignis Interruptauslöser sein soll. Besondere Beachtung beim Beschreiben des Registers verdient Bit 7, das darüber bestimmt, ob die nachfolgend gesetzten Bits 6 bis 0 in der Maske gesetzt oder gelöscht werden. Alle übrigen bleiben unangetastet. Deshalb löscht 127 (Bit 7 nicht gesetzt!) im Demo-Programm sämtliche Maskenbits (siehe Bitmuster im Assembler-Listing, Zeile 1010), deshalb setzt 129 (Bitmuster 10000001) das Bit 0 der Maske und schaltet damit auf Interrupt durch den Timer. Erzeugen Sie doch einmal im Direktmodus auf dem Bildschirm ein längeres Zählintervall durch Heraufsetzen des Timer-Highbytes: POKE 56325, 255 läßt den Cursor sehr träge werden, POKE 56325, 5 versetzt ihn in nervöses Flattern.

Dieser Timer besitzt einen Zwillingsbruder mit den Adressen 56326 und 56327, der nicht nur gleichartig konstruiert ist und ebenfalls eigenständig einen Interrupt auf Bit 1 des Control-Registers erzeugen kann, sondern sich auch mit dem Timer A koppeln läßt. Beide Timer können nämlich auf verschiedene Taktquellen gelegt, unterschiedlich getriggert werden. Im Demo-Programm nutzen wir das aus, indem wir Timer A Systemtakte zählen lassen (Bit 5 des Registers 56334 gelöscht — Standardeinstellung), Timer B hingegen nur die Unterläufe von Timer A durch Setzen des Bits 6 im Register 56335. Dadurch erhalten wir einen 32-Bit-Zähler, der beliebige Zeitverzögerungen ermöglicht, eleganter als mit jeder ausschließlich softwaremäßig realisierten Warteschleife, weil die Timer von keinem Interrupt unterbrochen werden.

In der Warteschleife des Demo-Programms (Listing ab Zeile 9010), die als Subroutine angelegt ist, wird mit den Timern kein Interrupt erzeugt, sondern lediglich eine Zeitverzögerung erzielt. Dazu wird zunächst Timer B mit den vom Hauptprogramm im Akku und im Y-Register übergebenen Werten geladen, während Timer A konstant mit einem mittleren Wert arbeitet. Dann werden beide gestartet durch Setzen des Bits 0 im Register 56334 für Timer A und 56335 für Timer B. Aus Zeile 9030 des Listings ist ersichtlich, daß Bit 3 für Timer A gelöscht ist, was Continuous- oder Dauerbetrieb zur Folge hat. Jedesmal, wenn der Timer einen Unterlauf hat, lädt er umgehend wieder den zwischengespeicherten Startwert und beginnt erneut zu zählen. Den anderen schalten wir hingegen auf One-Shot (Zeile 9050), einen »Einzelschuß«. Bei einem Unterlauf lädt er zwar wieder den Startwert, bleibt aber stehen, wodurch sein Start/Stoppbit automatisch gelöscht wird. Wir prüfen dies, indem wir Bit 0 logisch nach rechts ins Carry verschieben, wo es bequem mit einem Branchbefehl untersucht werden kann. Erst der One-Shot-Betrieb des Timers B stellt sicher, daß ein Unterlauf auch erkannt wird, weil er im Dauerbetrieb vorübergehen könnte, während sich der Prozessor im Interrupt befindet. Außerdem verlangt ein gesetztes Bit 4 in der Warteschleife für beide Timer Force-Load, einen unbedingten Ladevorgang. Unabhängig davon, ob der Timer gerade läuft oder nicht, wird der Startwert geladen. Mit einem gelöschten Bit 4 kommt ein neuer Startwert erst dann zum Tragen, wenn er nach dem nächsten Unterlauf geladen wird.

Neben den Unterläufen der beiden Timer kann das Control-Register 56333 auf Bit 2 auch einen Interrupt erzeugen bei Übereinstimmung der Echtzeituhr 56328 bis 56331 mit einer vorgewählten Alarmzeit, auf Bit 3 durch ein volles oder leeres Schieberegister (56332) und auf Bit 4 durch den Impuls einer externen Signalquelle. Ein gesetztes Bit 7 zeigt hier an, daß mindestens eines der gesetzten Bits auch in der Maske gewählt ist, also ein Interrupt stattfindet. Das Interrupt-Flag wird aber bereits durch Lesen des Registers gelöscht.

Diese Kurzabhandlung vermag nur ansatzweise darzustellen, wie flexibel das Instrumentarium ist, das hier dem Anwender zur Verfügung steht. Speziell die zahlreichen Interruptmöglichkeiten verlangen geradezu nach Anwendung, wobei wir abschließend auf eine bisher nicht erwähnte noch zu sprechen kommen müssen. Denn das Demo-Programm läuft in einer Endlosschleife, die nicht ohne weiteres abgebrochen werden kann. Außerdem wird ja durch den lahmgelegten Systeminterrupt ohnehin kein Tastendruck mehr erkannt. Den Ausweg aus diesem Dilemma, haben die Konstrukteure geschaffen, als sie den sogenannten NMI erfanden. Das ist die Abkürzung für nicht maskierbarer Interrupt, eine hardwareseitige Unterbrechungsmöglichkeit mit so hoher Priorität, daß selbst ein gesetztes Interruptflag keine Rolle spielt. Wir können den NMI auslösen, indem wir die STOP-Taste gedrückt halten und gleichzeitig auf die RESTORE-Taste klopfen. Und schon ist alles wieder normal: Bild und Interrupt. Sie können zwar gleich wieder mitSYS49152 ins Demo-Programm starten, doch vielleicht lassen Sie sich selbst einmal etwas einfallen. Nur zu — unterbrechen Sie doch Ihren Commodore 64 bitte mal ...

(Helmut Welke/aa)

# Betriebssystem-Erweiterung für den VC 20

> Hier sind einige Erweiterungen für das Betriebssystem des VC 20, die auf Tastendruck funktionieren, wie zum Beispiel Hardcopy, Find, Relocate, Append und Beep.

Diese nützlichen Routinen werden mit dem Basic-Lader (Listing) ab Adresse $6050 in den Speicher gebracht. Ein voll ausgebauter VC 20 (+24 KByte) ist daher Voraussetzung. Um das Programm in die Tastaturabfrage einzubinden, die alle 60stel Sekunde erfolgt, wird der Zeiger für die Tastaturdecodierung (655,656) abgeändert. Damit dort nicht nach jedem STOP/RESTORE wieder der alte Wert steht, wird auch noch der BRK-Vektor (790,791) abgeändert. Zu alledem dient der SYS-Befehl in Zeile 120. Im einzelnen stehen folgende Erweiterungen zur Verfügung (die Druckroutinen sind für den Epson RX-80 mit VC-Interface):
CTRL G: Grafik auf Drucker (mit VIC 1211A)
CTRL D: Bildschirm-Hardcopy mit Zwischenzeile
CTRL H: Bildschirm-Hardcopy ohne Zwischenzeile (zum Beispiel für normale Blockgrafik)

Dabei ist zu beachten, daß das letzte Zeichen rechts unten nicht gedruckt wird, da sonst der Bildschirm gescrollt würde. Ein Bildschirm-Dump kann jederzeit erfolgen, auch während des Programmablaufs.
CTRL F: FIND mit Eingabe des Suchstrings
CTRL L: FIND weiter

FIND durchsucht ein Basic-Programm nach bestimmten Befehlen oder Zeichenfolgen und listet die Zeile, in der sich der gesuchte Begriff befindet. FIND weiter (CTRL L)bedeutet, daß das Programm weiter nach demselben Begriff durchsucht wird. Dabei ist eine Zeichenkette in Anführungszeichen einzugeben. Beispiel: Gesucht wird die Anweisung IF. Eingabe IF. Gesucht wird der String »REIF«. Eingabe »REIF«.

Im folgenden bedeutet »CTRL+Com«, daß die CTRL- und die Commodore-Taste gleichzeitig gedrückt werden.

CTRL+Com R:RELOCATE; rückgängig machen des NEW-Befehls. Diese Routine ist besonders nützlich, wenn ein Reset-Schalter existiert, da bei einem Reset ein Basic-Programm nicht zerstört wird, sondern wie bei NEW nur die ersten beiden Bytes auf Null gesetzt werden. Falls der Computer sich also mal beim Aufruf eines fehlerhaften Maschinenprogramms »aufhängt«, kann nach Reset, SYS 25600 und Drücken von CTRL+Com R ohne Verlust des Basic-Programms weitergemacht werden.

Auch nach einem »LOAD-ERROR« kann nach RELOCATE das falsch geladene Programm gelistet werden.

CTRL+Com S: Kopiert die Zeiger auf den Basic-Programmstart, die Variablen, Arrays und Strings und die ersten 65 Byte des Basic-Programms in den (hoffentlich) geschützten Bereich, in dem sich die Betriebssystemerweiterung befindet.

CTRL+Com+RETURN-Taste: Umkehrfunktion von CTRL+Com S

Falls ein Programm gelöscht und anschließend im Direktmodus mit Variablen gearbeitet wurde, dann ist der Anfang des gelöschten Programms zerstört. Das Programm kann nicht mit RELOCATE repariert werden. Wurde aber vorher zu irgendeinem Zeitpunkt, an dem das zerstörte Programm noch existierte, CTRL+Com S gedrückt, dann steht das Programm nach Betätigen von CTRL+COM+RETURN-Taste wieder mit allen Variablen, Arrays und Strings so zur Verfügung, wie zum Zeitpunkt des Kopierens.
CTRL+Com —: BEEP aus
CTRL+Com +: BEEP an

BEEP dient als akustische Rückmeldung der Tastatur, daß eine Taste gedrückt wurde. Ein momentan laufender Sound wird nicht beeinflußt.

CTRL+Com t: APPEND. Der Zeiger auf den Basic-Anfang wird auf das Ende des momentanen Programms gesetzt. So können mehrere Basic-Programme aneinandergehängt werden. Dabei wird die Größe des zur Verfügung stehenden Speicherplatzesausgegeben. Durch CTRL+Com -: werden das angehängte und das vorherige Programm verknüpft.

CTRL+Com W: WARTE. »Friert« den Computer ein, bis die RETURN-Taste gedrückt wird. Diese Routine ist vor allem bei LIST nützlich: Das Bildschirm-Scrollen wird verhindert.

Die Funktion der Zusatztasten wird dabei nicht beeinflußt, so daß während dieses Zustands zum Beispiel auch eine Hardcopy angefertigt werden kann.

Soll das Progamm mit der VC1211A-Supererweiterung zusammmenlaufen, dann müssen folgende Änderungen vorgenommen werden:
Zeile 25: Die letzten drei DATA-Werte lauten 55,163,0.
Zeile 43: Die ersten vier DATA-Werte lauten 0,32,13,164.
Zeile 120: SYS 25453 (muß auch beim Aufruf der Relocate-Funktion angegeben werden.

Nachdem diese Änderungen durchgeführt sind, stimmen natürlich die Prüfsummenabfragen nicht mehr. Es empfiehlt sich daher, das Programm in jedem Falle zunächst einmal probeweise unverändert (und ohne VC 1211A) laufen zu lassen, um eventuelle Tippfehler in den DATA-Zeilen herauszufinden. Danach kann man die Prüfsummenabfragen in den Zeilen 10, 30, 40, 60, 70, 90, 100 und 110 einfach löschen.

(Manfred Weigt/ev)

# Befehlserweiterung für Simons Basic

> Die Fähigkeiten des Commodore 64 sind mit dem vorhandenen Befehlsvorrat des Basic 2.0 nur sehr schwer auszunutzen. Dafür bietet Commodore eine Erweiterung an, die diesen Mangel weitgehend behebt: Simons Basic. Dieser Artikel gibt eine grobe Speicherbelegung und behebt einige Mängel.

Leider muß im voraus erwähnt werden, daß nur Besitzer der Disk-Version POKEs anwenden können, da bei der Modul-Version ein unveränderbares ROM vorliegt und somit POKEs hier unwirksam sind.

Obwohl nur 8 KByte im Basic-Speicher verbraucht werden, ist Simons Basic eine 16-KByte-Basic-Erweiterung. Die zweiten 8 KByte liegen unter dem Basic-ROM im RAM, so daß Simons Basic immer trickreich zwischen beiden Ebenen umschalten muß. Zusätzlich wird auch der Bereich von $C400-$CBFF (dezimal 50176-52223) benutzt; zum Beispiel liegt der KEY-Funktionstastenspeicher ab $C64D (50765).

Bei MEM (dem Befehl zum Kopieren des Original-ZeichenROMs ins RAM und dessen Einschalten) liegt der Zeichensatz ab $E000 (57344) im RAM unter dem Kernal, der Bildschirm von nun an ab $CC00 (52224), die Sprite-Pointer ab $CFF8 (53240) und die Sprites von $C000-$C3FF (49152-50175).

Bei HIRES und MULTI (den Grafik- und Farbgrafik-Modi) liegt der Grafik-Speicher unter dem Kernal im RAM ($EOOO-$FFFF, 57344-65535), der Farbspeicher ab $C000 (49152), und Sprites finden sich in den Blocks 48-63 (ab $CC00, 52224). Man sieht also, daß $COOO-CFFF (49152-53247) laufend belegt sind und kleine Maschinenroutinen höchstens in Sprite-Speichern plaziert werden können.

Hier erst einmal Beanstandungen zur Beschreibung einiger Befehle:

Beim **TEXT-Befehl (Einsetzen von Text in die HiRes-Grafik-Seite) müssen Zeichentyp, Größe und Abstand als Konstanten gegeben sein, da der Text sonst nicht korrekt ausgedruckt wird. <CTRL-A> und <CTRL-B> können beliebig in einem String benutzt werden. Kein CTRL am Anfang wird als Großschrift ausgelegt. <RVS ON/OFF>-Zeichen werden auch richtig ausgeführt.

Beim Befehl **FETCH** (Eingaberoutine mit bestimmbarer Zeicheneingabe-Beschränkung) fehlt die Angabe, daß die Eingabelänge über ein Zeichen (wie angegeben) hinausgehen darf. Das Limit liegt bei 88 Zeichen. Danach ist der Eingabepuffer, in den die eingegebenen Zeichen abgelegt werden, gefüllt und dahinterliegende Systemvariablen (siehe C 64-Handbuch) können zerstört werden. Ein Fehler ist außerdem, daß nach der Eingabe des letzten Zeichens keine Korrektur (mit < DEL>) mehr möglich ist. Es bleibt keine andere Wahl, als <RETURN> zu drücken.

Bei **DUMP** (Ausgabe der Inhalte aller nicht indizierten Variablen) werden die Werte leider ohne Vorzeichen ausgegeben. Dies kann man beheben mit **POKE 32953,221**. Zudem werden leere Strings (Länge 0) als Strings mit zufälligen 255 Zeichen und Integervariablen als 16-Bit-Adressen ausgegeben. Das Programm in Listing 1 beseitigt alle drei Fehler.

Im Handbuch wird bei den Bildschirmroll-Befehlen das Format leider falsch angegeben. Die Parameter werden mit der Routine geholt, die auch INV und MOVE bedient. Daher ist auch das Format das gleiche:
Richtung W/B r,c,w,d.

Die Parameter entsprechen denen im Simons Basic-Handbuch in Abschnitt 7.6.

Bei **MERGE** kann es vorkommen, daß ein Programm nicht ordnungsgemäß angehängt wird. Dieser Fehler kommt nicht mehr vor, wenn man immer **OLD** vor MERGE eingibt, da dieser Befehl das Programmende noch einmal überprüft und gegebenenfalls bereinigt.

Bei **PAGE** kann man das Listen nicht, wie in der Anleitung angegeben, durch Drücken der RUN/STOP-Taste abbrechen. Das Programm in Listing 2 behebt diesen Fehler.

Befehle, die zwar nicht im Handbuch, jedoch in der Befehlsliste im RAM zu finden sind, wurden bereits in früheren Ausgaben behandelt.
Zur Speicherung der Simons Basic-Befehle:

Die Befehle werden als Zwei-Byte-Kombination abgespeichert. Das erste Byte hat den Wert 100, und das zweite einen Wert zwischen 1 und 127. Dies ergäbe eine Befehlsmenge von 127 Befehlen, einige Tokens sind aber nicht belegt.

Um alle Befehlscodes auszugeben, kann man Listing 3 verwenden. Nach RUN wird eine Liste der Interpretercodes ausgegeben, die direkt aus dem RAM von Simons Basic und aus dem Basic-ROM entnommen wird. Setzt man in Zeile 20 für A den Wert 12 7 ein, so wird nur der normale Befehlsvorrat ausgedruckt. Mit diesem geänderten Programm kann sich jeder C 64-Anwender eine Interpretercodetabelle erstellen, die leider im C 64-Handbuch fehlt.

Nun zwei kurze Maschinenprogramme, die nach einmaligem Lauf als neue Befehle zur Verfügung stehen:
**ERROR**:

Ausgabe des Diskettenstatus auf dem Bildschirm (Listing 4).
**JOY n**:

Nach Ausführung dieses Befehls liest die Funktion JOY den Control Port n (n=1 oder 2) (Listing 5).

Die Listings 1 und 5 lassen sich zum Beispiel als Vorprogramm nach dem Start von Simons Basic laden und starten und stehen danach bis zum Ausschalten des Computers bereit.
(Dieter Temme/gk)

# Die Ebenen des Absturzes

> Nachdem ich mir den Commodore 64 gekauft hatte, schnappte ich mir das Handbuch und fing an, in Basic zu programmieren. Wenn ich einmal versehentlich in eine Endlosschleife geriet, drückte ich die Run/StopTaste, und das Programm wurde unterbrochen, damit ich den Fehler beseitigen konnte — die Computerwelt war in Ordung!

Doch wer den C 64 kennt, hat sich sicher schon an die Befehle PEEK und POKE versucht. Zum Beispiel:
100 FOR I = 0TO999
110 POKE 1024 + I,0
120 POKE55296 + I,0
130 NEXT I

Dieses kleine Programm füllt den Bildschirm mit schwarzen Klammeraffen. Doch wehe, man hat in Zeile 100 statt 999 die leicht erweiterte Version 9999 stehen! Direkt hinter dem Bildschirmspeicher liegt der Basic-Benutzerspeicher. Bei solchen Fehlern frißt sich das Programm von selbst auf. Das Programm ist teilweise, wenn nicht ganz, zerstört. Der fortgeschrittene Programmierer macht sich sicher eines Tages Gedanken, wie er seine Programme durch versehentliches Drücken der Run/Stop-Taste schützen kann.

Dieses ist besonders dann angebracht, wenn das fertige Programm von einem C 64-Unkundigen bedient werden soll.

Dieses kleine Porgramm bewirkt Wunder:
100 FOR I = 830TO834
110 READ A : POKE I,A : NEXT I
120 POKE 808,62 : POKE 809,3
130 DATA169,1,201,0,96

Weshalb? Im Betriebssystem gibt es ein Unterprogramm, welches die 8topp-Taste abfragt. Das Programm liegt zwischen 63213 ($ F6ED) und 63226 ($ F6FA). Die Anfangsadresse dieser Routine ist in den Speicherzellen 808 und 809 gespeichert; und zwar Low-Byte vor High-Byte. Nun wird diese Routine regelmäßig aufgerufen. Ist die Stopp-Taste gedrückt worden, so veranlaßt diese Routine — abgesehen von ein paar anderen Instruktionen —, daß das Zeroflag gesetzt wird. Wurde die Stopp-Taste aber nicht gedrückt, so löscht dieses Unterprogramm das Zeroflag. Wenn die Speicherzellen 808 und 809 so verändert werden, daß zu einer Routine gesprungen wird, die immer das Zeroflag löscht, dann wird nie das Drücken der Stopp-Taste erkannt. Dieses geschieht durch unser kleines Programm, welches eine Routine in den Kassettenpuffer schreibt.

Haben wir für kritische Programmteile die Stopp-Taste unterdrückt, können wir jene wieder durch den Befehl
200 POKE 808,237 : POKE 809,246
aktivieren.

Nehmen wir einmal an, uns ist folgendes passiert: Wir haben ein Programm geschrieben, das die Stopp-Taste ausschaltet (damit auch Run/Stop + Restore). Das Programm stürzt ab (zum Beispiel durch eine Endlosschleife), und wir haben es noch nicht abgespeichert. Das Programm scheint verloren, denn wir können den Computer nur noch aus- und einschalten. Doch da gibt es noch eine Rettung. Das magische Wort heißt RESET.

Falls Sie in einem Programm einen Reset wünschen, dann benutzen Sie folgenden Befehl:
100 SYS 64738

Der Bildschirm verengt sich links und rechts um ein halbes Zeichen, und dann meldet sich der Computer, als ob sie ihn gerade eingeschaltet hätten. Hardwaremäßig bewirken sie einen Reset, indem Sie Pin 1 und Pin 3 am User-Port verbinden.

Sie können aber auch Pin 2 und Pin 6 am seriellen Bus verbinden. Dazu nehmen Sie das Kabel aus dem Floppy-Laufwerk und verbinden die beiden Pins. Das Prinzip ist, die Reset-Leitung mit der GND-Leitung (Erde) zu verbinden.

Komfortabler geht es mit einem Resetschalter, der in den User-Port eingeschoben wird und per Knopfdruck einen Reset bewirkt.

Wenn Sie nun versuchen, Ihr Programm zu listen, wird Ihre Skepsis zunächst bestätigt werden. Es gibt scheinbar kein Programm mehr.

Durch das Rücksetzen (Reset) des Computers sind alle Basic-Pointer auf ihren Urzustand gebracht worden. Das Programm selbst existiert noch, denn der Basic-Benutzerspeicher wurde nicht gelöscht. Um die Zeiger (Pointer) zurückzusetzen, und somit Ihr Programm wieder sichtbar zu machen, laden Sie das Programm »UNNEW« ein, das Sie hoffentlich vorher eingetippt haben. Nun starten Sie es und — das Basic-Programm wird wieder sichtbar.

Haben Sie vor dem Reset in Maschinensprache mit einem Monitor (zum Beispiel HES-Mon oder Supermon 64) programmiert, dann starten Sie den Monitor und fahren Sie mit der Programmierung beziehungsweise dem Testen fort. Sowohl Ihr Maschinenprogramm als auch der Monitor wurden nicht zerstört.

Haben Sie sich einmal mit dem Umgang des Resets vertraut gemacht, werden Sie sicher auch gerne einmal hinter die Kulissen von Videospielen schauen wollen. Dieses konnten Sie bisher nicht, weil viele Programme die Run/Stop-Taste sperren. Funktioniert der Reset, dann können Sie mit einem Monitor das Spiel erforschen. Doch was geschieht, wenn der Reset wirkungslos bleibt? Wie kann sich ein Videospiel gegen das scheinbare Aus- und Einschalten schützen?

Die Lösung besteht in der Möglichkeit, Module anzuschließen, nämlich wenn Sie ein Modul einschieben und das Gerät einschalten, dann meldet sich keineswegs Basic V2.0 mit einem READY, sondern das Modul übernimmt das Kommando, ohne daß Sie es dazu aufgefordert hätten.

Dazu muß das Modul drei Sachen veranlassen:

1.	Den Basic-Interpreter ausblenden,
2.	sich als Modul zu erkennen geben und
3.	eine Einsprungadresse zur Verfügung stellen.

Das Wegbleiben eines ROMs, sei es der Basic-Interpreter oder das Betriebssystem, erfolgt durch Setzen beziehungsweise Löschen von Bits in der Speicherzelle 0001. Dort liegen die für uns interessanten Kanäle High-RAM und Low-RAM, die durch die beiden Bits 0 und 1 dargestellt werden. Im Einschaltzustand sind beide gesetzt. Ferner gibt es die hardwaremäßigen Kanäle GAME und ExROM. Diese liegen im Moduleinschub und sind ohne Modul auf High (1) gesetzt. Wird ein Modul eingeschoben, so bewirkt dieses, daß die Kanäle GAME und ExROM auf Low gesetzt werden. Dadurch wird das Basic-ROM ausgeblendet.

Als zweites muß sich das Modul zu erkennen geben. Im Betriebssystem gibt es eine Routine, die erkennt, ob ein Modul eingeschoben ist. Sie liegt zwischen 64770 ($ FD02) und 64788 ($ FD14). Dabei wird überprüft, ob in den Speicherzellen 32772 bis 32777 ($ 8004 bis $ 8009) das Wort »cbm80« steht. Das sind die ASCII-Zeichen: 195,194,205, 56,48. Ist das der Fall, setzt das Unterprogramm das Zeroflag. Wenn nun eine Routine im Betriebssystem (zum Beispiel die Reset-Routine) dieses Unterprogramm aufruft, und das Zeroflag wird gesetzt, dann nimmt das Betriebssystem an, daß ein Modul vorliegt. Es springt zur Adresse, die in $8002 und $ 8003 steht. Die Steuerung wird dem Modul übergeben. Will man nun ein Modul simulieren, muß man

1. $ 8004 bis 8009 mit »cbm80« belegen,
2.	eine Adresse in $ 8002 und $ 8003 eintragen (Low-Byte vor High-Byte) und
3.	durch den Befehl CLI Interrupts (IRQ) erlauben.

Mit folgendem kleinen Programm sorgt man von Basic aus dafür, daß ein Reset keinen Effekt hat:
100 FOR I=32770 TO 32778
110 READ A : POKE I,A
120 NEXT I
130 DATA 10, 128, 195, 194, 205
140 DATA 56, 48, 88, 0

Unser Ausgangsproblem war aber: Wie kann ich ein Reset verursachen, obwohl es gesperrt ist? Es gibt zwei Methoden:

1.	Man sorgt dafür, daß in $ 8004 bis $ 8009 nicht »cbm80« steht.
2.	Die Routine im Betriebssystem ändert man so ab, daß sie nicht mehr »cbm80« sondern zum Beispiel »cbm81« abfragt.

Es soll zuerst der zweite Fall behandelt werden. Da das Betriebssystem (auch Kernal genannt) im ROM liegt, läßt es sich nicht ohne weiteres ändern. Deshalb wird es zuerst in das darunterliegende RAM kopiert. Dieses funktioniert folgendermaßen:
100 FOR I = 57344 TO 65535
110 POKE I,PEEK(l)
120 NEXT I

Nun könnte, durch Löschen des Bits 1 (High-RAM) in der Speicherzelle 0001, vom ROM auf RAM umgeschaltet werden:
320 POKE I,PEEK(l) AND 253

Durch das Löschen dieses Bits wird aber auch das Basic-ROM ausgeblendet. Also müssen wir dieses auch ins RAM kopieren:
200 FOR I=40960 TO 49151
210 POKE I,PEEK(I)
220 NEXT I

Jetzt könnte man das Programm starten, es hätte jedoch keinen Effekt, weil in der Adresse 0001 immer die Zahl 55 (High-RAM gesetzt) erscheint — statt der angestrebten 53. Dieses kommt durch den I/O-Reset. Diese Routine liegt im Kernal und setzt die Kanäle in 0001 immer wieder neu. Also muß man diese Routine für unsere Zwecke ändern: 300 POKE 64982,229

Schließlich werden wir aus der »cbm80«-Abfrage eine »cbm81«-Abfrage machen:
310 POKE 64788,49

Wenn man jetzt das Programm startet und ein Reset auslöst durch: SYS 64738 wird sich die Maschine zurücksetzen, auch wenn in 32772 bis 32777 (exklusive) »cbm80« stehen sollte. Betätigt man jedoch den Resetschalter, dann wird der Reset abhängig von 32772 bis 32777 ausgelöst. Beim Reset werden nicht nur der Prozessor, sondern auch die beiden CIAs und der SID zurückgesetzt. Diese bewirken, daß in 0001 High-RAM gesetzt wird, und somit kommt die Veränderung des Betriebssystems nicht zum Tragen. Im ersten Fall wird ein POKE 32772,0 das Nötige tun, sofern nicht das Programm seinerseits dafür sorgt, daß »cbm80« immer wieder erneuert wird.

Hier das Programm UNNEW:
100 FOR I=525 TO 578
120 READ A : POKE I,A : NEXT I
200 POKE 43,525 AND 255 : POKE 44,2
210 POKE 45,578 AND 255 : POKE 46,2
220 CLR : SAVE "UNNEW" ,8 : REM bzw. ,1,1
300 DATA 160,003,200,177,043,208,251,200
310 DATA 200,152,160,000,145,043,165,044
320 DATA 200,145,043,133,060,160,000,132
330 DATA 059,162,000,200,208,002,230,060
340 DATA 177,059,208,245,232,224,003,208
350 DATA 242,200,208,002,230,060,132,045
360 DATA 164,060,132,046,096,256

Wenn Sie dieses Programm eingeben und starten, wird es ein Programm namens »UNNEW« auf Diskette schreiben. Falls sie aus Versehen NEW eingetippt haben, dann laden sie das Programm durch
LOAD "UNNEW" ,8,1 und starten es durch
SYS 525

Ihr Basic-Programm ist gerettet, selbst wenn sie ein Reset ausgelöst haben. Das Programm setzt die Zeiger in $0801 und $0802, die auf die nächste Zeile zeigen, auf den richtigen Wert. Bei NEW werden diese beiden Bytes auf Null gesetzt, und zwei aufeinanderfolgende Nullen bedeuten für den Interpreter »Ende des Programms«.

(Daniel Kossmann/aa)

# Epedemic 2

> Ein Nachtrag zu dem VC 20-Spielprogramm aus der 64er/Ausgabe 10

Nachdem der Druckfehlerteufel in der letzten Ausgabe wieder einmal zugeschlagen hatte, bringen wir hier den fehlenden Teil zum Listing »Epedemic» für den VC 20. Nachzutragen wäre auch noch, daß man sich bei derartigen Simulationsspielen immer über die Handlungsbrisanz im Klaren sein sollte. Denn die Zahlenjonglierereien auf dem Bildschirm stellen immerhin Menschenleben dar. Wem das Spiel allerdings deswegen zu makaber ist, der sollte sich vielleicht einmal die Realität ansehen... (ev)

# In die Geheimnisse der Floppy eingetaucht

> Diese Folge befaßt sich mit dem Befehlssatz der VC 1541 und deren Meldungen an den Computer. Sie werden erkennen, daß Sie neben Ihrem C 64 noch einen anderen vollständigen Computer vor sich haben, der nicht nur als einfaches und »dummes« Peripheriegerät verstanden werden will.

Sicherlich machte sich mancher Floppybesitzer, der ein schnelleres Peripheriegerät als die Datasette haben wollte, schon seine Gedanken über den Preis der VC 1541: »Die kostet ja mehr als der Computer!«. In der Tat ist die VC 1541 von dieser Seite her betrachtet nicht gerade günstig, wer sich jedoch schon intensiver mit ihr beschäftigt hat, wird eine Eigenart festgestellt haben, die sie mit allen CBM-Floppys teilt: Es handelt sich hier um sogenannte Floppystationen, nicht nur um Laufwerke. Das bedeutet, diese Geräte besitzen ein eigenes Betriebssystem (DOS) und eigene Mikroprozessoren. Sie arbeiten völlig unabhängig vom Computer und dessen Speicher. Der Vorteil liegt auf der Hand: Die Floppy beansprucht weder Speicherplatz noch Rechenzeit des Computers, außer beim direkten Datenaustausch. Als Beispiel betrachte man den Befehl »N:« (Formatieren). Während der Formatierung steht der Computer zur (fast) freien Verfügung, da dieser Vorgang nur floppyintern abläuft und sich der C 64 mit READY meldet, während die 1541 noch arbeitet.

Wir wollen uns jedoch nur den Direktzugriffsbefehlen und den Speicherbefehlen widmen; auch übergehen wir die im Commodore-Handbuch nicht erwähnte relative Datenspeicherung, über die in anderen Ausgaben schon ausführlich gesprochen wurde. Uns sollen nur die Befehle beschäftigen, die uns zur willkürlichen Manipulation von Floppystation und Disketten nützen.

Zur Beruhigung: Ein Beschädigen der 1541 durch direkte Eingriffe in das DOS ist nicht zu befürchten, auch wenn es passieren kann, daß sich die Floppy nur durch Aus-/ Einschalten wieder in den Normalzustand versetzen läßt. Haben Sie übrigens einmal, wie in der letzten Folge empfohlen, das Formatkennzeichen einer Diskette verändert? Sie werden sicherlich bemerkt haben, daß sich danach nichts mehr auf Ihre Diskette schreiben läßt. Mit diesem Trick, der die gleichen Folgen wie das Anbringen einer Schreibschutzplakette an der Diskette hat, können Sie sich also ganz einfach Ihre Diskette gegen unbeabsichtigtes Löschen sichern. ACHTUNG: Diese Methode funktioniert natürlich nicht, wenn neu formatiert werden soll; hiergegen hilft nur das Anbringen einer Schreibschutzplakette!

Die Floppystation verfügt über, außer den schon bekannten Befehlen zur Diskettenorganisation, noch eine ganze Anzahl weiterer Befehle, mit denen sich ungeahnte Möglichkeiten ergeben, zum Beispiel Herstellen eines eigenen Diskettenformats, Leseschutz von Disketten, Programmschutz, Modifikation der Lade- und Saveroutinen und, und... Dafür ist es allerdings nötig, daß wir diese Befehle Schritt für Schritt kennen lernen, bevor wir auf die Tricks der Profis, die Manipulationen des DOS und den gezielten Eingriff in den Programmablauf der Floppystation zu sprechen kommen. Dafür ist allerdings das Beherrschen des C 64 und der Maschinensprache unerläßlich. So lohnt es sich unter Umständen, nachdem man aus Basic nichts mehr herausholen kann, den Einstieg in die Assemblerprogrammierung zu wagen. Sehr gute Literatur dafür ist vorhanden. Aber diesmal wollen wir uns noch auf Basic beschränken, um Sie mit dem Befehlssatz der Floppy vertraut zu machen.

Wie schon erwähnt, handelt es sich bei der 1541 um einen vollständigen Computer, der ebenso wie Ihr C 64 RAM und ein Betriebssystem (DOS) im ROM besitzt.

Die genaue Aufteilung ist in Bild 1 zu sehen. Jetzt soll uns nur der RAM-Bereich interessieren (Bild 2). Nicht nur auf der Diskette, sondern auch im RAM werden Speicherbereiche in Abschnitte zu jeweils 256 Byte aufgeteilt. Sie heißen dann nicht mehr BLOCKS sondern PAGES (Seiten). Das RAM der 1541 umfaßt nun genau 8 PAGES, durchnumeriert von 0 bis 7, insgesamt als 2 KByte. Die Page Nr. 0 (auch Zero-Page genannt) wird hier, wie auch im C 64, vom Betriebssystem als Arbeitsspeicher benutzt und steht uns deshalb nicht zur freien Verfügung. Ähnlich verhält es sich mit den Pages 1 und 2. Die Pages 3 bis 7 stellen sogenannte Pufferspeicher dar; hier werden alle Daten, die von der Diskette gelesen beziehungsweise auf sie geschrieben werden, zwischengespeichert, da nur blockweise gelesen oder geschrieben werden kann.

Soll zum Beispiel nur ein einziges Byte auf der Diskette geändert werden, so wird erst der gesamte Block in einen der 5 Pufferspeicher gelesen, dort abgeändert und schließlich komplett wieder zurückgeschrieben. Aus diesen Gründen ist es also notwendig, daß wir uns vor einem Direktzugriff einen der Puffer reservieren, in dem dann gearbeitet wird.

Mit Hilfe des »Open«-Befehls eröffnen wir einen Direktzugriffskanal. Die Syntax lautet wie folgt:
OPENfn, gn, kn, ”#”

Hierbei bedeuten:
fn — Filenummer (1-127)
gn — Gerätenummer (norm. 8)
kn — Kanalnummer in der Floppy (2-14)

Diese Abkürzungen werden wir im folgenden immer verwenden! Ein Beispiel:
OPEN 1, 8, 2, ”#”

Diese Anweisung eröffnet im Computer ein File mit der Nummer 1, adressiert als Gerät die Floppy (Nummer 8) und reserviert in der 1541 einen Kanal (Nummer 2), dem ein Puffer zugeordnet wird. Mit den floppyinternen Kanälen verhält es sich wie folgt: Es stehen insgesamt 16 Kanäle zur Verfügung. Hierbei sind Kanal 0 und 1 für LOAD und SAVE reserviert, Kanal 15 ist der Kommandokanal, den Sie bisher immer benutzt haben, um Befehle (zum Beispiel Formatieren) an die Floppy zu senden und die Fehlermeldungen der Floppy zu empfangen.

Für unsere Zwecke stehen also noch die Kanäle 2 bis 14 zur Verfügung. In unserem Fall reserviert die Floppy den nächsten freien Puffer. Will man jedoch einen bestimmten Puffer reservieren, etwa um dort ein Maschinenprogramm abzulegen, so ist es notwendig, der 1541 mitzuteilen, welcher Puffer gewünscht wird:
OPEN1,8,2,"#1"

Es ist hier allerdings zu beachten, daß der gewählte Puffer nicht schon belegt ist; in diesem Fall gibt die Floppy eine Fehlermeldung aus. Wollen Sie an dieser Stelle mehr über das Auslesen der Fehlermeldungen und deren Bedeutung wissen, können wir Sie hier beruhigt auf das Commodore-Handbuch verweisen. Im allgemeinen sind Puffer 4 für die BAM und Puffer 3 für das Directory reserviert. Haben Sie die Wahl des Puffers der Floppy überlassen, so erfahren Sie die gewählte Nummer durch Auslesen des soeben geöffneten Direktzugriffskanals:
10 OPEN 1,8,2,”#"
20 GET#1,D$
30D = ASC (D$ + CHR$(0))
40 REM Puffernummer in D

### Die BLOCK-Befehle

a)	Der BLOCK-READ-Befehl (B-R): Mit dem BLOCK-READ-Befehl liest man jeden beliebigen Block von Diskette in einen vorher reservierten Puffer. Die Syntax lautet:
PRINT#fn,"B-R";kn;dn;t;s
dn — Drivenummer (immer 0)
t — Tracknummer
s — Sektornummer
Beispiel: PRINT#15,"B-R 2 0 18 0”

Diese Befehlsfolge liest den Block 18,0 von der Diskette in den oben reservierten Puffer. Wie man sieht, können anstelle der CHR$-Codes feste Zahlenwerte in den Befehlsstring mit übernommen werden. Das ganze hat bloß einen kleinen Schönheitsfehler. Mit dem B-R-Befehl läßt sich das erste Byte eines Blocks nicht lesen. Deshalb benutzt man normalerweise anstatt des B-R-Befehls den U1-Befehl. Dieser hat exakt die gleiche Syntax und kann in jedem Fall benutzt werden:
PRINT#15,"U1 2 0 18 0”

Auf diese USER-Befehle kommen wir später zurück. Mit einer GET#-Schleife lassen sich nun die einzelnen Bytes in den Computer einlesen.

b)	Der BLOCK-WRITE-Befehl (B-W): Hiermit lassen sich die Daten aus dem reservierten Puffer wieder auf die Diskette schreiben. Syntax:
PRINT#fn,”B-W”;kn;dn;t;s
Beispiel: PRINT#15,"B-W 2 0 18 0”
Natürlich gibt es analog zum B-R einen USER-Befehl ; U2.
Beispiel: PRINT#15,"U2 2 0 18 0".

c) Der BUFFER-POINTER-Befehl (B-P):
Für jeden Puffer gibt es einen Zeiger, den BUFFER-POINTER. Dieser zeigt auf das aktuelle Byte im Puffer und wird bei jedem Datenzugriff um Eins erhöht, damit man alle 256 Bytes eines Blocks der Reihe nach lesen kann. Dieser Pointer wird mit dem B-P-Befehl gezielt auf bestimmte Bytes positioniert, wenn man nur einzelne Werte und nicht den gesamten Block lesen will. Syntax:
PRINT# fn,"B-P"; kn; position
Beispiel:
Wir möchten in die Variable A den Wert des 123. Bytes von Block 1;16 einlesen:
10 OPEN15,8,15
20 OPEN1,8,2,"#"
30 PRINT#15,"U1 2 0 1 16”
40 PRINT#15,"B-P2 122”
50 GET#1,A$
60 A = ASC(A$ + CHR$(0))
Als weiteres Beispiel dient Listing 1. d) Der BLOCK-ALLOCATE-Befehl (B-A):
Wenn Sie im Direktzugriffsverfahren eine Diskette beschreiben, muß in der BAM danach auch verzeichnet werden, daß die entsprechenden Blocks mit Daten gefüllt sind und nicht mehr überschrieben werden dürfen. Dazu dient der B-A-Befehl, der jeden beliebigen Block in der BAM als belegt kennzeichnet. Die Syntax lautet:
PRINT#fn,"B-A";dn;t;s
Beispiel:
PRINT#15,"B-A0 1 16”
kennzeichnet Block 1;16 als belegt; war dieser Block schon belegt, meldet sich die Floppy mit der Fehlermeldung >>65,NO BLOCK,XX,YY<<; wobei XX und YY die Track- und Sektornummer des nächsten freien Blocks angeben.

e)	Der BLOCK-FREE-Befehl (B-F): Dieser ist das genaue Gegenstück zum B-A-Befehl; er deklariert einmal belegte Blöcke wieder als frei für einen weiteren Zugriff. Seine Syntax ist identisch mit der des B-A-Befehls.

f)	Der BLOCK-EXECUTE-Befehl (B-E): Dieser Befehl nimmt eine Sonderstellung ein. Er gleicht im Prinzip dem B-R-Befehl; nur mit dem zusätzlichen Effekt, daß der eingelesene Block im Puffer als Maschinenprogramm gestartet wird.

Zur Vertiefung der Block-Befehle sei noch auf die Listings 2 bis 5 hingewiesen, welche die eben besprochenen Anwendungen noch an praktischen Beispielen verdeutlichen.

### Die MEMORY-Befehle

a)	Der MEMORY-READ-Befehl (M-R): Dieser Befehl entspricht haargenau dem PEEK-Befehl in Basic. Mit ihm können Sie jede beliebige Speicherstelle der Floppy auslesen. Syntax:
PRINT#fn,"M-R";CHR$(adl);CHR$ (adh);CHR$(n)
adl = Low-Byte
adh = High-Byte
n = Anzahl (0 bis 255)

Abgeholt werden die gelesenen Daten ebenfalls über den Kommandokanal mit GET#.
Beispiel: Lesen der beiden ID-Zeichen im ASCII-Format der zuletzt initialisierten Diskette:
10 OPEN15,8,15
20 PRINT#15,"M-R"CHR$(18)CHR$ (0)CHR$(2)
30 GET#15,A$,B$
40 PRINTA$;B$

Diese Routine liest die Zero-Page Adressen 18 und 19, in denen die entsprechenden Werte gespeichert sind. In Tabelle 1 sind einige der wichtigsten Zero-Page Adressen aufgeführt.

b)	Der MEMORYWRITE-Befehl (M-W):

Dieses Kommando kann als POKE-Befehl in den Floppy-Speicher angesehen werden. Die Syntax ist hier wie folgt:
PRINT#fn,"M-W";CHR$(adl)CHR$ (adh)CHR$(n)CHR$(data1)CHR$(data2)...

c)	Der MEMORY-EXECUTE-Befehl (M-E):

Auch dieser Befehl ist äquivalent zu einem Basic-Befehl, dem SYS-Befehl. Mit ihm kann man also ein Maschinenprogramm an einer beliebigen Stelle im Floppy-Speicher ausführen. Syntax:
PRINT#fn,"M-E"CHR$(adl)CHR$(adh). Siehe auch Listing 7.

### Die USER-Befehle

Die USER-Befehle stellen eine Erweiterung des Befehlssatzes dar, der fast ausschließlich der Bequemlichkeit dient. Ul und U2 wurden schon besprochen, sie ersetzen B-R und B-W. Die Befehle U3 bis U8 dienen dem Start eines Maschinenprogramms im Floppy-Speicher, dessen Anfangsadressen in einer Tabelle abgelegt sind, so entsprechen:
U3 einem Start bei $0500
U4 einem Start bei $0503
U8 einem Start bei $050F.
U4 ersetzt also beispielsweise den Befehlsstring: M-E CHR$(3)CHR$(5). U9 zeigt auf den NMI-Vektor der 1541, welcher allerdings eine Sonderfunktion hat: Mit U9+ wird die Floppy auf C 64- und mit U9- auf VC 20-Betrieb umgeschaltet.
U: stellt einen Reset dar, ähnlich dem SYS 64738 beim C 64.

Mit den Kenntnissen über den Befehlssatz der VC 1541 dürfte es Ihnen nun keine Schwierigkeiten mehr bereiten, sich das Programm EDDI einmal zu Gemüte zu führen. Das einzig Besondere daran sind die Routinen zum Lesen und Schreiben eines Blocks, die aus Geschwindigkeitsgründen in Maschinensprache geschrieben sind. Ein großer Teil der in diesen Folgen erwähnten Informationen ist auch im Commodore-Handbuch enthalten, nur sind dort oft Fehler.

Wir wollen uns für diese Folge von Ihnen verabschieden, nicht ohne Sie dringend dazu anzuhalten zu probieren.

(Schramm/Schneider/gk)

# Assembler ist keine Alchimie – Teil 3

> In den ersten beiden Folgen unseres Assembler-Kurses mußten Sie noch mit Basic- Ladern arbeiten. Jetzt steht Ihnen ein leistungsfähiger Monitor zur Verfügung, der SMON. Somit können Sie alle Beispiele direkt eingeben und ausprobieren.

In der letzten Folge haben wir die ersten Assembler-Befehle kennengelernt und wissen, wie man sie benutzt und was sich im Computer dabei tut. Die Zahlen der Assembler-Alchimisten haben uns einige Geheimnisse enthüllt, obwohl sie für die Zweifingerlinge und die Sechzehnfingerlinge gedacht sind. Die Binärzahlen können wir schon zusammenzählen. Heute werden Sie eine Reihe weiterer Assembler-Befehle kennenlernen und noch ein weiteres Zahlensystem. Wir ergründen das Geheimnis der negativen Zahlen und machen uns die Funktion der Flaggen zunutze.

Wir haben nun auch einen sehr brauchbaren Assembler für den C 64: Den SMON, dessen 1. Teil in dieser Ausgabe abgedruckt ist. Künftig wird in dieser Serie die SMON-Syntax verwendet und kein Basic-Lader mehr angegeben. Außerdem hat in Ausgabe 9 die Serie »Der gläserne VC 20« begonnen, so daß sich der Schwerpunkt hier mehr auf den C 64 verlagert. Das sollte aber die VC 20-Fans nicht davon abhalten, diesen Kurs weiter zu verfolgen, denn bis auf gelegentliche Adreßänderungen ist fast alles für sie verwendbar.

### Eine Zauberformel der Assembler-Alchimisten: INX, INY, INC, DEX, DEY, DEC?

Wir wissen ja schon, daß man diese »Zauberformeln« entzaubern kann. INX heißt einfach »increment X-Register«, also Inhalt des X-Registers um 1 erhöhen. Es wird Ihnen sicher einleuchten, daß INY dasselbe mit dem Y-Register tut. Etwas weniger deutlich ist das bei INC. Das bedeutet »increment memory«, also zähle zum Inhalt einer Speicherstelle eins dazu. INX und INY enthalten alles, was dem Computer zu sagen ist, sind also offensichtlich 1-Byte-Befehle mit der in der letzten Folge schon kennengelernten impliziten Adressierung. Bei INC muß dem Computer noch gesagt werden, welche Speicherstelle er um 1 erhöhen soll. Es gehört also noch eine Adresse dazu. Das läßt diesen Befehl im allgemeinen zu einem 3-Byte-Befehl werden.

## Befehle zum Zählen

Das umgekehrte leisten die Befehle DEX, DEY und DEC. Sie bedeuten nämlich »decrement X-Register«, also »zähle das X-Register um eins herunter«, beziehungsweise das Y-Register oder — bei DEC — die angegebene Speicherstelle. Für die Adressierungsart und die Anzahl Bytes pro Befehl gilt hier das gleiche wie für die INX...-Befehle. Sehen wir uns das an einem kleinen Beispiel an: Bitte lesen Sie sich dazu die Bedienungshinweise zum SMON durch.

1500	LDA #00
1502	LDX #01
1504	STA D800
1507	STX 0400
150A	INX
150B	STA D801
150E	STX 0401
1511	DEX
1512	STA D802
1515	STX 0402
1518	BRK

Wenn Sie das kleine Programm mit G 1500 starten, dann sollten Sie in der linken oberen Ecke des Bildschirms ABA in schwarzer Schrift stehen haben. Was ist geschehen? Wir haben den Inhalt des Akku (= 0, also Farbcode für schwarz) in das Bildschirm-Farbregister geschrieben (#D800), dann den Inhalt des X-Registers (1 = POKE-Code für den Buchstaben A) in die erste Bildschirm-Speicherzelle (# 0400). Anschließend wurde das X-Register um 1 erhöht (2 = POKE-Code für den Buchstaben B) und dieser Inhalt in die zweite Bildschirmzelle geschrieben. Außerdem mußte natürlich auch dieser Bildschirm-Farbspeicherplatz mit dem Farbcode 0 belegt werden. Durch DEX wurde das X-Register wieder herunter gezählt, somit wieder ein A erzeugt und in die dritte Bildschirmstelle gedruckt.

Sie haben sicher schon bemerkt, daß man auf diese Weise Abläufe mitzählen kann. Soll zum Beispiel ein Vorgang 20 mal wiederholt werden, dann packt man ins X-Register (oder ins Y-Register oder in eine andere Speicherstelle) den Anfangswert 0, läßt den Computer eine Arbeit ausführen, erhöht das entsprechende Register oder die Speicherzelle um 1 mit INX, INY oder INC, prüft dann, ob dieser Inhalt schon 20 geworden ist und so weiter. Wie man diese Prüfung vornimmt, dazu kommen wir erst später bei den BRANCH-Befehlen. Das ist also ähnlich wie im Basic bei den FOR...NEXT-Schleifen: Dort wird eine Variable als Zähler verwendet, hier ein Register (oder eine Speicherstelle). Ebenso wie im Basic bei diesen Schleifen kann man auch hier rückwärts zählen mit DEX, DEY oder DEC. Das hat oft gewisse Vorzüge, was uns aber noch nicht kümmern soll.

Wenn wir diese Befehle als Zähler verwenden, sollten wir im Auge behalten, daß eine Speicherstelle (auch ein X- oder Y-Register) Zahlen nur von 0 bis 255 enthalten kann. Die höchste 8-Bit-Zahl ist ja:
TODO
dez. 255 = bin. 1111 1111
+ 1	1
      —---------+
ergibt:	(1) 0000 0000

Wenn wir also über 255 hinauszählen, ergibt sich wieder 0 und so weiter, weil ein Überlauf stattgefunden hat. Das 9.Bit paßt nicht mehr in das Byte hinein. Üm nochmal genau sehen zu können, was unser Computer da tut, probieren Sie einmal aus:
1500 LDA #01
1502 BRK

Das soll uns die Register zunächst mal im Ausganszustand zeigen. Nach G 1500 werden sie angezeigt:
AC XR YR N V- BDI ZC
01 00 00 0 0 1 10 000

Im Akku steht jetzt die dort eingeladene 1. Nun wollen wir das X-Register laden mit 255 (also $FF). Dazu ändern wir das Programm:
1502 LDX #FF
1504 BRK

Nach erneutem G 1500 zeigen die Register:
AC XR YR N V- BDI ZC
01 FF 00 1 0 110 000

Im X-Register steht nun die Zahl $FF. Bei den Flaggen hat sich die N-Flagge (die negative Zahlen anzeigen soll) auf 1 geschaltet!

Nun wollen wir das X-Register über 255 hinauszählen. Wir verändern das Programm nochmal:
1504 INX
1505 BRK

Der Start mit G 1500 liefert uns die folgende Registeranzeige:
AC XR YR N V- BDI ZC
01 00 00 0 0 110 0 10

Wie erwartet, ist der Überlauf des X-Registers eingetreten: Es ist jetzt Null. Die N-Flagge hat ihren gewohnten Wert 0 wieder angenommen und die Z-Flagge, die uns anzeigt, ob die letzte Operation eine Null erzeugt hat, ist jetzt gesetzt. Bei weiterem Hochzählen verschwindet die Z-Flagge wieder:
1505 INX
1506 BRK

G 1500 liefert den Registerinhalt:
AC XR YR N V- BDI ZC
01 01 00 0 0 1 10 000

Das gleiche passiert bei Verwendung des Y-Registers als Zähler, wie Sie leicht durch Austauschen aller auf X bezogenen Befehle feststellen können. Sehr nett ist es, diesen Befehlsablauf einmal für den INC-Befehl auf die Speicherstelle $0400 (Bildschirmspeicher links oben) bezogen ablaufen zu lassen. Wenn man darauf achtet, daß kein Hochscrollen des Bildschirms eintritt, kann man das Ergebnis außer in den Registern auch noch als Zeichen auf dem Bildschirm verfolgen. Der Beginn der Befehlsequenz ist dann sinnvollerweise:
1500 LDA #FF
1502 STA 0400
1505 BRK

Im folgenden setzt man dann anstelle von INX immer INC 0400 ein.

Was passiert beim Herunterzählen unter Null? Sie können das mit der gezeigten Befehlskette leicht verfolgen, indem Sie immer statt INX jetzt DEX setzen und die Register nicht mit $FF, sondern mit 01 laden. Es zeigt sich, daß beim Herabzählen nach der Null wieder 255 (= $FF) im Register zu finden ist. Die Reaktion der N- und der Z-Flagge auf den jeweiligen Registerinhalt ist die gleiche wie beim Hochzählen.

Es ist uns nun deutlich, daß diese sechs Befehle die N-Flagge und die Z-Flagge beeinflussen können. Diese Tatsache wird später noch eine große Rolle spielen, wenn es um die bereits erwähnte Schleifenkontrolle geht.

### Noch ein alchimistischer Zahlentrick

Die Assembler-Alchimisten haben noch viel mehr Arten der Zahlen- und Zeichendarstellung auf Lager. Eine davon ist die Codierung als BCD-Zahlen. BCD kommt vom englischen »binary coded dezimal«, was bedeutet: Binär codierte Dezimalzahlen.

Zwischendurch möchte ich noch eine Bemerkung loswerden, die Sie als Trost auffassen sollen: Auch wenn wir später andere Zahlendarstellungen kennenlernen werden, es wird nicht so schwierig! Sogar so komplette Idioten wie Computer verstehen das, obwohl man ihnen alles haarklein vorkauen muß.

Wenden wir uns nun wieder den lächerlich einfachen BCD-Zahlen zu. Alle Zahlen von 0 bis 9 lassen sich binär mit nur 4 Bits ausdrücken:
TODO
Binär	Dezimal
0000	0
0001	1
0010	2
0011	3
0100	4
0101	5
0110	6
0111	7
1000	8
1001	9

Die weiteren Werte 1010 bis 1111 werden in der BCD-Codierung nicht benutzt. Liegt nun eine Dezimalzahl (zum Beispiel 12) vor, dann wird jede Stelle dieser Zahl (also die 1 und die 2) getrennt binär codiert. In unserem Beispiel mit der 12 wäre das dann 0001 für die 1 und 0010 für die 2. Somit ist die 12 im BCD-Code 0001 0010. Jede Ziffer erhält so ihr Nibble. Eine Zahl im BCD-Format hat deswegen keine feste Anzahl von Bytes, sondern die Byte-Zahl hängt von der Anzahl der Stellen ab. Die Zahl 1984 beispielsweise braucht 2 Bytes: 0001 1001 1000 0100.

Schwierig gestaltet sich das Rechnen mit diesen Zahlen wegen der sechs unbenutzten Codes. Aber auch da habe ich einen Trost für Sie: Wir werden damit nicht rechnen. Wozu das ganze dann, werden Sie sich fragen? Der Grund für das alles ist, daß BCD-Zahlen im Gegensatz zu den Zahlen mit festem Format (die sonst verwendet werden) so eingegeben und verarbeitet werden können, wie sie vorliegen. Das ist im kaufmännischen Bereich manchmal notwendig, wo eben 1000mal 0,1 Pfennige 1 Mark ergeben und Fehler unzulässig sind. Sollten Sie also vor dem Problem stehen, mit BCD-Zahlen rechnen zu müssen, grämen Sie sich nicht: Unser Prozessor kennt den Dezimalmodus. Er ist dann eingeschaltet, wenn die Dezimal-Flagge auf 1 gesetzt ist.

Damit sollen Sie dann auch noch gleich zwei neue Befehle kennenlernen: SED und CLD. Der erstere hat nichts mit Parteien zu tun, sondern ist die Abkürzung für »Set dezimal-flag«, also setze die Dezimalflagge. So schalten Sie den Dezimal-Modus ein. Wie Sie sicher schon messerscharf geschlossen haben, heißt CLD »Clear dezimal-flag«, also setze die Dezimalflagge auf Null, wodurch dieser Modus wieder auszuschalten ist.

Wichtig! Wenn Sie argwöhnen, daß in einem Programm irgendwann mal die Dezimal-Flagge gesetzt sein könnte, dann gehen Sie auf Nummer sicher und schieben vor eine Rechenoperation, die nicht im Dezimalmodus laufen soll, ein CLD.

Beide Befehle sind 1-Byte-Befehle mit implizierter Adressierung. Sie beeinflussen lediglich die Dezimalflagge.

### Das Geheimnis der negativen Binärzahlen

Wie schon mal betont: Der Computer ist strohdumm. Er kann nicht einmal auf normale Weise voneinander abziehen! Deswegen geht er den komplizierten Weg: Er addiert eine negative Zahl. Nur: Wie sehen negative Binärzahlen aus? Wir werden diese Frage in drei Etappen beantworten.

a) Man könnte eine Flagge setzen, die 1 ist bei negativen und 0 bei positiven Zahlen. Bei einigen Fließkommazahlen wird das auch so gemacht. Hier aber setzt man die Flagge direkt in die Zahl ein: Bit 7 jeder Zahl ist jetzt ein Vorzeichenmerkmal. Wenn dieses Bit 0 ist, handelt es sich um eine positive, wenn es 1 ist, um eine negative Zahl. Auf diese Weise ist also +1 wie bisher 0000 0001, wohingegen —1 jetzt 1000 0001 hieße. Damit wird allerdings der Zahlenbereich, der durch ein Byte auszudrücken ist, verschoben. 255 = binär 1111 1111 kann so nicht mehr verwendet werden. Die größte Zahl, die jetzt ausgedrückt werden kann, ist 0111 1111 = dezimal 127. Die kleinste Zahl ist dann 1111 1111 = —127. Probieren wir mal aus, wie sich damit rechnen läßt:
TODO
+ 10 0000 1010
-6	1000 0110
--------- +
ergibt 1001 0000 = -16,
was offensichtlich falsch ist, denn nach Adam Riese sollte + 4 herauskommen. So kann man also nicht rechnen!

Man nennt diese Art der Zahlendarstellung, übrigens »signed binary«-Format, also in Deutsch: markierte Binärzahlen.
b) Der nächste Schritt ist das sogenannte Einerkomplement. Dabei tritt für die positiven Zahlen keine Änderung ein. Die negativen entstehen aus den positiven durch Komplementbildung, das heißt jedes Bit der positiven Zahl wird in sein Gegenteil verkehrt, wie es das folgende Beispiel zeigen soll:
0000 1100 ist +12,

dann ist das Einerkomplement:
1111 0011 = -12.

## Komplement ist nicht kompliziert

Interessanterweise taucht hier auch wieder das Merkmal der »signed binary«-Zahlen auf: die 1 in Bit 7 bei negativen Zahlen. Beschränkt man sich auf den Zahlenbereich, der für die »signed binary<<-Zahlen gültig war, dann hätten wir jetzt beide Darstellungsweisen miteinander vereint. Nun müssen wir natürlich noch feststellen, ob man so auch rechnen kann.
+ 8	0000 1000
-6	1111 1001
in Einerkomplementdarstellung
-------- +
ergibt(l) 0000 0001
was 1 mit einem Übertrag ergäbe, jedenfalls nicht 2, wie’s sich gehört. Also ist auch die Einerkomplementdarstellung noch nicht das Gelbe vom Ei.
c) Ich will Sie nicht länger auf die Folter spannen: Wenn man zum Einerkomplement einer Zahl noch 1 dazuzählt, erhält man das Zweierkomplement. Und genau so werden negative Zahlen in unserem Computer gehandhabt. Die positiven Zahlen bleiben unverändert. Von den negativen bildet man das Zweierkomplement wie zum Beispiel hier mit der Zahl -12:
12	0000 1100
normale Binärdarstellung
(—12) 1111 0011 Einerkomplement
+ 1	0000 0001 addieren
-12	11110100 Zweierkomplement

Jetzt wollen wir auch diese Zahlenart ausgiebig testen:

Wir rechnen nochmal 8-6:
+ 8	0000 1000
—6	1111 1010 das ist -6 in der Zweierkomplementdarstellung.
------- + ergibt
(1)	0000 0010..
also 2 mit einem Übertrag, der ignoriert wird. Das Ergebnis ist richtig. Wenn bei einer solchen Rechnung eine negative Zahl herauskommt, ist sie nicht leicht zu erkennen. In solchen Fällen kehrt man das Vorzeichen um, indem man das Zweierkomplement berechnet. Das machen wir mal am Beispiel 5—6:
+ 5	0000 0101
-6	1111 1010
das ist wieder unser Zweierkomplement von 6, also —6
------ +
ergibt 1111 1111
das ist —1 in der Zweierkomplementdarstellung. Zur Kontrolle nun die Vorzeichenumkehr durch Umrechnen ins Zweierkomplement:
Einerkomplement davon 0000 0000
plus 1	0000 0001
------- +
 ergibt	0000 0001
also wie erwartet +1.

Auf diese Weise rechnet unser Computer mit negativen Zahlen. Negative ganze Zahlen speichert er im Zweierkomplement-Format. Auch wenn wir nun etwas vorgreifen müssen, wollen wir uns das ansehen. Dazu schalten Sie am besten erst einmal den Computer aus und laden dann den SMON beziehungsweise ihren Assembler. Dann bauen wir ein kleines Basic-Programm:
10 A% = -12
20 END

## Wie Variable im Speicher stehen

Noch nicht RUN eingeben! Zuerst schalten Sie den Maschinensprachmonitor ein und wir sehen uns das Programm so an, wie es im Speicher steht. Der Basic-Speicher des C 64 beginnt im Normalfall bei $0800. Wir geben also den Monitorbefehl
M 0800

Uns genügen schon die Speicherplätze bis $081C. Nun sehen wir das nackte Basic-Programm im Speicher, so wie es uns C. Sauer in seinem Artikel »Der gläserne VC 20, Teil 1« im 64'er, Ausgabe 9/84 auf Seite 156 beschrieben hat.

In Bild 1 ist unser Speicherinhalt kommentiert zu sehen. Das Programm endet im Speicherplatz $0813. Das Kennzeichen für Programmende sind zwei aufeinanderfolgende Bytes mit dem Wert Null. Dahinter werden die Variablen abgelegt, sobald das Programm gestartet wird. Wir steigen aus dem Monitor durch X aus und starten das Programm mit RUN. Jetzt sehen wir nochmal in den Speicher. Bis $0813 hat sich nichts verändert. Danach aber ist jetzt in 7 Bytes die Variable A% abgelegt. Das zeigt Bild 2.

Zunächst einmal die Bytes $0814 und $0815: Hier wird der Väriablenname und der -typ angegeben. Der Typ ist aus den Bits 7 zu erkennen. Sind beide (wie hier) gleich 1, dann handelt es sich um eine Integervariable (also eine ganze Zahl). Läßt man die Kennbits außer acht, zeigt sich, daß in $0814 der Code für den Buchstaben A steht und $0815 nur den Wert 0 enthält. Nun zum Rest: Der C 64 legt Integers in nur 2 Bytes ab — die restlichen 3 Bytes $0818 bis $081A bleiben unbenutzt. Das ist auch dann der Fall, wenn danach noch weitere Variable kommen. Es bringt also keine Speicherersparnis (VC 20-Benutzer aufgepaßt!), wenn man mit Ganzzahlvariablen arbeitet!

In $0817 steht $F4, welches binär ausgedrückt 1111 0100 ist. Das kennen wir noch von weiter oben als die —12 im Zweierkomplement-Format. Woher kommt $FF in Speicherzelle $0816? Wie gesagt, die Integers werden in 2 Bytes gespeichert, und wenn wir —12 in 16 Bits ausdrücken, dann sieht das so aus:
+ 12	0000 0000 0000 1100
Einerkomplement:
1111 1111 1111 0011
plus 1
0000 0000 0000 0001
ergibt-12:	1111111111110100
MSB	LSB
= $FF =$F4
als 16-Bit-Zweierkomplement.

Die größte positive ganze Zahl, die man in 2 Bytes ausdrücken kann, ist 32767, was binär
0111 1111 1111 1111
ergibt. Die kleinste ist
1000 0000 0000 0000
also —32768. Das ist der Grund dafür, daß der C 64 Integers größer als 32767 oder kleiner als —32767 dankend mit ILLEGAL QUANTITY ERROR ablehnt, wenn sie als Argument verwendet werden. (Die Zahl —32768 kann als Ergebnis von logischen Operationen durchaus auftauchen.)

Damit will ich Sie für diesmal von den Zahlenspielereien erlösen. In der nächsten Folge müssen wir darauf nochmal zurückkommen. Sie können die Art des Abziehens von Zahlen durch Addieren des Zweierkomplementes bis zum nächsten Mal an weiteren Beispielen üben. Wenn Sie das mit 16-Bit-Zahlen tun, werden Sie bald feststellen, daß noch nicht alles so funktioniert wie es sollte...

Wir können jetzt übrigens auch das Rätsel lösen, weshalb bei positiven Zahlen (zum Beispiel LDA # FF) die Negativ-Flagge auf 1 geht: Die Flagge wird immer dann gezückt, wenn eine Zahl auftritt, die in Bit 7 eine 1 aufweist. Ganz einfach, gell?

### Ein wirkungsvolles Zweiglein: BNE

Vermutlich raucht Ihnen nach soviel Zahlensalat der Kopf. Deshalb sollen Sie zur Entspannung noch einen neuen Assembler-Befehl kennenlernen und auch gleich ein nützliches Programmbeispiel dazu.

BNE heißt »branch if not equal zero«, was man übersetzen kann mit »verzweige, wenn ungleich Null«. Genauer gesagt: Es wird dann verzweigt — also zu einer angegebenen Adresse gesprungen —, wenn die Z-Flagge (die haben wir bei den INX,DEX...-Befehlen genauer untersucht) nicht gesetzt ist, also 0 zeigt. Sehen wir uns das mal an der nachfolgenden Verzögerungsschleife an, deren Flußdiagramm Bild 3 zeigt.

Das Progrämmchen dazu:	
1500	LDX #FF
1502	LDY #FF
1504	DEY
1505	BNE 1504
1507	DEX
1508	BNE 1502
150A	BRK

Zunächst einmal werden das X- und das Y-Register als Zähler initialisiert (also mit einem Ausgangswert geladen). Mit dem vorhin behandelten Befehl DEY wird dann das Y-Register um 1 heruntergezählt, was jetzt $FE ergibt. Für die Nullflagge (Z) bedeutet das den Inhalt 0, denn es liegt kein Grund vor, sie zu setzen (also eine 1 dort anzuzeigen), weil noch keine Null aufgetreten ist. Bei der nachfolgenden Prüfung durch BNE wird also eine Verzweigung nach 1504 das Ergebnis sein, worauf das Y-Register weiter verringert und dann die Z-Flagge erneut geprüft wird und so weiter. Das geht so lange, bis nun wirklich endlich die Null im Y-Register erreicht ist. In diesem Fall zählt DEX nun das X-Register herunter und der nächste BNE-Befehl führt zum Sprung nach 1502, wo das Y-Register wieder auf $FF gesetzt wird. Auf diese Weise wird die äußere Schleife 255mal und die innere 65025mal durchlaufen.

## Kein Widerspruch: Assembler-Programme langsamer machen

Sie haben beim Eingeben des Programmes vermutlich etwas gestutzt, als der Assembler nach dem BNE 1504 als nächste Adresse statt dem erwarteten 1508 eine 1507 ausgegeben hat. Der Befehl sieht zwar wie ein 3-Byte-Befehl aus, ist aber nur ein 2-Byte-Befehl! Das liegt an der speziellen Art der Adressierung von solchen Branch-Anweisungen: Der sogenannten relativen Adressierung, die wir aber erst später mit den anderen Branch-Befehlen behandeln werden.

Wenn Sie das Programm mit G 1500 starten, werden Sie — obwohl alles in Maschinensprache schnell läuft — eine merkliche Verzögerung feststellen, bevor die Registeranzeige auftaucht. Noch längere Verzögerungen lassen sich ohne weiteres erreichen, indem man mehr Schleifen ineinanderschachtelt. Dabei verwendet man dann den DEC-Befehl.

In der Tabelle sind auch die Zyklen angegeben, die die heute neu gelernten Befehle zur Abarbeitung benötigen. Mit solchen Angaben lassen sich recht genau definierte Zeiten einstellen, in denen der Computer nichts anderes tut als durch das Programm zu flitzen. Wozu das dient, braucht wohl kaum noch gesagt werden: Wenn Sie zum Beispiel einen Text auf dem Bildschirm lesen wollen, bevor das Programm weiterläuft oder wenn Sie mit Peripherie arbeiten, die langsamer als das Programm ist oder... Allerdings muß noch gesagt werden, daß es noch elegantere Methoden zur Verzögerungs-Programmierung gibt als das Lahmlegen des Computers, aber dazu kommen wir erst in einer späteren Folge.

(Heimo Ponnath/gk)

# Der gläserne VC 20 – Teil 3

> In der letzten Folge befaßten wir uns schwerpunktmäßig mit der Zeropage. Diesmal wird der sich daran anschließende Adreßbereich von $0100 bis $03FF unter die Lupe genommen.

Dieser Bereich ist so interessant, daß sich die Betrachtungen darüber bis in die 4. Folge erstrecken werden. Übrigens ist dieser Teil auch auf den C 64 anwendbar, denn Betriebssytem und Basic-Interpreter dieser beiden Computer sind ja nahezu identisch.

Wenn wir einen Basic-Befehl im Direktmodus (LIST, RUN, PRINT) oder eine Programmzeile mit Zeilennummer eingeben, werden die Informationen — wie bekannt — auf den Bildschirm geschrieben und gelangen gleichzeitig in den Basic-Eingabepuffer (Adresse 512-600/ $0200-$0258). Dort werden Programmzeilen oder direkte Befehle zunächst einmal im ASCII-Format gesammelt (Bild la). Dies geschieht solange, bis man die RETURN-Taste betätigt.

Dieser Puffer hat eine Kapazität von 88 Zeichen — also den bekannten vier Bildschirmzeilen.

## Der Weg einer Eingabezeile

Drückt man die RETURN-Taste, so beginnt der Interpreter mit der Auswertung der Kommandos. Eingaben ohne Zeilennummer werden auf ihre Syntax hin überprüft und danach ausgeführt.

Verfolgen wir nun einmal genauer den Weg einer Befehlszeile. Die einzelnen ASCII-Zeichen werden von der inzwischen hinreichend bekannten CHRGET-Routine aus dem Puffer gelesen und mit den Befehlswörtern aus dem ROM verglichen. War die Überprüfung positiv — ist der Befehl als identifiziert worden —, so verkürzt der Computer die Kommandozeile, indem er die Befehle in Token (siehe Teil 1, Tabelle 1) umwandelt. Diese Prozedur durchlaufen sowohl die Programmzeilen (mit Zeilennummer) als auch die direkten Kommandos (Bild 1b). An dieser Stelle trennen sich nun aber die Wege dieser beiden Zeilentypen.

Zunächst zu dem weiteren Weg einer Programmzeile. Die inzwischen komplett übersetzte Zeile im Basic-Puffer wird nun in einem zweiten Durchlauf vom Zwischenspeicher in den Programmspeicher übertragen, wobei sie auch gleich richtig eingeordnet wird (damit die Reihenfolge der Zeilennummern stimmt). Weil sich dadurch der Programmbereich im Basic-Speicher vergrößert, muß der Variablenbereich weiter oben angesiedelt werden. Die bis dahin gespeicherten Variablen werden dadurch natürlich überschrieben. Nach dem Übertragen der Programmzeile springt das Interpreterprogramm wieder in die Warteschleife zurück, damit weitere Befehle entgegen genommen werden können.

Nun möchte ich den weiteren Weg einer Direktmoduszeile beschreiben, denn der verläuft anders. Nachdem die Zeile mit Hilfe der CHRGET-Routine in Interpretercode (also Token) umgewandelt worden ist, wird der 2-Byte-Zeiger ($7A-$7B) auf den Pufferanfang zurückgestellt und der Inhalt wie eine Programmzeile behandelt und abgearbeitet (wieder mit Hilfe der CHRGET-Routine).

## Verbotenes

Die Befehle INPUT und GET dürfen im Direktmodus nicht verwendet werden. Der Grund liegt darin, daß diese Eingabebefehle ebenfalls den Basic-Eingabepuffer zur Zwischenspeicherung der Daten verwenden. Das »Direktmodusprogramm«, was sich zu dieser Zeit im Puffer befindet, würde dann überschrieben. Um das zu verhindern, sind diese Kommandos im Direktmodus verboten (Fehlermeldung »ILLEGAL DIRECT«).

## Die Tastaturverwaltung

Die Schlüsselfunktionen für Basic wie beispielsweise die Umwandlung der ASCII-Zeichen in Token (wie eben beschrieben), Umwandlung der Token in Klartext (die Befehlswörter werden bei LIST wieder als ASCII-Zeichen sichtbar gemacht), werden durch indirekte Sprünge über Vektoren abgewickelt. Durch Zusatzroutinen besteht so die Möglichkeit, Klartextbefehle wie SOUND, KEY, OLD ect. in den Interpreter mit einzubinden. Dieses Verfahren besprechen wir später, zunächst aber schreiten wir in der Betrachtung des Adreßbereiches von $0277-$03FF fort (dieser ist in Tabelle 1 genauer aufgelistet).

Der nächste, größere Komplex, den wir hier behandeln wollen, ist die Tastaturverwaltung. Wie sie bestimmt schon öfter bemerkt oder gelesen haben, wickelt der VC 20 (der C 64 übrigens auch) seine Tastaturoperationen ebenfalls über einen Puffer ab. Dies wird beim LISTen von Basic-Programmen deutlich, denn während der Computer ein Programm ausgibt, können sie alle Tasten (mit Ausnahme des STOP-Keys) drücken — diese erscheinen aber nicht auf dem Bildschirm. Erst wenn das Programm zu Ende gelistet ist, sieht man, daß keine Taste »vergessen« wurde, denn alle Eingaben wurden im Tastaturpuffer (Adresse 631-640/ $0277-$0280) zwischengespeichert .

Dieser Puffer hat eine Kapazität von maximal zehn Zeichen. Wem dies zuviel ist, der kann die Länge des Puffers durch Adresse 649 einstellen. Ratsam kann dies bei relativ langsamen Basic-Spielen sein, wo es empfehlenswert ist, nur ein Zeichen im Tastaturpuffer zwischenzuspeichern (POKE 649,1). Anderenfalls »hinkt« die Tastatur immer den Ereignissen hinterher.

Mit Hilfe des Tastaturpuffers kann aber auch — und das ist das interessante an diesen zehn Bytes — eine relativ unkonventionelle Art der Programmierung praktiziert werden.

## Der »DATA-Erzeuger«

Um dies verständlich zu machen, habe ich ein Programm (Listing 1) geschrieben, welches DATA-Zeilen aus Maschinenprogrammen oder Sonderzeichen erzeugt. Die Problematik dabei ist folgende: Wenn ich DATA-Zeilen ins Programm schreiben möchte, so ist dies nur im Direktmodus möglich. Um dies automatisch zu tun, benötigen wir ein Programm. Also was tun? — Man bedient sich des Tastaturpuffers!

Dazu nochmals die Durchleuchtung der Funktionsweise. Während des Systeminterrupts (was dort geschieht klären wir in einer der nächsten Folgen), der alle 60stel Sekunde durchlaufen wird, fragt der Computer die Tastatur ab. Ein eingegebenes Zeichen wird dabei im Tastaturpuffer abgelegt, wo es so lange verbleibt, bis ein Zeichen von der Tastatur benötigt wird. Dies ist zum Beispiel im Direktmodus der Fall (wenn der Cursor blinkt) oder im Programm — bei INPUT oder GET. Die Zeichen werden dann wieder aus dem Tastaturpuffer hervorgeholt und zwar nach dem Prinzip »First in, First out«. Bei unserem Programm werden zunächst einmal sechs Speicherzellen initialisiert. Die ersten zwei Adressen enthalten die Anfangsadresse der abzuspeichernden Daten aus dem Speicher. Dieser Zeiger wird solange inkrementiert, bis er den Wert der Endadresse — der in den zwei folgenden Bytes abgelegt ist — erreicht hat. In den letzten zwei Speicherstellen (Adresse 252, 253) steht die Zeilennummer in der Reihenfolge Low-/ High-Byte. Bequemer währe es natürlich, wenn man normale Variablen verwenden könnte. Dies ist jedoch nicht möglich, weil diese beim Einfügen einer DATA-Zeile gelöscht werden. Darum bleibt nur der Umweg über Speicherstellen, deren Inhalte durch Basic nicht überschrieben werden können.

Als nächstes erzeugt das Programm — mit Hilfe der in 252/253 gespeicherten Zwei-Byte-Zahl — eine Zeilennummer, welche auf den Bildschirm gePRINTet wird. Dann schreibt es das Befehlswort »DATA« und druckt acht dreistellige Zahlen (die Daten aus dem zu verarbeitenden Maschinenprogramm) aus. Nun haben wir eine fertige Programmzeile auf dem Bildschirm stehen, die sich allerdings noch nicht im Speicher befindet. Dies erledigt jetzt unser Tastaturpuffer.

Vorher müssen wir und jedoch genau überlegen, wie unser Bildschirm aussieht, denn dementsprechend muß der Cursor programmiert werden.

## Cursorprogrammierung einmal anders

Bild 2 zeigt ein Bildschirmfoto dieser Situation. Zuerst wird der Cursor mit HOME (= CHR$ (19)) an die linke obere Ecke befördert. Dort wird durch einen Druck auf die RETURN-Taste (=CHR$(13)) die Basic-Zeile in den Speicher übernommen. Nun befindet sich der Cursor in der dritten Zeile. Durch ein »Cursor down« (=CHR$(17)) bewegt er sich eine Zeile nach unten und steht nun auf dem Befehlswort RUN 60. Ein weiteres RETURN bewirkt den erneuten Start des Hilfsprogramms.

Wir benötigen für die Cursorbewegung also vier Werte. Diese werden vor dem Ende des Programms mit »POKE 631,19: POKE 632, 13: PO-KE 633,17: POKE 634, 13: POKE 198,4« in den Tastaturpuffer geschrieben. Hierdurch simulieren wir eine gedrückte Tastenfolge: denn nachdem sich der Computer über den Befehl END wieder im Direktmodus befindet, wird zuerst der Tastaturpuffer geleert, wodurch der Cursor den vorbestimmten Weg nimmt. POKE 198,4 gibt an (das noch als Nachtrag) wieviele Zeichen sich momentan im Puffer befinden. Dieser POKE-Befehl darf bei der Manipulation des Tastaturspeichers nie vergessen werden. Ferner ist die Bereitschaftsmeldung »READY«, die beim Übergang in den Direktmodus ausgegeben wird, zu berücksichtigen. Man muß beachten, daß dadurch nicht die bereits auf dem Bildschirm befindlichen Zeichen überschrieben werden.

Die Bedienung des Programms an sich ist ganz einfach. Nach Eingabe der Anfangs- und Endadresse werden die DATA-Zeilen mit jeweils acht Elementen in den Programmspeicher generiert; begonnen wird mit Zeilennummer 300, die in 10er-Schritten erhöht wird. Da sich das Listing selbst kommentiert, erübrigt sich alles Weitere. Der Vollständigkeit halber ist noch zu erwähnen, daß die REM-Zeilen nicht mit eingegeben werden müssen.

Benutzt wurde der Tastaturpuffer bereits in einem Programm, das im ersten Teil dieser Serie abgedruckt wurde. Die Rede ist von der Autostartroutine, welche einen Basic-Programmstart (aus einem Maschinenprogramm heraus) durch Füllen des Puffers mit dem Kommando RUN (+ CHR$ (13)) realisierte.

## Die Eckadressen

Als nächstes besprechen wir die Adressen 641-644/ $0281-$0284. Sie enthalten die Anfangs- beziehungsweise Endadresse des verfügbaren Speicherbereiches.

Bei dem Systemreset ($FD22/ 64802) werden verschiedene Routinen wie beispielsweise Initialisierung der Zeropage, Setzen der Vektoren, RAM-Test ect. durchlaufen. Dabei wird unter anderem auch der verfügbare Speicherplatz festgestellt und die Eckadressen den obengenannten Registern übergeben. Diese Daten sind die Grundlage für alle weiteren Grundeinstellungen des Systems, also Basic-Beginn und -Ende, Beginn des Video- und Farbspeichers ect.

Wird es nun nötig, eine Speicherkonfiguration zu simulieren, beispielsweise Grundversion bei eingesteckter 8-KByte-Erweiterung, so kann das über diese Zeiger geschehen:
POKE 642, 16: POKE 644, 30: SYS 64970: SYS 64821 bewirkt diese Simulation. Das Unterprogramm im Betriebssystem (Adresse 64970), das zur Reset-Routine gehört, hat die Aufgabe, die Seiten 0 (Zeropage), 2 und 3 zu löschen. Danach prüft der Computer seine Speicherzellen. Dieser Test hat die Aufgabe, das RAM auf seine Funktionsfähigkeit hin zu überprüfen, damit es nicht zu Fehlfunktionen durch einen beschädigten Speicher kommt. Bei dieser Gelegenheit wird die Ausbaustufe des Speichers festgestellt; das Ergebnis findet sich dann in den Registern für die Anfangs- beziehungsweise Endadresse.Hier steigen wir nun mit den entsprechend manipulierten Registern (642 auf 16 und 644 auf 30) in die ROM-Routine ein. Mit Hilfe dieser Werte richtet das Unterprogramm nun den Video- und Farbspeicher ein. Mit dem zweiten SYS-Befehl (SYS 64821) wird die Initialisierung fortgesetzt. Dabei richtet er den Speicher für Basic ein und gibt die Kaltstartmeldung
**** CBM BASIC V2 ****
3583 BYTES FREE
aus.

Soweit ein kleiner Einblick ins Betriebssystem, eine ausführlichere Erläuterung erfolgt in einer der nächsten Folgen.

## Die Speicherorganisation

Jetzt möchte ich noch einen kleinen Einblick in die Speicherorganisation geben, was auch im Hinblick auf Grafik von Bedeutung ist. Wie hinreichend bekannt sein dürfte, gibt es drei verschiedene Speichererweiterungen zu kaufen, nämlich 3 KByte, 8 KByte und 16 KByte. Die Sammelerweiterungen (also 27/32/64 KByte-Erweiterungen sollen hier gedanklich ebenfalls in diese drei verschiedenen Module zerlegt werden.

Bei Erweiterungen von mehr als 8 KByte verändert sich die Lage des Bildschirm- und Farbspeichers (die Einstellung nimmt die Reset-Routine vor). Anhand von Bild 3 soll erläutert werden, warum eine Verschiebung notwendig ist.

Der **V**ideo-**I**nterface-**C**hip VIC (daher auch der Englische Name des VC 20), der vor allem für die Erzeugung des Fernsehsignals und den Aufbau des Bildschirmes verantwortlich ist, kann hardwaremäßig nur Videospeicherplätze zwischen 4096 und 8192 adressieren. Folglich muß das Bildschirm-RAM in diesem Bereich angesiedelt werden.

In der Grundversion liegt es zwischen Adresse 7680 und 8191 — also am Ende des verfügbaren Speichers, damit der Speicherbereich für Basic auch bei eingesteckter 3 KByte-Erweiterung durchgängig ist (läge der Bildschirmspeicher sowie bei einer 8-KByte-Erweiterung, währe dies nicht der Fall).

Ist ein Speichermodul von mehr als 8 KByte eingesteckt (egal ob der 3-KByte-Bereich zugeschaltet ist oder nicht), so legt das System den Videospeicher an die unterste adressierbare Stelle für den VIC, also Adresse 4096. Aus diesem Grund kann die eingesteckte 3-KByte-Erweiterung nicht mehr für Basic benutzt werden, denn sonst wäre der Speicher nicht mehr durchgängig.

Programme sollten immer auf allen Erweiterungsversionen lauffähig sein. Wer also in Routinen mit dem Bildschirm- oder Farbspeicher arbeitet, kann sich mit Hilfe der Register 36866 und 86869 im VIC die momentanen Adressen beschaffen. Bildschirm: 4*(PEEK(36866)AND128) + 64*(PEEK(36869)AND120)
Farbspeicher:
4*(PEEK(36866)AND128) + 37888

## Gewußt wo — Die Bildschirmadressen

Mit Hilfe bestimmter Bits aus diesen Registern bildet der VIC die Adressen, die er benötigt, um — unabhängig vom Prozessor — Bild- und Farbspeicherstellen auszulesen, damit er mit diesen Informationen das Fernsehbild erzeugen kann.

Das Betriebssystem hingegen bezieht seine Informationen über die Lage des Videospeichers nicht aus diesen VIC-internen Registern, sondern aus Adresse 648. Gibt man beispielsweise »POKE 648,28« ein, so liegt der Bildschirmspeicher zwischen 7168 und 7679. In Wirklickkeit stellt der Video-Interface-Chip — der, wie gesagt, unabhängig arbeitet — weiterhin den Speicherausschnitt zwischen Adresse 7680 und 8191 auf dem Bildschirm dar. Der Cursor schreibt also in einem ganz anderen Speicherabschnitt. Erst durch einen Warmstart (durch die Tastenkombination RUN/ STOP — RESTORE) werden die VIC-Register angepaßt.

Vom Bildschirm nun wieder zur Tastatur. In unseren systematischen Betrachtungen der Seite 1 bis 3 im Speicher, kommen wir nun zu den Adressen $0280-$0291/649-656, die der Tastatur zugeordnet sind. Sie enthalten lediglich Parameter für die Arbeit mit der Tastatur wie zum Beispiel Repeat Flag, das Flag für Kontrolltasten ect. Näheres entnehmen sie bitte Tabelle 1.

## Praktisches: Die Befehlseingabe über Funktionstasten

Zwei weithin unbekannte Adressen ($028F, $0290/ 655,656) sind vorzüglich dazu geeignet, eine Funktionstastenabfrage auf Interruptbasis zu realisieren. Besagte Adressen bilden einen Vektor für die Tastaturdecodierung, der meines Erachtens nur für den Zweck der Funktionstastenabfrage geschaffen wurde.

Was sind überhaupt Vektoren? ROM, so sagt ja bereits der Name (**R**ead **O**nly **M**emory), ist grundsätzlich nicht überschreibbar. Wer dennoch das System ergänzen will (beispielsweise durch neue Basic-Befehle), ist gezwungen, das gesamte ROM auszutauschen, es sei denn, die Schöpfer des Computers haben mögliche Optionen — so wie beim VC 20 (oder C 64) — bereits eingeplant. Dies geschieht, indem aus dem ROM heraus ins RAM verzweigt wird.

Normalerweise steht an der entsprechenden RAM-Adresse nur ein Zeiger auf eine ROM-Adresse, eben ein Vektor. Durch Änderung eines solchen Vektors kann man elegant bestehende Routinen umgehen und sie durch eigene ersetzen beziehungsweise ergänzen. Soweit, so gut.

Wie im Handbuch zu lesen, gibt es Unterschiede zwischen den Bildschirmcodes eines Zeichens (»A« beispielsweise hat den Wert 1) und dem allgemein verbreiteten ASCII-Code (»A« hat hier den Wert 65). Gleiches gilt für die Tastatur. Hier unterscheidet man ebenfalls zwischen dem ASCII- und dem sogenannten Tastatur-Matrixcode. Diese VC 20-interne Codierung wird durch eine Betriebssystemroutine — die über einen Vektor verfügt (den oben erwähnten für die Tastaturdecodierung) — in ASCII-Zeichen umgewandelt. Das Maschinenprogramm in Listing 2 und 3 wird durch »verbiegen« des Vektors 655/656 in die Tastaturroutine mit eingebaut. Es fragt die Codes der Funktionstasten ab und druckt die Zeichen aus, mit denen sie belegt wurden.

Das recht komfortable Programm liegt als Basic-Lader in Listing 2 vor. Nach dem Starten mit RUN wird das Maschinenprogramm automatisch ans Ende des verfügbaren Speichers geladen. Mit der SPACE-Taste aktiviert man diese Routine. Als erstes werden die Befehle gelistet, mit denen die Funktionstasten belegt sind. (Tabelle 2).

Auffällig ist bei den Kommandos LIST und RUN der Pfeil nach oben (t). Er bewirkt ein sofortiges Ausführen des Befehls — entspricht also »LIST« und RETURN-Taste beziehungsweise »RUN« und RETURN-Taste. Das andere auffällige Zeichen ist der Apostroph (') bei dem Kommando LOAD, der dem Hochkomma (”) entspricht. Das echte Gänsefüßchen ist bereits für die Syntax des Änderungsbefehls (siehe unten) vergeben.

Auf den Befehl π wie er beispielsweise beim Programm »Basic-Switch« (Folge 2) verwendet wurde, habe ich dieses Mal aus Platzgründen verzichtet, damit Lader und Maschinenprogramm in der Grundversion Platz finden. Die Kommandos werden statt dessen über den Befehl »SYS0« (oder F5) eingegeben. Dabei machen wir uns den USR-Vektor (Adresse 0-2) als Sprungzeiger zu Nutze. Damit zur Syntax bei der Funktionstastenprogrammierung:
SYS0 L – Listen der Funktionstastenbelegungen
SYS0 O – (Off) schaltet die Funktionstasten ab
SYS0 R – (Restart) schaltet die Funktionstasten wieder ein.
SYS0,X, »befehl« – belegt die X-te Funktionstaste mit einem Befehl.

Zum Schluß kommen wir noch zu einem Thema, mit dem ich mich mehr an den fortgeschrittenen Maschinensprachenprogrammierer wenden möchte. Im ersten Teil dieser Serie wurde beschrieben, wie der Basic-Befehlssatz mit Hilfe der CHRGET-Routine und des Befehles »π« im beschränktem Umfang erweitert werden kann. Diese Methode hat allerdings viele Unzulässigkeiten; es sind beispielsweise keine verkürzten Befehle wie beim normalen Basic (LIST = L SHIFT I) möglich.

Nun soll beschrieben werden, wie der Basic-Befehlssatz um richtige Klartextkommandos erweitert werden kann. Auch hierfür müssen wir bestehende Interpreterroutinen, die über Vektoren angesprungen werden, umgehen beziehungsweise ergänzen.

Für das Verarbeiten von Basic-Programmen sind drei Schlüsselroutinen zu substituieren. Da ist zunächst das Unterprogramm »ASCII in Token wandeln«. ($C57C) welches — wie der Name bereits sagt — die Aufgabe hat, Eingabezeilen im Basic-Puffer (wie zu Anfang beschrieben) in Interpretercode zu wandeln. Das Gegenstück dazu ist die Unterroutine »Interpretercode in Klartext wandeln.« Will man Basic-Zeilen sichtbar machen, so benutzt man das Kommando LIST. Dazu wird eben diese ROM-Routine benötigt, die die Rückumwandlung der Token in ASCII-Zeichen vornimmt.

Sämtliche Befehle sind in Form von ASCII-Zeichen im Basic-ROM enthalten, lediglich zum letzten Buchstaben jedes Befehlswortes wurde 128 ($80) addiert. Läßt man sich die Befehle durch
FOR T= 49310 TO 47565: PRINT CHR$(PEEK(T)):NEXT
ausdrucken, so sehen die Kommandos im Groß-/Kleinschrift-Modus folgendermaßen aus:
END = enD
FOR = foR ect.

Ferner ist jedem Basic-Befehl eine Adresse zugeordnet, bei der eine Abarbeitung vorgenommen wird. Diese Adressen sind in einer Tabelle (von $C00C $C07F) zusammengefaßt. Eine spezielle Routine hat wiederum die Aufgabe, die Befehlsadresse für ein entsprechendes Token aus der Tabelle zu lesen, und einen Sprung nach dorthin durchzuführen. Auch dieses Unterprogramm kann man mittels eines Vektors umgehen.

Damit haben wir das nötige Rüstzeug, um selbst Basic-Kommandos in den Interpreter mit aufzunehmen. In Listing 4 ist ein dafür geeignetes Programm abgedruckt, welches ich jetzt näher erläutern möchte. Es ist der Kopf für ein Utility, in das nach Belieben Befehlswörter und Sprungadressen eingesetzt werden können.

Die Routine gliedert sich in vier Teile: Der erste Teil (von $2000 - $203A) ist eine Kopie der Reset-Routine. Dabei wird der Computer neu initialisiert und eine neue Kaltstartmeldung
**** 64’ER BASIC ****
ausgedruckt. Hier ist genügend Platz vorgesehen, damit der Text nach eigenen Wünschen gestaltet werden kann. Ferner wurden die ersten neun Bytes mit NOPs versehen, damit dort — falls das Programm im Modulbereich abgelegt wird — die obligate Autostartinformation (a0CBM) eingesetzt werden kann. Anderenfalls — wenn das Maschinenprogramm per SYS gestartet wird — muß der erste Mnemonic-Befehl ein SEI sein.

Die sich jetzt anschließenden Programmteile sind die oben erwähnten Ergänzungen zu den Interpreterroutinen. Dies sind teilweise Kopien aus den alten ROM-Routinen mit Ergänzungen für die neuen Basic-Kommandos. Die Befehlswörter müssen jetzt nur noch eingetragen werden. Das geschieht folgendermaßen:

Die Befehle werden mit Hilfe des Programms »Tokenerzeuger« (Listing 5) in den entsprechenden Adreßbereich geschrieben. Bei nachträglichen Eintragungen ist zu beachten, daß zum letzten Buchstaben jedes Befehlswortes der Wert $80 (=128) zu addieren ist. Die Ergänzungsbefehle beginnen mit Token 204. Das erste Befehlswort beginnt mit dieser Nummer, der zweite erhält automatisch die 205 und so weiter.

Weiterhin ist für jedes Kommando die Sprungadresse in der Tabelle ($2208-$2268) zu vermerken. Dabei muß die Reihenfolge Low-/High Byte beachtet werden. Außerdem muß das LOW-Byte vor dem Eintrag um eines dekrementiert werden (LOW Byte -1). Auch diese Arbeit erledigt das Programm in Listing 5.

Ein Befehl wurde bereits eingetragen. Der Befehl KILL führt einen Reset durch und damit ist das Programm abgeschaltet. Wer also seine Maschinenprogramme ins Basic einbinden möchte, kann dies mit der beschriebenen Methode tun. Beispielsweise könnte man die in Listing 2 abgedruckte Funktionstastenroutine mit dem KEY-Befehl belegen. Auch im Hinblick auf Grafik, Tonerzeugung oder Joystickabfrage bietet sich hier die Möglichkeit, die Unzulänglichkeiten des Basics zu überwinden. Auch die Besitzer eines C 64 können die beschriebene Routine benutzen, da die Basic-ROMs nahezu identisch sind (sie haben lediglich eine andere Adresse). Außerdem habe ich in Tabelle 3 eine Liste der wichtigsten Unterprogramme zusammengestellt, mit denen man unter anderem Parameter, Strings, Kommas oder ähnliches abfragen kann. Auf jeden Fall sollte man sich für diese Arbeit ein ROM-Listing (zum Beispiel »VC 20 Intern« von Data Becker) zulegen.

Damit möchte ich für heute schließen. Das nächste Mal werden wir sehen, was man mit den Kernal-Vektoren anfangen kann und betrachten die Grafikmöglichkeiten beim VC 20.

(Christoph Sauer/ev)

# Memory Map mit Wandervorschlägen

> Es steckt sehr viel im ersten Kilobyte des VC 20 und C 64. Wir werden Ihnen im Rahmen dieses Kurses die Bedeutung und Anwendung der Speicher und Register von Betriebssystem und Interpreter näherbringen.

Hinweise und Tips über nützliche PEEK- und POKE-Adressen gehören zum Standard-Repertoire einer Computer-Zeitschrift. Ebenso häufig werden Leserfragen zu diesem Thema gestellt, obwohl mehrere Handbücher für die beiden Home-Computer von Commodore bereits Speicherlisten (auf englisch »Memory Map«) enthalten.

Warum ich mich jetzt auch noch mit diesem Thema befassen will, hat zwei Gründe. Zum einen stört mich, daß ein Hinweis wie:
»...mit POKE 19,1 läßt sich das Fragezeichen bei INPUT-Befehlen unterdrücken...«
zwar richtig und auch anwendbar ist, aber halt nicht erklärt, was da eigentlich passiert und welche Folgen das für ein Programm haben kann. Zum anderen vermisse ich speziell in den Speicherlisten nähere, auch für den Anfänger verständliche und irgendwann einmal verwertbare Angaben.

Ich habe mir deshalb vorgenommen, Ihnen die Bedeutung und Anwendungen der PEEK- und POKE-baren Adressen, — sozusagen eine Wanderkarte mit Tourenvorschlägen und Sehenswürdigkeiten — in Form von Beispielen und Kochrezepten, näher zu bringen. Mir ist durchaus bewußt, daß das kein leichtes Unterfangen ist, da ich möglichst ohne Fach-Jargon auch für Nichttechniker verständlich bleiben möchte und da die Zahl der zu behandelnden Adressen recht hoch ist. Ich werde also um Kompromisse wohl manchmal nicht herumkommen. Bevor wir anfangen, möchte ich noch einen kleinen »Arbeitsplan« machen.

* Zur Methode:
Meine Erklärungen sind so aufgebaut, daß sie am besten vor dem Computer mit der Zeitschrift auf den Knien nachvollziehbar sind, also »Lies und Tipp«.
* Zum Adressenbereich:
Prinzipiell sind natürlich alle RAM-Adressen (RAM = Lese- und Schreibspeicher) POKEbar und kämen daher in Betracht. Vorerst aber werden wir uns nur den Bereich von 0 bis 1023 vornehmen.
* Zum Computer:
Der genannte Speicherbereich hat mit wenigen Ausnahmen für VC 20 und C 64 die gleiche Bedeutung. Ich werde daher beide Computer gleichzeitig behandeln und auf Unterschiede jeweils gezielt hinweisen.
* Der erste Hinweis:
InTabelle 1 sind die Unterschiede in groben Umrissen zusammengefaßt.
* Zur Darstellung:
Die Kenntnis der Bedeutung dieser Speicherzellen kommt auch Programmen in Maschinensprache zugute. Ich gebe daher alle Adressen sowohl als Dezimal- als auch als Hexadezimalzahl (mit vorgestelltem »$«) an.
* Zu den Adressen:
Wenn in die zur Diskussion stehenden Speicherzellen eine Adresse aus dem erlaubten Bereich 0 bis 65535 ($0 bis $FFFF) hineingeschrieben wird, geschieht das immer mit der Aufteilung in einen niederwertigen Teil (Low Byte) und einen höherwertigen Teil (High Byte). Das Rezept zur Umrechnung finden Sie auf Seite 137.

## Wozu brauchen das Betriebssystem und der Basic-Übersetzer RAM-Speicherzellen?

Auf den ersten Blick ist nicht verständlich, warum die Speicherzellen von 0 bis 1023 feste Bedeutung haben und für normale Programme nicht zur Verfügung stehen. Wenn sie schon, wie es heißt, vom Betriebssystem und dem Übersetzer-Programm verwendet werden, warum stehen sie dann nicht gleich im ROM-Speicher bei allen anderen Teilen dieser Systeme?

Ein Computer führt einen Programmschritt nach dem anderen aus, ganz stur, ohne eigene Entscheidungsfähigkeit, es sei denn, das Programm schreibt derartige Entscheidungen vor. Das Betriebssystem ist sozusagen im ROM eingefroren beziehungsweise festgeschrieben. Das würde aber bedeuten, daß der Computer keine Variationsmöglichkeiten hat, und daß alle Programme in gleicher Weise ablaufen. Aber das stimmt natürlich nicht! Alle Programme sind verschieden, sie belegen einen verschieden langen Speicherbereich und verarbeiten die unterschiedlichsten Variablen. Wir geben verschiedene Zeichen mit der Tastatur ein, der Computer wartet, bis eine Taste der Datasette gedrückt ist und so weiter.

Dafür braucht das Betriebssystem einen Speicherbereich, der variabel ist, in den es Zwischenwerte ablegen und später wieder auslesen kann.

Und das ist genau der Speicherbereich, der uns interessiert, nämlich von 0 bis 1023, womit wir wieder beim Thema wären.

Jetzt aber geht es los und zwar gleich in die Vollen. Denn ausgerechnet die ersten drei Speicherzellen haben laut Tabelle bei beiden Computern eine verschiedene Bedeutung und zusätzlich gehören sie mit zu den kompliziertesten.

### Adresse 0 bis 2 ($0 — $2) beim VC 20:

Sprungbefehl und wählbare »Sprungadresse« des USR-Befehls.

Die drei Adressen werden bei der Abwicklung des Basic-Befehls USR verwendet und stehen dem Programmierer zur Verfügung.

Hinweise: Diesen drei Adressen des VC 20 entsprechen beim C 64 die Adressen 784 ($310) bis 786 ($312). Die folgenden Erklärungen gelten also entsprechend auch für den C 64.

Hand aufs Herz: Haben Sie USR schon einmal benützt? Ohne Zweifel gehört dieser Befehl zu den seltenen. Ich will ihn daher hier kurz erläutern. USR hat dieselbe Funktion wie SYS, nämlich aus einem Basic-Programm direkt in ein Maschinenprogramm zu springen und dort solange weiterzufahren, bis mit dem Befehl RTS (entspricht dem Basic-Befehl RETURN) in das Basic-Programm zurückgesprungen wird. Die Sprungadresse in das Maschinenprogramm steht bei SYS gleich hinter dem Befehl.

Bei USR muß die Adresse zuerst in die Speicherzellen 1 und 2 (aha!!) gePOKEt werden.
Beispiel — Sprung auf 56524 ($DCCC):
mit SYS: SYS 56524
mit USR: POKE 1,204:POKE 2,220:X = USR(Y)

Kein Wunder, daß USR selten benützt wird. Aber erstens ist er durch das POKEn der Low-High-Byte-Darstellung aufgebläht und zweitens hat er auch wesentlich mehr Fähigkeiten als SYS.

Sein Argument, im obigen Beispiel also das »Y«, wird nämlich zuerst in den »Fließkomma-Akkumulator« FAC 1 (Floating Point Accumulator Nr. 1) gebracht, der sich in den Speicherzellen 97 bis 102 ($61 bis $66) befindet. Da wir ihn auf unserer Reise durch den Speicher noch treffen werden, brauche ich jetzt nicht näher darauf einzugehen. Wichtig ist lediglich, daß der Wert von »Y« dann vom angesprungenen Maschinenprogramm verarbeitet werden kann. Das Resultat kommt dann wieder in diesen FAC 1 und steht als Wert von X (siehe Beispiel oben) dem Basic-Programm zur Verfügung.

Mit USR kann man also Variable ins Maschinenprogramm zur Bearbeitung und zurück transferieren — und das ist der Unterschied zum SYS-Befehl. Ich möchte das an einem kleinen Beispiel demonstrieren. Statt allerdings ein Maschinenprogramm selbst zu schreiben, verwende ich, beziehungsweise springe ich, auf eine Routine des Betriebssystems, welches Werte des FAC 1 für mathematische Operationen verwendet.

Als mathematische Operation wähle ich das eingebaute Programm für INT, welches im VC 20 ab Speicherzelle 56524 ($DCCC) steht (im C 64 steht es ab 48332 ($BCCC)). Dieses wollen wir verwenden:
In Zeile 10 definieren wir einen Wert für die Variable X, der in das Maschinenprogramm gebracht werden soll. Mit Zeile 20 bringen wir die Startadresse des Maschinenprogramms in die Speicherzellen 1 und 2.

Laut Kochrezept teilen wir die Adresse 56524 auf in ein Low-Byte = 204 und ein High-Byte = 220.

Der Befehl in Zeile 30 löst den ganzen USR-Vorgang aus, Zeile 40 gibt uns das Resultat.
10 Y = 14.35
20 POKE 1,204:POKE 2,220
30 X = USR(Y)
40 PRINT X
Hinweis:
Entsprechend der anderen Adresse 48332 lautet die Zeile 20 beim C64:
20 POKE 785,204:POKE 786,188

Nach RUN erhalten wir das Resultat 14, wie das Gesetz für INT es befiehlt. Natürlich hätten wir gleich PRINT INT (14.35) schreiben können, aber ich wollte ja nur demonstrieren. Der eigentliche Wert des USR-Befehls kommt hauptsächlich bei selbtgeschriebenen Maschinenprogrammen zum Zuge.

Sie können zur Übung im obigen Programm statt INT auch COS verwenden, indem Sie auf die Adresse 57935 ($E261) beziehungsweise beim C 64 auf 57938 ($E264) springen. Der Vergleich mit dem Basic-Befehl COS muß dasselbe Resultat ergeben.

Wer hat gemerkt, daß wir überhaupt nichts mit der Speicherzelle 0 gemacht haben, obwohl sie doch beim USR angeblich beteiligt ist?

Sie ist es wirklich, doch ohne unser Zutun. In diese Adresse wird beim Einschalten des Computers die Zahl 76 ($4C) geschrieben. Das ist der Code für den Maschinenbefehl »JMP«, der soviel bedeutet wie GOSUB. Bei USR springt nämlich das Programm auf die Speicherzelle 0, findet dort den Sprungbefehl und in den nachfolgenden Zellen 1 und 2 die Sprungadresse — und führt den Sprung auch gleich aus.

Jetzt aber wollen wir uns anschauen, wie diese drei Speicherzellen beim C 64 verwendet werden.

### Adresse 0 ($0) beim C 64:

Datenrichtungsregister für Ein/Ausgabe-Port des 6510-Mikroprozessors

### Adresse 1 ($1) beim C 64:

Datenregister für Ein/Ausgabe-Port des 6510 — Mikroprozessors.

### Adresse 2 ($2) beim C 64:

unbenutzt

Im Gegensatz zum Mikroprozessor des VC 20 hat der des C 64 sechs Ein/Ausgabe-Leitungen die einzeln programmierbar sind und so eine direkte Verbindung zwischen dem Mikroprozessor und der Außenwelt herstellen. Warum nur sechs Leitungen und nicht wie üblich acht? Auf dem Chip selbst könnten acht Bit verkraftet werden, aber es stehen nur sechs Anschlußbeine zur Verfügung.

Um trotzdem flexibel zu bleiben, ist dieses Tor zum Prozessor — zutreffend auch »Port« genannt — in beiden Richtungen begehbar. Jede einzelne der sechs Leitungen kann vom Programmierer auf »Eingang« oder auf »Ausgang« geschaltet werden. Dazu dient das Datenrichtungsregister in der Speicherzelle 0.

### Datenrichtungs-Register in Zelle 0

Wenn zum Beispiel in das Bit 4 der Zelle 0 eine 0 hineingePOKEt wird, ist die Leitung Nummer 4 des Ports auf »Eingang« geschaltet. Es gilt für alle 6 Bits (Nummer 0 bis 5):
— Bit auf 0 = Eingang
— Bit auf 1 = Ausgang
Beim Einschalten schreibt das Betriebssystem in dieses Register die Dualzahl ..101111 (dezimal = 47). Das heißt also, daß nur die Leitung Nummer 4 als Eingang verwendet wird, alle anderen aber als Ausgang. Warum das so ist, sehen wir gleich. Vorher will ich aber noch erwähnen, daß im C 64 von dieser Flexibilität des Mikroprozessor-Ports kein Gebrauch gemacht wird. Ich habe das ganze Betriebssystem durchgesehen, aber das einzige Mal, wo die Speicherzelle 0 angesprochen wird, ist eben bei der Einschaltroutine.
Das heißt aber nicht, daß Sie, lieber Hobby-Programmierer, darauf verzichten müssen. Ich kann mir vorstellen, daß besonders Ausgefuchste unter Ihnen durch POKEn eines anderen Bitmusters in die Speicherzelle 0 vielseitige Befehle erzeugen und einsetzen können.

Das wird besonders deutlich, wenn Sie jetzt sehen, mit welchen Teilen des Computers diese sechs Leitungen verbunden sind.

### Datenregister in Speicherzelle 1

Mit diesem Register steuert der Mikroprozessor (und damit natürlich das Betriebssystem) die Auswahl von Speicherblöcken und den Betrieb mit dem Kassettenrecorder. Dem Programmierer steht diese Möglichkeit über POKEn auch zur Verfügung.

### Bit O

schaltet den Speicherbereich 40960 - 49151 ($A000 - $BFFF) zwischen dem Basic-Übersetzer (Interpreter) im ROM und freiem RAM um (Normalzustand = 1)

### Bit 1

schaltet den Speicherbereich 57344 — 65535 ($E000 — $FFFF) zwischen dem Betriebssystem (Kernal) im ROM und freiem RAM um (Normalzustand = 1)

### Bit 2

schaltet den Speicherbereich 53248 - 57343 ($D000 - $DFFF) zwischen Zeichen-ROM und Ein/Ausgabe-ROM um (Normalzustand = 1)

### Bit 3

sendet serielle Daten zum Kassettenrecorder (Normalzustand = 0)

### Bit 4

prüft, ob eine der Tasten des Recorders gedrückt ist, welche den Motor einschalten (Normalzustand = 1)

### Bit 5

schaltet den Motor des Recorders ein und aus (Normalzustand 1)

Als erstes möchte ich die RAM-ROM-Umschaltung näher beschreiben.

Sie wissen, daß Ihr C 64 deswegen so heißt, weil er 64 KByte Speicherplätze hat. Nur stimmt das nicht! Er hat nämlich 88 KByte und müßte eigentlich C 88 heißen.

Da mit den 16 Bit der High/Low-Byte Methode (siehe Bild 1) nur 64 KByte adressierbar sind, müssen die restlichen 22KByte bei Bedarf eingeschoben werden — und das machen die oben erwähnten Bits 0 — 2 des Datenregisters.

In Bild 2 sehen Sie die drei oben erwähnten Speicherblöcke, die sowohl mit RAM als auch mit ROM belegt sind, einer davon gleich doppelt. Ich habe ihnen folgende Namen gegeben:

- 40960-49151 ($A000-$BFFF) = BLOCK A
- 53248-57343 ($D000-$DFFF) = BLOCK D
- 57344-65535 ($E000-$FFFF) = BLOCK E

Tabelle 2 gibt Ihnen die Übersicht über die gemeinsame Wirkung der Bits 0,1 und 2 des Datenregisters auf den jeweiligen Inhalt der Speicherblöcke.

Wie Sie durch PRINT PEEK (1) selbst leicht feststellen, steht nach dem Einschalten des Computers im Register 1 die Zahl 55. In dualer Darstellung ist das 110111. Das entspricht dem oben genannten »Normalzustand« der einzelnen Bits.

Vergleichen Sie es bitte mit der Auflistung am Anfang der Beschreibung der Speicherzelle 1. Die in Tabelle 2 dargestellten Bits sind also die rechten drei Bits der Zelle 1. Lassen wir die Bits 3, 4 und 5 unverändert, ergeben die acht Kombinationen der Tabelle 2 die Zahlen 55 bis 48. Durch den Befehl POKE 1,54 können wir nun den Basic-Übersetzer ausschalten und 8 KByte Speicher gewinnen. Nur nutzt uns das nicht viel, denn was tun — ohne Basic! Es gibt aber doch eine Anwendung. Zuvor will ich Ihnen aber noch beweisen, daß wir tatsächlich den Block A auf RAM umschalten. Der Trick besteht darin, den Basic-Übersetzer vom ROM in den darunter liegenden RAM umzuladen. Wenn er tatsächlich inRAM steht, müßten wir ihn durch POKEn verändern können zu einem Privat-Basic. Geben Sie direkt ein:
FORJ = 40960 TO 49151: POKE J, PEEK(J):
NEXTJ
POKE J,PEEK(J)—das sieht dümmer aus als es ist. Die »Doppeldecker-Speicher« erlauben nämlich ein PEEKen nur aus dem ROM-Bereich. Ein hineinPOKEn dagegen geht nur in den RAM-Teil. Von dort aber kann er — wie gerade gesagt — nicht herausgelesen werden, es sei denn, wir schalten um !

Merken Sie was? Die Zeile oben liest also den Inhalt des Basic-ROMs und schreibt ihn in den RAM mit identischen Adressen. Die Ausführung der Zeile braucht einige Zeit. Wenn der Cursor wieder blinkt, schalten wir den RAM ein mit:
POKE 1,54

Wir merken natürlich noch keinen Unterschied, denn das RAM-Basic ist ja noch dasselbe, wie es im ROM steht.

Doch nun werden wir es verändern. In der Speicherzelle 41220 steht das »P« für den Befehl PRINT mit dem ASCII-Codewert 80. Dieses P ersetzen wir durch ein »G« (ASCII-Code = 71).
POKE 41220,71
Versuchen Sie bitte, mit dem (nicht durch »?« abgekürzten) PRINT-Befehl ein Zeichen auf den Bildschirm zu drucken. Es wird Ihnen nicht gelingen, denn der Befehl heißt jetzt:
GRINT ”A”
was beweist, daß das Basic jetzt in RAM steht. Das Umdefinieren von Befehlen ist natürlich wenig sinnvoll. Aber wer die Maschinenprogramme des Basic kennt, kann sie auf diese Weise ändern, erweitern, einschränken, solange er sich auf in sich geschlossene Teile beschränkt.

Eine inzwischen oft zitierte Anwendung stammt von Jim Butterfield (siehe Literatur), den es begreiflicherweise stört, daß der Befehl ASC, welcher den ASCII-Code eines Strings erzeugt, bei einem Null-String das Programm mit ILLEGAL QUANTITY ERROR beendet.
Versuchen Sie es:
PRINT ASC("A") ergibt die Zahl 65. PRINT ASC("") hat die obige Fehlermeldung zur Folge.
Wenn Basic im RAM steht, können wir das ändern:
POKE 46991,5
Die Wiederholung des Befehls PRINT ASC("") ergibt jetzt 0 — und, was das Wichtige ist, das Programm läuft weiter.

Durch zusätzliches Umladen des Speicherblocks E und anschließendes Umschalten mit POKE1,53 ist auch das Betriebssystem veränderbar — ein weites Feld für fortgeschrittene Programmierer in Maschinensprache.

Die wohl wichtigste Anwendung der Umschaltmethode wird den Maschinen-Programmierern geboten, die dadurch eine kostenlose Speichererweiterung von 16 KByte erhalten. Bei gleichzeitiger Verwendung von Basic und Maschinenprogramm kann die Umschaltung besonders vorteilhaft eingesetzt werden. Das Umschaltprogramm muß dann aber ebenfalls in Maschinensprache geschrieben sein und darf nicht im Umschaltbereich liegen.

Das Umschalten von den Ein/Ausgabe-Registern des Blocks D mit POKE 1,51 erlaubt, die Bitmuster der fest programmierten Zeichen aus dem Zeichen-ROM auszulesen, in einen freien RAM-Bereich zu bringen und dort dann nach eigenen Vorstellungen zu verändern. Im Grafik-Kurs war das ausführlich beschrieben.

Der Vollständigkeit halber muß ich hier noch erwähnen, daß neben den drei ersten Bits der Speicherzelle 1 noch zwei weitere Signale die RAM/ROM-Umschaltung beeinflussen. Es sind das die Leitungen auf Pin 8 und 9 des Erweiterungssteckers (GAME und EXROM), welche durch Spiel- und Programmodule benützt werden. Eine genaue Beschreibung der dadurch erzeugten sinnvollen Speicherkombinationen finden Sie in dem Buch »64 Intern« von Data Becker ab Seite 14.

Bit 3, 4 und 5 regeln wie schon gesagt den Betrieb des Kassettenrecorders.
Zu **Bit 3** ist oben schon alles notwendige gesagt.
**Bit 4** ist im Normalzustand auf 1, »normal« heißt hier, solange keine der Motor-Tasten der Datasette (PLAY, REWIND, FAST FORWARD) gedrückt ist.
Zur Probe:
10 X = PEEK(1)
20 PRINT X
40 GOTO 10

## Betrieb des Kassettenrecorders

Die schon erwähnte »Normalzahl« 55 (dual = 110111) läuft als Zahlenband solange, bis eine der besagten Tasten gedrückt wird. Dann läuft eine 7 (dual = 000111). Warum auch Bit 5 zu 0 wird, kommt gleich nachher zur Sprache.

Mit einer kleinen Erweiterung der drei Zeilen können Sie in einem Programm den Status der Motor-Tasten abfragen. Ergänzen Sie:
30 IFX = 7 THEN 50
50 PRINT »TASTE GEDRÜCKT«
Um nur Bit 5 abzufragen, schreiben wir besser:
30 IF (X AND 16) = 0 THEN 50

Diese Abfrage kann allerdings nicht unterscheiden, welche der drei Tasten der Datasette gedrückt worden ist. Außerdem funktioniert das alles nur, wenn — wie im »Normalfall« — das Bit 4 des Datenrichtungsregister (Speicherzelle 0) auf 0 (Eingang) steht.

**Bit 5** schaltet den Motor der Datasette ein und aus. Es bietet sich an, damit per Programm die Datasette zu schalten — wenn so etwas nützlich ist. Leider ist dieses Bit etwas schwieriger zu handhaben, da es in der Interrupt-Routine des Betriebssystems eine Rolle spielt.

Die Tasten der Datasette werden nämlich 60mal in der Sekunde abgefragt. Wenn keine Taste gedrückt ist, setzt das Betriebssystem sowohl das sogenannte »Interlock«-Register in Speicherzelle 192 auf 0 als auch Bit 5 der Zelle 1 auf 1, wodurch der Motor ausgeschaltet wird beziehungsweise bleibt. Da kann man nicht dagegen an. Wir haben nur eine Chance, wenn eine Taste bereits gedrückt ist und der Kassettenmotor schon läuft.

Dann nämlich können wir zuerst das Interlock-Register mit einem Wert größer als 0 lahmlegen:
POKE 192,255
Jetzt läßt sich der Motor der Datasette mit Bit 5 steuern:
POKE 1,39 beziehungsweise
POKE 1,PEEK(1) OR 32
schaltet den Motor aus,
POKE 1,7 beziehungsweise
POKE 1,PEEK(1) AND 31
schaltet den Motor ein.

Das Interlock-Register in Speicherzelle 192 werde ich später noch einmal erwähnen, da es seine Funktion auch beim VC 20 ausübt, allerdings mit anderen Ein/Ausgangs-Ports. Das ist alles, was zur Speicherzelle 1 zu sagen ist. Das nächste Mal wird unsere Speicherreise weitergehen, wobei natürlich nicht alle Speicherzellen soviel hergeben beziehungsweise dem Programmierer so direkt zur Verfügung stehen, wie die Adressen 0 und 1.

(Dr. Helmuth Hauck/aa)

<aside>

## Die Low-High-Byte-Methode

DARSTELLUNG VON ADRESSEN GRÖSSER 255

Um große Zahlen darzustellen, wird von allen Homecomputern die sogenannte High-Low-Byte-Methode angewendet.

Eine Speicherzelle der Commodore Computer ist 8 Bit lang, das ist 1 Byte, und sie kann daher als größte Zahl 255 ($FF) enthalten. Für Zahlen größer als 255 hängen wir mehrere Speicherzellen hintereinander, in unserem Fall deren zwei. Mit 2 Bytes (16 Bit) können wir nämlich maximal 65535 ($FFFF) darstellen. Diese Aufspaltung einer Adresse in zwei Speicherzellen soll das folgende Beispiel verdeutlichen.

TODO

Sie sehen, daß die Dezimalzahl 47491 aufgespalten wird in $B9 = 185 und $83 = 131. Zur Erinnerung: Jede Stelle einer Hex-Zahl kann direkt in eine 4stellige Dualzahl und umgekehrt gewandelt werden (1011 = $B, 1000= $8).

Der Umrechnungsweg über eine 16stellige Dualzahl ist natürlich viel zu aufwendig. Ich empfehle Ihnen folgendes Kochrezept:
(1) Dezimal High/Low-Byte:
47491 : 256 = 185, Rest 131
Der Rest fällt bei der Division per Hand automatisch an. Mit dem (Taschen-)Rechner erhält man den Rest durch:
185 * 256 - 47491 = -131
2) High/Low-Byte Dezimal:
HB* 256 + LB = Dezimal
185* 256 + 131 = 47491
Wichtige Regel:
Die Mikroprozessoren von VC 20 und C 64 verlangen, daß immer das Low-Byte vor dem High-Byte kommen muß. Die Zahl wird sozusagen von rechts nach links gelesen (im Beispiel: 131, 185)
</aside>

# Mode-Fotos – mit Bits und Bytes

> Aus anfänglichem Hobby wurde ernsthafte Anwendung. In seinem Münchener Hinterhofstudio verbindet der Fotograf Dirk Franke Schönheiten und Mode mit auf einem C 64 erzeugter Computer-Grafik. Die Ergebnisse können sich sehen lassen.

Das Lehel ist eines der ältesten und gemütlichsten Münchner Stadtteile. Hier wohnen neben Alteingesessenen Ausgeflippte aus den Bereichen Mode, Musik und Film. Versicherungskonzerne residieren protzig neben Tante-Emma-Läden, und vor nicht allzu langer Zeit gab es in diesem Viertel noch Münchens einzigen Pferdemetzger und sogar einen letzten, privaten Bauernhof. Auch heute gibt es dort noch viele kleine Handwerksbetriebe und Hinterhofwerkstätten. Und in einer von diesen beginnt unsere Geschichte.

In den Räumen einer aufgelassenen Galvanisierfabrik entstand mit viel Eigenleistung und Umbauarbeit das Lime-Light Studio. Dort machte sich nach langen »Lehrjahren« bei Profis der Mode- und Werbefotograf Dirk Franke mit einem eigenen Studio selbständig. Und lange sah es auch so aus, als würde dieses Studio ein Fotostudio wie so viele andere bleiben. Wäre da nicht...

Tja, wäre da nicht jemand aus dem großen Bekanntenkreis des jungen Fotografen mit einem TRS-80-Computer samt Monitor eines Tages im Studio bei Dirk Franke aufgetaucht.

Anfangs diente dieses heute schon antiquare Gerät nur zum Daddeln. Wer die eher einfachen bis langweiligen Spiele aus dieser Ära noch kennt, kann sich leicht vorstellen, daß bald mehr gefragt war. So machte Dirk Franke seine ersten Tapser in Basic. Und obwohl die grafischen Fähigkeiten dieses Modells noch nicht einmal bescheiden zu nennen waren, faszinierte ihn die Möglichkeit, mit einem solchen Gerät Bilder, wenn auch sehr primitive, erzeugen zu können.

Anders als die mit seiner Fotokamera geschossenen, hatten diese Bilder von sich aus schon ein gewisses Eigenleben, das man mit der herkömmlichen Fotografie erst mühsam und kreativ erzeugen mußte. Einen ersten Gehversuch, dieses für den Fotografen völlig neue Medium auch beruflich zu nutzen, zeigt das Cover für die Single »Letric Metric« von Peter Griffin (Bild 1), für den er das Titelbild vor nun fast drei Jahren knipste.

Der TRS-80 verließ einige Tage später samt dem Bekannten wieder das Studio. Aber von nun an war es klar, ein Computer mußte her. Es vergingen zwar noch ein paar Monate, doch dann war der C 64 und mit ihm bis dahin in dieser Preisklasse ungekannte grafische Möglichkeiten auf dem Markt.

Dennoch, mit der schnellen Entscheidung für diesen Computer war es nicht getan. Jeder kennt die umständliche Programmierung von Grafiken beim C 64, ohne Tools oder Grafikerweiterungen. Es folgten also die Floppy und das Koala Pad. Jetzt konnte es endlich losgehen. Denkste!

Nach nächtelangen Versuchen und endlosem Testen mit den verschiedensten Kameratypen, unterschiedlichen Filmmaterialien, ja sogar variierenden Film-Emulsionen, die einzelne Farben nuanciert anders wiedergaben, und nachdem Dirk Franke sämtliche Laboranten im Entwicklungslabor kirre gemacht hatte, wollte er beinahe aufgeben. Die Qualität war einfach nicht akzeptabel.

Wieder mal ging es quer durch den Dschungel des Münchner Computer-Handels, bis ein geeigneter Farbmonitor gefunden war. Mit diesem ließ sich dann auch die letzte Hürde, die vorher viel zu grobe Auflösung, nehmen. Die neuen Tests waren vielversprechend, und ein erster Kunde zeigte Mut und Interesse an der neuen »Technik«.

Eine junge Modefirma suchte nach etwas Neuem: einem »Eyecatcher«. Denn nach wie vor gilt auch in dieser Branche die Devise des Auffallens um jeden Preis. Und dafür schien die Frankesche Verbindung von Real-Fotografie und Computergrafik wie geschaffen.

Mittels des Tabletts vom Koala Pad und der mitgelieferten Schrift-Software entstand das Computerbild (Bild 2). Ein Modell war schnell gebucht und stellte sich mitsamt der, damit sie nicht reflektieren, an speziell behandelten Nylonschnüren aufgehängtenJeans vor den schwarzen Hintergrund in Pose (Bild 3).

Stimmte erst einmal das Licht und stand die Grafik, war der Rest nur noch für den Assistenten Plackerei. Er war es nun, der die Filmkassetten für die ständigen Mehrfachbelichtungen quer durchs Studio hin- und herbringen mußte. Zweimal Klick mit Modell und Jeans. Blitze aus. Zweimal Klack am Computer. Blitze wieder an. Und immer weiter so, mindestens hundertmal.

Das Endergebnis war dann die Vorlage für die Anzeige und der Modekunde zufrieden. Doch schon während der Aufnahmen hatte der Layouter der Werbeagentur Gelegenheit zu letzten Korrekturen. Ein kurzes Basic-Programm ermöglicht eine Hardcopy des Bildschirms auf dem grafikfähigen Drucker. So konnte der Art-Director immer wieder Varianten scribbeln oder Veränderungen am Bildaufbau vornehmen, bevor der letzte Schuß im Kasten und die Aufnahmen damit gestorben waren (Bild 4).

Welche Faszination diese Verbindung zweier, eigentlich artfremder Medien auf den Fotografen Dirk Franke ausübt, zeigt auch seine Visitenkarte: Ein 6 x 6-Dia, das den realfotografierten Meister im Bogie-Look zusammen mit Computerbild und Telefonnummer, einen bleibenden Eindruck hinterlassend zeigt (Bild 5).

Doch nicht nur das fotografische Leben hat der Computer bei Dirk Franke nachhaltig beeinflußt. Auch in die interne Organisation seines »Ladens« brachte der C 64 neuen Schwung. Der ganze Papierkram befindet sich nun auf Disketten und teils selbstgeschriebene, teils gekaufte Programme erleichtern und übernehmen das Halten der täglichen Ordnung.

Vom Hauptmenü (Bild 6 und 7) geht es zur Textverarbeitung, zum Rechnungsstellung- und Film- und Requisitenlager-Programm, in die Einnahmenüberschuß-Buchhaltung und in die Adressenverwaltung, die für die zahlreichen, berühmtberüchtigten Studiofeste besonders wichtig ist.

Dirk Franke möchte jedenfalls seinen »Compi« nicht mehr missen. Und seit es Spiele wie den Flugsimulator gibt, daddelt er auch manche Nacht mal wieder. Doch obwohl bereits erste Anzeigen mit seinen Computerbildern erschienen sind und er eigentlich recht zufrieden sein könnte, kommen angesichts der zahlreichen Veröffentlichungen über die Möglichkeiten großer Grafikcomputer bereits neue Wünsche auf. Verständlich...

(Klaus Koch/aa)

# 64'er Disk-Ecke

> Wie die Überschrift schon andeutet, hat sich eine Änderung vollzogen. Das »Ka« für Kassette ist weggefallen. Dafür hat sich »Di« zu Disk gemausert. Es ist uns also endlich gelungen, die Programme auch auf Diskette anzubieten. Wir mußten allerdings eine Entscheidung fallen:
Kassette oder Diskette, beides ging nicht. Die Diskette ist aufgrund ihrer Verbreitung ausgewählt worden. Dafür sind jetzt alte Programme einer Ausgabe (VC 20 und C 64) auf einer Diskette erhältlich.

Eines hat sich aber nicht geändert: der Preis. Die Diskette für eine Ausgabe kostet demnach 29,90 Mark. Sie werden bei einigen Disketten bestimmte Programme vermissen. Deren Autoren konnten sich nicht entschließen, ihr Programm im Rahmen des Leserservice für eine Verbreitung auf Datenträger freizugeben. Bei den Ausgaben 4, 5 und 6 können noch Kassetten (VC ...) bestellt werden. Auf kurze Programme wurde aus Gründen der Übersichtlichkeit verzichtet. Nun noch einige technische Details. Zu den Programmen sind immer die Seitenzahlen angegeben, unter der Sie die Beschreibungen in der entsprechenden Ausgabe finden können.
Der Diskette liegen also keinerlei Informationen bei. Lesen Sie daher aufmerksam die Anleitung (ob SYS-Befehle nötig sind, in welcher Reihenfolge geladen werden muß, eventuelle Sprach- oder Speichererweiterungen und ähnliches mehr) in dem jeweiligen Artikel nach. Aus Aktualitätsgründen wird jeweils die abgedruckte Version angeboten. Eventuelle systematische Fehler, die sich noch im Programm befinden können, müssen von Ihnen selbst, nach Studium des Druckfehlerteufelchens, korrigiert werden.
Fehlende Hefte erhalten Sie bei: Markt & Technik
Vertrieb 64’er
Hans-Pinsel-Str. 2, 8013 Haar

Ausgabe 11/84
Bestellnummer CB 020
Commodore 64
Turtle Grafik (LdM)	S.48
Schachmeister (AdM)	S.50
SMON (1. Teil)	S.59
Floppykurs	S.117
FPLOT-Befehlserweiterung S.73
Get Koala pic	S.66
Interrupttechnik	S.84
Exsort (UPB)	S.154
Einzeiler	S.158
Simons Basic	S.90
Befehlserweiterung (SB)
VC20
Pseudosprites(8K)	S.76
Laterna Magica (8K)	S.68
Betriebssystem-
Erweiterung (24K >)	S. 88
Supergrafik (GV)	S.71
VC20-Kurs(GV>)	S.126

Ausgabe 10/84
BestellnummerCB 019
Commodore 64
Finanzmathematik (AdM)	S.68
Hypra-Load (LdM)	S.67
Hardcopy
Compact 2	S.86
Hardcopy MPS 801	S.82
Hardcopy VC 1526 neu	S.83
Hardcopy Gemini-10X	S.85
Hardcopy FX-80	S.88
Hardcopy VC 1520 farbig S.84
Apocalypse now	S.106
Supercopy	S.102
Disk-Dump	S.95
Diskettenorganisation	S.97
User-Port-Tastatur	S.92
(UPB)-Maske	S.172
VC20
Epedemic	S.112
Video-Vorspann	S.81

Ausgabe 9/84
Bestellnummer CB 014
Commodore 64
Indexsequentielle Adreßdatei, S. 54 — Spring Vogel (LdM), S. 68 — Orgel/Synthesizer (AdM), S. 70 — Sprite Aid +, S. 89 — Screen Change, S. 94 — List-Stop, S. 97 — Renew, Datawandler, S. 102 — Synthetische suchen, S. 104 — Geregelter Zahlungsverkehr, S. 164
VC20
Schiebung (GV>), S. 77 - Deuzei (8K >), S. 79 - Hardcopy 1520 (GV>), S. 87 - RS232-Interface (GV>), S. 100 — Datawandler (GV>), S. 102

Ausgabe 8/84
Bestellummer CB 013
Commodore 64
Castle of Doom, S. 66 — Pac-Boy, S. 89 — Kopplung, S. 73 — User-Port-Display, S. 97 — RS232-Test, S. 77 - View BAM, S. 99 - Görlitz Hardcopy, S. 83 — Milchvieh, S. 156
VC20
Kudiplo (3K), S. 86 — Print at Restore n (GV), S. 101

Ausgabe 7/84
Bestellnummer CB 017
Commodore 64
Terminalprogramm, S. 24 — Softwarekatalog, S. 72 — Russvok (SB), S. 76 - Crown No. 1, S. 80 — Space Invaders, S. 81 — 1520 Hardcopy, S. 108 — Centronics Interface, S. 110 — Kurvendiskussion, S. 116 — Copy Rel. Files, S. 132 — Autostart, S. 138 — Strubs (OP u. QP), S. 154
VC20
Rätsel, S. 122

Ausgabe 6/84
Commodore 64
Bestellnummer CB 018
Lehrerkalender,S.64-Morsetrainer,S. 72 — Supervoc, S. 69 — Grafische Darst. (SB), S. 82 — Hot Wheels, S. 92
VC 20 Bestellnummer VC 008 Movemaster (8K), S. 78 — Ghost Manor (GV), S.104 - Logic Disass. (3K>),S. 108 - Underground (LdM 16K), S. 120

Ausgabe 5/84
Commodore 64
Bestellnummer CB 016
Adreß- & Telefonregister, S. 64 — Fahrsimulator, S. 82 — Schatzsucher (LdM), S. 90
VC 20 Bestellnummer VC 007
Relative Datei (8K), S. 69 — Schmatzer (GV) S. 76 — 3D-Grafik (8K), S. 78 - Rallye (28K), S. 128 

<aside>
### Bedeutung der Abkürzungen
*LdM - Listing des Monats
*AdM = Anwendung des Monats
*SB = Simons Basic
*GV = Grundversion
*GV> = alle Speicherversionen können verwendet werden (einschließlich GV)
*3K = 3-KByte-Speichererweiterung wird benötigt
*8K> - Speichererweiterung größer als 8 KByte wird benötigt.
</aside>

# Unterprogrammbibliothek Exsort – Sortieren mit Komfort

> Exsort zeichnet sich zum einen durch die Sortiergeschwindigkeit aus. Zum anderen werden sowohl numerische als auch alphanumerische Felder auf- oder absteigend sortiert. Ein weiterer Clou: Ein zweites Feld kann abhängig vom ersten Feld mitsortiert werden.

<aside>

Jeder Programmierer ärgert sich irgendwann einmal über das langsame Basic, das vor allem beim Suchen und Sortieren stört. Gute Sortierroutinen, in Assembler geschrieben, kann nicht jeder entwickeln. Viele Sort-Programme sind aber auch sehr einseitig: Entweder sortieren sie nur aufsteigend oder lediglich alphanumerische Felder. Exsort kann beides und noch mehr.

### Vorteile:

* Zirka zehnmal so schnell wie die schnellste Basic-Version.
* Die Befehle können in jedem Basic-Programm angewendet werden.
* Unterprogramme in Basic, die oft nur ein bestimmtes Feld in einer Richtung sortieren können, entfallen.
* Die Erweiterung belegt keinen Basic-Speicher.
* Beim Sortieren von Strings kommt es nicht zu einem zeitraubenden Garbage-Collect, da die Descriptoren vertauscht werden.
* Ein zweites Feld, das Informationen über das erste Feld enthält, kann mitsortiert werden.
* Das zu sortierende Feld kann numerisch oder alphanumerisch sein.

### Nachteile:

* Es kann nicht mit Exbasic oder Simons Basic zusammen genutzt werden.
* Es kann nicht compiliert werden.

### 1. Befehl »so«

Syntax: so, (feldname), (anfangsindex), (endindex), (sortierungsrichtung)

Dieser Befehl sortiert ein beliebiges eindimensionales Feld innerhalb von zwei Grenzen mit einer vom Benutzer gewählten Sortierungsrichtung.
Beispiel 1:

Das Feld heißt ax$, alphanumerisch aufsteigend sortieren (von Index 100 bis Index 5000).
Befehl: so,ax$,100,5000,l (1 = aufsteigend)
Beispiel 2:

Das Feld heißt qe%, numerisch absteigend sortieren (von Index 0 bis zu dem Index, der in der Variable »en« enthalten ist).
Befehl: so,qe%,0,en,0(0 = absteigend)
Option: Manchmal ist es notwendig, daß Daten, die in einem zweiten Feld vorhanden sind, entsprechend dem ersten Feld sortiert werden.
Syntax: so,(feldname 1), (anfangsindex), (endindex), (sortierungsrichtung), (feldname2)
Beispiel: Das Feld fe$ soll alphanumerisch aufsteigend von Index 0 bis Index 10 sortiert werden. Die Daten in dem Realfeld »nr« sollen entsprechend dem ersten Feld sortiert werden.
Befehl: so,fe$,0,10,1,nr

### 2. Befehl: »se«

Syntax: se,(feldname),(anfangsindex),(endindex),(element)

Dieser Befehl durchsucht ein beliebiges eindimensionales Feld innerhalb von zwei Grenzen nach einem Element.
Beispiel: Es soll die Zahl - 12 in dem Feld rt% von Index 0 bis Index 100 gesucht werden.
Befehl: se,rt%,0,100, - 12

Wenn das Element gefunden wird, enthält die Variable »in« den jeweiligen Index. Wird das Element nicht gefunden, so enthält »in« den Wert -1.

### Fehlermeldungen:

* type mismatch:
Sie versuchten, einen String in einem numerischen Feld zu suchen (oder umgekehrt).
* wrong index:
Beim Suchen war der Anfangsindex größer als der Endindex.
* bad subscript:
Index außerhalb des zulässigen Bereiches.
* only one dimension array:
Sie können nur eindimensionale Felder durchsuchen oder sortieren.
* array not found:
Das Feld war nicht durch einen DIM-Befehl dimensioniert worden.
* wrong array name:
Geben Sie bitte nur die ersten beiden Buchstaben des Feldnamen ein (plus % oder $ wenn nötig). Es wird dann sicher funktionieren.
* wrong sorting direction error:
Sie haben einen anderen Wert als 0 oder 1 als Sortierungsrichtung angegeben.

### Zu den Programmen:

Listing 1

Das Programm »Exsort data« erstellt das Maschinenprogramm aus DATA-Zeilen und speichert es als »Exsort«-Absolutprogramm auf Diskette oder Kassette. Sie können es dann jederzeit durch LOAD »Exsort«, 8,1 absolutladen. Dabei geht ein Basic-Programm nicht verloren (siehe auch Listing 2, Demo-Programm).
Listing 2

Das Programm »Exsort demo« lädt das Absolutprogramm »Exsort« nach und startet es. Danach folgt eine Demonstration der beiden Befehle.

Um »Exsort« zu laden, muß Zeile 0 des Basic-Programms lauten:
0 if k = 0 then k = 1 : load"ex-sort",8,1 (für Diskette)
0 if k = 0 then k = 1 : load"ex-sort",1,1 (für Kassette)

In Zeile 1 muß stehen:
1 sys 49400

Da die Erweiterung nur einmal geladen und gestartet werden muß, kann sie bei späteren Starts des Programms übersprungen werden.

(Marcus Rickert/gk)



## Sortierter Lebenslauf:

Ich wurde am 26.10.1967 in Köln geboren und wohne zur Zeit in Bergisch Gladbach. Ich besuche die elfte Klasse des Johann-Gottfried-Herder-Gymnasiums in Köln-Buchheim. Zum Computern kam ich durch meine Liebe zur Mathematik. Es hat mit kleinen Taschenrechnern angefangen, ging über die ersten programmierbaren Rechner (32,128,512 Schritte) zum ersten Heimcomputer (ZX81) und schließlich zum C 64, den ich im Oktober letzten Jahres als Geburtstagsgeschenk erhielt. Später folgten Floppy und Drucker 1526. Auf dem ZX81 machte ich Bekanntschaft mit Assembler (Z-80) und programmierte kleine Programme, die aber oft nur 100—300 Bytes lang waren. Erst auf dem C 64 begann ich längere Maschinenprogramme zu schreiben, da ich mit meinem Monitor arbeiten konnte.

### Zur Entstehungsgeschichte des Programms:

Ich brauchte für ein Datenverwaltungsprogramm eine Sortierroutine. Ich kannte zu diesem Zeitpunkt nur das BUBBLE-Sort-Verfahren. Auf die Basic-Version programmierte ich eine in Assembler, die zwar bei Dateien unter 50 Einträgen annehmbare Zeiten lieferte, aber bei größeren Datenmengen zeitlich versagte. Dann bekam ich von einem Freund eine Kopie des QUICKSORT-Algorithmus, der schon in Basic sehr schnell ist. Nachdem ich das Sortiersystem begriffen hatte, konnte ich es in Maschinensprache umschreiben und es mit einigen Extras versehen. Das Ergebnis ist mein Programm »Exsort«, das ich inzwischen in mein Datenverwaltungsprogramm integriert habe.

Ich hoffe, daß es vielen Lesern des 64’er-Magazins eine komfortable Hilfe ist.

M. Rickert

</aside>

# Einzeiler-Wettbewerb – die Top 10

Wir wußten gar nicht, was auf uns zukommen sollte, als die Idee zum Einzeiler-Wettbewerb geboren war. Täglich gingen zirka 20 bis 40 Einzeiler bei uns ein. Und diese Flut hat noch kein Ende.

Man glaubt gar nicht, wie interessant manche Einzeiler sind. Hier werden Probleme in eine Zeile gesteckt, bei denen manche Programmierer etliche KByte benötigen. Ein Beispiel ist das Mini-Orgel-Programm. Vielleicht finden Sie, daß hier mit einem Trick gearbeitet wurde, aber Einzeiler ist Einzeiler. Sehr viele Programme lassen sich nur eingeben, wenn die Abkürzungen der Basic-Befehle benutzt werden. Sie stehen im Anhang D Ihres C 64 Handbuches. Doch schauen Sie sich die folgenden Mini-Programme an, von denen man sagen kann: Klein — aber oho! Jedes von ihnen wird deshalb mit 100 Mark honoriert.

### Merge (C 64)

TODO

Möchte man zwei Programme zu einem einzigen zusammenfassen, gab es oft nur eine Möglichkeit: das kürzere an das Ende des längeren zu tippen. Manche längere Hilfsprogramme vollbringen durchaus ein richtiges MERGE. Es geht aber auch ganz kurz.

(Andreas Gast)

### Directory laden, ohne Basic-Programm zu zerstören (C 64/VC 20)

TODO

Zunächst eine Bemerkung zu einem dem Programmierer sehr bekannten Problem. Hat man nun, mit Ach und Krach, ein wichtiges Programm in Basic geschrieben, und man will seine Arbeit mit dem Abspeichern dieses Programmes beenden, so kann es vorkommen, daß man seine freien Disketten nicht wiedererkennt. Also muß man sich die Disketten listen. Mit LOAD”$”,8:LIST würde aber das eigene Basic-Programm gelöscht und die ganze Arbeit wäre umsonst. Wenn man dagegen diese kleine Zeile eingibt, und zwar so, daß sie vor dem eigenen Programm liegt, läßt sich das Directory listen, ohne das im Speicher befindliche Programm zu zerstören.
Zum Starten:
OPEN 1,8,2,”$”:GOTO 0

Beschreibung
TODO

**Weitere Anwendungen:**

Da man alle auf der Diskette befindlichen Programme als sequentielle Datei lesen kann, ist es ohne weiteres möglich, mit dem obigen Programm alle Kommentare, Inhalte von Printanweisungen und Texte des auf der Diskette befindlichen Programms auf den Bildschirm zu bringen. Zum Starten eröffnet man dann die Datei nach dem folgenden Schema:
OPEN 1,8,2,”filename”
und startet das Programm mit GOTO 0.

Wenn die Ausgabe beendet ist, wird mit der RUN/STOP-Taste die Endlosschleife verlassen.

(Reinhard Abdel-Hamid)

### Speicherblockverschiebung — Blitzschnell (C 64)

TODO

Dieses Programm dient zur Übertragung von Speicherblöcken. Die Variablen mit L sind also jeweils das Low-Byte, die mit H das High-Byte der Adresse.
Sie lassen sich für eine Adresse X so berechnen:
AL = X-256*INT(X/256): AH = INT(X/256)

Dieser Einzeiler benützt die Blockverschieberoutine des ROMs. Er ist zum Beispiel nützlich, um das Basic beziehungsweise das Betriebssystem vom ROM ins RAM zu verlegen oder um den Zeichengenerator zu kopieren (!).

(Jens Baas)

DI-AS, ein grafischer Disassembler für C 64

TODO

Der Speicherbereich des C 64 läßt sich in 256 Seiten (Pages) ä 256 Byte aufteilen. DI-AS interpretiert die Speicherinhalte als Bildschirmcode und stellt die 64 KByte des C 64 Seite für Seite auf den Zeilen 7-13 des Bildschirms dar. Die Seitennummer wird am oberen Bildschirmrand angezeigt.
Die Bedienung:

Bevor das Programm geladen und gestartet wird, muß mit SYS64738 unbedingt ein Reset durchgeführt werden, da sonst möglicherweise die Zeiger der Zeropage nicht korrekt initialisiert werden. Es empfiehlt sich, den Bildschirm mit CLR zu löschen, um dieÜbersichtlichkeit zu erhöhen.
Das Programm wird mit RUN gestartet.
Dem Benutzer stehen nun folgende Optionen offen:

1. Mit CURSOR-RIGHT im Speicher vorwärts blättern
2. Mit CURSOR-DOWN im Speicher rückwärts blättern
3. Mit R/S POKE3, NR :CLR: RUN die Seite NR betrachten

Fehlerbehandlung:

Es stehen umfangreiche Fehlerbehandlungen zur Verfügung: Der Versuch, Seiten kleiner als 0 oder größer als 256 anzusehen wird mit »illegal quantity error in 5« quittiert. Mit CLR: RUN wird das Programm normal wiedergestartet.

Beachten Sie sorgfältig die Hinweise zum korrekten Eintippen des Programms!

Gehen Sie die Anwendungsbeispiele durch, um sich mit der Speicheraufteilung Ihres C 64 vertraut zu machen. Da das Programm die 80 Zeichen des Basic-Editors benötigt, muß der Cursor erst eine Zeile hochgefahren werden, bevor diese mit RETURN in den Programmspeicher übernommen wird.
Steuerzeichen:
Reverses s = Home
Reverses r = RVSON
Reverses R = RVSOFF
hinter dem P: Commodore O
die Restlichen: Cursor links, rechts, unten

Anwendungsbeispiele:

Wenn Sie das Programm zum ersten Mal starten, so wird Ihnen wahrscheinlich Seite 170 angezeigt. Drücken Sie solange auf CURSOR-DOWN, bis Sie bei Seite 0 angelangt sind. Falls Sie zu weit gefahren sein sollten, und das Programm den Fehler meldet, so starten Sie es einfach noch einmal. Sie sehen jetzt die Zeropage als Bildschirmcodes. Nun gehen Sie die Seiten Schritt für Schritt durch. Dabei können Sie beobachten:

TODO

*Anmerkung: Manches läßt sich erst entdecken, wenn durch gleichzeitiges Drücken von SHIFT und COMMODORE der Zeichensatz umgeändert wird. Nun nehmen Sie doch einmal Simons Basic oder Spiele und schauen, wo der Text, die Befehle etc. stehen!

(Andreas Carl)

### Scrollen mit bleibendem Text (C 64)

TODO

Dieses kleine Programm bewirkt, daß nicht mehr der gesamte Bildschirm gescrollt wird. Wieviel Zeilen am oberen Rand fest stehen bleiben, bestimmt die Zahl, die Sie in 59639 POKEn. So kann man eine Information, die für ein Programm wichtig ist, auf dem Bildschirm festhalten. Oder die Kopfzeilen einer Tabelle, etc.

Mein Beispiel mit 0 gePOKEt hält eine Zeile fest. Eine 1 würde 2 Zeilen festhalten, etc. Abgestellt wird das Programm einfach durch »POKE 1,55«. Es muß noch darauf hingewiesen werden, daß dieses Programm, obwohl es so kurz ist, sehr lange bis zur ersten Ausführung braucht.

(Peter Eckart)

### Maschinenprogramme abspeichern (C 64)

TODO

Mit folgendem Einzeiler können Maschinen-Programme sehr einfach gespeichert werden: (ohne Basic-Pointer zu verstellen)

Für die Berechnung von LE und HE muß die Endadresse + 1 genommen werden.
Als erstes Beispiel soll ein Programm von 20 000 — 22 000 unter dem Namen »BEISPIEL 1« auf Diskette gespeichert werden.
SYS(57812)"BEISPIEL 1”, 8:POKE193,32:POKE194,78:POKE 174,241:POKE175,85:SYS62957
Als zweites Beispiel soll ein Programm von $C000 — $C37E unter dem Namen ’’BEISPIEL 2” auf Kassette gespeichert werden.
SYS(57812)”BEISPIEL 2",l:POKE193,0:POKE194,192:POKE174, 127:POKE175,195:SYS62957
Falls der Einzeiler infolge eines längeren Programm-Namens zu lang werden sollte, können die POKE-Befehle selbstverständlich durch P, Shift O abgekürzt werden.

(Markus Eicher)

### Das kürzeste Heimcomputerorgelprogramm der Welt (C 64)

TODO

Um in Basic ein Maschinenspracheprogramm einzulesen, schreibt man normalerweise einen Basic-Lader, der in einer FOR/NEXT-Schleife mehrere DATAs einliest und in einen freien Speicherbereich POKEt, um dann das Programm mit SYS zu starten. Da diese Befehle und die DATAs sehr viel Platz benötigen, können so in einer Zeile kaum umfangreiche Programme geschrieben werden. Deshalb haben wir eine Möglichkeit entwickelt, den Basic-Lader zu umgehen: Wir PRIN-Ten das Maschinenspracheprogramm in die erste Bildschirmzeile und starten das Programm mit SYS 1024. Mit diesem Trick ist es uns gelungen, ein Programm von 45 Maschinesprachebytes in einer Basic-Zeile zu laden und zu starten.

Das Programm »MICROSOUND« ist das, unseres Wissens, kürzeste Heimcomputerorgelprogramm der Welt. Es ist 86 Basic-Bytes lang und erzeugt ein Maschinenspracheprogramm von 45 Byte. Davon werden 14 Byte für Grafik-Effekte und 3 Byte für eine Programmende-Abfrage genutzt. Da der Einzeiler bereits beim geringsten Tippfehler nicht mehr richtig funktioniert, haben wir zum Vergleich den normalen Basic-Lader und das Monitor-Listing mit Erklärungen beigefügt.

Das Musik-Programm funktioniert im Wesentlichen dadurch, daß die Zahl der gedrückten Taste (PEEK (203)) mit 63 AND-verknüpft in das Hi-Byte der 1. Stimme des SID 6581 gebracht wird. Der Grafik-Effekt kommt durch einen Vergleich mit dem Rasterregister in 53266 zustande.

MICROSOUND ist für den Commodore C 64 entwickelt. Das Programm wird mit RUN gestartet und mit INST/DEL beendet. Es können ohne weiteres Basic-Zeilen angefügt werden, die dann nach INST/DEL abgearbeitet werden. Wenn das Maschinenspracheprogramm in der erste Zeile nicht mehr sichtbar sein soll, muß vorher die Zeichenfarbe auf die Bildschirmfarbe umgestellt werden. Der Basic-Lader kann auch ohne weiteres auf Bereiche außerhalb des Bildschirms gesetzt werden, indem man die Variable »anfang« entsprechend ändert. Alle Tasten, außer CTRL, COMM., SHIFT und RESTORE sind mit Noten belegt, die überwiegend so angeordnet sind, daß die linken Tasten tiefere Töne spielen als die rechten. Die Funktions- und Cursor-Tasten sind Bässe.

Tips zur Eingabe dieses Programms:

1. Schalten Sie vor der Eingabe durch SHIFT/COMM. auf Kleinschrift.
2. Geben Sie ? statt print und sY4(Pfeil n. oben)5 statt sys1O24 ein und verzichten Sie auf unnötige Leerzeichen.
3. SPACEs bitte ohne COMM. oder SHIFT-Tasten zu drücken eingeben. Ausnahme: Das letzte SPACE muß ein SHIFT/SPA-CE sein.
4. Achten Sie genau auf Groß- und Kleinschreibung! Das Programm kann beim kleinsten Tippfehler abstürzen!

MICROSOUND als Basic-Lader:
10 rem***microsound***
20 anfang = 1024
30 for x = 0 to 44:read a:poke an + x,a:next
40 sys an
100 data 169, 143, 141, 24, 212, 169, 240, 141, 5, 212, 238
110 data 32, 208, 160, 16, 140, 4, 212, 206, 32, 208, 165
120 data 203, 240, 19, 41, 63, 141, 1, 212, 200, 140, 4
130 data 212, 173, 18, 208, 205, 18, 208, 208, 214, 240, 246, 96

Der Basic-Lader hat gegenüber dem Einzeiler den Vorteil, daß man ihn leichter abtippen und ohne weiteres in einen anderen freien RAM-Bereich verlegen kann. Wenn Sie richtig abgetippt haben, müssen beide Programme identisch arbeiten.

Monitor Listing:

0400  lda #$8f;
0402  sta $d418;  Lautstärke(si + 24)
0405  lda #$f0;
0407  sta $d405;  Halten d. Tones (si + 5)
040a  inc $d020;  Rahmenfarbe um 1 erhöhen
040d  ldy #$10;
040f  sty $d404;  Wellenform (si + 4) = 16
0412  dec $d020;  Rahmenfarbe um 1 vermindern
0415  lda $cb;    gedrückte Taste (peek(203))
0417  beq $042c;  wenn $cb = null (inst/del gedrückt) dann Ende
0419  and #$3f;   wenn $cb = 64 dann akku = 0
041b  sta $d401;  akku nach hi-byte von Stimme 1 (si +1)
041e  iny;
041f  sty $d404;  Wellenform(si + 4) = 17
0422  lda $dO12;  Rasterregister(v+18)
0425  cmp $dO12;  (Grafik-Effekt durch registergesteuerte Verzögerung)
0428  bne $0400;
042a  beq $0422;
042c  rts;        Basic-Rücksprung

### Elektronisches Klavier für den VC 20

Das Programm läuft nur auf dem VC 20 und verwandelt den Computer in ein elektronisches Klavier. Die Tasten 1 bis 8 dienen dabei als Klaviatur, auf der man in etwa eine D-Dur Tonleiter spielen kann.

Der Computer gibt beim Niederdrücken der Tasten 1 bis 9 jeweils einen kurzen Ton aus. Die Zahlen 1 bis 8 entsprechen dabei den Tönen einer D-Dur Tonleiter, also d, e, fis, g, a, h, cis, d. Das Betätigen der Taste 9 ergibt zwar auch einen Ton, der sich aber nicht mehr in die Tonleiter einreiht. Andere Tasten haben, außer der RUN/STOP-Taste, keine Funktion.

Basic-Programm:
1 POKE36878,15:GETA$:A=VAL(A$):POKE36876,127+(10-(A>1)+(A>3)+(A>5)*4+(A>6)*3+(A>7)*6)*A:GOTO1

Beschreibung des Programms:
POKE36878,15: Die Lautstärke des VIC-Chips wird gesetzt.
GETA$:A=VAL(A$): Der Variablen A wird ein Wert zwischen 0 bis 9 zugewiesen, je nachdem, welche Taste man drückt. Das Einlesen der Variablen A$ verhindert einen SYNTAX ERROR bei Betätigung einer Buchstabentaste.
POKE36876,...: Die Tonhöhe wird gesetzt, und ein Ton wird ausgegeben, wenn A>0. Die Ausdrücke (A>1), (A>3), und so weiter bewirken eine Anpassung des Tonregisters an die Tonleiter, da sie bei erfüllter Bedingung den Wert —1 ergeben und im anderen Fall 0 sind.
GOTO1: Das Programm wird so lange wiederholt, bis die RUN/STOP-Taste gedrückt wird.

(Joachim Günther)

### Track-Zerstörer: Kopierschutz (C 64/VC 20)

TODO

Diese Zeile produziert auf dem gewünschten Track der Diskette (Variable T) einen READ ERROR 21. Das bedeutet einen relativ sicheren Kopierschutz.

(Jörg Wegmeyer)

# Programmierwettbewerb: Das »intelligente« Programm

> Computerprogramme tun sich ja in der Regel recht schwer, in normaler Umgangssprache eingegebene Sätze zu »verstehen« und womöglich noch folgerichtig zu reagieren. Viele Adventure-Programme zeigen aber zumindest ansatzweise, daß es doch geht.

Warum fällt dem Computer so schwer, was uns Menschen so leichtfällt, nämlich sich einfach zu unterhalten ? Diese Frage ist gleichzeitig die Frage nach dem Wesen der Intelligenz. Eine Forschungsrichtung innerhalb der Informatik beschäftigt sich schon seit Jahren mit der Entwicklung und Erforschung von »Künstlicher Intelligenz«. Wir wollen Sie nun einmal dazu anregen, Programme zu entwickeln, die intelligentes Verhalten in einem gewissen Rahmen simulieren.

## Die Eliza-Story

Im Jahre 1966 entwickelte Joseph Weizenbaum vom Massachusetts Institute of Technology ein Programm namens »Eliza«, das — vereinfacht gesagt — einen Psychoanalytiker simuliert. Der Mensch begibt sich also in der Rolle als Patient an die Tastatur des Eliza-Computers und wird aufgefordert, von seinen Schwierigkeiten zu berichten. Aufgrund der Eingaben gibt Eliza dann durchaus differenzierte Antworten oder stellt auch schon mal eine Zwischenfrage, so daß ein regelrechtes Zwiegespräch zustandekommt (siehe Bild).

Eliza wurde ursprünglich, wie fast alle Programme zur künstlichen Intelligenz, in der Programmiersprache Lisp geschrieben. Eine-Basic-Version von Steve North wurde in den Siebziger Jahren in Creative Computing veröffentlich. Das Bemerkenswerte an dem Eliza-Programm ist seine Einfachheit. Eliza wurde auch nicht als »intelligentes Programm« entwickelt, sondern sollte lediglich bewußt einfach menschliches (Gesprächs-) Verhalten simulieren. Die Eingabe des menschlichen Gesprächspartners wird nach bestimmten Schlüsselwörtern durchsucht, und zu jedem Schlüsselwort ist eine Reihe von möglichen Antworten vorgesehen.

Eliza wurde sehr schnell dadurch bekannt, daß ein großer Teil der Versuchspersonen der festen Überzeugung war, von einem anderen Terminal aus würde tatsächlich ein Psychiater die Antworten geben und dem Programm ihre ganz persönlichen Probleme anvertrauten. Aus diesen Versuchen wurde schließlich die Erkenntnis gezogen, daß die einfache Simulation menschlichen Verhaltens kein ausreichendes Kriterium für Intelligenz ist (so bitter das dem einen öder anderen erscheinen mag), denn Eliza analysiert jain Wirklichkeit nicht die Satzstruktur, sondern akzeptiert auch völligen Unsinn.

Dennoch bleibt unbestreitbar eine gewisse Faszination, wenn man einmal mit Eliza gearbeitet hat. Diese Faszination wollen wir auch ins 64’er Magazin holen. Setzen Sie sich doch einmal an Ihren Schreibtisch und überlegen Sie sich, wie ein Programm funktionieren müßte, mit dem man sich in ganzen Sätzen unterhalten kann.

Um die ganze Angelegenheit nicht zu kompliziert zu machen, braucht das Programm nur einfache deutsche Sätze bearbeiten, das heißt es muß bei Eingabe von Goethes »Faust« nicht unbedingt von sich aus den »Faust II« zitieren. Außerdem können Sie den Themenbereich, in dem das Programm sicher arbeitet, durchaus auf bestimmte Gebiete einschränken. Beispielsweise wäre ein Programm denkbar, das mit dem Menschen über die Vor- und Nachteile von Computern diskutiert. Seien Sie bei der Themenwahl (und beim Programmieren) ruhig kreativ.

Das beste Programm, das sich mit uns Redakteuren unterhalten will, ist uns 1000 Mark wert. Länge und Programmierstil sind unwichtig, entscheidend ist der Effekt.

Senden Sie uns Ihr Programm für den C 64 oder VC 20 auf Diskette oder Kassette zu, und vergessen Sie nicht, eine ausreichende Beschreibung beizufügen. Unsere Adresse ist:

Redaktion 64’er, Stichwort »Programmierwettbewerb: Das »intelligente Programm«, Markt & Technik Verlag AG, Hans-Pinsel-Str. 2, 8013 Haar bei München.

<aside>
Der Beginn einer Sitzung mit »Eliza«

**HI, I AM ELIZA
PLEASE TELL ME YOUR PROBLEM**<br>
I HATE COMPUTERS
**DO COMPUTERS WORRY YOU?**<br>
YES
**ARE YOU SURE?**<br>
I DON’T REALLY KNOW
**DON’T YOU REALLY REALLY KNOW**<br>
HA HA
**SAY, DO YOU HAVE ANY PSYCHOLOGICAL PROBLEMS?**<br>
ELIZA YOU ARE MY PROBLEM
**WHAT MAKES YOU THINK I AM YOUR PROBLEM**<br>
YOUR SYNTAX ERRORS
**WHY ARE YOU CONCERNED ABOUT MY SYNTAX ERRORS**<br>
I HATE THEM
**WHAT DOES THAT SUGGEST TO YOU?**<br>
I DON'T KNOW
**WHY DON'T YOU KNOW**<br>
I CAN’T THINK ABOUT IT
**HOW DO YOU KNOW YOU CAN'T THINK ABOUT IT**<br>
YOU ASK FUNNY QUESTIONS
**WE WERE DISCUSSING YOU - NOT ME!**
</aside>

# Vorschau

## C 64 und Floppy schneller gemacht

Während das HYPRA-LOAD in Ausgabe 10/84 eine reine Software-Lösung war, werden jetzt Systeme vorgestellt, die zusätzlich auch Hardware benötigen. Dabei beschränkt man sich nicht nur darauf, die schnellermachende Software auf EPROMs zu brennen, sondern die Daten werden nun parallel transportiert. Doch wie ist es mit der Kompatibilität bestellt? Ist der Drucker ansprechbar? Lohnt sich also eine Umrüstung?

## Kreuzworträtsel-Wettbewerb

Der Sieger war ziemlich schnell gefunden. Dessen Programm unterschied sich in einigen wesentlichen Merkmalen von den anderen: Es besitzt eine sehr komfortable Wörterauswahl, erstellt eine hervorragende Druckerausgabe und ist auch noch das schnellste Programm gewesen.

## Vergleichstest Joysticks

Mit der Spiele-Welle kam auch die Joystick-Welle. Wir haben die verbreitetsten Joysticks für C 64 und VC 20 getestet. Dieser Test stellt eine wirkliche Hilfe bei der Auswahl eines Joysticks dar.

## Ein neuer Kurs über Musik

Der SID vom C 64 wird oft als der leistungsfähigste Synthesizer-Chip in einem Heimcomputer bezeichnet; wir meinen mit recht. Was liegt also näher als mit einem Kurs zu beginnen, der Ihnen diesen elektronischen Musikus aufschlüsselt.

## Test: Lernsoftware

Sie ist im Kommen, die Software, mit der man mühelos mittels des C 64 Vokabeln pauken, Fremdsprachen und Basic erlernen oder mathematische Probleme lösen kann. Also weg vom Spielen und hin zum spielenden Lernen.

## Der mathematische VC 20

»Mathematical Basic«, eine umfangreiche Basic-Erweiterung für den VC 20 mit über 40 neuen Befehlen und Funktionen wurde diesmal Listing des Monats. Neben zusätzlichen mathematischen Funktionen gibt es eine Reihe von Befehlen zum einfacheren Arbeiten mit der Diskettenstation und weitere Programmierhilfen.

## Das Spiel des Jahres

Es gab 1984 eine wahre Flut an neuen Spielen für den C 64. Ein Spiel hat uns jedoch 1984 besonders beeindruckt, weil es nicht nur für kurze Zeit interessant ist, sondern weil man es um so lieber spielt, je länger man es hat. Warum? — Lassen Sie sich überraschen.

## Synthesizer

Unser Synthesizer zum Abtippen ist kein einfaches Orgelprogramm. Mit ihm lassen sich alle möglichen Einstellungen des Sound-Chips simulieren. Sie können sogar dreistimmig spielen. Ein Programm, das keine Wünsche offen läßt.

## Print 64 — ein außergewöhnliches Interface

Centronics-Schnittstellen für den Commodore 64 gibt es einige auf dem Markt. Auch Print 64 ist sicherlich noch nicht der Weisheit letzter Schluß. Dennoch überrascht es mit einigen erfreulichen Leistungsmerkmalen.

