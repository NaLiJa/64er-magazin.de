# Zuviel Programme, keine Ideen?

In Amerika stöhnen die Propheten (und vor allem die, die sich auf die Voraussagen verließen): Sie haben sich offenbar geirrt. Nach den Schätzungen von Future Computing dürften die Softwareumsätze in diesem Jahr nicht um 100 sondern »nur« um 60 Prozent wachsen. Ein anderes Marktforschungsunternehmen, Creative Strategies, schätzt bei Business Software sogar nur 40 (statt vorher über 50) Prozent — und ist bei Heimcomputer-Software noch skeptischer: Die schlechten Umsätze in diesem Sommer könnten zwar saisonbedingt sein — wahrscheinlich fehle es aber an der richtigen Art von Programmen. Ein Mitarbeiter des Verlags Prentice-Hall wurde noch deutlicher: »Es wird ein Haufen Mist angeboten« erklärte kürzlich Lynn Lumsden »Und so etwas kauft der Kunde einfach nicht mehr«. Es gebe, so meinen die Amerikaner, zu viele schlechte und unter den brauchbaren zu viele »me too«-Programme — an der xten Textverarbeitung oder der yten Dateiverwaltung bestehe kein Bedarf; sie drückten höchstens die Preise. Es fehle an guten und innovativen Produkten.

Ein kleines Beispiel dafür, daß sich der Markt anders entwickelte, als viele dachten, bietet Commodore: Mit Handbüchern wird mehr Umsatz gemacht als mit Spiel-Program-men.

Bei Heimcomputersoftware stimmt leider in vielen Fällen das Verhältnis von Nutzen und Kaufpreis nicht — zumal sich Arbeiten von Hobbyprogrammierern häufig mit dem messen können, was kommerziell vermarktet wird. Der Erfolg unseres Einzeiler-Wettbewerbs zeigt, daß es an Ideen ebensowenig mangelt, wie an der Bereitschaft, Anregungen aufzugreifen. Vielleicht sind die Anwender auf dem richtigen Weg — und nur manche Marketing-Profis auf dem Holzweg.

Michael Pauly, Chefredakteur

# Informationen zur Datenfernübertragung

> Die DFÜ steckt in Deutschland mehr oder weniger noch in den Kinderschuhen. Dennoch oder gerade deshalb halten wir Sie über die neuesten Entwicklungen auf dem laufenden.

## Vertrag zwischen IMCA und Radio Austria steht

Der Vertrag zwischen IMCA, die ein professionelles System in der Nähe von Frankfurt betreiben, und dem österreichischen Staat ist vor kurzem abgeschlossen worden. Das Endprodukt, was sich dann DADAUS-Mailbox nennt, hat dann die inzwischen allgemein üblichen Fähigkeiten: Messages schicken und empfangen, ein Schwarzes Brett, Telex-Zugang und natürlich mehrere Datex-P-An-schlüsse.

## Preiswerter Akustikkoppler für den C 64

Für den C 64 und den VC 20 wird derzeit der billigste 300 Baud-Akustikkoppler überhaupt angeboten. Dieses »Modul« wird unter Umgehung einer V.24-Schnitt-stelle direkt an den Userport des Rechners angesteckt und ist dann sofort betriebsbereit. Es bietet die für Akustikkoppler üblichen Fähigkeiten, wie CALL- und AN-SWER-Modus, sowie eine zusätzliche Testfunktion, die ja nicht jeder Akustikkoppler besitzt. Das Gerät wird ohne jedes Gehäuse geliefert, es fehlen auch die »Gummimuffen«, das heißt Lautsprecher und Mikrofon hängen im Rohzustand von der Platine weg. Mit dem Gerät erhält man noch ein kleines Kommunikationsprogramm in Form eines Listings, mit dem die Sache einwandfrei betrieben werden kann. Der Preis ist wirklich fast schon sensationell: Für das »Modul« 138 oder das Ganze als Bausatz für 88 Mark. Zusätzlich werden noch angeboten: Ein Terminalprogramm mit Up- und Downloading inklusive Diskette für 25 Mark und ein kleines Interface, das dann die automatische Telefonwahl ermöglicht für 39 Mark. Das Gerät hat keine FTZ-Zulassung und darf nicht am Telefonnetz der Deutschen Bundespost betrieben werden. Die Adresse: Fotoelektronik Dipl.-Ing. Immo Drust, Landwehrstr. 5, 6100 Darmstadt.

Der Vertrieb läuft nur über den Versand, Bezahlung wie üblich per Nachnahme oder V-Scheck. Der Computertyp muß angegeben werden (C 64 oder VC 20). Noch ein Tip: brauchbare »Gummimuffen« erhält man in Sanitärfachgeschäften, die dort als Installationszubehör für die Toilette geführt werden.

## RMI und Software Express arbeiten zusammen

Die RMI-Nachrichten GmbH in Aachen wird für die Firma Software-Express in Duisburg und Bocholt jeweils acht Mailboxen einrichten. Auch ist der Datex-P-Antrag für einen Hauptanschluß bereits gestellt. Diese Systeme sollen dann hauptsächlich für die Produkte des Software-Express werben. Damit wäre dann langsam die Mailbox als Werbemedium interessant geworden, da man auch als »Fremdfirma« dort Platz mieten kann.

## RMI expandiert und verlangt Gebühren

Seit neuestem kann man die RMI-Mailbox in Aachen, erreichbar über Datex-P-NUA 44241040341, nur noch vernünftig nutzen, wenn man monatlich 10 Mark von seinem Konto abbuchen läßt. Dazu hat Sysop Rupert Mohr einen Verein gegründet, der sich AMDAT e.V. nennt. Zahlende Mitglieder heißen dann assoziierte Benutzer. Begründet wird die Gebühr von 10 Mark mit steigenden Kosten. So hat man dann Zugang auf das Telex-Netz und längerfristig sind mehrere Datex-P Anschlüsse geplant. Im Großen und Ganzen ist dann das RMI-Netz eine preiswerte Möglichkeit von Hobby-DFÜlern ein semiprofessionelles System zu benutzen.

## Btx und Datenschutz

Btx wird (hoffentlich) bald auch für die C 64 Anwender interessant, da das Btx-Steckmodul für den C 64 allmählich auf den Markt kommen soll. Dieses Modul soll dann für zirka 150 Mark erhältlich sein. Um letztendlich Btx-Benutzer über den C 64 zu sein, ist aber noch ein Loewe oder Blaupunkt-Fernseher mit CEPT-Dekoder notwendig. Worum es bei Btx im Groben geht dürfte inzwischen fast jedem bekannt sein: Die Anbieter bieten ihre »Seiten« an, das heißt sie stellen eine bestimmte Information, mit Grafik und Farbe versteht sich, gegen Gebühren zur Verfügung.

Diese Seiten können alles mögliche beinhalten, zum Beispiel den Wetterbericht, lokale Informationen (Veranstaltungen etc.) oder auch aktuelle Nachrichten einer Zeitungsredaktion. Der Benutzer, also der, der dann mit seinem C 64 und Btx-Fernse-her daheim sitzt und gebührenpflichtige Seiten abruft, muß auch dafür zahlen. Diese Gebühren werden dann praktisch auf die normale Telefonrechnung mit aufgeschlagen. Jetzt kommt — in Bezug auf den Datenschutz — der Haken an der Sache: Wer wann welche Seiten sich wie lange angeschaut hat, muß — aus Abrechnungsgründen — erfaßt werden, ganz klar. Nun ist es aber nicht nur theoretisch möglich Persönlichkeitsprofile zu erstellen, das heißt man kann aufgrund der im Btx-Rechner gespeicherten Daten ziemlich genau feststellen, welche Vorliebe und welche Abneigungen ein bestimmter Benutzer hat. Bei der Benutzung einer »Telezeitung« etwa würde auch die Zeit abrufbar sein, die sich ein Benutzer zum Beispiel im Wirtschaftsteil aufgehalten hat, und daraus könnte man auf die Verständnisfähigkeit der Person in bestimmten Gebieten schließen. Das »Bild« oder Persönlichkeitsprofil, das so von jedem Btx-Benutzer gemacht werden kann, könnte theoretisch irgendwie ausgenutzt werden. Das alles wäre überhaupt kein Problem, wenn die Abrechnungsdaten unter Aufsicht regelmäßig gelöscht würden, und genau das wird bis jetzt — obwohl vorher vereinbart — von der Bundespost abgelehnt. Klar, daß die Datenschutzbeauftragten der Länder ihre Kritik äußern. Es bleibt nur noch die Frage nach dem Grund dieser Verweigerung.

## Elektronische Mitfahrerzentrale in Hamburg

Der Chaos Computer Club in Hamburg will seine elektronische Mitfahrerzentrale auf einen C 64 mit Floppy realisieren. Bei diesem System, dessen Benutzung absolut gebührenfrei sein soll, kann dann jeder, der eine Autofahrt plant, sich — natürlich nach Städten sortiert — unter Angabe seiner Telefonnummer und Adresse eintragen. Genauso können dann die Mitfahrer die Angebote abrufen und sich dann mit den Fahrern telefonisch in Verbindung setzen. Die Wahl eines C 64 bei diesem System macht das günstige Preis-Leistungs-Verhältnis des C 64 deutlich. Übrigens: Der Chaos Computer Club hofft noch auf Spenden, die die finzianziel-len Aufwendungen etwas mildern sollen. Die Adresse: CCC c/o Schwarzmarkt Bundesstr. 9, 2000 Hamburg 13

(Thomas Obermair/aa)

## C 64 Interface für Centronics-Drucker

Rolf Rocke Computer bietet mit dem »Print 64« ein prozessorgesteuertes Drucker-Interface für Anspruchsvolle. Nachahmenswert ist ein auf der mitgelieferten Diskette befindlicher Druckerkurs, der den Umgang mit der Schnittstelle und den gängigsten Matrixdruckern wie Epson, Star oder Sekonic für den Anfänger anschaulich erläutert.

Außergewöhnlich ist auch die Möglichkeit der Darstellung von Farben (auf Schwarz-Weiß-Druckern) durch geeignete Wahl von zugeordneten Graustufen beim Druck von Mehrfarbgrafiken. Mit fünf unterschiedlichen Tönungen bleiben bei Mehrfarbbildern (die vom Koalapainter oder Paint Magic erstellt sein können) die Nuancen des Bildes in der Hardcopy erhalten. »Print 64» soll alle gängigen Textverarbeitungsprogramme für den C 64 unterstützen. Das heißt, auch Umlaute, Fettschrift oder Unterstreichen werden getreu wiedergegeben. Programmlistings werden mit allen Grafik- und Steuerzeichen in Grafik-oder Groß/Kleinschrift-Modus ausgeben. Der Ausdruck des Bildschirms ist in verschiedenen Varianten möglich. Der Textbildschirm kann in einfacher oder doppelter Dichte ausgegeben werden. Bilder in hochauflösender Grafik benötigen für die Übertragung sowohl in normaler als auch in doppelter Dichte nur zirka 70 Sekunden (FX 80). Durch die Wahl der Bildbreite über das gesamte A4-Format ergibt sich ein Verhältnis von Höhe zu Breite die auch die Darstellung von Kreisen orginalge-treu zuläßt. Die Sekundäradressen 3, 4, 6, 8 und 9 wurden für selbst zu erstellende Hardcopy-Routinen reserviert. Das Centronics-Interface mit der Diskette wird voraussichtlich 300 Mark kosten. (aa)

Info: Rolf Rocke Computer, Auestraße 1, 5090 Leverkusen 3, Tel.: 0 2171-26 24

## Deutscher Zeichensatz für 626 und MPS 802

Das Ingenieurbüro Hollmann in Hamburg bietet für die Commodore-Drucker 1526 und MPS 802 deutsche Zeichensätze im EPROM an. Die Zeichensätze sind auf mehrere zum C 64 erhältliche professionelle Textprogramme abgestimmt.

Zur Zeit sind deutsche Zeichensätze für SM-Text und Vizawrite verfügbar. In Vorbereitung sind Zeichensätze für Vizawrite-Benutzer in der Schweiz sowie C 64-DIN-Zei-chensatz und andere Spezialzeichensätze. Die Zeichensätze können direkt im Drucker betrieben werden. Allerdings ist erst durch die Verwendung einer Umschaltplatine (Multifont, vom selben Hersteller) volle Kompatibilität gewährleistet (Textverarbeitung und Ba-sic/Grafik-Listings). Auf der Einbauplatine lassen sich bis zu vier Zeichensätze/Be-triebssysteme (im EPROM) unterbringen, die von zwei außenliegenden Schaltern ausgewählt werden. Die Zeichensätze kosten jeweils 79 Mark, die Umschaltplatine 90 Mark.

# Commodore Fachausstellung

> Commodore ist wohl der einzige Computer-Hersteller der in Deutschland eine eigene Fachmesse veranstaltet. Auf der diesjährigen vierten internationalen Commodore Fachausteilung (CFA) in Frankfurt, gab es neben Attbewährtem einige Überraschungen. Software für den Plus/4, grafisch gestaltete Diskettenhüllen, Video-Digitizer, ein Joystick ohne Boden, Musikprogramme und Keyboards, Lernsoftware oder eine schnellere 1541 sind nur einige Beispiele. Doch eins war besonders klar zu erkennen: Der C 64 dominierte an allen Ecken und Enden.

Weniger die Software, sondern mehr die Datenträger erregten großes Interesse auf der CFA in Frankfurt. Bunte Disketten waren »in«, in jeder erdenklichen Farbe oder Farbkombination. Da diese Disketten auch nicht sehr viel teurer waren als normale Disketten, fanden sie natürlich reißenden Absatz. Besonders gefragt waren Memron-Disketten, die es mit allen möglichen abgebildeten Motiven gab: Weintrauben, golden mit schwarzen Streifen, bunte Schrift »Memo«, undsoweiter. Einen besonderen Leckerbissen für Händler und private Großabnehemer bietet Lucius-Computer-Program-me: Bei einer Abnahme von über 1000 Stück kann man sich sein eigenes Motiv auf die Diskettenhüllen drucken lassen.

## Absteiger und Renner

Der VC 20 scheint nun endgültig auf dem absteigenden Ast zu sein. Ein Vertreter einer englischen Softwarefirma wunderte sich, warum in Deutschland überhaupt noch Software für den VC 20 angeboten wird. Selbst Commodore verzichtete darauf, irgend etwas zu zeigen, das mit dem VC 20 zu tun gehabt hätte — kein Wunder, denn der C 16 soll ja schließlich als Nachfolger für den VC 20 dessen Rolle übernehmen. Der Plus/4, jetzt mit vier fest eingebauten Programmen, war ebenfalls von Menschentrauben umlagert. Bei Commodore hieß es, man könne gegen Ende des Jahres mit der Auslieferung des C 16 und des Plus/4 rechnen.

Die größeren Commodore-Computer waren hauptsächlich mit Steuerungssoftware, Textverarbeitungs- und Anwendungsprogrammen vertreten. Besonders zu erwähnen ist die Textverarbeitung mit vollautomatischer Silbentrennung für die Commodore Serie 600/700 und 8000 von Hard + Soft in Bayreuth.

Auch der neue Commodore PC, der kompatibel zum IBM PC ist, wurde sehr intensiv auf dem Commodore-Stand vorgeführt. 
Der eigentliche Favorit aber war — wie immer — der C 64.

Das Hauptangebot bei der Software bestand in Spielen, bei denen es einige Neuvorstellungen gab.

Ariola führte das Ballerspiel »River Raid« vor. Obwohl Ariolasoft gute neue Programme hat (Seven Cities of Gold, Archon II, Realm of Impossibility), konnten diese leider nicht gezeigt werden. Sie waren wohl aus Versehen von der Hifi-Video-Messe nicht zur Commodore Fachausstellung (CFA) nach Frankfurt, sondern zurück zu Ariola nach München geschickt worden.

Kingsoft stellte zwei neue Spiele vor: »Tom« und »Zaga«, beide durch gute Grafik und günstigen Preis (39 Mark auf Diskette) überzeugend. »Tom« ist ein Spiel, das man zu den intelligenten »Irrgar-ten-Hüpf-und-Kletterspielen« rechnen kann. »Zaga« ist ein Hubschrauberspiel, das sehr viel Ähnlichkeit zum bekannten »Zaxxon« aufzeigt. Beide Spiele sind voraussichtlich bei Erscheinen dieser Ausgabe schon lieferbar.

Die englische Softwarefirma Anirog brachte gleich drei neue Spiele auf den Markt: »The Soul Gem of Martek«, »PG Fuzz« und »The Catacombs«, die ebenfalls durch Leistung und einem Preis von weniger als 40 Mark beeindrucken und ab Oktober über Kingsoft und Micro-Händler beziehbar sein werden. Bei diesen Spielen zeigte sich schon deutlich der Trend weg von den Schießspielen hin zu den intelligenteren Programmen.

Anspruchslos aber billig waren die Spiele von Bubble Bus: Messepreis 20 Mark das Stück, und das war für die Qualität der Spiele noch zu hoch.

PSS-Software aus England stellte das neue Taktikspiel »Battle for Midway« vor, das aus 90% Taktik und 10% Action (Kampf nur bei Konfrontation mit feindlichen Truppen) besteht.

Bei Lucius-Computer-Programme waren zwei Keyboards zu bewundern: Das Colortone-Sensortasten-Key-board und das Colortone-Professional-Keyboard. Mit dem Sensortasten-Keyboard wird eine ausgezeichnete Musiksoftware geliefert, die wegen Ihrer einfachen Handhabung speziell für Musikanfänger geeignet ist. Zum Professional-Keyboard wird entsprechende Professional-Software geliefert, die von den musikalischen Möglichkeiten her fast mit Musi-calc konkurrieren kann. Beide Keyboards sind außerdem noch passend zum Synthesizer-Softwarepaket »Musicalc«, welches ebenfalls von Lucius vertrieben wird.

Das Wersi-Keyboard wurde bereits in der letzen Ausgabe vorgestellt. Wersi setzt mittlerweile den C 64 auch zur Steuerung ihrer großen Heimorgeln ein.

Interface Age zeigte das »Extended Graphik System«, ein gutes Grafik-Utility, über das wir in diesem Heft auch näher berichten.

Handic-Software bot keine neuen Produkte für den C 64, zeigte aber überraschenderweise schon Spiele für den Plus/4: Drei Textadventures, die an die Abenteuerspiele von Scott Adams angelehnt sind, sowie ein einfaches Datenverwaltungsprogramm.

Auch an Hardware wurden einige interessante Neuigkeiten gezeigt, wenn auch die Erwartungen etwas höher ausgefallen waren. Hallberg Elektronik stellte eine 128 KByte-EPROM-Platine für den C 64 vor. Sie ist per Software ein-und ausschaltbar. Damit ist es nun möglich, eine ganze Reihe von verschiedenen Programmen auf EPROM zu brennen und zu nutzen, ohne jedesmal von Diskette zu laden. Sofort beim Einschalten des C 64 stehen alle Programme zur Verfügung. Durch einen POKE-Befehl oder mit den Funktionstasten können Sie das gewünschte Programm aktivieren. Wenn die Karte ausgeschaltet ist, belegt sie weder Speicherplatz noch stört sonst irgendwie. Es können EPROM-Typen von 4 bis 16 KByte eingesteckt werden. Sehr interessant war ein völlig neuartiger Joystick, ebenfalls von Hallberg. Bei diesem Joystick scheint der untere Teil zu fehlen. Er besteht also nur aus dem Griff mit den Feuerknöpfen. Das Prinzip ist einfach und genial zugleich: es wird nach den Gesetzen der Trägheit mit Quecksilber gearbeitet. Zur Steuerung benötigt man nur eine Hand, die andere bleibt frei.

Es wird aber bereits an einer Version gearbeitet, die ähnlich Navigationsinstrumenten in der Schiff- und Luftfahrt mit Kreisel arbeiten, so daß auch Relativ-Be-wegungen möglich sind. Das heißt, daß die Bewegung des Cursors (des Sprites, etc.) aufhört, wenn auch der Joystick still steht.

Michael Lamm, ein Hardware-Entwickler, stellte einen neuen IEEE-Bus vor. Durch dessen externes, erweitertes Betriebssystem wird kein Speicherplatz verbraucht. Im Gegensatz zu vielen herkömmlichen IEEE-Bussen sind die RS232-Rou-tinen noch voll erhalten. Die serielle Schnittstelle des C 64 kann ebenfalls benutzt werden. Die Karte wird von Jann-Datentechnik Berlin vertrieben.

Print-Technik und Roland Köhler stellten einen Digitizer vor. Mit Ihnen kann ein von einem Video-Recorder beziehungsweise einer Video-Kamera aufgenommenes Bild in digitale Informationen umgewandelt werden. Diese Bilder lassen sich auf Diskette speichern und von Grafikdruckern ausgeben. Auch Schwingungen, zum Beispiel Töne über ein Mikrofon aufgenommen, können digitalisiert und als grafische Darstellung der Schwingungen verarbeitet werden.

International Computing aus Holland präsentierte eine wesentlich schnellere VC 1541, bei der alle Datenübertragungen beschleunigt werden. Zu diesem Zweck sind einige Umbauten am C 64 und an der Floppy notwendig. Die Kompatibilität bleibt jedoch voll erhalten. Es wird zusätzlich zu dem seriellen Port eine parallele Datenübertragung installiert. Mit einem Schalter kann umgeschaltet werden. Es ist auch möglich, ein EPROM mit Btx-Software zu integrieren. Ein weiterer Schalter läßt auch die Benutzung der Diskettenrückseite zu, ohne eine zusätzliche Kerbe in die Diskette zu stanzen. Die junge Firma steht gerade in Verhandlungen mit deutschen Firmen, die den Vertrieb und den Service übernehmen sollen. Die 64’er Redaktion fand die Demonstration so interessant, daß ein ausführlicher Test vorbereitet wird.

Wer seinen SX 64 mit einem Doppellaufwerk ausstatten will, kann dies bei RMC für 2 500 Mark machen lassen. Dort wird die Micropower 2000 zerlegt und in den SX 64 eingebaut.

## Datenfernübertragung

Am Stand von Software Express wurde DFÜ »zum Anfassen« präsentiert. Über einige Telefonleitungen konnten die Messebesucher Akustikkoppler und Treibersoftware (Teleterm für 198 Mark) ausprobieren. Für diejenigen, die keinen Platz am Computer erreichten, wurde das, was auf einem Monitor zu sehen war, auf eine 2 x 3 Meter große Leuchtdiodenwand übertragen.

Als Renner stellte sich der Akustikkoppler AK 300 (Vertrieb Software Express: Preis 548 Mark) heraus. Er war nach kurzer Zeit vergriffen.

Auch Roboter waren auf diesem Stand zu sehen. Einer von ihnen machte aus einem Akustikkoppler ein »Modem«, in dem er das automatische Abheben des Telefonhörers übernahm.

Sehr interessant war der Workshop vom »Commodo-re-Guru« Jim Butterfield über die neuen Computer Plus/4, C 16 und C116. Ein Interview mit Jim Butterfield zu diesem und noch anderen Themen wird in der nächsten Ausgabe folgen.

Nach langer Zeit haben die deutschen Softwarehersteller endlich die Lernsoftware entdeckt. Die ersten Ergebnisse, die auf der Messe vorgestellt wurden, konnten uns aber nicht in jedem Fall überzeugen. Man wird noch lernen müssen, daß schnelles Reagieren auf einen neuen Markt, nicht auf Kosten der Qualität gehen darf.

Das Produktspektrum konnte sich allerdings schon sehen lassen.

An die Jüngsten unter den Computer-Benutzern wendet sich der Otto Maier Verlag (Ravensburger) mit Spielen, die das gestalterische Denken entwickeln und fördern sollen. Die Altersgruppen, auf die diese Programme abgestimmt sind, liegen zwischen fünf und zehn Jahren. Die Preise für die neuen Produkte liegen zwischen 88 und 98 Mark.

Mathematikprogramme wurden von zwei Anbietern vorgestellt. DerWestermann Verlag beschäftigte sich hauptsächlich mit den Grundrechenarten. Weiterhin wird ein Programm zum Rechtschreibtraining angeboten. Die Produktpalette umfaßt zur Zeit elf Programme, soll aber in Kürze auf 28 Programme erweitert werden. Die Preise hierfür liegen zwischen 39 und 89 Mark. Das Mathematikprogramm ALI von Heureka-Software ist auf die Schüler der Klasse fünf bis hin zur Oberstufe abgestimmt.

Das größte Angebot ist bei den Vokabellernprogrammen zu finden.

Die Langenscheidt Verlagsgruppe bietet zur Zeit vier Programme für die englische Sprache für je 80 Mark. Die Produktpalette soll in Zukunft erheblich erweitert werden. Also nach dem reinen Übersetzungscomputer von Langenscheidt nun auch Sprachprogramme für Heimcomputer. SM Software hat in seinem Angebot drei Englisch-, zwei Französisch-, einen Spanisch- und einen Italienischkurs. Diese Kurse kosten je 198 Mark. Ein Vokabelprogramm für Latein wird vom Markt&Technik Verlag angeboten.

Einige der Vokabellernprogramme enthalten kleine Spiele. Hat man eine bestimmte Anzahl von Vokabeln gewußt, so darf man als Belohnung einmal spielen.

Ein Lernprogramm ganz anderer Art wurde von Ho-mesoft vorgestellt. Diese Kurse sollen die Computerhändler in die Lage versetzen, ihren Kunden ausreichend Hilfestellung zu geben. Der Einsteigerkurs von 4 x 2 Stunden kostet 98 Mark, der Preis des Basic-Fortge-schrittenenkurses liegt bei 198 Mark. Beide Preise sind inklusive komplettem Unterrichtsmaterials.

(aa/gk/rg/M. Kohlen)

# Leserforum

## MPS 801: Verständnis für den Handel

**Zum Artikel MPS 801 in Ausgabe 8/84**

Ich arbeite als Verkaufsberater und Filialleiter in einem Computershop einer Spezialfirma in einem Warenhaus (eingemietet).

Zu dem »...ist bestellt« und »...ist momentan nicht vorrätig« möchte ich Ihnen folgendes mitteilen:

1) Stimmt, kommt vor.
2) Sobald etwas angekündigt ist, wird es bestellt!
3) Die Auslieferung eines Artikels erfolgt meist einige Monate später als die Werbung dafür!
4) Wir können nicht hexen!
5) Die Nachlieferfrist beträgt je nach Hersteller und Artikel ebenfalls bis zu 2 Monaten! (Wenn überhaupt lieferbar!)
6) Suchen Sie den Fehler bezüglich Liefersituation nicht immer im Handel; reklamieren Sie einmal beim Hersteller oder Importeur!
7) Beim momentanen Preissturz kann es sich keine (Klein-) Firma mehr leisten, ein großes Lager zu halten, will sie überleben!
8) Ein wirkliches Fachgeschäft kann bald nicht mehr bestehen, weil die Billigdiscounter die Preise zerstören! (Gutes Personal aus der Computerbranche ist teuer und selten!) Bei uns sagt man »den Bazen und das Weggli kann man nicht haben!« dies heißt: Das Geld und das Brötchen kann man nicht haben! Übrigens: Software wie div. Spiele können wir wegen Raubkopien meistens nur noch auf Bestellung liefern. Bei uns kauft beinahe niemand mehr Software (Anwenderprogramme und Spiele).

Das Beste: Kommt doch einer und fragt: »Haben Sie auch Spiele?« Ich: »Ja, dieses Regal ist nur für den C 64.« Er: »Nein nein, nicht zum Kaufen, gratis, zum Tauschen!«

Ich hoffe, Sie haben nun auch ein wenig Verständnis für die Seite des Handels gefunden.

Alfred Theiler

## Fragen Sie doch!

Selbst bei sorgfältiger Lektüre von Handbüchern und
Programmbeschreibungen bleiben beim Anwender immer wieder Fragen offen. Viel mehr Fragen ergeben sich bei Computer-Interessenten, die noch keine festen Kontakte zu Händlern, Herstellern oder Computerclubs haben. Sie können der Redaktion Ihre Fragen schreiben oder Probleme schildern (am einfachsten auf der beigehefteten Karte). Wir veranlassen, daß die Fragen von einem Fachmann beantwortet werden. Allgemein interessierende Fragen und Antworten werden veröffentlicht.

## Ziemlich übertrieben!

Im Bericht über die Customer Electronics Show in Chicago in Ausgabe 8/84, Seite 13 steht:

»Diese Musikprogramme sind mittlerweile so ausgereift, daß fast kein Unterschied mehr zu einem digitalen Synthesizer bemerkbar ist.«

Ich halte diesen Absatz für ziemlich übertrieben, ja eigentlich ist dieser sogar falsch! Denn keine noch so ausgefeilte Programmierung macht aus dem digital gesteuerten, aber ansonsten analogen SID des C 64 einen digitalen Sythesizer ä la Emulator, Fairlight oder PPG.

Als einziger Vergleichsmaßstab käme eventuell die Bedienungsfreundlichkeit in Frage, mehr aber auch nicht. Auch hier gilt: Hardware kann nicht durch noch so gute Software ersetzt werden.

Abgesehen vom Einsatz als preiswerter Sprachgenerator oder der Eignung zum Heranführen an eine einfache Synthesizer-Programmierung, sollte der SID das bleiben, was er ist, nämlich eine nicht unerhebliche Aufwertung von Computerspielen.

Es ist schade, daß die Begriffe analoge- und digitale Synthesizer in einen Topf geworfen werden, obwohl sich beide Systeme doch ziemlich unterscheiden. Ich möchte kurz folgende Unterscheidungsmöglichkeit aufzeigen:

Bei analogen Synthesizern wird zunächst eine Grundschwingung erzeugt (VCO, DCO). Diese wird über einen steuerbaren Filter (VCF) geleitet und steht hinter einem ebenfalls steuerbaren Verstärker (VCA) zur Verfügung. Anders bei digitalen Synthezisern. Hier wird das Ausgangssignal direkt erzeugt und über D-A-Wandler ausgegeben. So ist es sicherlich zu verstehen, daß Naturklang-speicher-, FM-Synthese- oder rechnende Klang-Parameter-Systeme nicht mit dem Synthesizer-Chip im C 64 zu vergleichen sind. Meiner Ansicht nach wird der SID gelegentlich überbewertet. Es soll allerdings nicht unerwähnt bleiben, daß dieser Baustein einen zunehmenden Kreis von Home-Computer-An-wendern spielerisch an die Musik heranführen kann.

Markus Cohnen
Mitglied im Arbeitskreis Musikelektronik (AME)

## VC 20 als 64’er?

Kann man auf dem VC 20 mit 64 KByte Erweiterung auch Programme für den C 64 laufen lassen?

Jan Wilbert

Leider nein, die Hardware beider Computer ist völlig unterschiedlich. Nur Programme ohne PEEK, POKE, SYS und USR laufen einwandfrei.

## Modulprogramme laden?

Kann man beim VC 20 Modulprogramme von Diskette laden?

Andreas Hübert

Ja, mit LOAD »NAME«, 8.1. Sie benötigen allerdings RAM im Bereich $A000-$BFFF.

## Nochmal MPS 801: Es geht auch einfacher

In bezug auf den Artikel über den MPS 801-Drucker in Ausgabe 8/84 möchte ich Ihnen mitteilen, daß man sich bloß kein komplett neues Farbband kaufen sollte. Den Farbtank kann man auf einfachste Weise mit schwarzer Stempelfarbe nachfüllen! Erst bei starker mechanischer Abnutzung des Farbbandes würde ich ein neues Band empfehlen, da dieses recht teuer ist (25 Mark).

Etwaige Bedenken einer Verstopfung des Druckkopfes sind unbegründet. Ich habe den Tank schon öfter nachgefüllt — ohne Probleme.
Übrigens:
Sperrschrift und Reversschrift sind auch im Direktmodus möglich:
OPEN 1,4
PRINT#1, CHR$(14) (bzw. 18 für rvs)
CMD 1
LIST
PRINT#1, CHR$(15) (Normalschrift)
CLOSE 1

Hartmut Wenzel

## Wollen Sie antworten?

Wir veröffentlichen auf dieser Seite auch Fragen, die sich nicht ohne weiteres anhand eines gutes Archivs oder aufgrund der Sachkunde eines Herstellers beziehungsweise Programmierers beantworten lassen. Das ist vor allem der Fall, wenn es um bestimmte Erfahrungen* geht oder um die Suche nach speziellen Programmen beziehungsweise Produkten. Wenn Sie eine Antwort auf eine hier veröffentlichte Frage wissen - oder eine andere, bessere Antwort als die hier gelesene - dann schreiben Sie uns doch. Die Antworten werden wir in einer der nächsten Ausgaben publizieren. Bei Bedarf stellen wir auch den Kontakt zwischen Lesern her.

# MSD-Super-Drisk-Drive

> Bei den Commodore-kompatiblen Einzellaufwerken gibt es inzwischen einige Alternativen. Jetzt gerät allmählich auch der Markt für Doppellaufwerke in Bewegung.

Das »MSD Super Disk Drive«, kurz SD-2, kommt aus den USA und wird durchaus höheren Ansprüchen gerecht.

Das SD-2 kann zwischen dem C-1541-Laufwerk und dem CBM 4040 angesiedelt werden.

Denn die 1541 bietet für eine ganze Menge Anwender zu wenig Leistung, die großen CBM-Floppys der 8000er-Serie sind ganz und gar nicht kompatibel, und das CBM 4040-Doppellaufwerk ist viel zu teuer (neu 2500 bis 3000 Mark).

## Komfort-Laufwerk mit guter Optik

Das Gerät überrascht angenehm: Statt einer grauen 1541-Plastik findet man ein sehr solides weißes Metallgehäuse vor, in dem zwei Laufwerke platzsparend verteilt sind. Das MSD-SD-2 nimmt mit beiden Laufwerken nicht sehr viel mehr Platz weg als die C 1541.

Die Disketten werden senkrecht in die Laufwerke eingeführt. Für jedes Laufwerk wird der Betriebszustand einzeln angezeigt. Pro Laufwerk existiert ein Fehlerlämpchen und ein Betriebslämpchen.

Auf der Rückseite des Gerätes befinden sich zwei serielle Anschlüsse und ein paralleler IEEE-488-Bus, der Netzanschluß, ein Ein/Aus-Schalter sowie eine gut zugängliche Sicherung.

## Nicht schnell wie der Wind, aber flink wie ein Wiesel

Ein gutes Argument für den Kauf des MSD-Doppellaufwerks ist die Geschwindigkeit, die sich je nach Schnittstelle richtet.

Wählt man die serielle Schnittstelle, so ist die Geschwindigkeit annähernd die gleiche wie bei der 1541 (sofern man hier von Geschwindigkeit reden kann), sogar minimal langsamer.

Lohnender ist allerdings der Anschluß über den IEC-Bus, zu dem man allerdings ein spezielles Interface kaufen muß. Das Laufwerk wurde mit den IEEE-488-Interfaces von Telesys, Dynamics und RMC-Sy-stems getestet.

Die Geschwindigkeitsvergleichstests wurden anhand eines 153 Block langen Files durchgeführt (siehe Tabelle).

Das Kopieren einer ganzen Disk benötigt auf dem MSD-Floppy nur etwa knapp 2 Minuten: Einfach Original- und Zieldiskette in die Drives und Backup-Befehl ans Floppy senden. Schade, daß man mit einem Einzellaufwerk wie der 1541 nicht so einfache Befehle wie Backup (”Dl = 0”) oder Copy ("C0 = l”) benutzen kann.

## Kompatibel muß es sein

Obwohl die MSD-Floppy also nicht die gleiche Geschwindigkeit herzaubert wie das CBM-4040-Dop-pellaufwerk (über IEC-Bus zirka fünfmal schneller), ist das SD-2 mit dem Geschwindigkeitsfaktor 2,3 mal schneller und im Hinblick auf die Kompatibilität der Software mehr zu empfehlen.

Diese Unterschiede lassen sich mit den Eigenarten der Floppy-Betriebssysteme erklären, die mit der 1541 natürlich nicht identisch sind und aus Copyright-Gründen auch gar nicht sein dürfen.

Das MSD-Laufwerk ist mit seriellem Kabel zu zirka 90% der Software kompatibel, sogar der doch etwas kompliziertere Disketten-Kopier-schutz von Synapse-Software lief darauf. Bei der Wahl der parallelen Schnittstelle sieht die Sache leider etwas düsterer aus:
Nur etwa 75% der kommerziellen, kopiergeschützten Software lief darauf.
Hätte MSD nicht aus den Fehlern der alten CBM-4040-Floppy gelernt, wäre die Kompatibilität zum C-1541-Einzellaufwerk gänzlich in den Wind zu schreiben gewesen. Bei vielen Software-Produkten wird keine Laufwerksnummer 0 oder 1 angegeben. Das 4040-Floppy hat die Angewohnheit, dabei immer auf beide Laufwerke zuzugreifen und Programme wie zum Beispiel die Adventurespiele von Infocom nur zu starten, wenn in beiden Laufwerken die gleiche Disk vorhanden ist. Das MSD-Laufwerk greift automatisch aufLaufwerkOzu, um die Kompatibilität zum Einzellaufwerk stärker zu gewährleisten.

## Solide Hardware bis ins letzte Detail

Bei der Verarbeitung zeigt das MSD Super-Disk-Drive große Vorteile gegenüber dem C-1541-Laufwerk. Zum einen ist es bei weitem nicht so überhitzungsgefährdet wie das Commodore-1541, zum anderen ist es sehr stabil gebaut. Nach einem Härtetest (25 Disketten hintereinander formatieren) hatte sich der Schreib/Lesekopf nicht einmal um Bruchteile von Millimetern verschoben — der Schreib/Lesekopf des 1541 wäre längst dejustiert gewesen. Bemerkenswert ist auch, daß bei auftretenden Lesefehlern kein lautes Rattern wie am 1541 oder 4040 zu hören ist. Das SD-2 schont sich also praktisch selbst.

## Die besondere Fähigkeit

Laut englischer Anleitung weist das MSD-Super-Disk-Drive einen besonderen Gag auf: Nachdem die Datendiskette im einen Laufwerk voll ist, wird einfach auf eine Diskette im 2. Laufwerk umgeschaltet. Dies würde natürlich für den kommerziellen Anwender bei vollen 340 KByte Speicherkapazität sehr von Nutzen sein. Leider lag uns zum Test noch keine Version des MSD-Dop-pel-Disk-Drives vor, das diese Umschaltung geboten hätte.

Alles in allem gesehen, kann man das SD-2 als hervorragendes Gerät bezeichnen, das sich besonders durch seine stabile Verarbeitung auszeichnet. 1998 Mark für dieses Diskettenlaufwerk (ohne IEC-Bus) sind kein besonders billiges Vergnügen. Es lohnt sich aber trotzdem für die kommerziellen Anwender und Viel-Kopierer.

## Für Profis geeignet

Insbesondere die üblichen Reparaturkosten, die man sich mit dem Kauf des 1541 früher oder später aufhalst, sprechen für den Kauf des MSD-Laufwerks.
Dem einfachen Hobby-Benutzer, der seinen C 64 (plus Floppy) nicht länger als drei Stunden pro Tag angeschaltet hat (echte Dauerbenutzer haben mindestens ein Pensum von fünf Stunden täglich), ist jedoch weiterhin der Kauf der sehr viel billigeren C 1541 anzuraten, besonders im Hinblick auf die Kompatibilität der Software.

(M. Kohlen)

Höhe 15,7 cm
Breite 15 cm
Tiefe 33,8 cm
Anschlüsse: wahlweise IEEE-Bus parallel oder seriell.
Diskformat: 5,25-Zoll-Disketten
Single Density Speicherkapazität: pro Laufwerk wie 1541: sequentiell 168 656 Byte relativ 176 132 Byte

# Monitor kontra Fernseher

> Nur wenige Computer haben einen eingebauten Monitor. Weil auch ein vorhandener Fernsehapparat angeschlossen werden kann, können die Preise eines Computers auch relativ niedrig gehalten werden. Doch wenn man es leid ist, das Wohnzimmer mit einer undekorativen Computeranlage zu verunstalten, wird der Kauf eines zweiten Fernsehers erwogen. Oder sollte es vielleicht besser ein spezieller Monitor sein?

Bildschirmgeräte stehen heute in fast allen Haushalten — in Form eines Fernsehgerätes. Kein Wunder also, wenn viele Hersteller von Heimcomputern auf das vorhandene Reservoir zurückgreifen und für ihre Geräte ein solches Fernsehgerät als Ausgabeeinheit vorsehen. In manchem Heimcomputer-Besitzer mag aber — nach langen Abenden vor dem zweckentfremdeten Fernseher — der Wunsch entstanden sein, auch einmal vor einem scharfen Monitorbildschirm sitzen zu dürfen.

Wir haben uns fünf Geräte ausgesucht und von jedem Bildschirm einige Aufnahmen gemacht. Wir wählten zwei Farbmonitore aus (das Modell 1701 von Commodore (zirka 900 Mark) und den Taxan Vision Ex (zirka 1000 Mark)), zwei Farbfernseher mit Video-Eingang (Panasonic TC 1637 DR (zirka 1000 bis 1100 Mark) und Sharp DV-1400 G,S,N (zirka 900 Mark)) sowie einen monochromen Monitor (Zenith ZVM-123-E (zirka 350 Mark), Bilder 1 bis 3). Wir wollten wissen, ob es lohnend ist, sich einen Farbmonitor anzuschaffen, der sich lediglich zum Anschluß an einen Computer eignet und ob der Unterschied zu einem guten Farbfernseher mit Videoeingang sich wirklich stark bemerkbar macht. Den monochromen Monitor brauchten wir, um die Qualität einer 80-Zeichen-Karte zu dokumentieren.

Von jedem Bildschirm wurden zwei Aufnahmen gemacht, je eine mit einer Grafik und mit einem Text (Bilder 4 bis 14). Die beiden Farbmo-nitore und der monochrome Monitor mußten sich zusätzlich noch mit der 80-Zeichen-Karte quälen lassen (Bilder 15 bis 17). Sie stammt von der Firma Decam electronic aus Ettlingen. Bei den Aufnahmen muß man berücksichtigen, daß die Einstellungen von Farbe, Helligkeit und Kontrast sich verändern lassen, daß auch foto- und drucktechnische Gegebenheiten das Ergebnis etwas verfälschen können. Doch lassen sich einige grundsätzliche Unterschiede schon feststellen.

Um die Unterschiede noch etwas klarer herauszustellen, haben wir zu jedem Bildschirm eine Ausschnittsvergrößerung der Grafik (Bild 4) und des Textes gewählt. Hier wird auch die Struktur des Bildschirmes sichtbar.

Da die Sehgewohnheiten sehr unterschiedlich sind, haben wir auf eine Bewertung verzichtet. Dieser Artikel ist auch kein Vergleichstest, sondern soll Ihnen die Unterschiede zwischen Fernseher und Monitoren demonstrieren.

## »Zeichen pro Zeile« ist Unsinn

Viele Anwender interessieren sich im Zusammenhang mit Textverarbeitung mit den Problemen bei der Darstellung von einer bestimmten Anzahl von Zeichen pro Zeile.

Die Angabe »Zeichen pro Zeile« hat sich eigentlich erst verbreitet, als sich zunehmend technisch Unbedarfte im Computerbereich zu interessieren begannen. Sie scheint so schön anschaulich und unkompliziert zu sein. Dabei ist sie Ursache einer großen Verwirrung in diesem Bereich. Sie suggeriert nämlich, daß es im Monitor irgendeine Stelle gäbe, die entweder 40 oder 80 Zeichen akzeptieren würde, aber nicht beides und nichts zwischendrin. In einigen Anzeigen wird dieses Mißverständnis noch gefördert, indem sie von »umschaltbar auf 40 oder 80 Zeichen« sprechen!

Der Monitor erkennt Zeichen schon aus technischen Gründen überhaupt nicht als solche, da er ja immer nur die auf einer Bildzeile nebeneinanderliegenden Matrixzeilen einer ganzen Textzeile schreibt. Jede Punktmenge, die kleiner ist als die maximal mögliche, wird selbstverständlich auch abgebildet. Ein Monitor, der 400 Punkte pro Zeile abbilden kann, kann auch 200 abbilden, oder 360 oder irgendeine andere Anzahl, ohne Umschaltung. Ob diese Punkte zu 22, 40 oder 80 Zeichen gehören, ist ihm, schlicht gesagt, egal.

Die Umschaltmöglichkeit, die manche Hersteller anbieten, hat einen anderen Grund: Wenn nämlich ein Monitor, der 800 Punkte pro Bildzeile noch scharf abbildet, aber von einem Computer nur 400 angeboten bekommt, kann die Auflösung zu gut sein. Dann sind die Punkte durch deutliche Zwischenräume getrennt. Das ist unter Umständen für den Betrachter unangenehm. Mit dem Umschalter wird die Bandbreite deshalb absichtlich soweit eingeschränkt, daß die Punkte etwas ver-schliffen werden. Das Auge nimmt sie breiter gezeichnet wahr, die Zeichen erscheinen im Bild geschlossener und die Arbeit mit ihnen ermüdet weniger. Alle diese Ausführungen treffen in vollem Maße auch auf Farbmonitore zu.

Welches Bildschirmgerät ist aber am geeignetsten? Nun, das kommt ganz auf den Verwendungszweck an. Für Textverarbeitung und alle Anwendungen, die auf die Darstellung großer Datenmengen pro Bildschirmzeile beruhen, erst recht bei 80-Zeichen-Karten, ist ein monochromer Bildschirm am besten geeignet, es sei denn, daß die Farbe ein wesentlicher Bestandteil der Bildinformation ist. Selbst gute Farb-monitore haben aber nur eine Auflösung, die derjenigen billiger monochromer Monitore entspricht. Absolut ungeeignet ist ein Farb- oder Schwarzweiß-Fernseher für diesen Zweck. Für grafische Anwendungen bietet sich ein Farbmonitor ab mittlerer Preislage an. Eventuell geht auch ein Farbfernseher mit Video-Eingang; die Farben sind zwar dann brillant, an der Auflösung mangelt es jedoch. Die Domäne normaler Farbfernsehgeräte sind eigentlich nur Anwendungen im Bereich der Videospiele. Hierbei ist zum einen der Tonteil von Bedeutung und andererseits keine übermäßige Schärfe nötig.

Insgesamt betrachtet, erscheint ein Farbfernseher mit Videoeingang ein guter Kompromiß zu sein. Man sollte dann jedoch darauf achten, daß die Bildschirmgröße bei 20 bis 35 cm Schirmdiagonale liegt. Dann kann man in einem optimalen Abstand zwischen 0.5 und 1.5 Metern vom Bildschirm sitzen (schon deshalb ist ein großer Farbfernseher ungeeignet). Verbindliche Werte gibt es jedoch nicht. (gk)

Bezugsquellen: siehe Marktübersicht aufSeite 22. Die beiden Farbfernseher sind im Fachhandel erhältlich.

# Marktübersicht Schwarzweiß- und Farbmonitore

> Ob wegen Textverarbeitung oder Familienprotest — immer mehr Computerbesitzer ersetzen den Fernseher durch einen Monitor. Diese Marktübersicht soll eine kleine Hilfe im Vorfeld der Kaufentscheidung sein.

Wir haben uns dabei auf die Mo-nitore beschränkt, die vom Preis her in ein C 64-System passen. Das bedeutet im Klartext, daß wir monochrome Monitore oberhalb von etwa 600 Mark ebensowenig berücksichtigt haben wie Farbmonitore, die wesentlich mehr als etwa 1600 Mark kosten.

Die angegebenen Preise verstehen sich als ungefähre Richtwerte; Preisvergleiche bei verschiedenen Händlern lohnen sich in der Regel.

Die meisten Monitore werden über den Fachhandel oder über Kaufhäuser vertrieben. Die folgende Anbieterliste enthält für den Interessierten die Adressen der Vertriebsfirmen, bei denen Datenblätter und nähere Informationen zu bekommen sind.

(ev)

Anbieter:
Apple Computer, Freischützstr. 92, 8000 München 81
Commodore Deutschland, Lyoner Str. 38, 6000 Frankfurt 71
Feltron Elektronik, Auf dem Schnellerod 22, 5210 Troisdorf
Gerb Elektronik, Roedernallee 174-176, 1000 Berlin 51
Hantarex Deutschland, Siegener Str. 23,5230 Altenkirchen
ITT/SEL, Frankstr. 60, 7530 Pforzheim
Loewe Opta, Industriestr. 11, 8640 Kronach
C Melchers & Co., Schlachte 39/40, 2800 Bremen 1
Microscan, Postfach 601705, 2000 Hamburg 60
Mirwald Electronic, Fasanenstr. 8b, 8025 Unterhaching
National Panasonic, Winsbergring 15, 2000 Hamburg
Philips Data Systems, Weidenauer Str. 211-213, 59 Siegen 21
Sanyo Deutschland, Widenmeyerstr. 25, 8000 München 22
Unitronic, Münsterstr. 338, 4000 Düsseldorf 30
Zenith Data Systems, Robert-Bosch-Str. 32-38, 6072 Dreieich-Sprendlingen

# Marktübersicht Drucker – Teil 2

> Hier ist der zweite Teil unserer aktuellen Marktübersicht über das Angebot an Druckern und Plottern für den Commodore 64 und den VC 20.

Wie bereits im ersten Teil, so fehlen auch diesmal zwei Kategorien von Druckern und Plottern. Zum einen nämlich Geräte aus Preisklassen, die für den C 64/ VC 20-Anwender nicht mehr interessant sind, also beispielsweise Superdrucker für 5000 Mark oder DIN A3-Plotter im fünfstelligen Preisbereich. Zum anderen wurden auch diesmal Drucker nicht berücksichtigt, die nur mit unvertretbar großem Aufwand an den C 64 / VC 20 angeschlossen werden können.
Sie können also davon ausgehen, daß alle in dieser Marktübersicht vertretenen Drucker und Plotter ohne große Probleme mit dem C 64/ VC 20 arbeiten. Bei Geräten, die direkt über den seriellen Bus anschließbar sind, ist in der Rubrik »Interface« »C 64/VC 20« vermerkt.
Die Liste der an den C 64/VC 20 anschließbaren Drucker soll auch zukünftig weiter aktualisiert werden. An dieser Stelle sind daher auch die Anbieter entsprechender Drucker oder Plotter aufgefordert, uns entsprechende Informationen zukommen zu lassen.
Alle Preisangaben sind nur ungefähre Werte. Wer sich bei verschiedenen Anbietern informiert, kann unter Umständen günstiger einkaufen.

### Anbieter-Liste Drucker & Plotter (Teil 2)

Die hier aufgeführten Adressen sind in der Regel keine direkten Bezugsquellen. Sie erhalten hier jedoch Datenblatt und Händlernachweis für den von Ihnen ins Auge gefaßten Drucker oder Plotter. (ev)

Ascalon-Vertrieb Mayon Elektronik GmbH, Postfach 1925, 8034 Germering
Brother International GmbH, Im Rosengarten 14, 6368 Bad Vilbel
Centronics System Elektronik Vertriebs GmbH, Heesfeld 4, 3300 Braunschweig
DEC Transtec Computervertriebsges. mbH, Schaffhausenstr. 113, 7400 Tübingen
Dyneer Vertrieb Technitron GmbH, Charles-de-Gaulle-Str. 4, 8000 München 83
Facit-Ericson, Niederheider Str. 3, 4000 Düsseldorf 13
Honeywell-Fachhandel Lackner GmbH, Willstr. 2, 8500 Nürnberg
C. Itoh Deutschland GmbH, Königsallee 21, 4000 Düsseldorf 1
Macrotron, Stahlgruberring 28, 8000 München 82
Mannesmann-Tally GmbH, Postfach 2969, 7900 Ulm
G. Melchers & Co., Schlachte 39/40, 2800 Bremen 1
Mitsui-Vertrieb Technitron GmbH, Charles-de-Gauile-Str. 4, 8000 München 83
NEC Europa, Wiesenstr. 148, 4040 Neuss 1
Olivetti-Fachhandel, Ingenieurbüro Jörg Michael, St. Katharinen-Weg 6, 7750 Konstanz 16
Roland GmbH, Postfach 1905, 2000 Norderstedt
Siemens Vertrieb PAV, Gerzener Str. 5, 8311 Dietelskirchen
Star Europe GmbH, Frankfurter Allee 1-3, 6236 Eschborn

TODO

# Ein starkes Stück

> Die beiden Matrixdrucker Itoh 8510 und 1550B unterscheiden sich hauptsächlich durch ihre Druckbreite. Enorm leistungsfähig sind sie beide.

Der optische Unterschied ist auffällig, denn der Itoh 8510 (Bild 1) ist im Gegensatz zum 1550B ein fast zierlicher Drucker. Dabei haben beide Drucker viele Gemeinsamkeiten. Sie arbeiten nach dem Punktmatrixprinzip mit einer Zeichenmatrix von maximal 8x8 Zeichen. Auch ist ihnen die Fähigkeit sowohl Einzelblatt als auch Endlospapier zu verarbeiten gemeinsam. Der Unterschied liegt in der Papierbreite. Der Itoh 1550B druckt mit einer Breite bis zu 15 Inch, der Itoh 8510 bis zu 10 Inch. Ein weiterer Unterschied ist die Schreibgeschwindigkeit, denn der 1550B schafft 120, der 8510 aber 180 Zeichen pro Sekunde.

Wesentlich vielfältiger als die Unterschiede sind die gemeinsamen Fähigkeiten dieser beiden Druckertypen. Dem Konzept nach wurden die beiden Hauptfunktionen eines Punktmatrixdruckers, nämlich die Textausgabe und die Grafikausgabe optimiert. Das Schriftbild ist bereits in der schnellen Normalschrift sehr klar und die Buchstaben wohlgeformt. Einzelne Punkte sind kaum noch wahrzunehmen, nur an den Kanten der Buchstaben sind kleine Ecken sichtbar. Etwas größer als die Normalschrift ist die Picaschrift, bei der allerdings wieder mehr einzelstehende Punkte erkennbar sind. Ausgeglichen wird dieser Nachteil in der Fettschrift, die besonders deutlich, aber auch merklich langsamer ist. Die Krönung der verfügbaren Schriften aber ist die Proportionalschrift. Sie gleicht nicht nur die Zeichenabstände optimal aus, sondern verwendet auch eine andere Zeichendefinition. Der Probeausdruck (Bild 2) zeigt, daß diese Schrift den Anforderungen der täglichen privaten, aber auch der geschäftlichen Korrespondenz gerecht wird. Der Programmiervorgang ist relativ einfach, denn er wird mit den üblichen ESC-Sequenzen vorgenommen.

## Matrixdrucker mit Schreibmaschinenqualität

Damit diese Druckfunktionen aber auch richtig aufs Papier kommen, bedarf es der richtigen Verbindung zum Computer. Für die Besitzer des C 64/VC 20 ist dies eine relativ problemlose Angelegenheit, denn beide Drucker haben in der Regel eine Centronics-kompatible Schnittstelle. Die Commodore-Grafik- und Cursorsteuerzeichen sind im Zeichensatz der Itoh-Drucker nicht vorhandenen. Erst die Verwendung eines speziellen Soft- oder Hardwareinterfaces mit entsprechender Programmierung, macht diese Zeichen verfügbar. Die zweite Anschlußmöglichkeit der Itoh Drucker besteht im Einbau einer seriellen Schnittstelle.

Sehr erfreulich verlief der Praxistest mit einem Textverarbeitungspro-

TODO TODO TODO TODO

# Der Petal MA20 – kleiner Name, großer Drucker

> Obwohl das Schriftbild der Matrixdrucker ständig besser wird, sind Typenrad-Drucker in diesem Bereich bislang ungeschlagen. Ein auch für den C 64 bestens geeigneter und preisgünstiger Typenraddrucker ist der Petal MA20.

Leider waren Typenraddrucker bislang immer relativ teuer. Nicht so der Petal MA20 (Bild 1), er ist baugleich mit dem bekannten Juki 6100 Typenraddrucker, unterscheidet sich von diesem aber im Preis. Der Juki hat einen empfohlenen Verkaufspreis von zirka 1798 Mark. Der Petal MA 20 soll laut Liste 1498 Mark kosten. Er ist aber unserer Erfahrung nach noch um einiges günstiger zu haben. Der Petal MA20 ist ein Typenraddrucker, das heißt er besitzt im Gegensatz zu einer Schreibmaschine keine eigene Tastatur. Die Texteingabe und Drucksteuerung muß von einem Computer übernommen werden. Mit diesem Konzept sind natürlich Vor- und Nachteile verbunden. Hauptnachteil ist für den Commodore 64-Besitzer, daß keine Grafik- und Commodore-eigene Schriftzeichen ausdruckbar sind. Außerdem sind Typenraddrucker oft relativ langsam und laut (beim Petal zirka 62dBA). Der Vorteil des exzellenten Schriftbildes überwiegt diesen Nachteil aber dann bei weitem, wenn hauptsächlich Texte ausgedrucktwerden. Durch Auswechseln der Triumph-Adler-kompatiblen Typenräder (100 Zeichen) steht eine enorme Anzahl der verschiedensten Schriftarten zur Verfügung. Wissenschaftliche Sonderzeichen, Schreibschrift und fremdsprachliche Schriften sind so innerhalb von Sekunden verfügbar. Aber auch das zum Drucker mitgelieferte Typenrad Caroll-Pica erlaubt schon einige Variationen der Schrift (Bild 2). Nicht vergessen wurde dabei die Unterstreichfunktion und die Fettschrift. Der Haupteinsatzbereich eines Druckers wie dem Petal MA20 ist sicherlich die Textverarbeitung. Mit einem guten Textverarbeitungsprogramm, wie dem Vizawrite 64 (das eine eigene Druckoption für den Petal/Juki hat), verwandelt sich die gute Stube in ein kleines Büro. Der Petal MA20 kann sowohl Einzelblatt-, als auch Endlospapier verarbeiten. Für unbeaufsichtigtes Drucken sind zusätzlich ein automatischer Einzelblatteinzug und ein Traktoraufsatz erhältlich. Für den normalen Betrieb genügt aber die Standard-Ausrüstung. Die aber kann sich sehen lassen: Die Druckgeschwindigkeit beträgt 18 Zeichen pro Sekunde bei bidirektionalem Druck. Sehr praktisch ist der sowohl hard- als auch softwaremäßig bestimmbare Zeichenabstand. Er beträgt entweder 10, 12 oder 15 Zeichen pro Zoll. In der Standardschrift können so bis zu 165 Zeichen in einer Zeile untergebracht werden. In der ebenfalls verfügbaren Proportionalschrift (automatischer Ausgleich der Zeichenabstände) sind sogar 220 Zeichen pro Zeile verfügbar. Damit ist auch gesagt, daß die Papierbreite bis zu 13 Inches (= 33 cm) betragen kann. Der Petal MA20 verarbeitet somit j,auch DH4-A4-Papier im Querformat.

Die unumgängliche Wartezeit auf das fertige Schriftstück wird durch den eingebauten Pufferspeicher von 2 KByte (erweiterbar auf 8 KByte) angenehm verkürzt. Angeschlossen wird der Petal MA20 an den C 64/VC20 wie jeder andere Drucker mit Centronics-kompatibler Schnittstelle.

(Arnd Wängler/aa)

Bezugsquelle: WeberComputertechnik, Eulenspiegelstraße 86, 8000 München 83, Tel. 089/6012554

# Drucksympathie

> Nicht nur die gute Optik, sondern auch sehr gute Leistungen kennzeichnen den BMC BX100. Dabei ist dieser Matrixdrucker auch noch sehr preisgünstig.

Ein guter Matrixdrucker kostete vor etwas mehr als einem Jahr noch ein halbes Vermögen. Das hat sich geändert. Der BMC BX100 (Bild 1) kann als Paradebeispiel dieser Entwicklung bezeichnet werden. Er bietet für relativ wenig Geld (anschlußfertig 1200 Mark) Leistungen, die auch im professionellen Einsatz kaum Wünsche offen lassen.

Schon nach dem ersten Augenschein wirkt er sympathisch, ja man kann sogar von einem hübschen Gerät sprechen. Der Drucker ist kompakt aufgebaut. Das wurde vor allem durch den im Gehäuse versenkten Antriebsmechanismus für Einzelblätter und Endlospapier möglich. Der Vorteil dieses Konstruktionsprinzips liegt in dem auch für die beachtliche Druckgeschwindigkeit von 100 Zeichen pro Sekunde angenehmen Geräuschpegel. Der BMC BX100 wird in der Regel mit einer Centronics-kompatiblen Schnittstelle ausgeliefert. Es sind aber auch eine serielle Schnittstelle und, besonders interessant, eine Version zum direkten Anschluß an den Commodore 64/VC 20 erhältlich. Zum Test stand die Commodore-Version mit externem Interface zur Verfügung. Die ohnehin umfangreichen Druckfunktionen des BX100 werden durch das Commodore-Interface noch um einige Varianten erweitert. Dazu gehört auch der gesamte Commodore-Zeichensatz und die Cursor-Steuerzeichen. Sogar reverse Buchstaben sind enthalten. Die für jeden Programmierer besonders wichtigen Programmlistings werden komplett mit allen Grafikzeichen und den re-versen Steuercodes ausgegeben. Der Drucker wird dabei kaum langsamer. Aber auch die Standardfunktionen des BX100 brauchen den Vergleich mit anderen Druckern nicht zu scheuen: Kursiv-Proportional-, Elite-, Schmal-, und Breitschrift sind mit einfachen ESC-Befehlen zu aktivieren (Bild 2).

Befehle zur Formatierung des Textes, wie sie von jedem guten Textverarbeitungsprogramm vorausgesetzt werden, sind dem BX100 nicht unbekannt. Dazu gehören Funktionen wie das Anspringen bestimmter Tab-Positionen, das Setzen des linken und rechten Randes oder die Festlegung der Seitenlänge. Man kann sogar das Papier rückwärts transportieren. Das Druckbild kann zwar nicht mit einem Typenraddrucker verglichen werden, ist aber mit das Beste, was wir bei einem Matrixdrucker dieser Preisklasse bisher gesehen haben. Verglichen mit einem Epson FX80 ist das Schriftbild des BX100 sogar noch etwas besser. Verantwortlich für diese sehr guten Druckeigenschaften ist der Druckkopf, der mit seiner 9xll + 3sp Nadelmatrix üppig ausgestattet ist.

Mit seinen zwei verschiedenen Nadeldichten kann der BX100 als voll grafikfähig bezeichnet werden, zumal das verwendete Interface diese Funktionen voll unterstützt. Zum Ausdruck des Textes oder der Grafik beträgt die einstellbare Papierbreite zwischen 4,5 und 10 Inches (11,43 bis 25,40 Zentimeter). Die Handgriffe für die Justage des Traktors sind einfach und als durchaus fingerfreundlich zu bezeichnen. Ebenso das Einlegen der Farbbandkassette. Das Eindrehen eines einzelnen Blattes ist Dank des leichtgängigen Drehknopfes und der sinnvollen Papierführung problemlos.

Mit 100 Zeichen pro Sekunde liegt die Druckgeschwindigkeit des BX100 etwas über dem Durchschnitt dieser Klasse. Der Druckkopf schreibt dabei in beiden Richtungen (bidirektional) mit Druckwegoptimierung. Beim Grafikausdruck wird unidirektional geschrieben. Diese weit über den Standard hinausgehende Druckfunktionen machen den BMC BX100 zur idealen Ergänzung des Commodore 64/VC 20.

Bis auf das zwar ausführliche, aber leider noch englische Handbuch, ist der BMC BX100 in dieser Preisklasse nur schwer zu überbieten.

(Arnd Wängler/aa)

Bezugsquelle: Weber Computertechnik, Eulenspiegelstr. 56, 8000 München 83, %1. 0 89/ 6 0125 54

# Wie super ist die Supergrafik?

> Supergraphik 64 ist ein Programm, dessen Befehle sich nicht nur auf die Grafik beziehen.

Nun, gehen wir den Befehlssatz von »Supergraphik 64« mal Schritt für Schritt durch. Da wäre als erstes der GMODE-Befehl zu nennen. Er ist die Schaltzentrale der Supergraphik, denn mit ihm bestimmen Sie, was angezeigt, und was befehligt wird. Denn zusätzlich zu den beiden hochauflösenden Seiten kann in der Textseite eine 80 x 50-Blockgrafik erstellt werden, und zwar mit genau denselben Befehlen. Es ist möglich, die Grafikseite 1 anzuzeigen, während Seite 2 oder die Textseite bearbeitet wird. Natürlich wird auch der Multicolormodus unterstützt. Allerdings ist es aus syntaktischen Gründen nicht möglich, eine Seite »normal« anzuzeigen und die andere in Multicolor zu bearbeiten. Mit diesem Befehl kann auch ein Textfenster in der Grafik definiert werden, allerdings nur im Normal-, nicht im Multicolormodus. Zum Textfenster ist zu sagen, daß die obere Kante nicht ganz flimmerfrei ist, was durch die zahlreichen Umschaltungen im VIC bedingt wird.

Hat man erst einmal eine Modus-wahl vorgenommen, so kann man mit dem PLOT-Befehl fleißig Punkte setzen und löschen. Hier ergeben sich zusätzlich noch die Möglichkeiten, Punkte zu invertieren, wie auch einen Grafikcursor an die entsprechende Stelle zu setzen. Dieser Grafikcursor kann dann bei weiteren Befehlen als Ausgangspunkt benutzt werden. Ebenfalls mit dem PLOT-Befehl können Linien und sogar Linienzüge gezeichnet werden. Zu den Optionen »Setzen«, »Löschen«, »Invertieren«, »Grafikcursor Bewegen«, treten nun noch »Punktieren« und »Zählen«. Beim »Zählen« wird in eine beliebige Variable die Anzahl der abgefahrenen Punkte übergeben. Auch können zwei Linien, die nirgends im selben 8 x 8-Kästchen verlaufen, verschiedene Farben haben, obwohl Sie sich im »normalen« Modus befinden. Eine Option bewirkt, daß gleichzeitig mit der Linie die entsprechenden Bytes im Farb-RAM gesetzt werden.

Nun gibt es aber nicht nur Linien, auch Kreise wollen gezeichnet sein. Der zuständige Befehl heißt (natürlich) CIRCLE. Aber CIRCLE kann noch mehr. Auch Ellipsen und Vielecke sind kein Problem, es können sogar ein Anfangs- und ein Endwinkel für das Zeichen mitgegeben werden. Natürlich funktioniert CIRCLE auch mit allen schon bei PLOT angegebenen Optionen.

Weitere Befehle sind FRAME, mit dem ein beliebig dicker, rechteckiger Rahmen gemalt werden kann, sowie FILL, das allerdings nur ausgefüllte Rechtecke zeichnen kann. Das Ausfüllen beliebiger umrandeter Flächen ist mit Supergraphik nicht möglich.

Mit TEXT kann ein Text aus einem String an eine beliebige Stelle in eine Grafik hineinkopiert werden. Im 80 x 50 Modus erhalten Sie so vierfach vergrößerte Buchstaben. Natürlich kann die so entstandene Grafik auch wieder gelöscht werden; der Befehl lautet GCLEAR.

Mit dem INVERS-Befehl kann man die beiden Grafikseiten invertieren. Hier ist die Angabe einer Bitmaske möglich, um gestreift zu invertieren. Leider ist es weder möglich, bereichsweise zu invertieren, noch kann die Textseite invertiert werden.

Mit GCOMB lassen sich die beiden Grafikseiten verknüpfen; neben dem einfachen Kopieren einer Seite in die andere kann wahlweise eine UND-, ODER- oder EXKLUSIV-ODER-Verknüpfung durchgeführt werden.

Mit dem TRANS-Befehl wird die Textseite in eine der beiden Grafikseiten kopiert. Daraus ergeben sich völlig neue Dimensionen, wenn Sie einen Sieben-Nadel-Drucker, beispielsweise den MPS 801 besitzen. Dann können Sie nämlich über den HCOPY-Befehl die original 8 x 8-Ma-trix der Bildschirmzeichen ausdrucken!

In dieser Übersicht der allgemeinen Befehle fehlt nur noch GMOVE. Damit ist ein Verschieben oder Scrollen von Bildschirmzeilen nach links oder rechts möglich. Welche Zeilen verschoben oder gescrollt werden sollen, kann angegeben werden. Allerdings können auch im hochauflösenden Modus nur 8 x 8-Blöcke gescrollt werden.

Kommen wir als nächstes zu den selbstdefinierbaren Figuren. In einem Definitions-String muß angegeben sein, in welcher Richtung der Grafikcursor weiterbewegt, beziehungsweise wann ein Punkt gesetzt werden soll. Die so definierte Figur kann mit dem DRAW-Befehl an jeder Stelle des Bildschirms gezeichnet werden. Auch hier dürfen sämtliche oben angesprochene Optionen verwendet werden. Mit SCALE= können Sie vorher noch übergeben, mit welchem Vergrößerungsfaktor und um welchen Winkel gedreht ihre Figur erscheinen soll. Eine Anwendung sehen Sie in der Bildschirmaufnahme.

Die nächste Gruppe von Befehlen sind die Farbbefehle. Mit COLOR = können, fürjeden der drei Bildschirme einzeln, Hintergrund- und Rahmenfarbe gesetzt werden. SCOL = bestimmt die Zeichenfarbe auf der gesamten entsprechenden Seite; sie kann mit PCOL= für einzelne Bildelemente abgeändert werden, um mehrfarbige Grafiken zu erhalten. Im Multicolor-Modus werden mit SCOL= auch die zwei zusätzlichen Farben angewählt.

Dem Speichern und Laden von Grafiken dienen die Befehle GSAVE und GLOAD. Da das Format, in dem ihre Grafiken geladen oder gespeichert werden, frei wählbar ist, können Bilder der verschiedensten Malprogramme geladen und weiterverarbeitet werden. Dummerweise scheint es kein Einheitsformat zu geben, so daß Sie beim Speichern oder Laden immer eine Formatangabe machen müssen, was auf die Dauer ziemlich lästig ist.

Mit HCOPY lassen sich Grafiken zu Papier bringen. Supergraphik unterstützt hierbei die verschiedensten Druckertypen, sogar den Farbdrucker Seikosha GP-700. Um nicht zuviel Speicherplatz für die Hardco-py-Routinen in Anspruch nehmen zu müssen, werden Sie beim Laden der Erweiterung nach Ihrem Druckertyp gefragt. Sie haben die Wahl zwischen den Commodore-Druk-kern 1525, 1526, MPS801, den Seikosha-Druckern GP 100-VC und GP 700A sowie Epson-Druckern mit Data Becker-Interface. Die entsprechende Routine wird dann nachgeladen.

Kommen wir nun zu den Sprites. Hier liegen einige Schwachpunkte. Denn bevor Sie mit den Spritebefehlen arbeiten können, müssen Sie erst einmal ein paar Sprites haben, und zwar in Form von 63 DATAs, wie in den guten alten Zeiten, in denen Sie noch keine Supergraphik hatten. Um diesem Mißstand abzuhelfen, hat Data Becker der Supergra-phik-Diskette einen relativ komfortablen Sprite-Editor beigefügt. Dieser hat allerdings drei Mängel: Er mag keine Multicolor-Sprites; er ist aufgrund von eigenen Maschinenroutinen nur dann lauffähig, wenn Supergraphik nicht geladen ist; die von ihm erzeugten Disketten-Files können immer noch nicht von Ihnen und der Supergrafik verwendet werden. Ein kleines abgedrucktes Programm liest angeblich die Files von der Diskette und gibt die entsprechenden Zahlenwerte aus. Aber: Das abgedruckte Programm funktioniert nicht! Deswegen geben wir mit dem Listing 1 allen Supergra-phik-Besitzern eine Routine in die Hand, mit der Sie sehr einfach DA-TA-Zeilen aus SPRITEFORMER-Fi-les erzeugen können. Alles, was Sie jetzt zu tun haben ist: Startzeilennummer und Filename eintippen, 15 Sekunden warten, HOME und 21x RETURN drücken. Haben Sie alle Sprites im Speicher, einfach die Zeilen 0 bis 9 löschen und den Rest auf Disk speichern. Wenn Sie die Sprites später brauchen, einfach mit MERGE nachladen.

Mit SREAD können die 63 Daten einer Sprite-Definition in einen String eingelesen werden. Das geht wesentlich schneller als mit einer FOR-NEXT-Schleife. Mit SDEFINE können Sie dann einem der Sprites eine der Stringdefinitionen zuteilen. Dies hat den Vorteil, daß Sie die Definition für ein einzelnes Sprite schnell wechseln und somit Spriteinterne Bewegungsabläufe auch in Basic programmieren können. Mit SMODE legen Sie die übrigen Eigenschaften eines Sprite wie Multicolor, Farben, Größe und Priorität gegenüber dem Hintergrund fest.

Und wie kriegen Sie das nun auf ihre Mattscheibe? Dazu dient der Befehl SSET. Sie können damit nicht nur Sprites setzen, sondern auch bewegen, indem Sie Start- und Zielkoordinaten sowie die Geschwindigkeit angeben. Das Sprite läuft dann von selbst, und Ihr Programm etwas langsamer, das sich das ganze interruptgesteuert abspielt. Wenn Sie auf das Eintreffen eines Sprites am Ziel warten wollen, so hilft ihnen der SWAIT-Befehl weiter.

Und nun zu den in der Werbung angekündigten 16 Sprites, die gleichzeitig auf dem Schirm erscheinen sollen. Ich halte diese Formulierung für ein wenig übertrieben, 2 mal 8 Sprites wäre wohl richtiger. Denn mit dem SPOWER-Befehl können sie ein Bildschirmfenster definieren, in dem 8 andere Sprites erscheinen können, also auf dem restlichen Bildschirm. Sie haben beispielsweise oben 8 Sprites und unten 8 Sprites.

Aber die Supergraphik bietet nicht nur Grafik-Befehle, auch die Tongeneratoren des SID können per Basic angesteuert werden. Mit VOLUME = , legen Sie erst einmal die Lautstärke fest. SOUND dient der Einstellung von Wellenform und Hüllkurve der drei Stimmen. Mit FILTER kann der Filter des SID gesteuert werden. Und als letztes gibt es TUNE, das nach Voreinstellung der oben genannten Parameter einen Ton spielt.

Supergraphik benötigt eine Menge Speicherplatz, Ihnen gehen 10 KByte Ihres Basic-Speichers und sämtliche RAM-Bereiche in der ROM-Gegend, auch der $C-Bereich verloren. Deshalb wird die Supergraphik wohl kaum mit irgendeiner anderen Basic-Erweiterung zusammenarbeiten können. Aus diesen Gründen wurden die »wichtigsten« Programmierhilfen in das Programm mit eingebaut. So bringt der Befehl DIRECTORY selbiges ohne Programmverlust auf den Bildschirm. Mit MERGE können Pro-

TODO TODO TODO Fortsetzung auf Seite 157

# Viel zu schade, um nur damit zu kalkulieren

> Ufer bisher gemeint hat, Multiplan läuft nicht auf dem C 64, erfährt es hier besser. Dieses Tabellenkalkulationsprogramm ist schon seit Jahren für Personal Computer auf dem Markt. Wer aber immer noch glaubt, Multiplan sei nur zum Rechnen und Kalkulieren da, sollte ganz aufmerksam weiterlesen.

Multiplan wurde vor Jahren von der amerikanischen Softwarefirma Micro-Soft für 16-Bit-Computer entwickelt und entpuppte sich vom Start weg als der Renner auf dem Software-Markt.

Seit geraumer Zeit nun findet sich Multiplan 64 mit deutscher Benutzerführung und ebensolchem Handbuch im Handel. Jedem, der jetzt befürchtet, daß dies eine stark abgemagerte Version ist, sei gleich der Wind aus den Skeptikersegeln genommen: Mit häufigem, aber den Arbeitsablauf kaum störenden Nachladen einzelner Systemdateien arbeitet Multiplan auf dem C 64 befriedigend schnell und mit voller Leistung.

Doch gerade diese Leistung und hier besonders wiederum ihre Vielseitigkeit ist wohl für viele der Stolperstein bei Multiplan, obwohl gerade diese Fülle an Möglichkeiten bei Multiplan dieses Programm immer noch interessant macht — besonders dann, wenn man mit einem neidischen Auge auf die jüngste Generation von integrierter Software bei den »Großen« schielt.

Denn gerade wer sich ernsthaft mit seinem C 64 beschäftigt, das soll heißen, wer mit ihm seine Briefe oder Manuskripte schreibt und sein Haus oder seine Wohnungen verwaltet, oder wer mit ihm seinen kleinen Betrieb auf Trab bringt, wird sich schon oft über das häufige Programmwechseln-Müssen geärgert haben. Und nicht jeder kauft sich deshalb gleich einen neuen Computer. Und genau dort liegt der Casus-Knacksus in der Anwendung von Multiplan Richtig in den Griff bekommen und mit ein paar Kunstgriffen und Tricks liefert es uns auf dem C 64 fast schon die gleichen Features wie wesentlich aufwendigere und teurere Programme für große PCs. Doch dazu später und ausführlicher mehr. Kurz noch mal Generelles: Multiplan ist ein sogenanntes Spreadsheet. Ein aus 63 Spalten und 255 Zeilen bestehendes Arbeitsblatt. Jede der Spalten kann in ihrer Breite variiert, und sowohl Spalten wie Zeilen, also jedes einzelne Feld kann mit Daten, Formeln, Funktionen oder Texten gefüllt werden. Hat man sich erst einmal so eine Tabelle nach eigenen Wünschen aufgebaut, reagiert Multiplan auf die geringsten Veränderungen und berechnet getreu den Anweisungen alle betreffenden Positionen neu.

Dies setzten wir einmal als mittlerweile hinreichend bekannt voraus und ersparen uns so die trockenen Erklärungen der Wie und Warums und der einzelnen, über 120 Befehle, Funktionen, mathematischen Kürzel und zahlreichen Fehlermeldungen. (Die Nur-Multiplan-Interessierten mögen trotzdem hier noch nicht aufhören weiterzulesen.)

Diese Vielzahl an frei benutzbaren Möglichkeiten macht Multiplan schon fast zu einer eigenen Programmiersprache. Und sie erklärt, warum diese Software so gleichermaßen beliebt und unverstanden geblieben ist.

Doch kommen wir zum Wesentlichen, zum Programm selber. Jeder Neuerwerber wird erstmal positiv überrascht sein. Denn für seine knapp dreihundert Mark, die er für die C 64-Version von Multiplan dem Händler auf die Theke blättern muß, bekommt er genau 1,56 K. Diesmal handelt es sich aber ausnahmsweise nicht um die Meßlatte für Computerleistung oder Softwarelänge, sondern um die guten alten Kilogräm-mer der Marktfrauen. Genausoviel wiegt nämlich das in einer Acrylbox verpackte Handbuch samt Systemdiskette.

## Vorbildliche Dokumentation

Und zu diesem, selbstverständlich ebenfalls deutschen Handbuch, fallen einem eigentlich nur höchstlöbliche Worte ein. Es ist eines, das diesen Namen wirklich verdient. Microsoft hat hier nicht nur ein Nachschlagwerk geschaffen, sie liefern auch gleich ein komplettes und gut aufgemachtes Lehrbuch mit. Alles in allem zeigt dieses 432 Seiten starke Ringbuch, wie gut und auführlich man Bedienungsanleitungen machen kann. Und man fragt sich, warum es dennoch so viele zusätzliche Bücher, auch noch für jeden Computer ein eigenes, über dieses Programm auf dem Markt gibt.

Doch was bietet nun das Multiplan 64 dem Anwender, außer der Möglichkeit, die Auswirkung einer 5prozentigen Preiserhöhung auf seinen Energie- oder Wirtschaftshaushalt zu kalkulieren? Kann es mehr, als nur ausrechnen, ob nun 6,78% Zinsen auf 35 Jahre oder 7,86% Zinsen auf 5 Jahre günstiger sind? Und lohnen sich die drei Blauen für die meistverkaufte Software der Welt in einem Handwerksbetrieb oder Kleinversand, damit der Inhaber dann elektronisch weiß, daß er bei 3,5% mehr Spanne tatsächlich auch mehr verdient? Um es gleich vorwegzunehmen: JA. Man muß nur wissen wie ...

Wer sich durch die Befehlsvielfalt von Multiplan 64 durchgewühlt hat, wird vielleicht schnell feststellen, daß sich dieses Programm ganz ausgezeichnet in einzelne, immer wieder aufrufbare Module unterteilen läßt. Ein etwas größeres für zum Beispiel die Rechnungsstellung oder das Angebotswesen mit wiederum kleineren Modulen für die jeweiligen Posten und Kosten. Durch die Option der Formeln hat man bei der Gelegenheit auch gleich noch einen Überblick über den augenblicklichen Stand der geschriebenen Angebote, Kosten, Einnahmen oder was auch immer gewünscht wird.

Für eine kleine und natürlich nur eingeschränkt komfortable Textverarbeitung reicht es schon aus, die Spaltenbreite entsprechend zu vergrößern und die Felder mit dem Befehl »Zusamm(en)« zu kennzeichnen (Bild 1). Schon schreibt Mulitplan brav den eingetippten Text Zeile für Zeile ins Arbeitsblatt. Der Ausdruck des Geschriebenen erfolgt mit dem Befehl >>Z(eilen)/S(palten)-Num-mern: Ja (Nein)« auch ohne die, bei Briefen unangebrachten, Numerierungen.

Noch besser geeignet ist Multiplan für das Angebots- und Rechnungswesen (Bild 2). Hier zeigt es seine wahren Stärken, wenn man mal von dem Nur-Kalkulieren absieht. Da Angebots- und Rechnungstexte meist gleichlautend sind, bedarf es hierfür nur je eines Moduls. In diesem sind Text, Artikeldaten und natürlich die Formeln (Artikel mal Stückpreis gleich Angebot plus Mehrwertsteuer) »programmiert«. Bei Anfrage und noch besser nach Lieferung holt man sich das Modul als Datei in den Rechner, braucht nur noch die gelieferten Waren einzugeben und ab die Post.

Auch eine Hausverwaltung ist kein Problem. Einmal programmiert, liefert die Datei die Vorgaben, und die Mieter haben ihre Nebenkostenabrechnung wenig später auf dem Tisch (Bild 3). Den Anwendungen sind praktisch keine Grenzen gesetzt. Der kleine Betrieb spart sich zum einen den permanenten Programmwechsel und zum anderen auch Geld für teure Einzel-Software. In Kauf nehmen muß er dafür nur einige Stunden Anpassungsarbeit und die, allerdings rechnerbedingte, manchmal und bei ziemlich vollem Arbeitsplatz etwas langsame Geschwindigkeit, hat dafür aber eben alles in einem.

Wem diese Arbeit dennoch zuviel ist, kann sein Multiplan 64 auch weiterhin nur für seine Kalkulationen unterbelasten. Was allerdings schade wäre.

(Klaus Koch/aa)

# David und Goliath

> Für den C 64 sind inzwischen diverse Zeichenprogramme auf dem Markt. Sie werden mit dem Lichtgriffel, dem Joystick oder mit Paddles gesteuert. Interessant sind in diesem Zusammenhang auch Grafik-Tabletts.

Das Grafik-Tablett »Super Sketch« von PPI (Personal Peripherals, Inc) ist fast vier mal so groß als das »Koala Pad« von Koala Ware. Dem »Koala Pad« liegt eine Diskette mit dem dazugehörigen Programm »Koalapainter« und einigen Beispielbildern bei. Bei PPI wurde das Programm »Graphics-Master« für den »Super Sketch« in ein Steckmodul gepackt. Auf der mitgelieferten Diskette befindet sich lediglich ein Demo-Programm, um die Fähigkeiten des »Graphics-Master« aufzuzeigen. Die Kabel beider Tabletts werden in den Control Port 1 des C 64 gesteckt.

Das »Koala Pad« besitzt eine dunkelgraue druckempfindliche Zeichenfläche, die es erlaubt, mit einen mitgelieferten Stift oder mit dem Fingernagel am Bildschirm zu zeichnen (natürlich nur mit dem dazugehörigem Programm). Über der Zeichenfläche befinden sich zwei Tasten, die jedoch beide die gleiche Funktion haben. Sie werden zur Auswahl im Menü und zum Zeichnen benötigt.

Das Zeichnen mit dem »Super Sketch« ist leider nicht so komfortabel wie mit dem »Koala Pad«. Hier wurde ein Zeiger über einen Kontrollarm mit zwei Paddles verbunden. Diese Version ist in der Herstellung billiger, hat jedoch den großen Nachteil, daß beim Zeichnen immer der ganze Arm mitbewegt werden muß. Dies führt zu recht zackigen Bewegungen. Trotz der größeren Zei-chenfläche des »Super Sketch«,.werden oft feinere Bewegungen des Kontrollarms nicht wahrgenommen, da die Paddles diese Bewegungen kaum registrieren. So ist exaktes Zeichnen recht schwierig.

Mit dem »Koala Pad« ist das Zeichnen von kleinen Details trotz der kleineren Zeichenfläche einfacher, da jede kleinste Bewegung auf der druckempfindlichen Membrane an den Computer weitergegeben wird. Das »Super Sketch«- Tablett besitzt fünf Tasten. Der große »RELEASE«- Taster in der Mitte der Tastenreihe hat nur mechanische Funktion. Er hebt die Papierhalter auf beiden Seiten des Tabletts, an denen man Vorlagen befestigen kann.

Damit das Tablett sowohl von Links- als auch von Rechtshändern bequem bedient werden kann, wurden jeweils am linken und am rechten Rand der Tastenreihe eine »LIFT«-Taste angebracht. Wenn eine dieser Tasten gedrückt ist, kann der Kontrollarm bewegt werden, ohne daß der »Graphics-Master« am Bildschirm zeichnet. Beim »Koala Pad« ist dies umgekehrt, denn hier muß beim Zeichnen eine der beiden Tasten gedrückt werden. Die »LIFT«-Taste hat weiterhin die Aufgabe, das Menü des »Graphics-Master« zu verlassen und auf Zeichenbetrieb umzuschalten. Weiterhin befinden sich noch eine »MENÜ«-Taste und eine »SELECT«-Taste auf dem Tablett. Mit der »MENÜ«-Taste wird der Zeichenmodus unterbrochen, und am linken Bildschirmrand erscheint das Hauptmenü. Mit dem Kontrollarm kann nun auf die gewünschte Option gezeigt und mit der »SELECT«-Taste ausgewählt werden.

## Software im Steckmodul

Beide Programme (Koalapainter und Graphics-Master) besitzen fast die selben Fähigkeiten. Wie schon erwähnt muß der »Koalapainter« im Gegensatz zum »Graphics-Master« erst von der Diskette geladen werden. Nach dem beeindruckendem Titelbild erscheint das sehr übersichtliche Menü. Hier kann zunächst die Pinselform ausgewählt werden. Es stehen acht verschiedene Stärken zur Verfügung. Das Auswählen ist denkbar einfach. Man drückt zunächst mit dem Stift oder dem Finger auf die Oberfläche des Zeichentabletts, und es erscheint ein Cursor, den man nun durch Stift- oder Fingerbewegung auf das gewünschte Symbol führt und eine der beiden Tasten drückt. Genauso kann mit dem Cursor eine Farbe aus der Farbpalette ausgesucht werden. Zum Zeichnen wählt man mit dem Cursor das Symbol »Draw« an, und schaltet auf den Zeichenbildschirm um. Dies geschieht, in dem man mit den Stift an das untere Ende des Zeichentabletts fährt, so daß der Cursor nicht mehr sichtbar ist, und eine der oberen Tasten betätigt. Das Umschalten zum Menü erfolgt auf die gleiche Weise. Zum Zeichnen benötigt man nun beide Hände, da der Pinselstrich erst angenommen wird, sobald eine der beiden Tasten gedrückt ist. Läßt man die Taste los, fährt der Cursor über das Bild, ohne einen Spur zu hinterlassen. Doch »Draw« ist nur eine von 17 verschiedenen Optionen des »Koalapain-ters«.

So können mit »Frame« beliebig große Vierecke ins Bild gesetzt werden. Mit »Box« füllt man diese gleich mit der gewählten Farbe. Die Option »Circle« generiert Kreise. Mit »Disk« werden diese ebenfalls farbig ausgefüllt. Hier sei erwähnt, daß leider nur die Größe der Kreise und nicht deren Form beeinflußbar ist, so daß diese nicht rund sondern oval auf dem Bildschirm erscheinen. Durch »Xcolor« kann eine Farbe durch eine andere ersetzt werden. Die Option »Mirror« teilt den Bildschirm durch vertikale und horizontale Teilung in vier gleich große Teile. Zeichnet man nun in einem der vier »Quadranten« so wird dies an der X- und Y-Achse gespiegelt und erscheint auch in den angrenzenden »Quadranten«, natürlich spiegelverkehrt. »Line« verbindet zwei Punkte durch eine Linie miteinander. Die Option »Lines« beschränkt dies nicht auf zwei Punkte. Es können also beliebig viele Punkte mit einer Linie verbunden werden. Mit »Rays« läßt sich ein Strahlenbündel erzeugen. Die Option »Fill« füllt eine begrenzte Fläche mit einer bestimmten Farbe auf.

Sehr interessant ist »Zoom«. Mit ihr kann ein bestimmter Bildschirmausschnitt vergrößert und herangeholt werden (Bild 2). Außerdem erscheinen am unteren Rand des »Zoom«-Fensters alle 16 Farben, so daß Details sehr genau gezeichnet werden können. Zu Beachten ist allerdings, daß in einer 8x8-Matrix nicht mehr als vier Farben vorkommen dürfen. »Copy« dupliziert einen beliebigen Bildausschnitt. Hier sind auch Überlagerungen möglich. »Swap« schaltet zwischen ersten und zweiten Zeichenbildschirm um. Hat man einen entscheidenden Fehler gemacht, zum Beispiel eine falsche Fläche ausgefüllt, so kann dies durch den Befehl »Oops« rückgängig gemacht werden. Das Bild erscheint dann wie vor dem letzten Wechsel zum Menü. Mit »Erase« kann die Zeichnung wieder gelöscht werden. Die 17te und letzte Option »Storage« schaltet auf das Disk-Menü um. Hier können Bilder geladen, abgespeichert und Disketten formatiert werden. Auf der Diskette befinden sich einige Kunstwerke wie zum Beispiel das Bild »Jungle« (Bild 1).

## Super Sketch

Das Programm »Graphics-Master« befindet sich auf einem Steckmodul. Wird die Menü-Taste gedrückt, erscheint eine leere Zeichenfläche, an deren linken Seite sich das Hauptmenü befindet — leider nicht so übersichtlich wie bei »Koalapainter«. Im Gegensatz zu »Koalapainter« kann hier aber die Pinselform selbst kreiert werden. Hierfür wählt man mit dem Kontrollarm die Option »brush« an. Zum Zeichnen stehen natürlich auch alle 16 Farben zur Verfügung. Hier funktioniert das Zeichnen jedoch anders. Das Zeichenbrett registriert jede Bewegung und hinterläßt, wenn die »LIFT«-Taste nicht gedrückt wurde, ungewollte Spuren in der Zeichnung.

Nun zu den einzelnen Befehlen: »clear« löscht logischerweise den Bildschirm. Die Befehle »swap«, »fill« und »draw« haben gleiche Funktionen wie bei »Koalapainter«. Die Option »eraser« simuliert einen Radiergummi. Mit »undo« können (wie mit »Oops« beim »Koalapainter«) Fehler rückgängig gemacht werden. Auch der »Graphics-Master« besitzt zwei Zeichenflächen, zwischen denen mit »page« umgeschaltet werden kann. Beim »Koalapainter« werden bei »Fill«, »Box« und »Disk« nur begrenzte Flächen mit Farbe aufgefüllt. Beim »Graphics-Master« bieten sich mit »design« weitere Möglichkeiten, Flächen auszufüllen. So kann ein Zeichenmuster entworfen werden, mit dem eine Fläche aufgefüllt wird.

Mit der letzten Option im Hauptmenü »expert« wird auf das »Expert-Menü« umgeschaltet. Hier finden sich die Befehle »lines«, »rays«, »circle«, »box«, »copy« und »zoom« wieder, die auch dieselbe Bedeutung wie beim »Koalapainter« haben. Hier sei jedoch erwähnt, daß es mit »circle« möglich ist, wirklich runde aber auch ovale Kreise (Ellipsen) darzustellen.

Kommt man mit einem Kreis über den Bildschirmrand hinaus, so wird dieser im Gegensatz zum »Koalapainter« nicht hinausgeschoben sondern »staut« sich am Bildschirmrand. Das »zoom«-Fenster ist leider nicht so komfortabel, da keine Farbänderung vorgenommen werden kann. Das Fenster erscheint am linken unteren Eck der Zeichenfläche und ist nicht annähernd so groß wie beim »Koalapainter« (Bild 4). Mit der Option »h or v« können nur horizontale oder vertikale Linien gezeichnet werden, »window« erlaubt es, daß sich bestimmte Befehle wie »clear« oder »fill« nur auf den durch »window« gekennzeichneten Bereich, beschränken.

Die Option »copy 1/2« kopiert Bildausschnitte von der ersten zur zweiten Zeichenfläche oder umgekehrt. »quad« hat die gleiche Funktion wie »Mirror« beim Koalapainter, während »mirror« beim »Graphics-Master« den Bildschirm nur vertikal trennt. Die Option »flip« spiegelt jede Tätigkeit an einer horizontalen Trennlinie des Bildschirms. Mit »show« können Sie Ihr Meisterwerk bewundern, ohne daß ein flackernder Cursor Sie ablenkt. Die Option »reset« schaltet »window«, »quad«, »mirror«, »flip« und »zoom« wieder aus. »files« hat die selbe Bedeutung wie »Storage« beim Koalapainter. Nur kann hier auch mit Kassette gearbeitet werden. Es bleibt hier noch zu erwähnen, daß mit »Super Sketch« und »Graphics-Master« auch die Bilder vom »Koalapainter« geladen und bearbeitet werden können. Künstlerisch gelungen ist der Pelikan (Bild 5).

Beide Handbücher sind recht ausführlich. Jedoch muß man seine Englischkenntnisse wieder hervorkramen, da beide Bedienungsanleitungen englisch abgefaßt sind. Dem »Super Sketch« liegen außerdem einige Vorlagen bei, die auf dem Tablett befestigt werden können. Beim Nachzeichnen braucht man einiges Geschick, um mit dem Kontrollarm exakt der Vorlage zu folgen.

Da die Hardware von PPI dem »Koala Pad« unterlegen ist, versucht man mit zusätzlichen Funktionen im »Graphics-Master« wieder an Boden zu gewinnen. Ob dies gelingt ist Ansichtssache.

(Christian Quirin Spitzner/rg)

# Grafik hoch zwei – das Extended Graphik System

> Eine der interessantesten, aber auch schwierigsten Anwendungen des Commodore 64 ist die Grafikprogrammierung. Mit dem Extended Graphik System geht es einfacher.

Mit dem Extended Graphik System hat Interface Age ihre bekannte Ex-(tended-)Produkt-reihe fortgesetzt und dem Programmierer ein taugliches Werkzeug in die Hand gegeben. Die Konzeption dieses Programmpaketes beruht auf der Philosophie, dem Grafikinteressierten im Handbuch Kenntnisse zu vermitteln, die dieser dann sofort in der Praxis erproben kann. Das umfangreiche deutsche Handbuch hat deshalb auch den Charakter eines gut gemachten Lehrbuches. Angefangen mit der Darstellung des VIC 6567 (Video Interface Chip) über die Erklärung der Speicheraufteilung bis zum Anwendungsbeispiel wird Schritt für Schritt vorgegangen.

Für die praktischen Übungen wird nicht nur das Standard-Basic eingesetzt, sondern das von Diskette ladbare Extended Graphik System. Diese Erweiterung verändert den Speicher des Commodore 64. So werden beispielsweise neue Befehle implementiert, und der Videobereich verlegt. Nach dem Start des Graphik Systems beginnt der Basic-Speicher beispielsweise bei Speicherstelle 1024 (früher lag da der Bildschirm). Insgesamt bleiben dem Anwender 15,5 KByte für seine Programme. Das ist allerdings mehr, als die Zahl andeutet. Weder für einen neuen Zeichensatz noch für bis zu 175 Spritedaten geht etwas vom Basic-Speicher verloren. Weiterer Vorteil des Grafik-Systems ist es, daß der Bereich für Autostartmodule weiterhin verfügbar ist. Das bekannte Extended Basic Level II kann zur gleichen Zeit eingesetzt werden. Das Grafik System ersetzt die im Extended Basic weitgehend fehlenden Grafikbefehle.

Die Leistungsfähigkeit der neuen Grafikbefehle, die übrigens alle mit dem Vorsatz »CALL« aufgerufen werden, zeigen die mitgelieferten Hilfsprogramme. Dazu gehören Zeicheneditor, ein Spritegenerator und ein Grafikeditor. Mit dem Zeicheneditor ist es eine Leichtigkeit den Zeichensatz den persönlichen Wünschen anzupassen. Der Spriteeditor dient dem schnellen Entwerfen von Single- und Multicolor Sprites. Am leistungsfähigsten ist aber der Grafikeditor, mit dem eigene Hires-Grafiken hergestellt, beziehungsweise bestehende verändert werden können. Zum Befehlsvorrat des Grafikeditors gehören Funktionen zum Zeichnen von Kreisen, Linien, Rechtecken sowie die Einblendung von Texten in die hochauflösende Grafik. DerVorteil dieses Konzeptes ist die Flexibilität, denn eine Anpassung und Erweiterung der Hilfsprogramme ist jederzeit möglich.

Der fortgeschrittene Programmierer wird aber wahrscheinlich mehr am Graphik System interessert sein. Seine Erwartungen werden nicht enttäuscht, denn der Befehlsvorrat ist umfangreich und den gewachsenen Kenntnissen angepaßt. Die Schwerpunkte liegen bei der Farbgebung (Hires und Text), der Spriteverwaltung und -Bewegung (Single-und Multicolor) sowie der Unterstützung hochauflösender Grafik. Bis auf den Befehl zum Ausfüllen bestimmter Flächen (Fill) ist der Befehlsumfang komplett. Für ein flexibles Werkzeug wie das Extended Graphik System ist es fast schon eine Selbstverständlichkeit, daß Bilder von anderen Grafikprogrammen (Micropainter, Koala, Doodle) eingeladen und verarbeitet werden können. Zur Verarbeitung gehören alle Manipulationen am Bild einschließlich der Hardcopys auf einem grafikfähigen Drucker. Besonders sinnvoll ist die Fähigkeit auch Spriteformen auf allen Druckern auszugeben.

Nicht nur der Anfänger wird es schätzen, daß alle wichtigen Programme im umfangreichen Handbuch abgedruckt sind. Sinnvoller wäre es allerdings, diese Programme auf der ohnehin vorhanden Diskette mitzuliefern, zumal die Listings nicht immer fehlerfrei sind. Auf die vielen Beispielbilder für hochauflösende Grafik hätte statt dessen verzichtet werden können. Auch fehlt der Hinweis, daß Programme, die mit dem Graphik System entworfen wurden, auch nur mit diesem wieder gestartet werden können. Ein kleines Ladeprogramm schafft hier Abhilfe, indem das Graphik System jedesmal vor das betreffende Programm geladen wird. Weitergeben darf man diese Programme allerdings nicht, denn damit wäre das Urheberrecht verletzt.

Das Extended Graphik System ist auch für den fortgeschrittenen Programmierer ein sinnvolles Hilfsmittel. Zusammen mit Exbasic Level II ist es zwar nicht ganz billig, aber fast unschlagbar. Besonders lobenswert ist das Handbuch, das schrittweise in die Grafikprogrammierung einweist und noch nach mehrmaligem Lesen bei wichtigen Fragen herangezogen werden kann.

(Arnd Wängler/aa)

Bezugsquelle: Interface Age, Josephsburgstraße 6, 8000 München 80. Preis: 138 Mark.

# Viza Star – Ein Stern wird geboren – der Commodore 64

> Als erstes deutsches Computermagazin testeten wir Vizastar, die neue Datenbank-Tabellenkalkulations- und Geschäftsgrafiksoftware für den C 64.

In unserer letzten Ausgabe haben wir Vizawrite 64 vorgestellt, eines der leistungsfähigsten Textverarbeitungsprogramme für den C 64, wenn nicht sogar das leistungsfähigste überhaupt. Der Commodore 64 stößt damit in die Klasse der kleinen (aber vor allem preiswerten) Personal Computer vor. Zu den Fähigkeiten eines Personal Computer gehört aber mehr, als nur die Textverarbeitung. Drei der meistgebrauchten PC-Anwendungen sind die Datenverwaltung, die Tabellenkalkulation und die Geschäftsgrafik. Oft werden diese Funktionen in einem Programmpaket (zum Beispiel Lotus 1 2 3) kombiniert angeboten. So auch Vizastar 64. Bis auf die Textverarbeitung sind alle anderen Komponenten in Vizastar 64 vereinigt. Obwohl natürlich die Datenübertragung von einer Funktion in die andere (auch in die Textverarbeitung) möglich ist, soll hier zunächst auf die Leistungsmerkmale der einzelnen Funktionen eingegangen werden.

Vorab aber ein paar allgemeine Worte zu Vizastar 64 an sich. Geliefert wird das Programmpaket auf zwei Datenträgern, einem Modul und einer Diskette. Das Modul beinhaltet einen wesentlichen Teil des Steuerprogramms und lädt automatisch die restlichen Programmteile von der Diskette nach. Nach dem Laden kann die Programmdiskette weggelegt werden. Das gesamte Steuerprogramm (reine Maschinensprache) befindet sich im Speicher. Ab da wird nur noch mit Datendisketten gearbeitet. Die von Vizawrite 64 bekannten Einstellmöglichkeiten auf verschiedene Laufwerkskonfigurationen, die Farbgebung und den angeschlossenen Drucker sind auch in Vizastar 64 enthalten. Ein Centronics-kompatibler Drucker kann mit einem einfachen Userport-Kabel direkt angeschlossen werden, die Centronics-Treibersoftwa-re wird immer mitgeladen. Vizastar 64 unterstützt eine große Anzahl von Druckermodellen wie beispielsweise CBM, Epson, Juki und Brother. Zum Lieferumfang gehört ebenfalls ein 90-seitiges ausgezeichnetes deutsches Handbuch. Ein zusätzliches Übungsbuch, ist nach Auskunft des Herstellers, in Kürze erhältlich. Die getestete Vorab-Version verfügte über keinen deutschen Zeichensatz, in der endgültigen Version soll er aber enthalten sein. Auch die Benutzerführung von Vizastar 64 ist noch englisch, die Kommandos sind allerdings einfach und einprägsam.

## Die Tabellenkalkulation

Nach dem zirka 115 Sekunden dauernden Laden erscheint das Arbeitsblatt (Bild 1). Es ist wie ein richtiges Stück grafisches Papier aufgebaut. In den oberen drei Zeilen befinden sich die Menü- und Kommandohinweise. Die jeweils geltende Funktion wird revers. dargestellt. Durch Druck auf die »Space«-Taste wird von Menüpunkt zu Menüpunkt gesprungen. Die jeweiligen Unterfunktionen erscheinen in Zeile 2 und 3. Ein Arbeitsblatt besteht aus Zeilen (0 bis 999) und aus Spalten (A bis BL). Jede Spalte kann eine beliebige Breite zwischen 3 und 36 Bildschirmspalten haben. Das Arbeitsblatt ist natürlich viel zu groß um als Ganzes auf dem Bildschirm zu erscheinen. Deshalb ist immer nur ein Teil abgebildet. Mit den Cursortasten wird der Arbeitsblattausschnitt über den Bildschirm verschoben. Ein direkter Sprung an eine Adresse ist natürlich auch möglich. Manchmal wird es notwendig, an verschiedenen Punkten des Arbeitsblattes auf einmal zu arbeiten. Vizastar 64 bietet deshalb eine »Window«-Funktion (Bild 2) an, mit der beliebige Teile des Arbeitsblattes auf dem Bildschirm eingeblendet werden (bis zu acht Windows). Die »optisch« darunter liegenden Informationen gehen natürlich nicht verloren, sondern bleiben weiterhin im Berechnungsprozeß eingebunden. Die Schnittpunkte zwischen den Zeilen und Spalten nennt man Zellen (insgesamt 64000). Jede Zelle hat ihre eigene »Adresse«, so heißt beispielsweise die erste Zelle A0, die rechts daneben liegende B0. Die Zellen sind der kleinste Informationsträger. Hier werden Texte und Zahlen gespeichert. Da aber jede Zelle ihre eigene Adresse hat, sind die verschiedensten Verknüpfungen zwischen den einzelnen Zellen möglich. Das Ergebnis einzelner Berechnungen wird wiederum in vorher definierten Zellen abgelegt, beziehungsweise beeinflußt alle von diesem Ergebnis abhängigen Zellen. Ein Beispiel soll dies verdeutlichen: Nehmen wir an, Sie wollen die jährlichen Kosten Ihres Autos berechnen. Aber Sie wollen auch wissen, was passiert, wenn der Benzinpreis steigt, oder wenn Sie mehr Kilometer fahren. Diesen Sachverhalt nennt man in der Betriebswirtschaft »Entscheidungsfindung«. Sie erhalten Auskünfte über die Auswirkungen einzelner Maßnahmen in Abhänigkeit von vorgegebenen Werten und Bedingungen.

Bild 3 zeigt, wie so ein Kalkulationsblatt aussehen könnte. Feste Werte sind Anschaffung, Reparaturen und Zubehör. Alle anderen Werten werden von Vizastar 64 anhand von Verknüpfungsbedingungen errechnet. Der Wertverlust wurde im Jahr 1982 mit 15% vom Anschaffungspreis angegeben. Der Anschaffungspreis von 1983 ist natürlich der Restwert von 1982. Die Benzinkosten werden in Abhängigkeit von den gefahrenen Kilometern und dem Benzinpreis berechnet. Ändert man nun auf dem Arbeitsblatt eine der unabhängigen Zahlen, zum Beispiel die gefahrenen Kilometer verändern sich sofort die Benzinkosten, und die Gesamtkosten pro Jahr. In Bild 4 sieht man was geschieht, wenn der Benzinpreis auf 2 Mark und die gefahrenen Kilometer auf 15000 ansteigen. Vizastar 64 bietet eine große Anzahl von Verknüpfungsfunktionen (Bild 5), die für optimale Geschwindigkeit sorgen. Damit aber auch die Eingabe der Werte und Formeln einfach zu handhaben ist, stehen dem Benutzer umfangreiche Editierbefehle zur Verfügung. Sie reichen vom Einfügen und Löschen einzelner Zeilen/Spal-ten über das Sortieren von Reihen bis zum Kopieren und Verschieben ganzer Blöcke.

Ganz besonders leistungsfähige Funktionen sind die sogenannten EXEC-Befehle. Dieser Operationsmodus verwendet den Inhalt des Arbeitsblattes um die Tastatur zu simulieren. Sich wiederholende Befehlssequenzen (ähnlich einem Basic-Unterprogramm) können in Spalten innerhalb des Blattes eingetippt und zu jedem Zeitpunkt wiederholt ausgeführt werden. Zusätzliche EXEC-Befehle erlauben das bedingte Überspringen zu anderen Zellen. Imposantestes Beispiel für die EXEC-Befehle ist das auf der Systemdiskette mitgelieferte Demo-File, das einen kompletten Arbeitsablauf inklusive bewegter Grafik simuliert. Alle diese Funktionen werden mit unglaublicher Geschwindigkeit ausgeführt (man glaubt gar nicht wie schnell der C 64 sein kann). Das Abspeichern einzelner Arbeitsblätter zur späteren Verwendung ist für Vizastar 64 eine Selbstverständlichkeit. Damit sind die Anwendungsmöglichkeiten des Arbeitblattes natürlich bei weitem noch nicht ausgeschöpft. Aber gerade dank der Flexibilität der Arbeitsblattfunktionen ist es für jeden Anwender möglich, sich seine eigene Problemlösung zu kreieren. Vizastar 64 unterstützt ihn dabei mit seiner Leistungsfähigkeit und der sinnvollen Benutzerführung.

## Die Datenbank

Der zweite Bestandteil von Vizastar 64 ist die Datenbankfunktion. Die Operationen dieser Datenbank werden aufgerufen, als ob sie Teile des Kalkulationsprogrammes wären — was sie eigentlich auch sind. Vom Kalkulationsprogramm kann, ohne daß etwas nachgeladen werden muß, direkt in die Datenverwaltung und zurückgesprungen werden (inklusive Datentransfer). Das Arbeitsblatt verwandelt sich dabei zur frei definierbaren Karteikarte. Wie eine solche Karteikarte aufgeteilt aussehen könnte, zeigt Bild 5. Spezielle Zeichenbefehle ermöglichen den Einsatz des gesamten Commodore-Zeichensatzes. Die Eingabemaske kann somit extrem individuell gestaltet werden. Der Anwender ist nicht an eine Karteikarte gebunden, sondern kann einen einzelnen Eintrag über mehrere Karten ausdehnen. Auch ist die spätere Umgestaltung (Einfügen, Löschen) der einzelnen Karteikarten jederzeit möglich. Der grundsätzliche Aufbau der Datenbank ist mit dem Superbase 64 zu vergleichen. Grundsätzlich kann eine Viza-star 64-Datenbank aus bis zu 15 Einzeldateien bestehen. Ein Datensatz (Record) besteht aus bis zu 1000 Zeichen (Superbase 1108). Pro Satz sind 64 verschiedene Felder mit maximal 128 Zeichen pro Feld möglich (Superbase 127 Felder/255 Zeichen). Bei jedem Feld muß ein Indexschlüssel definiert werden, damitje-der einzelne Eintrag schnell aufgerufen werden kann. Ein Feld, das als Index-Schlüssel dient, hat eine maximale Länge von 30 Zeichen (Superbase 30). Da die Daten gemäß dem Schlüssel in alphabethischer oder numerischer Reihenfolge auf der Diskette geordnet sind, ermöglicht dieser Schlüssel beinahe den sofortigen Zugang zu jedem Datensatz innerhalb des Files. Die Zugriffszeit beträgt dabei im Durchschnitt nur 4 Sekunden pro Record. Die Anzahl der Datensätze (Records) findet bei Vizastar 64 ihre einzige Beschränkung in der vorhandenen Disketten-Speicherkapazität. Beim 1541-Lauf-werk kann beispielsweise eine Kundenkartei (Name, Adresse, Tel. Ansprechpartner, Datum) über 500 Datensätze enthalten. Sind zwei Laufwerke angeschlossen, oder die SFD 1002, erhöht sich die Anzahl der Datensätze. Hierbei sei angemerkt, daß der Anschluß der SFD 1001 nicht problemlos ist, da das Commodore IEEE-Interface den Einsatz eines zusätzlichen Moduls mit Autostart nicht zuläßt. Der Zugriff auf die einzelnen Daten eines Files wird mit dem ACCESS-Befehl ausgeführt. Dieser Befehl erlaubt es, jeden Eintrag nach Wünschen einzugeben, abzurufen zu ändern oder zu löschen. Die Auswahlkriterien können definiert werden, so daß nur die gewünschten Einträge ausgewählt werden.

Mit etwas Übung und Geschick dauert es mit Vizastar 64 nicht lange, eine Buchhaltung oder eine Lagerbestandskartei aufzubauen. Im privaten Sektor ist an Anwendungen wie eine Bücher- oder Adreßdatei zu denken. Alle Daten, auch die des Arbeitsblattes, können mit Vizastar 64 auch ausgedruckt werden. Dazu dienen zwei Funktionen. Wenn ein grafikfähiger Drucker angeschlossen ist genügen zwei Tasten um eine entweder 1:1 oder 1:2 Hardcopy auf dem Drucker auszugeben. Nicht grafikfähige Drucker tun das zwar auch, haben aber keine reversen Zeichen beim Ausdruck. Datensätze können in beliebiger Form, zum Beispiel als Adreßaufkleber auf fast jedem Drucker oder Schreibmaschine zu Papier gebracht werden.

Der dritte Bestandteil von Vizastar 64 ist die Geschäftsgrafik. Der Anwender hat hier die Wahl zwischen Balken- oder Liniendiagrammen (Bild 6 und 7). Die abzubildenden Werte lassen sich aus beliebigen Bereichen des Arbeitsblattes entnehmen. Mit Hilfe der. EXEC-Funktion sind sogar Änderungen bestimmter Werte im Zeitverlauf darstellbar. Die Trendanalyse (ein wichtiges betriebswirtschaftliches Instrument) wird somit ungemein erleichtert. Durch die oben besprochene Window-Technik ist auch eine optisch ansprechende Abbildung bestimmter Werte denkbar. Grafik, Zahlen und Kommentare können beliebig gemischt werden.

Fazit: Es gibt keinen Zweifel, Vizastar 64 ist eines der leistungsfähigsten Programme, — aus dem Bereich Datenbank und Tabellenkalkulation —, das bisher in unserer Redaktion getestet wurde. Es zeichnet sich nun auch bei den Heimcomputern — wie bereits bei den PCs seit einem Jahre — der Trend zur integrierten Software ab. Die genaue Beschreibung aller Befehle von Vizastar 64 würde den Rahmen bei weitem sprengen. Zusammen mit Vizawrite 64 ist Vizastar 64 die optimale Programmausstattung für den Commodore 64. Nicht nur der Privatmann, sondern gerade der kleine Unternehmer wird viele seiner täglichen Entscheidungen mit Vizastar 64 leichter und genauer beurteilen können. Der einzige Nachteil dürfte die geringe Kapazität von zirka 9 KByte für Daten sein.

Wie eine Commodore 64-»PC«-Konfiguration aussehen könnte, haben wir in Bild 8 darzustellen versucht. Es besteht aus dem C 64, einem Floppy-Laufwerk, einem Farbmonitor, einem Matrix- und Typenraddrucker sowie aus dem Viza-Paket. Der Preis für das gesamte System liegt bei zirka 6500 Mark (mit den beiden Druckern), wobei Vizawrite 64 und Vizastar 64 mit etwa 700 Mark beteiligt sind. Man könnte in Anbetracht der Leistungsfähigkeit schon fast von »billig« reden.

(Arnd Wängler/aa)

Deutschland: Interface Age, Josephsburgstr. 6, 8000 München 80
Bezugsquellen: Microton, Postfach 40, CH-2542 Pieterlen, Preis: 398,—

# Exodus – Ultima III

> Exodus, auch als Ultima III bekannt, ist die Fortsetzung zum vorhergehenden Verkaufshit »Ultima II«. Exodus ist ein Spiel, an dem man entweder ewig spielt oder verzweifelt: Zum Lösen des Spiels benötigt man zirka fünf Wochen — ein Tagespensum von 10 Stunden vorausgesetzt.

Ultima III ist zwar die Fortsetzung zu Ultima II, das man aber zum Spielen von Exodus nicht benötigt. Um die Handlung von Ultima III zu begreifen, muß jedoch auf die Geschichte des zweiten Teils zurückgegriffen werden:

Das Ziel des C-64-Spiels Ultima II war, den bösen »Minax« zu eliminieren. Als dieser schließlich starb (nachdem der Spieler Ultima II gelöst hat), herrschte im Lande schließlich 20Jahre lang Frieden. Doch die Horden des Bösen kamen wieder. Exodus, der Sohn des toten Minax, wählte den richtigen Augenblick, um das Land »Sosaria« erneut mit Tod und Verderben heimzusuchen. Ihre Aufgabe ist es nun, mit einer Gruppe von vier Abenteurern, das Land Sosaria vom Bösen zu befreien.

Sie sehen sich der Aufgabe gestellt, das Land zu erkunden und das Böse wo es auftritt zu zerstören. Das Endziel ist, Exodus zu finden und zu vernichten.

Zunächst wählt man unter seinen Charakteren vier »Adventurer« aus, mit denen man in eine Welt der Gefahren aufbricht. Zur Wahl stehen zehn verschiedene Charakterklassen (»Fighter, Paladin, Ranger, Barbar, Alchemist, Druid, Cleric, Wizard, Illusionist, Thief«), die man mit fünf verschiedenen Rassen kombinieren kann (»Human, Elf, Dwarf, Fuzzy, Bobbit«). Jede dieser Charakterklassen hat bestimmte Attributwerte: Ein Kämpfer hat seine Stärke, ein Zauberer seine Intelligenz, ein Dieb seine Geschicklichkeit, etc. Die Rasse ist mitentscheidend für die Maximalverteilung der Werte: Ein Zwerg kann seine Stärke auf bis zu 95 Punkte bringen, seine Geschicklichkeit jedoch höchstens auf 50. Die Maximalwerte für Menschen sind für alle Werte 75 Punkte. Zusätzlich steht Ihnen noch die Wahl des Geschlechts Ihrer Spielfiguren offen: Männlich, weiblich oder »other« (was das ist, dürfen Sie sich selbst überlegen).

Durch die geeignete Zusammenstellung Ihrer Charaktere und deren Attributwerte, sichern Sie sich also Ihr Überleben und den eventuellen Erfolg. Bei unglücklicher Auswahl der Charaktere, zum Beispiel lauter schwache Zauberer und nichts anderes, werden Sie sehr bald auch große Mißerfolge erleben müssen.

Wenn Sie in die weite Welt hinausziehen, begegnen Ihnen viele verschiedene Kreaturen, einige gut und viele böse. Sind die Kreaturen Ihnen freundlich gesinnt, so haben Sie die Möglichkeit, mit ihnen zu reden. Dabei können Sie oftmals nützliche Hinweise zur Lösung des Rätsels erfahren. Im Falle, daß Sie auf feindliche Monster stoßen, steht Ihnen meistens ein schwerer Kampf bevor.

Sie sind in diesem Kampf nicht nur auf Nahkampfwaffen oder Weitschußwaffen (zum Beispiel Pfeil und Bogen) beschränkt: Wenn Sie Ihre Spielcharaktere sorgfältig ausgewählt haben, können Ihre »Wizards« oder »Clerics« den Tod der Feinde mit machttollen Zaubersprüchen auch ein bißchen beschleunigen.

Im Verlauf des Spiels treffen Sie auf Städte, Dungeons (unterirdische Labyrinthe, in Exodus acht Stockwerke tief), Burgen und sogar ein »längst vergessenes Land«. Zusätzlich gibt es noch versteckte Städte, die man nur bei genau der richtigen Stellung des Mondes und durch Gehen in den richtigen Teleporter erreicht.

## Geduld ist nötig, aber es lohnt sich

In den Städten und Burgen gibt es fast sämtliche Ausrüstung zu kaufen, die man zur Bewältigung des Abenteuers benötigt (Rüstungen, Waffen, Essen, Pferde). Außerdem gibt es noch besondere magische und exotische Gegenstände.

Um den Schluß des Abenteuers erreichen zu können, benötigt man noch viele Hilfsmittel, die man im Laufe des Spiels ergattern muß, beispielsweise die »Mark of Fire«, mit der man ungeschoren durch Lava gehen kann.

Wer Ultima III lösen will, der benötigt viel Zeit und Geduld. Wer beides aufbringen kann, für den lohnt sich dieses Spiel, auch bei einem Preis von zirka 170 Mark.

Außerdem sollte man beachten, daß im Preis nicht nur die Spielediskette enthalten ist, sondern auch eine luxuriös aufgemachte Verpackung, in der sich einige Besonderheiten befinden: Eine auf Stoff gedruckte farbige Landkarte, Zauberspruchbücher für »Clerics« und »Wizards«, ein Heft mit der Geschichte der Entstehung des Landes und Informationen über Fauna und Flora (Monstercharakteristiken, Zeichnungen und Erläuterungen, Beschreibung der Städte etc.), und natürlich eine genaue Spielanleitung.

Exodus ist ein durchaus empfehlenswertes Spiel, das den Spieler auch über längere Zeit hinweg beschäftigen kann (außer er verzweifelt daran) und nicht so schnell langweilig wird.

(Manfred Kohlen/F.Wlodarczyk/aa)

PS: Wir werden auch weiterhin über interessante Fantasy- und Abenteuerspiele berichten, sowie Lösungshinweise zu besonders schwierigen Abenteuern bieten. Im Augenblick arbeiten wir an einer Lösung zu Encharter, die wir voraussichtlich in der Februar-Ausgabe veröffentlichen werden.Weitere Lösungsvorschläge zu besonders guten und besonders schwierigen Abenteuerspielen sind jederzeit willkommen.

# Abenteuer selbst gemacht

> Der »Adventure Creator« von Spinnaker macht es möglich: Der Abenteuer-Spieler kann in selbstprogrammierte Fallen tappen. Oder Freunde ganz schön ins Schwitzen bringen.

Den Begriff »Abenteuer-Spiel« beziehungsweise »Adventure« sollte man in Zusammenhang mit diesem Programm nicht falsch verstehen: Hier ist kein Spiel gemeint, bei dem man Kommandos wie »Go north« oder »Open door« eingibt. Bei »Adventure Creator« handelt es sich um einen sogenannten Abenteuerspiel-Generator, bei dem man sich verschiedene Szenen selbst aufbauen muß, durch die man sich dann mit Hilfe seines Joysticks durchkämpft.
Ganz Faule können den Marsch durch die Gänge und Zimmer natürlich auch dem Zufall überlassen. Der Computer bestimmt dann, auf welche Tücken der Spieler trifft. Das Programm wurde jedoch eigentlich dazu entwickelt, um sich eigene Abenteuerszenen aufzubauen. In diese Abenteuer kann man die verschiedensten Gegenstände einbauen: Geheimtüren, Fallen, Schatztruhen, heiße Wände,. . .
Von Schildern über Fackeln bis hin zu sogenannten »Hobbles« und »Nippers« kann man alles auflesen und mitschleppen.
In einem richtigen Abenteuerspiel sind natürlich auch die Feinde und Freunde nicht weit: Im Kreaturen-Laboratorium (frei übersetzt nach der englischen Anleitung) entwickelt man die Persönlichkeit und Eigenschaften der Monster. Zur Wahl stehen Kreaturen, die einem etwas geben oder etwas haben wollen, handeltreibende und als Teleporter fungierende, sowie Angreifer.
Bei Angriffen fließt übrigens überhaupt kein Blut. Das einzige, was passieren kann, ist der Verlust von Energie, aber auch Schlaffheit kann zum (friedlichen) Tod führen.
Wenn auf der Packung »ab 8 Jahren« steht, so ist dies durchaus richtig. Spinnaker Software ist bekannt dafür, Lernspiele für Kinder auf den Markt zu bringen. Das soll natürlich nicht heißen, daß Erwachsene nicht genauso viel Spaß daran haben können. Das Spiel fördert die Kreativität des Kindes, indem es ihm erlaubt, eigene Szenen des Adventures auf dem Bildschirm aufzubauen. Der Schwierigkeitsgrad des Adventures ist in einem Maße angelegt, das es auch Kindern ermöglicht, das Abenteuer erfolgreich durchzustehen. Allerdings bedeutet die natürlich, daß der geringe Umfang der Abenteuer Erwachsene schnell langweilt. Die Kinderfreundlichkeit des Programms geht also auf Kosten der älteren Computerfans.
Hier hätte Spinnaker ruhig mehr Fantasie aufbringen können, so daß auch Erwachsene nicht so schnell das Interesse verlieren. Das Spiel kostet schließlich 130 Mark. Eltern von acht- bis zwölfjährigen Kindern kann man dieses Spiel durchaus empfehlen — sofern sie die (einfache) englische Anleitung verstehen und ihren Kindern das Spiel erklären.
(M. Kohlen/F. Wlodarczyk/aa)

# Comal – eine Einführung – Teil 1

> Ist Ihnen Basic zu wenig leistungsfähig, Pascal zu ermüdend, Assembler zu primitiv und Forth zu merkwürdig ? Dann wird es Zeit für Comal.

Die Programmiersprache Comal ist keine ganz neue Sprache, wenngleich sie auch — ähnlich wie Forth — erst seit relativ kurzer Zeit in Europa kursiert. Comal (COMmon Algorithmic Language) wurde bereits 1973 von Borge R. Christensen und Benedict Loefstedt in Dänemark entwickelt, fand aber, wie viele andere Programmiersprachen, zunächst kein großes Echo. Ähnlich wie bei Forth bildeten sich aber bald in vielen Ländern nationale User-Groups, die sich für die Verbreitung und kontinuierliche Verbesserung der Sprache einsetzten.

Das im 64'er Magazin, Ausgabe 8/84, besprochene Comal ist die Version 0.14, das auch als Grundlage für diesen Einführungskurs dient. Comal 2.0 ist um einiges schneller und ist ein 52 KByte langes Programm. Dabei sind mehr als 30 KByte frei für eigene Programme. Das Modul selbst enthält 64 KByte ROM. In Dänemark wird es für umgerechnet 600 Mark angeboten und istdort fast an allenSchulen im Einsatz. Ältere Comal-Versionen als 0.14 (zum Beispiel 0.12) verfügen unter Umständen über eine Reihe von Befehlen nicht. Umgekehrt ist die Version 0.14 gegenüber der kommerziellen Version 2.0 mit einigen Nachteilenbe-haftet, zu denen vor allem der mit exakt 9902 Bytes nicht gerade üppig bemessene Speicherplatz gehört. Die Comal-Versionen 0.xx sind sogenannte »Public Domain Software«, dasheißt sie dürfen kopiert und weitergegeben, allerdings nicht kommerziell vertrieben werden. Der Sinn dieser auf den ersten Blick verblüffenden Freizügigkeit liegt in der gewünschten möglichst umfassenden Verbreitung der Sprache.

In letzter Zeit gewinnt Comal zunehmende Bedeutung als Alternative zur vergleichsweise primitiven Basic-Programmierung. Der Benutzer von Comal hat dabei gegenüber der Verwendung anderer Programmiersprachen den entscheidenden Vorteil, daß die Sprache stark an Basic angelehnt ist, daß aber die vielen Schwachpunkte von Basic überwunden wurden. Hinsichtlich des Konzeptes der strukturierten Programmierung wurden viele Anleihen bei Pascal gemacht, ohne jedoch dessen oft unnötig komplizierte und langatmige Sprachstruktur zu kopieren.

Doch damit noch nicht genüg. Jetzt wird es für den Besitzer eines C 64 erst richtig interessant (für den VC 20 ist Comal leider nicht erhältlich). Comal hat nämlich noch bei einer dritten Programmiersprache Anleihen gemacht, und zwar bei Logo. Damit stehen eine ganze Anzahl von sehr stark an Logo angelehnten Befehlen für hochauflösende Grafik zur Verfügung. Der große Vorteil dieser Befehle ist ihre einfache und übersichtliche Struktur. Es sind kaum Koordinatenangaben nötig, sondern es wird mit einer sogenannten »Turtle« gearbeitet.

Turtle ist die englische Bezeich-nung für »Schildkröte«. Dieser etwas ungewöhnliche Name stammt aus Logo, das ursprünglich als grafische Programmiersprache für Kinder entwickelt wurde. Die »Schildkröte« ist dabei ein Grafik-Cursor (bei Comal durch ein Dreieck dargestellt), der auf den gerade aktuellen Punkt im Grafik-Bildschirm zeigt. Die Turtle kann nun mit verschiedenen einfachen Befehlen bewegt werden. FORWARD n bewegt die Turtle um n Grafikpunkte vorwärts, BACK n bewegt sie rückwärts. LEFT w und RIGHT w drehen die Turtle um den Winkel w (in Grad) nach links oder rechts. HOME setzt die Turtle wieder auf ihre Ausgangsposition in der Bildschirmmitte.

Es existieren natürlich noch eine ganze Reihe weiterer Grafikbefehle und sogar etliche Befehle zur Spritesteuerung. Das kleine Demo-Programm (siehe Listing) zeichnet einige Quadrate mit zunehmender Seitenlänge auf den Bildschirm. An diesem Programm sind schon einige grundsätzliche Eigenschaften von Comal erkennbar, zum Beispiel die Programmstrukturierung und das Arbeiten mit Prozeduren. Wenn Sie Comal bereits zur Verfügung haben, dann geben Sie doch dieses kleine Programm einfach einmal ein und lassen sich überraschen.

Wir wollen uns an dieser Stelle jedoch noch nicht weiter mit Einzelheiten wie Prozeduren oder Funktionen beschäftigen, sondern uns dieses sehr umfassende Thema für später aufheben. Auch Comal-Grafik und Sprites werden wir ausführlich in einer der nächsten Folgen behandeln. Wir wollen stattdessen ganz am Anfang beginnen und uns etwas genauer damit beschäftigen, wie man denn nun Comal dazu bekommt, die grundlegenden Dinge wie Programm editieren, laden, speichern und drucken für uns zu erledigen.

## Das Arbeiten mit Comal

Kommen Sie mit Basic zurecht? Dann wird Ihnen auch das Arbeiten mit Comal keine Schwierigkeiten bereiten. Genau wie Basic ist auch Comal eine interaktive Sprache. Die meisten Befehle lassen sich auch im Direktmodus ausführen. Soll jedoch eine Programmzeile gespeichert werden, so setzt man einfach — wie von Basic bekannt — eine Zeilennummer davor.

Doch Vorsicht! Einige Unterschiede zu Basic gibt es schon beim Editieren eines Programms. Zum Beispiel dürfen in einer Comal-Zeile nicht mehrere Befehle stehen (der Doppelpunkt fungiert in Comal nicht als Trennzeichen zwischen zwei Befehlen, sondern hat verschiedene andere Funktionen). Auch ist es zum Löschen einer Programmzeile nicht ausreichend, nur die Zeilennummer einzugeben. Dafür gibt es den »DEL«-Befehl, mit dem man nicht nur einzelne Zeilen, sondern auch ganze Zeilenbereiche löschenkann. Die Syntax ist die gleiche wie bei »LIST«. »DEL 50-150« löscht also beispielsweise die Zeilen 50 bis 150. Der »LIST«-Befehl ist in Comal übrigens sehr komfortabel. Das Listen eines Programms läßt sich nämlich durch Drücken der Space-Taste anhalten. Ein zweiter Tastendruck, und das Listen wird fortgesetzt.

Zu beachten ist auch, daß Zeilennummern in Comal maximal vierstellig sein dürfen, sonst wird ein Syntax-Fehler angezeigt. Auch die Null ist als Zeilennummer nicht erlaubt.

Bei der Programmeingabe wird man sehr schnell eine wesentliche Eigenschaft von Comal kennen- und schätzenlernen, nämlich den sofortigen Syntax-Check. Alle fehlerhaften Programmzeilen werden bereits bei der Eingabe mit einer entsprechenden Fehlermeldung zurückgewiesen. Der Cursor blinkt dabei genau an der Stelle, an welcher der Fehler aufgetreten ist.

## Interpreter oder Compiler?

Comal führt die meisten Befehle im Direktmodus aus, die Programme werden einfach mit »RUN« gestartet —wie bei einem typischen Interpreter. Andererseits müssen Strings dimensioniert und Variablen vor dem ersten Aufruf einen definierten Wert besitzen — wie bei einem typischen Compiler.

In Wirklichkeit ist Comal keins von beiden — oder beides zur Hälfte, je nach Standpunkt. Das Handbuch spricht von einem »Three Pass Interpreter«, was möglicherweise der Wahrheit am nächsten kommt. Jedenfalls arbeitet Comal tatsächlich in drei Phasen. Die erste Phase kennen Sie bereits, wenn Sie schon Programmierversuche in Comal hinter sich haben. Es ist der Syntax-Check, der unmittelbar nach Eingabe einer Zeile ausgeführt wird. In dieser Phase wird die Programmzeile — ähnlich wie bei Basic — in eine kompakte Form umgewandelt, indem die Schlüsselwörter in Ein-Byte-Abkür-zungen, sogenannte Token, umgewandelt werden.

Der Syntax-Check funktioniert im Prinzip recht einfach. Bei jeder eingegebenen Zeile wird zunächst überprüft, ob die Zeilennummer im erlaubten Bereich von 1 bis 9999 liegt. Anschließend wird getestet, ob eine Kommentarzeile vorliegt. Ein Kommentar wird in Comal allerdings nicht mit »REM« eingeleitet, sondern mit zwei Schrägstrichen.Je-de Zeile, die mit »//« beginnt, wird daher nicht weiter beachtet. Alle anderen Zeilen durchlaufen jedoch die Routine »Text in Token wandeln«. Dabei wird ganz einfach überprüft, ob das erste Zeichen in der so codierten Zeile ein Token ist. Ein Token erkennt das Comal-System daran, daß in dem betreffenden Byte Bit 7 gesetzt ist; das funktioniert also völlig analog zu Basic.

Ist das erste Zeichen einer Zeile also weder das Kommentarsymbol noch ein Token, dann wird ein Syntax-Fehler gemeldet. Des weiteren wird einfach die Anzahl der öffnenden und schließenden Klammern einer Zeile gezählt. Ergibt sich eine Ungleichheit, dann resultiert das in einer Fehlermeldung. Eine kontextabhängige Syntaxprüfung findet jedoch nicht statt, das heißt, daß die Eingabezeile in dieser ersten Phase ohne Bezugzum Rest des Programms überprüft wird.

Sie können das Prinzip leicht selbst testen, indem Sie beispielsweise die folgende Zeile eintippen:
100 print sqr(2)

Wie zu erwarten, wird die Zeile widerspruchslos angenommen. Ändern Sie die Zeile jetzt doch einmal in
100 print xyz(2)

## So funktioniert der Syntax-Check

Auch diese Zeile wird widerspruchslos angenommen, da sie mit einem zulässigen Schlüsselwort (print) beginnt und die gleiche Anzahl öffnende wie schließende Klammern enthält. Warum erfolgt hier keine Fehlermeldung ? Es gibt doch gar keine Funktion »xyz(2)«. Wirklich nicht? Was wäre, wenn Sie vor dem Eintippen der Zeile kein »NEW« gegeben hätten, um ein eventuell vorher vorhandenes Programm zu löschen? Woher wollten Sie dann mit Bestimmtheit sagen können, daß es eine Funktion xyz nicht gibt? Außerdem handelt es sich möglicherweise gar nicht um eine Funktion, sondern um ein eindimensionales Feld. Sie merken schon, solange Sie nur diese eine Zeile kennen und vom eventuell vorhandenen übrigen Programm keine Ahnung haben, sind Sie in der gleichen Situation wie der Comal-Interpreter. Der behandelt nämlich bei einer Eingabe auch nur diese eine Zeile und beachtet den Rest des Programms nicht weiter. Daher gibt er in so einem Fall auch lieber keine Fehlermeldung aus, denn möglicherweise wurde vorher im Programm eine Funktion xyz definiert oder ein Feld xyz dimensioniert. Die eingegebene Zeile ist also in Wahrheit tatsächlich syntaktisch korrekt, denn auf eine Print-Anweisung kann ein beliebiger Ausdruck folgen, es muß nicht unbedingt eine der Standardfunktionen oder eine Konstante sein.

Die Überprüfung, ob alle Programmzeilen zusammen auch tatsächlich ein vernünftiges Programm bilden, erfolgt in einer zweiten Phase. Diese Phase wird mit dem Befehl »RUN« gestartet. Im Gegensatz zu Basic beginnt Comal nämlich nach »RUN« nicht unmittelbar mit dem Abarbeiten des Programms, sondern führt zunächst eine Überprüfung der Programmstruktur durch. Dabei wird zum Beispiel festgestellt, ob Schleifen richtig geschachtelt sind und beendet werden, ob jede aufgerufene Funktion und Prozedur auch tatsächlich definiert wurde und so fort. Bei der Gelegenheit werden gleich alle Sprungadressen berechnet und in eine parallel zum Programmtext angelegte Tabelle eingetragen.

Der Begriff »Sprungadresse« ist hier im weiteren Sinn zu verstehen, denn obwohl Comal über ein GO-TO-Statement verfügt, sollte dieses im Sinne einer übersichtlichen Programmstruktur nur in Ausnahmefällen verwendet werden. Mit Sprungadressen sind hier also auch »interne« Sprünge gemeint, zum Beispiel auf den Anfang einer Prozedur, wenn diese aufgerufen wird. Damit braucht der Comal-Interpreter beim späteren eigentlichen Programmlauf beispielsweise nicht mehr den gesamten Programmtext nach der Definition einer Prozedur oder Funktion zu durchsuchen, sondern findet die entsprechende Adresse viel schneller durch »Nachschlagen« in einer Tabelle.

## Fehlerhafte Programme werden gar nicht ausgeführt

Dieser Vorgang der Ersetzung von symbolischen Adressen (Prozedur-, Funktions-, Variablen- und Labelnamen) durch die tatsächlichen Adressen dieser Objekte im Speicher ist eine der wesentlichen Aufgaben eines Compilers. Insofern hat Comal also tatsächlich Compiler-Eigenschaften. Allerdings werden zum Beispiel arithmetische Ausdrücke nicht in eine andere, maschinennahe Form übersetzt, wie das bei einem »richtigen« Compiler der Fall wäre. Auch findet keinerlei Übersetzung in Maschinensprache statt, so daß es tatsächlich falsch wäre, von einem Compiler zu sprechen.

Nachdem alle Überprüfungen und Übersetzungen abgeschlossen sind, beginnt schließlich die dritte und letzte Phase der Interpretation, nämlich der eigentliche Programmlauf. Diese Phase wird automatisch eingeleitet, wenn in Phase zwei kein Fehler aufgetreten ist. Für den Benutzer sind die Phasen zwei und drei daher in der Regel nicht zu unterscheiden. Daß es sie aber wirklich gibt, kann man mit einem kleinen Testprogramm sehr einfach feststellen:
10 print "hier ist Zeile 10"
20 //
30 // es folgt ein Fehler
40 // in der Programmstruktur
50 //
60 endif

In Zeile 60 steht das Schlüsselwort für das Ende eines If-Blocks, aber nirgends vorher taucht ein »if... then« auf.

Ein reiner Interpreter — wie Basic — würde nach »RUN« die Meldung »hier ist Zeile 10« auf den Bildschirm schreiben und erst anschließend feststellen, daß hier ein endif ohne if vorliegt. Lassen Sie aber dieses kleine Programm einmal in Comal laufen und sehen Sie selbst, was passiert. Nach »RUN« wird die Print-Anweisung in Zeile 10 nicht ausgeführt, sondern erst einmal Phase zwei gestartet und das Programm überprüft. Dabei wird der Fehler gefunden, und es erscheint eine entsprechende Meldung. Phase drei, nämlich die eigentliche Programmausführung, wird wegen dieses Fehlers gar nicht erst erreicht.

Phase drei wird überhaupt nur gestartet, wenn ein Hauptprogramm vorhanden ist. Besteht der gesamte Programmtext nur aus Funktionsoder Prozedurdefinitionen, dann wird nach »RUN« ebenfalls nichts ausgeführt. Allerdings können nun — und das ist ganz wesentlich — alle im Programm definierten Funktionen und Prozeduren im Direktmodus aufgerufen werden.

Das ist eine Eigenschaft von Comal, die für den Benutzer von großer Wichtigkeit ist. Denn damit kann, wie sonst in dieser Form nur bei Forth, Logo oder Lisp möglich, der Sprachumfang fast beliebig erweitert werden. Benötigen Sie zum Beispiel eine Funktion, ähnlich wie PEEK, die aber nicht nur ein Byte, sondern ein 16-Bit-Wort aus dem Speicher liest? Kein Problem. Geben Sie im Direktmodus NEW ein und danach die folgenden Programmzeilen (Sie können sich das Tippen der Zeilennummern sparen, wenn Sie zuvor den Befehl »AUTO« eingeben):
10 func deek(x)
20 wert := peek(x) + 256*peek(x +1)
30 return(wert)
40 endfunc deek

Bei diesem Vierzeiler handelt es sich um die Definition einer Funktion »DEEK« mit einem Parameter. In Zeile 20 werden die nötigen Berechnungen ausgeführt. Das Schlüsselwort »RETURN« in Zeile 30 hat eine andere Bedeutung als in Basic. Es besagt, daß die Funktion als Ergebnis des Funktionsaufrufes den Wert der Variablen »WERT« zurückliefern soll. Mit »ENDFUNC DEEK« schließlich wird dem Comal-Interpreter das Ende der Funktionsdefinition angezeigt. Nach »RUN« erfolgt sofort die Meldung »END AT 0040«, und der Comal-Sprachschatz ist um die Funktion »DEEK« erweitert. »PRINT DEEK(209)« zeigt beispielsweise die Speicheradresse des Beginns der aktuellen Bildschirmzeile an.

Doch damit zunächst einmal genug über die Arbeitsweise des Comal-Interpreters. Wenden wir uns nun einigen wichtigen Kommandos zu, die das Arbeiten mit Diskette, Kassette und Drucker ermöglichen.

## Wie kommt das Programm auf die Diskette?

Nehmen wir einmal an, wir hätten gerade unser erstes kleines Testprogramm in Comal geschrieben. Natürlich wollen wir unser Erstlingswerk gerne der Nachwelt erhalten. Doch wie bekommen wir das Programm auf die Diskette (oder auch auf die Kassette)? Etwa mit SAVE, wie in Basic? Ja, genauso.

Wie bereits zu Anfang erwähnt, ist Comal stark an Basic angelehnt (siehe Tabelle 1). Die Befehle »LOAD« und »SAVE« dienen zum Laden und Speichern von Programmen. »VERI-FY« steht leider in der Comal Version 0.14 noch nicht zur Verfügung. Dafür gibt es aber zusätzlich den »CHAIN«-Befehl, der ein Programm von Diskette lädt und automatisch startet. Im Unterschied zu Basic ist Comal allerdings diskettenorientiert, das heißt Sie können sich das lästige »,8« sparen. Soll allerdings statt auf Diskette auf ein Kassettenlaufwerk zugegriffen werden, so muß die Sekundäradresse 1 angegeben werden.

Zur einfacheren Bedienung der Floppy ist in Comal der Befehl »PASS« vorgesehen, der einen Kommandostring an die Floppy sendet. Soll zum Beispiel eine Diskette neu initialisiert werden, dann braucht nicht erst umständlich der Kommandokanal geöffnet werden, sondern es reicht der Befehl »PASS "I"«. Die Systemvariable »STATUS$« enthält immer den Fehlerstatus der Floppy, und zwar im Klartext. Wem das Eintippen von »PRINT STATUS$« noch zu mühselig ist, der kann auch nur »STATUS« eintippen. Comal versteht dann schon, was gemeint ist.

Erheblich komfortabler als in Basic ist auch das Laden des Directory. Einfach »CAT« (für catalog) eingeben, und das Inhaltsverzeichnis der Diskette wird angezeigt, und zwar ohne das Programm zu zerstören.

Neben »LOAD« und »SAVE« gibt es noch zwei weitere Lade- und Speicherbefehle. »LIST "name”« legt ein Comal-Programm als sequentielles File aufDiskette ab. Mit »ENTER "na-me” «wird ein solches sequentielles File wieder als Comal-Programm eingelesen.

Was ist der Unterschied zwischen diesen beiden Formen des Abspeicherns? Die Antwort darauf mag der eine oder andere schon von Basic her kennen. Der Comal-Befehl »LIST "name"« hat die gleiche Wirkung wie die Basic-Befehlsfolge »OPEN 1,8,1, "name,s,w"« : CMD 1 : LIST : CLOSE 1«. Anschließend existiert in beiden Fällen auf der Diskette ein sequentielles File, das das entsprechende Basic- oder Comal-Programm als reine ASCII-Zeichen-folge, also ohne Token, enthält.

Das kann durchaus nützlich sein, weil man ein solcherart gespeichertes Programm sehr leicht und ohne Kenntnis der speziellen Befehlstoken weiter bearbeiten kann. Auf der Comal-Diskette befindet sich zum Beispiel ein Demo-Programm »FOR-MATTER.COM«, mit dessen Hilfe sich solche sequentiellen Files formatiert auf dem Drucker listen lassen, wobei alle wichtigen Parameter eingestellt werden können.

Zum Laden mit »ENTER« gibt es kein einfaches Basic-Äquivalent, sondern dort muß man schon ein kleines Programm schreiben. In Comal dient der »ENTER«-Befehl dazu, ein sequentielles File zu lesen und dabei wieder in »normalen« Comal-Text mit Token-Codierung umzuwandeln.

Natürlich wäre es einigermaßen lästig, wenn man Programmlistings nur auf solchen verschlungenen Pfaden auf dem Drucker ausgeben könnte. Aber Comal wäre nicht Comal, wenn nicht alles etwas einfa-cher.ginge als in anderen Sprachen. Da ein Umschalten zwischen Bildschirm- und Druckerausgabe oft gebraucht wird, gibt es in Comal einen speziellen Befehl dafür: Mit »SELECT OUTPUT "gerät" « kann das gewünschte Ausgabegerät gewählt werden. Die Angabe des Schlüsselwortes »OUTPUT« ist dabei nicht unbedingt notwendig. Für »gerät« gibt es zwei Möglichkeiten: »LP:« (Line Printer) für Druckerausgabe, »DS:« (Data Screen) für Ausgabe auf den Bildschirm.

Um also ein Listing auf den Drucker auszugeben, gibt man nacheinander die beiden folgenden Befehle ein:
SELECT "LP:”
LIST

Nach dem LISTen wird übrigens automatisch wieder auf Bildschirmausgabe umgeschaltet.

Damit sind alle wichtigen Befehle behandelt worden, um Comal-Programme vernünftig editieren zu können. In der nächsten Folge werden wir uns (endlich) dem eigentlichen Programmieren in Comal zuwenden.

(ev)

# Turtle-Grafik – Die schnelle Schildkröte

> Turtle-Grafik ist eine Spracherweiterung, die es in sich hat. Vollständig in Maschinensprache geschrieben stellt sie einige Befehle zur Verfügung, mit denen Sie komfortabel sehr schnell Bilder erzeugen können.

Wenn Sie dieses Programm abtippen, werden Sie keinen Ärger mit den vielen DATAs bekommen. Haben Sie einen falschen Wert eingegeben, weist Sie die eingebaute Prüfsummenroutine auf die fehlerhafte Zeile hin und listet sie am Bildschirm. Bitte halten Sie sich daher an die Zeilennumerierung. Nach der Eingabe sollten Sie das Programm speichern und erst dann starten. Wenn alles ok ist, empfehle ich Ihnen, das Demoprogramm (Listing 2) einzugeben. Es vermittelt Ihnen einen sehr guten Eindruck von den Fähigkeiten der Grafikerweiterung. Doch nun zur Turtle-Grafik selbst.
Das Programm ermöglicht die Programmierung von hochauflösender Grafik in Basic mit neuen leistungsfähigen Befehlen. Wird das Programm gestartet, meldet es sich mit: TURTLE GRAPHICS
BY PETER MENKE
38911 BASIC BYTES FREE

Nun sind alle Funktionen und Befehle des Programms fest in Basic eingebettet und bleiben bis zum Ausschalten erhalten.
Das Programm unterstützt die Programmierung zweier voneinander völlig unabhängiger Bildschirme:

1.	Den normalen Textbildschirm
2.	Den Grafikbildschirm auf dem die hochauflösende Grafik erscheint.

Zwischen den beiden Bildschirmen können Sie mit der Funktionstast1 Fl hin- und herschalten. Der neue Befehl HIRES1 schaltet den Grafik-Bildschirm ein (HIRES 0 = ausschalten).

Im folgenden die Befehle im Einzelnen

### HIRES1 hi, ra

hi = Hintergrundfarbe (0-15)
ra = Randfarbe (0-15)
Die Angaben für Hintergrund und/oder Randfarbe sind nicht unbedingt notwendig, die alten Farben werden dann beibehalten.

### CLEAR

Dieser Befehl löscht den gesamten Grafikbildschirm.

### REVERS

Dieser Befehl invertiert den gesamten Grafikbildschirm.

### COLOR pu, hi, ra

Die Farben der hochauflösenden Grafik werden neu definiert (pu = Punktfarbe). Wie beim HIRES-Befehl können auch hier die Angaben für hi und/oder ra entfallen.

### GSAVE »Name«, Gerätenummer

Speichert eine erzeugte Grafik ab.

### GLOAD »Name«, Gerätenummer

Lädt eine vorher gespeicherte Grafik in den Computer.

Wenn Sie den Grafikbildschirm einschalten, sehen Sie in der Mitte des Bildschirms einen blinkenden Punkt: Den Grafikcursor (oder »Turtle«, zu deutsch »Schildkröte«),

Durch Bewegen dieses Grafikcursors können Sie Linien auf dem Bildschirm zeichnen.

### DEG wi

Bestimmt die Bewegungsrichtung der Turtle. Acht Richtungen sind möglich (»wi« kann Werte zwischen 0 und 7 annehmen).

TODO
2
3	1
4	* 0
5	7
6

### MOVEx

Move bewegt die Schildkröte um x Punkte.

Der HIRES-Befehl positioniert den Grafikcursor automatisch auf die Bildschirmmitte. Der eingestellte Winkel ist 0. Außerdem wird Modus 0 eingeschaltet (siehe MODE).

### LTURNx(x max.=255)

Dreht den Grafikcursor um x Einheiten nach links.

### RTURN x (x max.=255)

Dreht den Grafikcursor um x Einheiten nach rechts.

### PLOT x-cor, y-cor

Setzt den Grafikcursor auf eine bestimmte Bildschirmposition. Die obere linke Ecke des Bildschirms hat die Koordinaten 0,0; die rechte untere 319,199.

### MODE m (m max 4)

Bei den Befehlen MOVE und PLOT kennt das Programm 4 Modi.
0 = Punkt setzen
1 = Punkt löschen
2 = Punkt invertieren
3 = nichts verändern Normalerweise ist Modus 0 eingeschaltet. Mit dem MODE-Befehl läßt sich dies ändern.

## Gleichzeitige Darstellung von Text und Grafik

Das Programm teilt den Bildschirm in einen Text- und in einen Grafikteil.

Betätigt man bei eingeschaltetem Grafikbildschirm die F3-Taste, so wird im unteren Teil des Bildschirms der untere Teil des normalen Textbildschirms eingeblendet.

Bei nochmaligem Betätigen dieser Taste wird das »Textfenster« wieder ausgeblendet.

### WINDOW 1

Schaltet Textfenster ein.

### WINDOW 0

Schaltet Textfenster aus.

Mit der Taste F5 wird der Cursor (der normale) in die obere linke Ecke des Textfensters gebracht. Dies entspricht der HOME-Taste für den gesamten Bildschirm. Die F5-Taste läßt sich ebenso programmieren wie die HOME-Taste, das heißt mit PRINT ”(F5)” (auf dem Bildschirm erscheint ein reverses Grafikzeichen) läßt sich der Cursor in die obere linke Ecke des Textfensters bringen.

### JOYSTICK ve

(ve=Verzogerung. Mit ve = 0 malt man am schnellsten, mit ve = 255 am langsamsten.)

Dieser Befehl erlaubt das Zeichnen von Bildern mit dem Joystick (Port 2). Mit dem Joystick kann der Grafikcursor bewegt werden. Druckt man gleichzeitig den Feuerknopf, wird entsprechend dem eingestellten Modus ein Punkt gesetzt, gelöscht etc. Nun können beliebige Bilder gezeichnet werden, solange, bis mit der F7-Taste mit der Programmabarbeitung fortgefahren wird.

### LPEN

Dieser Befehl erlaubt das Zeichnen von Bildern mit dem Lightpen (Port 1). Ini Prinzip gilt das gleiche wie beim JOYSTICK-Befehl, nur daß hier statt des Feuerknopfes die CTRL-Taste beziehungsweise der Knopf am Lightpen benutzt wird. Man verläßt den Lightpenmodus mit F7.

Alle Befehle können unabhängig vom Einschaltzustand des Grafikbildschirms angewendet werden. Sie lassen sich auch wie normale Basic-Befehle abkürzen.

Die Funktionen und Anwendungen des Programms und seiner Befehle sind sehr gut in dem Programm »TURTLE DEMO« demonstriert (Listing 2).

(Peter Menke/gk)

Die drei auf Seite 49 genannten Möglichkeiten haben jedoch alle große Nachteile: Sie sind alle entweder zu langsam (1. und 3.), die Befehle lassen sich nur im Direktmodus anwenden (2.) oder sie können nicht abgekürzt werden. Deshalb wurden die Befehle mit sehr komplexen Routinen voll als Tokens integriert. Aus diesem Grund wurde die Interpreterschleife, die Routine zur Umwandlung in Interpretercode und die Routine zur Rückumwandlung in Klartext verändert. Die Vorteile dieser Arbeitsweise sind, daß sich die neuen Befehle wie normale Basic-Befehle anwenden lassen und daß nur minimale Geschwindigkeitsverluste bei der Ausführung von Basic-Programmen in Kauf genommen werden müssen. Ähnliche Methoden verwenden übrigens auch professionelle Basic-Erweiterungen, wie zum Beispiel Simons Basic.
Ein solches »Anzapfen« von Betriebssystem- und Basic-Routinen wird beim C 64 durch zahlreiche Sprungvektoren ermöglicht, die verändert werden können. Dies ist leider nicht bei allen Computern so gut möglich. Die hier benutzten Vektoren sind:

TODO

Das Wissen über die Programmierung des Programms ist für dessen Anwendung nicht nötig. Doch nun viel Spaß mit Turtle Grafik.

(Peter Menke/gk)

## Der Programmierer der Schildkröte

Geboren wurde ich am 3.1.1968 in Lüneburg. Meine erste Begegnung mit dem Computer fand am dortigen Gymnasium statt. Än einem heute schon fast fossilen CBM 4016 lernte ich Basic. Kurz nachdem der Commodore 64 auf den Markt kam, erstand ich ein Gerät für sage und schreibe 1298 Mark (Wucher!!). Wegen seines schwachen Basics lernte ich bald Maschinensprache. Doch das bloße Programmieren von Videospielen befriedigte bald nicht mehr. So stürzte ich mich in die Tiefen des Basic- und Betriebssy-stem-ROMs, um eine Ba-sic-Befehlserweiterung zu schreiben. Eins der besten und umfangreichsten Ergebnisse: Diese Turtle-Grafik.

(Peter Menke/gk)

---
TODO

Das Programm beginnt mit Titel und Autorenanschrift. Das GOSUB in Zeile 260 dient nur zur Suche von Syntax-Fehlern in den DATA-Zeilen. Im Programmteil »Variable« ab Zeilennummer 290 wird der Variablen AN die Startadresse des Maschinenprogramms zugewiesen, der Variable ZI die Endadresse. In NA$ steht der Programmname. Die eigentliche Einleseroutine (ab Zeile 350) funktioniert folgendermaßen: Es werden in einer Schleife die ersten 16 Zahlen aus einer jeden DATA-Zeile gelesen und in den Speicher gePOKEt. Gleichzeitig wird aus den gelesenen Daten eine Prüfsumme gebildet. Diese Summe wird mit der letzten Zahl in der DATA-Zeile verglichen, dies ist die richtige Prüfsumme. Unterscheiden sich die beiden Zahlen, so wurde ein Tippfehler gemacht und die fehlerhafte Zeile wird vom Programm automatisch geLI-STet. Außerdem wird geprüft, ob eine Zeile vergessen wurde (Zeile 517-520) und ob die Anzahl der Daten richtig ist (Zeile 530-537). Zusätzlich wird noch getestet, ob die gelesene Zahl auch zwischen 0-255 liegt (Zeile 391). Ist dies nicht der Fall, wird eine Fehlermeldung ausgegeben (Zeile 503-505). Ursache ist wahrscheinlich ein Kommafehler. Wurde kein Fehler gefunden, so fragt das Programm, ob es sich selbst abspeichern soll (davon sollte bei der ersten Benutzung des Programms unbedingt Gebrauch gemacht werden, Zeile 546-580). Danach wird das Maschinenprogramm gestartet (Zeile 590-610). Trotz der Prüfsummen ist ein Fehler in den DATAs nicht völlig ausgeschlossen. Vertauschungen werden zum Beispiel nicht bemerkt. Solche Fehler sind jedoch sehr unwahrscheinlich.

Diese Art der Überprüfung von DATA-Werten sollten Sie sich genau ansehen. Sie erleichtert der Redaktion und vor allem den Lesern die Eingabe und Überprüfung großer Zahlenkolonnen. Falls Sie uns Programme einschicken wollen, dann nehmen Sie sich doch auch bitte etwas Zeit und fügen eine komfortable Prüfroutine in Ihre Programme ein.

### Programmierung

a) Speicheraufteilung:
Das Video-RAM steht ab $0400. Der Hires-Speicher wurde hinter $ CC00 gelegt, das Hires-Farb-RAM nach C800. Das Programm selbst beginnt bei $C000 und endet bei $C88B. Programmvariable liegen im Bereich vor $CC00.
b) Die Belegung der Funktionstasten wird durch ein »Anzapfen« des Interrupt ermöglicht. Die Funktion PRINT ”(fs)” wird durch Verändern der BSOUT-Routine erreicht.
c) Das Textfenster:
Wie Sie wissen, wird das Bild auf dem Fernseher (Monitor) durch einen Elektronenstrahl erzeugt, der den Bildschirm zeilenweise von oben nach unten abfährt. Der VIC bietet nun die Möglichkeit bei einer bestimmten Zeilenposition einen Interrupt auszulösen. Diese Fähigkeit des VIC wird ausgenutzt. In der dann ausgeführten Interruptroutine wird zwischen Hires- und Textmodus hin und her geschaltet, so daß der Bildschirm in ein Text und ein Grafikfenster eingeteilt wird.
d) Die neuen Befehle:
Es gibt zahlreiche Möglichkeiten, neue Basic-Befehle zu implementieren. Anzapfen der
1. CHRGET-Routme (DOS 5.1)
2. Eingabe-Warteschleife (Toolkits)
3. Interpreterschleife (beschrieben im 64 Intern)

TODO TODO TODO Fortsetzung auf Seite 55

# Schachmeister

> Viele Schachspieler zeichnen ihre Partien auf und überprüfen sie hinterher. Oder sie spielen berühmte Partien nach. Der C64 übernimmt nicht nur die Rolle des Protokollanten — er splelt mit Hilfe dieses Programms gespeicherte Partien mit guter grafischer Darstellung nach.

Nach dem Start dös Programms muß man einen Augenblick warten, bis der Computer die neuen Multi-color-Zeichen definiert hat und diverse Felder und Listen aufgestellt hat (zirka 20 Sekunden). Darauf kann man eine der gespeicherten Partien auswählen und das Schachbrett baut sich auf.

Am rechten Rand werden dieNamen der Spieler, das Jahr, die Zugnummer und der Zug sowie verschiedene Meldungen wie »Schach«, »Matt«, »Rochade« ... ausgegeben. Das Schachbrett nimmt zirka % des Bildschirms ein.

Durch Drücken der F7-Taste nach einem Zug wird das Bild bis zu einem erneuten Tastendruck »eingefroren«. Durch Drücken einer anderen Taste nach einem Zug wird der Ablauf beschleunigt. Durch anhaltendes Drücken der Space-Taste kann man so eine Art »Blitzschach« erreichen. Nach Spielende führt ein Ta-stendruck wieder zum Auswahlmenü.

Eingeben eigener Schachpartien:
1.	Zuerst werden die Namen der Spieler und das Jahr eingegeben:
10000 DATA SPIELER 1', SPIELER 2, 1984.
2.	Die Eingabe der Züge: Beispiel für einen normalen Zug: 10010 DATA E2E4, E7E5, G1F3 ...
Wenn eine Figur eine gegnerische schlägt, braucht man das nicht anzugeben; der Computer erkennt das von selbst.
3.	Sonderregeln:
■ Aufgabe eines Spielers: 10020 DATA ...,SA (Schwarz gibt auf) 10020 DATA WA (Weiß gibt auf)
■ Rochaden: 10020 DATA KR (kurze Rochade) 10020 DATA LR (lange Rochade)
Es braucht nicht angegeben zu werden, welcher der beiden Spieler rochiert.
■ Schach, Matt, Remis:
Um dem Computer einen dieser drei Zustände anzuzeigen, muß ein S (Schach), ein M (Matt) oder ein R (Remis) dem jeweiligen Zug angehängt werden:
10020 DATA ..., D6E6S (Schach wird geboten) 10030 DATA ..., F6E6M (Schachmatt)
10020 DATA ..., E5E6R (Remis)
■ Dametausch:
Wenn ein Bauer in eine Dame umgetauscht wird, so ist dem jeweiligen Zug ein D anzufügen:
10020 DATA .... A7A8D (weißer Bauer wird in Dame getauscht)
Wichtig:
Nach Ende jeder Partie muß unbedingt ein E angefügt werden, damit der Computer eine Liste der Partien aufstellt. Nach der letzten Partie ist statt dem E ein X anzufügen:
19999 DATA ...,F6E6M,E
19999 DATA ...,F6E6M,X

Die Programmlänge ohne gespeicherte Partien beträgt zirka 7,5 KByte pro gespeicherter Partie werden zusätzlich zirka 0,5 KByte benötigt.
Da der Bildschirmspeicher verschoben wird, muß nach einem RUN STOP-RESTORE blind RUN einge-tippt werden, um das Programm wieder auflisten zu lassen.

(Thomas Behrend/rg)

## Der Schachmeister und sein Programm

Ich bin 16 Jahre alt und gehe in die 11. Klasse eines Ulmer Gymnasiums. Seit Weihnachten '83 besitze ich einen Commodore 64; sein Vorgänger war ein ZX81.
Das Programm:

Der Computer spielt berühmte oder weniger berühmte Schachpartien vor, die man leicht selbst einprogrammieren kann, so daß man sich mit der Zeit eine richtige Sammlung aufbaut. Besonderer Wert wurde auf eine gute Multicolor-Grafik gelegt.
Entstehungsgeschichte:

Das Programm entstand aus einer spontanen ,Idee heraüs. In Büchereien findet man unzählige Bücher mit aufgeschriebenen Schachpartien, die manauf einem Brett nachspielen kann, was aber nicht unbedingt jedermanns Sache ist, und außerdem ist die Gefahr groß, daß man sich verschaut und einen Fehler macht. Da müßte es doch viel einfacher sein, wenn der Computer dies übernehmen würde. In zirka einwöchiger Arbeit entstand so das vorliegende Programm.

Wesentlich Merkmale und Vorzüge des Programms:
– Multicolorgrafik, die sich zum Beispiel hinter »Grandmaster« nicht zu verstecken braucht.
— alle wichtigen Schachregeln sind berücksichtigt (zum Beispiel Rochaden, Dametausch, Matt, Remis ...) — jeder Benutzer kann seine eigenen Partien eingeben und mit dem Programm speichern (maximal 20)
— das Bild kann jederzeit »eingefroren« werden
— der Programmablauf kann beschleunigt weiden.

(Thomas Behrend)

# Ohne gutes Werkzeug geht es nicht: SMON – Teil 1

> In mehreren Teilen möchten wir Ihnen einen Maschinensprachmonitor vorstellen. Parallel zum Kursus über Assembler-Programmierung wird Schritt für Schritt ein Programm entstehen, das sich durchaus mit kommerziellen Monitoren messen kann.

Ich kann mich noch gut an unsere ersten Schritte in die Maschinensprache erinnern. Ausgerüstet mit einer Befehlsliste für den 6502 und einem in Basic geschriebenen »Mini-Monitor« entstanden Programme, die 3 und 5 addieren und das Ergebnis im Speicher ablegen konnten. Dazu mußten wir die Befehlcodes aus der Liste heraussuchen und dann in den Speicher »POKEn«. Jeder Sprung mußte von Hand ausgerechnet werden, jeder falsch herausgesuchte Befehl führte zum Programmabsturz. Der erste Disassembler — ein Programm zur Anzeige der Maschinenbefehle in Assemblersprache — war für uns die Offenbarung. Von nun an konnten wir Maschinenprogramme analysieren und daraus lernen. Zum Verständnis der Maschinensprache ist es nämlich noch weit mehr als bei anderen Sprachen wichtig, vorhandene Programme zu verstehen und sich dabei die wichtigsten Techniken anzueignen.

Mit der Zeit wuchsen unsere Ansprüche, ein Assembler mußte her, um die neugewonnenen Erkenntnisse auch auszuprobieren. Das war zuerst wieder ein Basic-Programm, langsam und wenig komfortabel, aber immerhin. Wir schrieben unsere ersten kleinen Routinen, vor allem, um vorhandene Maschinenprogramme unseren eigenen Wünschen anzupassen. Mit dem AMON für den VC 20 bekamen wir dann einen Monitor, der (fast) alle unsere Wünsche erfüllte. Als wir jedoch auf den C 64 umstiegen, mußten wir feststellen, daß es für diesen Computer nichts gab, das uns zufriedenstellen konnte. Der einzige Ausweg: Selbst programmieren. So entstand im Laufe eines Jahres SMON. Ursprünglich hatten wir nur vor, die Funktionen von AMON für den C 64 zu programmieren, aber dabei blieb es nicht. Immer neue Befehle und Routinen kamen hinzu, bis wir endlich zufrieden waren.

## Was bietet SMON?

Zunächst ist alles enthalten, was zum »Standard« gehört: Memory-Dump, also die Anzeige des Speicherinhalts in Hexbytes, mit Änderungsmöglichkeiten, ein Disassembler mit Änderungsmöglichkeit sowie Routinen zum Laden, Abspeichern und Starten von Maschinenprogrammen. Darüber hinaus gibt es einen kleinen Direktassembler, der sogar Labels verarbeitet, Befehle zum Verschieben im Speicher mit und ohne Umrechnen der Adressen und Routinen zum Umrechnen von Hex-, Dezimal- und Binärzahlen. Der besondere Clou von SMON liegt aber zweifellos in seinen leistungsfähigen Suchroutinen und vor allem im Trace-Modus. Damit lassen sich Maschinenprogramme Schritt für Schritt abarbeiten und kontrollieren.

Dieser erste Teil umfaßt sämtliche Eingabe- und Ausgaberoutinen, die Registeranzeige, den Memory-Dump sowie Disassembler und Assembler. Damit steht Ihnen bereits ein lauffähiges Monitorprogramm mit den unten aufgeführten Befehlen zur Verfügung.

Der Monitor benötigt für alle Eingaben die hexadezimale Schreibweise, das heißt zu den Zahlen 1 bis 9 kommen noch die Buchstaben A (für dez. 10) bis F (für dez. 15) hinzu.

Bei der Eingabe von Adressen ist folgendes zu beachten: [ANFADR] bedeutet exakt die Startadresse, [ENDADR] bedeutet hierbei die erste Adresse hinter dem gewählten Bereich. Im Normalfall ist die Eingabe mit und ohne Leerzeichen zulässig. Beim Abweichen von dieser Regel wird darauf besonders verwiesen.

### Assemblieren

A [ANFADR]
Assemblierung beginnt bei angegebener Adresse Beispiel:
A 4000 Beginn bei Startadresse $4000

Nach Eingabe von »RETURN« erscheint auf dem Bildschirm die gewählte Adresse mit einem blinkenden Cursor. Die Befehle werden so eingegeben, wie sie der Disassembler zeigt: LDY #00 oder LDA 400E,Y und so weiter. »RETURN« schließt die Eingabe der Zeile ab. Bei fehlerhafter Eingabe springt der Cursor wieder in die Anfangsposition zurück. Ansonsten wird der Befehl disassembliert und nach Ausgabe der Hex-Bytes gelistet. Zur Korrektur vorhergehender Zeilen gehen Sie mit dem Cursor zur Anfangsposition (hinter die Adresse) zurück, schreiben den Befehl neu und gehen nach »RETURN« mit dem Cursor wieder in die letzte Zeile. Falls Ihnen bei Sprüngen (Branch-Befehl, JSR und JMP) die Zieladressen noch nicht bekannt sind, geben Sie einfach sogenannte »Label« ein.

Ein Label besteht aus dem Buchstaben »M« (für Marke) und einer zweistelligen Hex-Zahl von 01 bis 30.
Zum Beispiel: BCC M01

Wenn Sie die Zieladresse für diesen Sprung erreicht haben, dann kennzeichnen Sie diese mit eben dieser »Marke«.
Zum Beispiel: M01 LDY #00

Einzelne Bytes nimmt der Assembler an, indem Sie diese mit einem Punkt kennzeichnen: .00 oder .AB. In diesem Modus werden die Eingaben natürlich nicht disassembliert.

Nach Beendigung des Assemblierens geben Sie »F« ein. Danach sehen Sie alle Ihre Eingaben noch einmal aufgelistet und korrigieren bei Bedarf wie beim Disassembler (!) angegeben.

Probieren Sie einmal das folgende Beispiel:
A4000

Der Assembler meldet sich mit: »4000« und einem blinkenden Cursor. Geben Sie nun ein (die Adressen erscheinen automatisch):

<pre>4000 LDY #00
4002 LDA 400E,Y
4005 JSR FFD2
4008 INY
4009 CPY #12
400B BCC 4002
400D BRK</pre>

Die folgenden Bytes werden wie beschrieben mit einem Punkt eingegeben. Sie werden nicht disassembliert.

<pre>400E .0D
400F .0D
4010 .53
4011 .4D
4012 .4F
4013 .4E
4014 .20
4015 .49
4016 .53
4017 .54
4018 .20
4019 .53
401A .55
401B .50
401C .45
401D .52
401E .0D
401F .0D</pre>

Drücken Sie anschließend »F«. Ihr Programm wird nochmal aufgelistet. Starten Sie es nun mit »G 4000«. Es erscheint ein Text auf dem Bildschirm — lassen Sie sich überraschen.

## Disassemblieren

D[ANFADR,ENDADR]
disassembliert den Bereich von ANFADR bis ENDADR, wobei ENDADR nicht eingegeben werden muß. Wird keine Endadresse eingegeben, erscheint zunächst nur eine Zeile:
ADR	HEXBYTES	BEFEHL
4000	A000	LDY #00
TODO

Mit der SPACE-Taste wird der jeweils nächste Befehl in der gleichen Art und Weise gezeigt. Wünschen Sie eine fortlaufende Ausgabe, drücken Sie »RETURN«. Die Ausgabe wird dann so lange fortgesetzt, bis eine weitere Taste gedrückt wird oder bis ENDADR erreicht ist.Mit »RUN/STOP« springen Sie jederzeit in den Eingabemodus zurück.

Das Komma, das vor der Adresse auf dem Bildschirm er-scheint, ist ein »hidden command« (verstecktes Kommando). Es braucht nicht eingegeben zu werden, da es automatisch beim Disassemblieren angezeigt wird. So ermöglicht es ein einfaches Ändern des Programms. Fahren Sie mit dem Cursor auf den zu ändernden Befehl und überschreiben Sie ihn mit dem neuen. Wenn Sie jetzt »RETURN« drücken, erkennt SMON das Komma als Befehl und führt ihn im Speicher aus. Achten Sie aber darauf, daß der neue Befehl die gleiche Länge (in Bytes) hat und füllen Sie gegebenenfalls mit »NOPs« auf. Zur Kontrolle können Sie den geänderten Bereich noch einmal disassemblieren.

Lassen Sie als Beispiel einmal das Programm (siehe Befehl »A«) ab 4000 disassemblieren (»D 4000 4011«). Ändern Sie nun den ersten Befehl auf LDY #01. Die Änderung zeigt sich daran, daß die HEX-Bytes automatisch den neuen Wert annehmen. Starten Sie nun das Programm nochmals mit »G 4000«. Jetzt erscheint der Text mit nur einer Zeile Abstand auf dem Bildschirm.

### Starten eines Maschinenprogramms (Go)

G [ADRESSE]
startet ein Maschinenprogramm, das bei ADRESSE beginnt. Das Programm muß mit einem BRK-Befehl abgeschlossen werden, damit ein Rücksprung in SMON erfolgen kann. Wird nach »G« keine Adresse eingegeben, benutzt SMON die, die mit dem letzten BRK erreicht worden ist und bei der Register-Ausgabe als PC auftaucht. Mit dem »R«-Befehl (siehe unten) werden die Register vorher auf gewünschte Werte gesetzt.

### Memory-Dump

M [ANFADR ENDADR]
gibt die HEX-Werte des Speichers sowie die zugehörigen ASCII-Zeichen aus. Auch hier kann auf die Eingabe einer Endadresse verzichtet werden. Die Steuerung der Ausgabe entspricht der beim Disassemblieren.
Beispiel:

M 4000 gibt die Inhalte der Speicherstellen $4000 bis $4007 aus. Weiter geht es wie beim Disassemblieren mit SPACE oder RETURN. Die Bytes können ebenfalls durch Überschreiben geändert werden, allerdings nicht die ASCII-Zeichen. Verantwortlich dafür ist der Doppelpunkt, der am Anfang jeder Zeile ausgegeben wird, ein weiterer »hidden command«. WennJhre Änderung nicht durchgeführt werden kann, weil Sie zum Beispiel versuchen, ins ROM zu schreiben, wird ein »?« als Fehlermeldung ausgegeben.

### Registeranzeige

R zeigt den gegenwärtigen Stand der wichtigsten 6510-Register an: Programmzähler (PC), Status-Register (SR), Akkumulator (AC), X-Register (XR), Y-Register (YR), Stackpointer (SP). Außerdem werden die einzelnen Flags des Status-Registers mit 1 für »gesetzt« und O für »nicht gesetzt« angezeigt. Durch Überschreiben werden die Inhalte auf einen gewünschten Wert gesetzt. Die Flags können allerdings nicht einzeln verändert werden, sondern nur durch Überschreiben des Wertes von SR.

### Exit

X springt ins Basic zurück. Alle Basic-Pointer bleiben erhalten. Sie können also zum Beispiel direkt im Programm fortfahren, wenn Sie zwischendurch mit SMON einige Speicherstellen kontrolliert haben.

Probieren Sie alle bisher beschriebenen Befehle in Ruhe aus und machen Sie sich mit SMON vertraut. Arbeiten Sie auch parallel den Kurs über Assemblerprogrammierung in dieser Ausgabe durch. Alle Beispiele dort sind auf SMON abgestimmt.

Wir wollen jetzt einen Blick auf das Programm selbst werfen. Natürlich ist es unmöglich, den gesamten Quelltext umfassend zu beschreiben. Andererseits enthält SMON aber eine Reihe von Routinen, die in jedem Maschinenprogramm vorkommen. Wir werden im Rahmen dieser Serie versuchen, die wichtigsten zu erklären, damit Sie sie später in eigene Programme einbauen können.

Zum besseren Verständnis werden solche Routinen so abgedruckt, wie wir sie im Assembler-Quelltext geschrieben haben. Sie enthalten daher anstelle absoluter Adressen Labels, deren Name — hoffentlich — etwas über den Sinn und Zweck aussagt. Parallel dazu sollten Sie sich diese Routinen von SMON disassemblieren lassen, damit Sie sehen, wie es denn nun fertig im Speicher aussieht.

Beginnen wir mit der Routine GETCHRERR. Das soll soviel bedeuten wie »Hole ein Zeichen und erzeuge eine Fehlermeldung, wenn keins eingegeben wurde«. Leider wäre so ein Label auch für den geduldigsten Assembler viel zu lang, daher die merkwürdige Abkürzung. Mit dieser Routine holen wir ein Zeichen von derTastatur. Das erledigt die Betriebssystemroutine CHRIN. Um zu prüfen, ob überhaupt etwas eingegeben wurde, untersuchen wir das Zeichen. Handelt es sich um die »RETURN«-Taste ($0D), hat der Benutzer gar kein Zeichen eingegeben. Dies quittiert SMON mit einem »?« und dem Rücksprung in den Eingabemodus. So läßt sich — in gewissen Grenzen — kontrollieren, ob zu einem Befehl die richtigen Eingaben gemacht wurden. Geben Sie einmal den »D«-Befehl ohne Angabe einer Adresse ein, dann sehen Sie, was gemeint ist.

Alle Eingaberoutinen benutzen GETCHRERR, um Falscheingaben zu prüfen. Nehmen wir als Beispiel GETBYT. Diese soll ein Byte, also zwei ASCII-Zeichen 0 - F von der Tastatur holen und in ein Byte umwandeln. Das erste Zeichen wird darauf überprüft, ob es sich um ein »Space« oder ein Komma handelt. Trifft das zu, wird es einfach übergangen und das nächste Zeichen geholt. Der Benutzer kann also Leerzeichen und Komma benutzen, um seine Eingaben übersichtlicher zu machen, er muß aber nicht! Ist das Zeichen aber gültig, wird es von ASCHEX in eine Hexzahl gewandelt.
Dazu ein Beispiel:

Auf der Tastatur wurde 5B eingetippt. Zuerst wird jetzt die 5 (ASCII $35) mit $3A verglichen, um festzustellen, ob es sich um eine Zahl (0 - 9) oder einen Buchstaben (A - F) handelt. ASCII $35 ist eine Zahl, also wird nur die linke Hälfte ausmaskiert (AND #$0F). Ergebnis ist $05. Jetzt wird viermal nach links geschoben und das Ergebnis ($50) in $B4 zwischengespeichert. Nun ist das B (ASCII $42) an der Reihe. Da $42 größer ist als $3A werden diesmal 8 und das gesetzte Carry-Flag, also 9 addiert. Ergebnis ist $5B. Linke Hälfte ausmaskieren wie gehabt und eine OR-Verknüpfung mit dem gemerkten $50 ergibt $5B. Das war’s.

Meistens aber braucht SMON zwei Bytes als Eingabe, zum Beispiel für Adressen. Mit dem, was wir schon haben, kein Problem: GETADR ruft einfach GETBYT zweimal hintereinander auf und legt das Ergebnis in zwei Speicherstellen in der Zeropage ab, die mit dem X-Register ausgewählt werden können. Brauchen wir mehr als eine Adreßeingabe, rufen wir einfach GETADR mehrmals auf. So etwas machen GET3ADR und GET2ADR. Bisweilen aber, zum Beispiel beim G-Befehl, darf eine Adresse eingegeben werden, es muß aber nicht sein. Deswegen prüft GETSTART, ob direkt nach dem »G« »RETURN« gedrückt wurde. Dies erledigt GETRET. Wenn ja, wird die Adresse benutzt, die in PCL und PCH steht. Das sind SMONs interne Programm-Counter. Ansonsten wird die eingetippte Adresse benutzt.

Sie sehen, wie aus einfachen Routinen immer kompliziertere Befehle zusammengesetzt werden. Und das ist das ganze Geheimnis, wenn Sie umfangreiche Programme schreiben: Gliedern Sie sich das Problem (hier eine benutzerfreundliche Eingabe) in kleine und kleinste Schritte auf, die Sie dann jeden für sich programmieren und austesten.

Werfen wir noch einen Blick auf die Art und Weise, wie SMON Befehle verarbeitet. In EXECUTE setzen wir zunächst den Stackpointer auf den Wert, den er beim letzten BRK erreicht hatte. Dann werden als erstes die »hidden commands« abgeprüft. Wir lesen dazu direkt vom Bildschirm. D3 enthält die Anfangsadresse der aktuellen Zeile im Speicher. Übrigens gibt es neben den bereits erwähnten noch weitere »hidden commands«, die in den späteren Folgen noch auftauchen werden. Liegt kein verstecktes Kommando vor, holen wir mit GETCHRERR ein Zeichen und merken es uns in COMMAND. Jetzt untersuchen wir, ob dieses Zeichen in der Befehlsliste (CMDTBL) steht. CMDTBL steht übrigens ab $C00B ganz oben im Speicher. Sie endet mit fünf Nullen für spätere Erweiterungen. Direkt dahinter stehen die Anfangsadressen der zugehörigen Routinen in derfürden 6502 typischen Reihenfolge, Low-Byte zuerst, dann High-Byte. Sehen Sie sich das mit M C00B einmal an. Am Ende dieser Tabelle stehen nochmals 10 Nullen, denn zu jedem Byte in CMDTBL gehören ja zwei Adreßbytes in der Liste (CMDS). Wenn nun ein Kommando in CMDSEARCH gefunden wurde, wird CMDEXEC als Subroutine aufgerufen. CMDEXEC legt nun die zugehörigen Adreßbytes auf den Stack und führt dann einen RTS aus, der jetzt — nach der Stackmanipulation — zu dem gewünschten Befehl führt. Beachten Sie, daß RTS immer auf die um eins erhöhte Adresse springt, daher müssen Sie zu den Adressen in CMDS immer 1 addieren, wenn Sie den Anfang einer Routine suchen.

Alle Befehle in SMON enden mit einem RTS, springen also auf den JMP EXECUTE hinter CMDFOUND. Damit ist eine Endlosschleife geschlossen, die immer einen Befehl ausführt und anschließend wieder in die Eingabe zurückspringt. Beim nächsten Mal erfahren Sie etwas über LOAD, SAVE und die Umrechnung verschiedener Zahlensysteme.

(Dietrich Weineck/N. Mann/gk)

### Hinweise zum Abtippen

Es ist mal wieder eine DATA-Wüste, die wir Ihnen zumu-ten, aber wenn Sie die erfolgreich hinter sich brachten, haben Sie schon mehr als die Hälfte vom gesamten SMON geschafft. Um Ihnen das Abtippen beziehungsweise die anschließende — fast unvermeidliche — Fehlersuche so einfach wie möglich zu machen, unterteilten wir das Gesamtprogramm in Blöcke zu je 256 Bytes, die jeweils eine eigene Prüfsumme haben. Wenn Sie sich vertippt haben, erscheint eine Fehlermeldung mit Angabe des Blocks, in dem sich der Fehler — höchstwahrscheinlich — befindet.

Vor dem ersten »RUN« sollten Sie aber unbedingt das Programm speichern, sonst kann Ihnen bei Fehlern der Computer abstürzen, und alle Mühe war umsonst.

Eins findet die Prüfsummenmethode allerdings nicht, nämlich zuviel eingegebene Nullen oder Kommas. Erhalten Sie aber keine Fehlermeldung und das Programm läuft trotzdem nicht, kontrollieren Sie als erstes, ob wirklich alle DATAs »aufgebraucht« sind. Dazu tippen Sie im Direktmodus PRINT A ein. Jetzt muß die letzte Zahl, also 197 erscheinen. Wenn nicht, haben Sie eine 0 oder ein Komma zu viel.

Wenn das Ladeprogramm endlich ohne Fehler bis zum READY durchläuft, können Sie SMON mit SYS 49152 starten. Die Bildschirmfarben ändern sich und es erscheint die Registeranzeige und in der nächsten Zeile ein Punkt mit blinkendem Cursor. Probieren Sie jetzt alle Kommandos durch. Hüten Sie sich aber vor allen anderen Kommandos. Die Fehlermeldung bei falschen Kommandos funktioniert noch nicht richtig!! Deshalb führen Falscheingaben in den meisten Fällen zum Programmabsturz. Das wird sich im Verlauf dieser Serie allerdings noch ändern.

Bevor Sie Ihren Computer aus dem Fenster werfen, noch ein Hinweis: Von der nächsten Folge ab wird SMON auch fix und fertig im Leserservice zu erhalten sein.

Und noch ein letzter Tip: Das Wichtigste, was ein angehender Maschinenprogrammierer braucht, ist ein Reset-Taster. (Bauanleitungen oder fertige Taster wurden schon oft im 64’er vorgestellt.) Sie werden es merken, wenn Sie mit sorgenzerfurchter Stirn, den Tränen nahe, vor Ihrem Bildschirm sitzen, kein freundlich blinkender Cursor weit und breit und RUN/STOP RESTORE auch dann nichts mehr bringt, wenn Sie die Tasten durch das Gehäuse durchdrücken. Verzweifeln Sie nicht, drücken Sie RESET, starten Sie SMON neu mit SYS 49152 und schon können Sie bis zum nächsten Absturz weiterarbeiten......

# Get Koala Pic

> Wenn Sie sowohl einen C 64 als auch das Koala Pad besitzen, dann können Sie Jetzt Koala-Bilder in ganz »normale« Basic-Programme einbeziehen.

Sie möchten Koala-Bilder auch ohne Koala laden und zeigen können. Wahrscheinlich haben Sie das Programm am Ende der Anleitung abgetippt, wie ich. Aber dann dachten Sie vielleicht auch, wie schön es wäre, wenn es möglich wäre, die Bilder der Reihe nach, wie eine Dia-Show abzurufen. Dann müßte man nicht mehr STOP-RETURN drücken, und unser Basic-Programm könnte weitergehen. Somit hätte man vielfältige Möglichkeit, Koala-Bilder anzuwenden! Zum Beispiel könnte man:

1.	...mit Koala ein Titelbild machen
2.	...mit Koala ein Abenteuer-Programm schreiben; denn: Wenn der Anwender einen Text lesen muß, während das Bild geladen wird, ergibt sich praktisch keine »Wartezeit« für ihn!
3.	...mit Koala ein Lernprogramm schreiben.

Tja, so ähnlich waren meine Gedankengänge. Aber meine Programmierkenntnisse in Basic nützen nichts; so ein Programm muß in Maschinensprache geschrieben werden! Also telefonierte ich mit einigen C 64-Besitzer-Kollegen herum und wurde fündig: Michael M. Meiszl war schon dabei, an so einem Programm zu basteln. Er paßte es meinen Wünschen an und stellte es in Rekordzeit fertig. Und nun können Sie alles oben Erwähnte tatsächlich tun, und noch viel mehr.

Listing 1 ist das Hauptprogramm. Es wird als erstes geladen. Listing 2 ist ein kleines Anwenderbeispiel, damit Sie sehen, wie die SYS-Befehle in ein normales Basic-Programm eingebaut werden. Bild 1 ist eine Übersicht, welcher SYS-Befehl nun was bewirkt. Falls Sie zwei Laufwerke besitzen, dann können Sie wahlweise 8 oder 9 eingeben.

Das Hauptprogramm ist sehr anwenderfreundlich: Es geht kein Basic-Speicherplatz verloren. Da jedes Bild einzeln geladen und danach alle Zeiger auf Null gesetzt werden, kann man, der Reihe nach, praktisch unzählige Bilder hintereinander im selben Basic-Programm zeigen. Hierzu muß der Anwender nur die Bilder-Diskette einlegen. Sollten Sie mehrere Bild-Disketten benützen wollen, so genügt ein PRINT-Hinweis auf dem Bildschirm, welche Diskette jetzt eingelegt werden muß. Da die Bilder per Leertaste »beendet« werden, kann das Programm nach einem Bild ganz normal weiterlaufen. Ein SYS-Befehl ermöglicht das Nochmalzeigen des letzten Bildes. Dies kann bei Lernprogrammen von Vorteil sein. Ein anderer SYS-Befehl ermöglicht das Laden ohne Zeigen, so daß dieses Bild dann blitzschnell abgerufen werden kann, da es »unsichtbar« bereits »besteht«. Wenn Sie die Tabelle griffbereit neben sich legen, haben Sie die SYS-Befehle bald im Griff.

## Noch ein paar Koala-Tips

1.	Im Menü finden Sie »INIT DISK«. Damit ist nicht »initialisieren« sondern formatieren gemeint. Trotzdem: Bei Disketten, die mit Koala formatiert wurden, ging jeder zweite Versuch, ein Bild zu laden schief: Dabei stieg dann jedesmal der Computer aus, so daß nicht nur das Bild verloren war, sondern man Koala neu laden mußte, und so weiter.
2.	Ich habe bereits des öfteren gelesen, daß die Handhabung im ZOOM-Modus so schwierig sein soll. Mein Vorschlag: Setzen Sie den Pfeil an die richtige Stelle und drücken Sie dann kurz auf die Taste oben. Auf diese Weise kann man punktweise (ebenfalls sehr schnell in lauter Einzelpunkt-Aktionen) und extrem akkurat arbeiten!
3.	Wenn Sie ein größeres Stück sauber »radieren« wollen (was durch DRAW mit Hintergrundfarbe leicht ist), dann hilft Ihnen ZOOM ebenfalls: »Radieren« Sie mit ZOOM erst die Ränder mit dem feinsten »Pinsel«, dann können Sie mit einem breiten »Pinselstrich« den Mittelteil schnell weg-malen!
4.	Wenn Sie etwas Riskantes ausprobieren wollen, was möglicherweise Ihr Bild kaputtmachen müßte (erst »radieren«, dann das Neue zeichnen, dann erst sehen, ob es Ihnen gefällt), dann rate ich Ihnen: Kopieren Sie das gesamte Bild per COPY (dem ein SWAP vorausgehen muß) auf den zweiten Bildschirm. Jetzt können Sie nach Herzenslust experimentieren, denn Ihr Bild existiertja noch »im Original« auf der anderen Grafikseite.

So, jetzt hoffe ich nur noch, daß Sie in Zukunft noch mehr Spaß mit Koala haben werden.

(Vera F. Birkenbihl/aa)

# Der VC 20 als Laterna Magica

> Laterna Magica macht Spiele beweglicher und professioneller. Man kann Zeichen und zusammengesetzte Bilder nicht nur entwickeln, sondern auch bewegen, pulsieren, rotieren oder explodieren lassen und in eigene Programme einbauen.

»Laterna Magica« ist für jeden VC 20 gedacht, sei er erweitert oder nicht. Als Peripherie wird ein Floppy-Disk-Laufwerk VC-1541 vorausgesetzt. Das Programm kann aber für die Datasette umgeschrieben werden, indem die Gerätenummer 8 in Zeile 60 des DATA-Laders in eine 1 umgewandelt wird. Außerdem muß es dann im Hauptprogramm heißen: 490 PRINT”SAVE”CHR$(34)” ”CHR$(34)”,1,1”

Das Programm (Listing 1) ist nicht mehr zu erweitern, es können also auch keine REM-Zeilen mehr eingefügt werden. Es sieht zwar als Listing nicht sehr umfangreich aus, jedoch mußte das Basic-Ende heruntergesetzt werden, um das Maschinenprogramm, den neuen Zeichengenerator und den Speicherplatz, in dem wir später unsere Ersatzbilder speichern, vor Überschreibung zu schützen. Die Erzeugung von Grafik beim VC 20 beruht ja darauf, die Zeichen auf dem Bildschirm, die aus 88 Punkten aufgebaut sind, in ihrem Aufbau zu ändern. Bei einem Zeichen hieße es, 8 Byte gegen 8 andere auszutauschen. Bei 9 Zeichen (das ist die Zeichenanzahl, mit der »Lan-terna Magica« arbeitet) werden es 7 2 Byte. Versuchte man das Problem mit Basic zu lösen, müßte man bei jedem Tauschvorgang eine Zählschleife von 1 bis 72 mit einigen POKEs dazwischen in Kauf nehmen. So etwas kann Action-Spiele ganz schön langsam machen. Ich habe diese Routine daher in Maschinensprache geschrieben. So genügt ein SYS-Aufruf, und 9 Zeichen auf dem Bildschirm ändern sofort ihre Form.

Ausgeführt werden kann derTausch nur, wenn der Zeichengenerator nicht wie üblich im ROM liegt. Das ist also die erste Aufgabe des Maschinenprogramms. Es legt den Zeichengenerator ins RAM ab $1COO(entspricht dezimal 7168). Danach holt es sich aus dem Reserve-Bildschirmspeicher ($1A00 bis $1BFF, dezimal 6656 bis 7167) die ersten 72 Byte und legt sie im Bildschirmspeicher ab. Das ist zunächst alles. Beim nächsten Aufruf verfährt es mit den folgenden 72 Byte in gleicher Weise. Das geht siebenmal so, danach werden wieder die ersten 72 Byte geholt und so weiter.

Wichtig ist, daß vor jedem Aufruf in die Speicher $FB und $FC (dezimal 251 und 252) ein Wert von maximal 7 gePOKEt wird. An diesem Wert erkennt das Maschinenprogramm, wievielmal es die Bilder austauschen soll, bis es wieder beim ersten beginnt. Das bedeutet, daß man auch »Filme« mit nur drei Bildern laufen lassen kann, indem man den Wert 3 in diese Speicher POKEt.

## Der Bildeditor

Um diese besprochenen Bilder zu entwickeln, wären langwierige Berechnungen und viel Tastaturarbeit zum Eingeben der bis zu 504 Werte notwendig. Deswegen habe ich ein Programm geschrieben, das diese Arbeit übernimmt. (Listing 2).

Der Umgang mit dem Bildeditor ist recht einfach. Nach RUN erscheint in der oberen Hälfte des Bildschirmes eine Maske, in der die Zeichen aufgebaut werden und in der unteren Hälfte das Menü (siehe Bild).

Das Feld rechts oben zeigt das erste Bild. Man sieht zwar zunächst nur ein abstraktes Gebilde, das liegt aber nur daran, daß noch keine Zeichen entwickelt wurden. Links daneben stehen die gleichen Zeichen in Klarschrift. In beiden Feldern sind die gleichen Zeichen in der linken oberen Ecke schwarz, um herauszustellen, daß dieses Zeichen bearbeitet werden kann.

Mit F1 kann man nun ein Zeichen auswählen, das verändert werden soll. Dabei wandert das schwarze Feld jeweils eine Ziffer weiter.

Weiterhin kann man über den beiden Feldern die Bildnummer ablesen. Mit F3 können wir zwischen sieben Bildern wählen. Die Bilder werden jeweils im rechten Feld gezeigt. Es entsteht so schon ein Zeichentrickeffekt.

Hat man nun seine Wahl getroffen, kann man mit F7 in den Entwicklungsmodus wechseln. Der Cursor steht nun in der linken oberen Ecke des großen Entwicklungsfeldes. Er läßt sich voll steuern, jedoch nicht über den Feldrand hinaus. Tippt man nun, mehr oder weniger willkürlich, Buchstaben oder Zeichen in das Feld, sieht man gleichzeitig an der vorgewählten Ziffer im rechten Feld das Ergebnis. Man sollte nur nicht den Fehler machen, CLR/HOME oder INST/DEL zu drücken. Das kann den Bildschirmaufbau durcheinander bringen.

Mit RETURN kommt man ins Menü zurück.

Ist eine Bild- oder Zeichenfolge fertiggestellt, kann man den Trickfilm mit F5 ausprobieren. Im Menüfeld wird die Geschwindigkeit des Ablaufes erfragt. Eine gute Geschwindigkeit von 100 ist vorgegeben. Ein Wert von Null ergibt die größte Geschwindigkeit. In der anderen Richtung wird man selbst merken, wenn es langweilig wird. Mit RETURN wird gestartet, und mit der SPACE-Taste kann der Vorgang abgebrochen werden.

Es bleibt noch die F2-Funktion zu erklären. Bei Druck auf F2 erscheinen ein paar im ersten Augenblick wirr anmutende Befehle und die Bitte, den Namen der Bildfolge einzutragen. Das bedeutet, daß in der ersten Zeile (mit den vielen POKEs und dem SAVE) in die Lücke ein Name eingetragen werden soll. Es ist auch angebracht, das zweite Anführungszeichen an den Namen heranzuziehen. Dann drückt man RETURN, und alles geht wieder automatisch. Die Bildfolge wird als Maschinenprogramm geSAVEt und das Programm startet von neuem.

Zur Eingabe des Programmes: Bei Verwendung der Data-sette muß zunächst der DATA-Lader (Listing 1) abgetippt und abgespeichert werden und danach Listing 2, weil der DATA-Lader selbständig das nächste Programm nachlädt. Verwendet man ein Floppy-Laufwerk, ist die Reihenfolge unerheblich.

Will man mit dem Programm arbeiten, muß erst der DATA-Lader geladen werden. »RUN« startet den Lader, der das Hauptprogramm lädt.

## Bildfolgen in eigenen Programmen

Will man die Trickfolge im selbstgemachten Programm anwenden, muß natürlich das Machinenprogramm im Speicher vorhanden sein. Dazu lädt man den DATA-Lader, löscht die Zeilen 60-75, setzt in Zeile 60 ein NEW und startet den Lader. Damit ist das Maschinenprogramm im Bereich dezimal 6400 bis 6640 abgelegt und vor Überschreibung geschützt. Der Lader löscht sich selbst. Außerdem ist auch der Bereich geschützt, in den nun die selbstgemachte Bildfolge mit »LOAD ”Name”,8,1« oder »LOAD ”Name”,1,1« geladen werden kann.

Damit keine Fehlermeldungen auftreten, gibt man jetzt noch den Befehl NEW ein und drückt die Return-Taste. Jetzt kann man das eigene Programm laden oder eintippen.

Das Maschinenprogramm wird übrigens mit SYS6400 aufgerufen.

Und noch einmal: Am Anfang des Programmes, vor dem ersten SYS6400 muß unbedingt eine Zahl zwischen 1 und 7 in 251 und 252 gePOKEt werden, eben die Anzahl der Bilder des Trickfilms. Alle kleineren Zahlen als 1 und alle größeren als 7 richten zwar keinen Schaden an, jedoch bewirken sie eine Einschränkung der Funktion.

Sollte man dies einmal vergessen haben, ist es angebracht, das Maschinenprogramm neu zu laden.

Zum Schluß noch zwei Tips.

1.	Bei erweitertem VC 20 sollte man für eigene Programme nicht das Basic-Ende herunter-, sondern den Basic-Beginn heraufsetzen. Damit hat man mehr Speicherplatz für seine Programme. (Zeile 20) des DATA-Laders: POKE44,32:POKE8192,0:CLR).
2.	Da bei der Arbeit mit diesem Programm nicht der Original-Zeichensatz vorhanden ist, kann man ihn, wenn gebraucht, über die RVS-ON-Taste darstellen. Dieses Verfahren habe ich selbst im Listing 1 verwendet.

(Bernd Schrödter/ev)

# Grafik leicht gemacht

> Mit einigen neuen Befehlen macht dieses Programm das Plotten von Funktionen zum Kinderspiel. Das mühsame Arbeiten mit den Commodore-Grafik-befehlen ist vorbei, wenn man die neuen Befehleeinsetzt.

Das Programm stellt eine Basic-Erweiterung dar, die im Bereich von $0800-$4000 angesiedelt ist. Dieser Bereich enthält das Maschinenspracheprogramm sowie den Grafikbildschirm. Die neuen Befehle und ihre Bedeutung:
**HIRES**: Dieser Befehl schaltet die hochauflösende Grafik ein. SCNCLR: Hiermit wird der Grafikbildschirm gelöscht.
**TEXT**: Um die Grafik wieder auszuschalten wird dieser Befehl benutzt. Am Programmende schaltet die hochauflösende Grafik automatisch ab.
**REGION a**: Die Cursor- beziehungsweise Plotfarbe wird festgelegt. Der Parameter a darf Werte von 0 bis 15 annehmen. COLOR a,b,c: Bestimmt die Hintergrundfarbe ( a ), die Rahmenfarbe (b) und die Zeichenfarbe (c ).
**PLOT x,y**: Dieser Befehl setzt einzelne Punkte auf dem Grafik-bildschirm. Die Parameter x und y geben die Position des Punktes an. Der Ursprung des Koordinatensystems liegt in der linken oberen Bildschirmecke. X darf Werte von 0 bis 319, y Werte von 0 bis 199 annehmen. Bei Überschreiten dieser Bereiche gibt der Computer jedoch keine Fehlermeldung aus, wie es bei anderen Programmen meist der Fall ist. Für die Darstellung von Funktionen ist diese Einrichtung jedoch sehr nützlich.
**UNPLOT x,y**: Löscht einen gesetzten Punkt. Für die Parameter gelten die gleichen Grenzen wie beim Befehl PLOT.
**AXES x,y**: Zeichnet Koordinatenachsen auf den Grafikbildschirm. Die Parameter x und y bestimmen in diesem Fall den Ursprung des Koordinatensystems.

**ONERROR GOTO n**: Dieser Befehl fängt Definitionslücken von Funktionen ab, wenn nicht mit dem FPLOT-Befehl gearbeitet wird (siehe dort). Tritt während des Programmablaufs ein Fehler auf, der durch eine Definitionslücke verursacht wurde, wird zur Zeile n verzweigt. Dort wird das Programm ohne Unterbrechung weitergeführt. Die Fehlerausgabe wird sinnvollerweise jedoch nur bei den folgenden Fehlern unterdrückt:
ILLEGAL QUANTITY, DIVISION BY ZERO, OVERFLOW Bei anderen Fehlerursachen bricht das Programm wie üblich ab.
**FPLOT f(x) STEP n**: Dieser Befehl stellt das Kernstück des Programms dar. Er ermöglicht das Plotten einer beliebigen Funktion mit einem Befehl. Er setzt voraus, daß das Koordinatensystem seinen Ursprung in der Mitte des Bildschirms hat. Nach STEP kann noch angegeben werden, in welchen Intervallen Punkte für die Funktionsdarstellung berechnet werden sollen. Soll die Funktion sehr genau ausfallen, muß n klein gewählt werden. Reicht eine grobe Darstellung, so wählt man den Parameter n größer. Läßt man den STEP-Befehl aus, wird n=0.03 gesetzt, was sich meist als bester Wert erweist. Die Anwendung des FPLOT-Befehls an einem Beispiel: Die Funktion f(x)=SQR(X) soll ausgegeben werden.
10 HIRES
20 SCNCLR
30 AXES160,100
40 FPLOTSQR(X)
Das Programm schaltet die hochauflösende Grafik ein, löscht den Grafikbildschirm, zeichnet die Koordinatenachsen und plottet die Funktion. Alle neuen Befehle des Programms können übrigens wie die normalen Basic-Befehle über die Shift-Taste abgekürzt werden.

Zum Schluß noch ein Tip: Es gibt Funktionen, die in der Hauptsache in einem Bereich verlaufen, der nicht innerhalb der Koordinaten liegt, die für den FPLOT-Befehl vorgesehen sind. In diesem Fall wird einfach auf den PLOT-Befehl zurückgegriffen. Ein kleines Basic-Programm plottet unter Verwendung dieses Befehls auch solche Funktionen problemlos. In diesem Fall ist außerdem die Benutzung des ONERROR-Befeh|s sinnvoll.

Hier noch Hinweise zum Eintippen und Abspeichern beziehungsweise Laden des Programms. Vor dem Eingeben des Basic-Quellprogramms werden die folgenden Befehle eingegeben, die den Anfang des Basic-Speicherbereichs nach oben verschieben:
POKE44,16:POKE4096,0:NEW
Danach gibt man das Quellprogramm ein. Es enthält die DATAs für das Maschinenprogramm sowie eine Prüfsummenroutine. Nachdem das Maschinenprogramm erzeugt ist, wird es abgespeichert. In Zukunft muß nur noch das Maschinenprogramm geladen und gestartet werden.

(Uwe Seimet/rg)

# Supergrafik II
> Dieses Programm liefert eine Grafik-Auflösung von 200 mal 256 Punkten und nützt damit den Bildschirm vollständig aus, und dies in der Grundversion des VC 20.

Es handelt sich hier um eine Weiterentwicklung des im 64’er, Ausgabe Mai 1984, Seite 81 abgedruckten Programms. Nach Eingabe der Größe des Koordinatensystems generiert das Programm den Grafen einer Funktion und ihrer Ableitung in verschiedenen Farben. Es ist sicher für viele Besitzer des VC 20, insbesondere für Schüler und Lehrer interessant.

Die Funktionsgleichung wird in Zeile 1 definiert. Das Programm legt den Koordinatenursprung in die Bildschirmmitte und zeichnet den Grafen der Funktion (rot) und ihrer Ableitung (gelb). Nach dem Programmstart wird der Definitionsbereich der Funktion abgefragt (-XMAX^X^XMAX) und der Maßstab für die Hochwert-Achse gewählt (-YMAX^Y^YMAX). Das Programm kann aus Gründen des beschränkten Speicherplatzes zwar »nur« 159 Felder aus jeweils 8 mal 16 Punkten ansprechen, was aber für diese Anwendung vollkommen ausreicht. Um Speicherplatz zu sparen, wurde auf Kommentare im Programm und Grundsätze zur übersichtlichen Programmierung bewußt verzichtet.

(Rudolf Dörr/ev)

# Sprites ohne Esoterik

> Auch fortgeschrittenen Programmierern bleibt es meist rätselhaft, wie der C 64 die Sprites auf den Bildschirm zaubert. Wir wollen dieses Thema einmal ohne Geheimniskrämerei (Esoterik) angehen.

Noch vor fünf Jahren war alles ganz einfach. Im guten alten PET 2001 wurde das Bild durch ein mittleres TTL-Bergwerk erzeugt. In den Nachfolgern CBM 30xx und so weiter wird diese Aufgabe durch einigeTTL-ICs und den Bildschirmcontroller MC6845 erledigt. Bis dahin war alles überschaubar.

Da Commodore die Halbleiterfirma MOS Technology besitzt, liegt es nahe, eigene Video-Controller zu entwickeln. So treibt im VC 20 der noch relativ einfache VIC I (Video-Interface-Chip I) sein Unwesen. Im C 64 wirft der sehr komplexe VIC II die »Flammenschrift« auf den Bildschirm.

Die Funktionsweise dieses Video-Controllers soll dieser Bericht ein wenig enträtseln. Leider muß man es größtenteils durch Überlegung lösen.

Zunächst ein paar Worte zum Bildschirmformat: Es entspricht weitgehend der normalen Fernsehnorm. Je 312 Rasterzeilen ergeben fünfzig Bilder in der Sekunde. Jede Rasterzeile (Bild 1) ist 64 µs lang und beginnt mit einem Synchronisationsimpuls, der dem Monitor mitteilt, wann er mit der neuen Zeile beginnen soll. Ohne diese Synchronisation gäbe es nur Bildsalat und durchlaufende Bilder. Der Synchronisationsimpuls entspricht in der Helligkeitsskala der Videosignale einem Dunkelschwarz, so daß man den Strahlrücklauf nicht sehen kann. Es gibt übrigens nur fünf Helligkeitsstufen:

1.	Schwarz
2.	Rot, Blau, Braun, Grau 1
3.	Violett, Grün, Orange, Hellrot, Grau 2, Hellblau
4.	Türkis, Gelb, Hellgrün, Grau 3
5.	Weiß

Es ist empfehlenswert, für die Vorder- und Hintergrundfarbe Farben aus verschiedenen Helligkeitsstufen zu wählen, da man sonst auf farblosen Monitoren nicht viel sehen kann...

40 µs der Rasterzeile werden für das eigentliche Bild benützt. Bei derTaktfrequenz (desVIC) von zirka8MHz ergeben sich 512 Punkte auf der ganzen Rasterzeile, was mit der horizontalen Auflösung der Positionen der Sprites übereinstimmt. Aus den 64 µs ergibt sich eine Zeilenfrequenz von 15625 Hz, die für das unangenehme Pfeifen verantwortlich ist, das man beijedem Bildschirm hören kann, sofern man noch gute Ohren hat. Das horizontale Scrolling ist übrigens sehr einfach zu verwirklichen. Statt dem ganzen Bild wird kurzerhand der Synchronisationsimpuls und das durch den Rand gebildete »Fenster« verschoben.

Das vertikale Format ist folgendermaßen aufgebaut:
4 Zeilen Schwarz, damit man den Strahlrücklauf nicht sieht
3 Zeilen Synchronisationsimpuls
4 Zeilen Schwarz
51 Zeilen Rand
200 Zeilen Bild
51 Zeilen Rand

Den aufmerksamen Lesern wird aufgefallen sein, daß ich hier von 312 Zeilen pro Bild rede und nicht von 625 Zeilen, wie es beim normalen Fernseher der Fall ist. Beim Fernseher werden nacheinander zwei »Halbbilder«, die zueinander um eine halbe Rasterzeile versetzt sind, geschrieben, so daß die Auflösung höher ist. Nachteilig ist bei diesem Verfahren die geringe Bildwiederholfrequenz von 25 Hz, bei der das Bild leicht flimmert. Beim C 64 sind beide Bilder identisch und nicht versetzt (non-interlace), die Bildwechselfrequenz beträt 50 Hz.

Um ein Zeichen darzustellen, muß der VIC in einer einzigen Mikrosekunde folgende Informationen lesen:

1. POKE-Wert des Zeichens aus der Videomatrix; zeigt in den Zeichengenerator
2. Farbe aus der Farbmatrix
3. Daten aus dem Zeichengenerator.

Das heißt, zusammen mit den Zugriffen der CPU müßte der Speicher mit einer Zyklusfrequenz von 4 MHz (!) betrieben werden. Das ist nicht möglich. Dieses Problem wird auf eine andere Weise gelöst.

Die CPU 6510 gibt an ihrem Ausgang Pin 2 einen Takt von zirka 1 MHz ab (Bild 2). Wenn Pin 2 Low ist, ist der Bus frei, wenn Pin 2 High ist, benötigt die CPU den Bus für ihre Speicherzugriffe.

Der VIC liest, während Pin 2 Low ist, die Daten aus dem Zeichengenerator oder aus der hochauflösenden Grafik.

Das Farb-RAM wird vom VIC parallel zum normalen RAM gelesen. Der VIC hat also einen 12-Bit-Datenbus.

Zum Lesen der Videomatrix ist keine Zeit mehr übrig. Deswegen muß der VIC regelmäßig die CPU anhalten, um die Daten lesen zu können. Durch dieses »Kaltstellen« wird der Prozessor natürlich verlangsamt. Damit die CPU nur um etwa zehn Prozent und nicht um die Hälfte verlangsamt wird, hat der VIC intern Puffer für die Video- und Farbdaten der aktuellen Zeile. Daraus ergibt sich die auf Bild 3 gezeigte Reihenfolge der Zugriffe:
a) Letzte Rasterzeile der vorherigen Zeile: Die CPU wird angehalten, in die Puffer werden die Daten für die neue Zeile gelesen.
b) Während den sieben ersten Rasterzeilen der neuen Zeile wird die CPU nicht angehalten.
a) Wieder von vorn.

Leider hat auch dieses Verfahren Nachteile. Erstens wird der Prozessor verlangsamt, zweitens geraten bei zeitkritischen Programmen durch das Anhalten des Prozessors die Zeitverhältnisse aus dem Lot. Deswegen wird zum Beispiel beim Laden von Programmen von Kassette der Bildschrim abgeschaltet!

Und nun zu den Sprites. Unbegrenztes Vertrauen in die Leistungsfähigkeit der CPU 6510 ist nicht angebracht. Im VIC ist kein Maschinenprogramm versteckt. Es wäre ganz einfach zu langsam. Statt dessen werden die Sprites durch aufwendige Hardware erzeugt. Dieser Aufwand macht aber nicht so viel aus, da eben alles in einem Chip versammelt ist. Schwierig wird die Entwicklung eines solchen Video-Controllers vor allem durch die notwendige hohe Geschwindigkeit: Der IC hat immerhin eine Taktfrequenz von 8 MHz zu verkraften. Deswegen wird der VIC gewaltig heiß und residiert in einem unter kühlendem Blech verborgenen Keramikgehäuse.

Trotz allem ist die Logik für die Sprites eigentlich verblüffend einfach und elegant. Da Digitalelektroniker auch beim Einschlafen noch Gatter zählen, die über Schafe springen, und auch sonst mit jedem Gatter geizen (einfache ICs sind billiger), kann man schließen, daß wahrscheinlich auch hier der einfachste Weg benützt wird.

Die Daten der Sprites müssen zuerst gelesen werden. Die Logik zur Errechnung der Adressen der Sprites soll hier nicht erklärt werden, da sie nicht besonders interessant ist. Es ist mir leider nicht bekannt, wann die Spritezeiger (am Ende der Videomatrix) gelesen werden.

In jeder Rasterzeile müssen die Daten aller Sprites gelesen werden, also 3 x 8 Byte, die nahtlos in das »gemütliche Eckchen« in der Austastlücke passen. Jetzt wissen wir auch, wieso die Sprites ein so unmögliches Format (24 x 21 Pixel) haben...

Ich möchte nun anhand von Bild 4 erklären, wie die Sprites dort angezeigt werden, wo sie hingehören. Im Schema ist nur die Schaltung für ein Sprite gezeichnet, die anderen Sprites sind gleichartig aufgebaut.

Die Spritedaten werden in einen Puffer gelesen. Ein Zähler gibt die Nummer der aktuellen Rasterspalte, also die X-Koordinate, an. Davon wird die X-Koordinate der Sprites abgezogen, und man erhält eine auf den »Ursprung« des Sprites bezogene Koordinate. Die Ausdehnung von Sprites in der X-Richtung ist sehr einfach: Die Koordinate wird einfach durch zwei geteilt (in Binärsystem sehr einfach: rechts schieben). Das gleiche geschieht übrigens auch bei der Ausdehnung von Sprites in der Y-Richtung. Ein Multiplexer gibt das, durch die so erhaltene Koordinate, gewählte Bit (oder Bitpaar bei mehrfarbigen Sprites) aus. Falls die Koordinate nicht im Bereich des Sprites liegt, gibt der Multiplexer einfach den Wert für »Sprite transparent« — also 0 — aus.

Wie werden die Sprites nach der Priorität geordnet und Kollisionen von Sprites mit anderen Sprites oder mit dem Vordergrund des normalen Bilds erkannt?

Jedes Sprite gibt ein Signal von sich, das angibt, ob das Sprite jetzt transparent oder »deckend« ist. Eine relativ einfache Schaltung (in TTL nur 28 Gatter: 74LS148) erzeugt die Nummer des Sprites mit der höchsten Priorität, das gerade deckend ist oder zeigt an, daß gar kein Sprite deckend ist.

Nun muß noch entschieden werden, wer jetzt Vorfahrt hat (in der Reihenfolge der Prioritäten): Der Rand, Sprites im Vordergrund, das normale Bild, Sprites im Hintergrund oder der Hintergrund. Entsprechend dieser Entscheidung wird der richtige Farbcode ausgewählt und an den PAL-Codierer weitergegeben, der das Helligkeitssignal (Videosignal) und das Farbsignal (Chroma) erzeugt.

Die Erkennung von Kollisionen ist keine schwierige Sache mehr. Wenn sowohl das Bild als auch ein oder mehrere Sprites nicht transparent sind, werden im Kollisionregister für Sprite-Bild-Kollisionen die Bits der nicht transparenten Sprites gesetzt.

Sprite-Sprite-Kollisionen sind etwas schwieriger auszuwerten, auch hier bleibt der Aufwand aber im Rahmen.

Ich hoffe, daß ich bei den Lesern mit diesem Artikel jeglichen Geisterglauben ausgetrieben habe.

(Pascal Dornier/aa)

# Pseudo-Sprites auf dem VC 20

> Der VC 20 kennt von Haus aus leider nicht die freibeweglichen Grafikobjekte des C 64, die sogenannten Sprites. Das bedeutet aber nicht, daß man auf die Vorteile der Sprites oder MOBs gänzlich verzichten muß.

Das Programm ist für den VC 20 mit 8 KByte Speichererweiterung konzipiert. Es läuft jedoch mit einigen Änderungen auch bei nur 3 KByte Speichererweiterung.

Vor dem Eintippen oder Laden muß man POKE 44,32:POKE 8192,0: NEW eingeben, womit der Basic-Anfang im Speicher auf die Adresse dezimal 8193 ($2001) erhöht wird. Somit ergibt sich folgende Speicheraufteilung:
4096 — 4607 Bildschirm
4608 — 8191 frei
8192 — 16383 (bei + 8 KByte) Basic-Programmspeicher
8192 — 24575 (bei + 16 KByte) Basic-Programmspeicher
8192 — 32767 (bei + 24 KByte) Basic-Programmspeicher

Der freie Bereich wird nun vollständig von dem Maschinenspracheprogramm gebraucht. Die Aufteilung des Speicherraums ist die folgende:

TODO

Die Pseudo-Sprites sollten eine Auflösung von 16 x 16 Punkten haben, das sind 256 Punkte oder 4 Zeichen im freidefinierbaren Zeichensatz (Bild 1). Damitaberein 16 x 16 Punkte großes Zeichen jede Position auf dem Bildschirm einnehmen kann, braucht man eine 24 x 24 Punkte große Umdefinier-Matrix, in die das Zeichen hineinkopiert wird. Das Aussehen dieser Umdefinier-Matrix ist in Bild 2 zu sehen. Das Programm übernimmt nun die Aufgabe, das Zeichen in die Umdefinier-Matrix zu kopieren (Bild 3), in die richtige X-Position zu schieben (Bild 4), und dasselbe mit der Y-Position zu tun.

Außerdem werden die Zeichen, die später auf dem Bildschirm von den Sprites verdeckt werden, mit in die Umdefinier-Matrix hineinkopiert. So entsteht der Eindruck, daß die Sprites wirklich über die Zeichen wandern. Beim späteren Löschen werden die verdeckten Zeichen wieder hergestellt. Wie funktioniert das nun?

Im Speicher ab dezimal 4608 ist 9mal (für jedes Sprite einer) der sogenannte Sprite-Control-Block (SCB) eingerichtet. Er hat die Aufgabe, die momentane X- und Y-Position, die Farbe des Sprites, den Bildschirmmodus (gesetzt/gelöscht) des Sprites, die durch die Umdefinier-Matrixverdeckten 9 Zeichen und Farben zwischenzuspeichern:

TODO

Die Basisadresse des SCB errechnet sich somit aus der Formel Basisadresse = 4608 + Spritenummer x 22. Das Zwischenspeichern und die Auswertung der Parameter übernimmt natürlich das Maschinenprogramm. Über den SCB werden auch im nachfolgend beschriebenen Programm »Sprite-Definer« die Sprites initialisiert und deren Farbe festgelegt. Da nur die oberen 128 Zeichen des Zeichensatzes für die Sprites verwendet werden, hat man eine ausreichende Anzahl von noch frei definierbaren Zeichen, nämlich genau 128, zur Verfügung. Außerdem kommenjeweils 13 Zeichen, nämlich 4 für das Sprite und 9 für die Umdefinier-Matrix hinzu, wenn man auf ein Sprite verzichtet. Die Matrixen werden im Speicher so abgelegt:

TODO

Konkret wird das Programm (Listing 1) nun folgendermaßen bedient: Vor dem Laden oder Eingeben wird POKE 44,32:POKE 8192,0:NEW eingetippt. Ist nun das Maschinenspracheprogramm im Speicher, kann es mit einem Monitorprogramm auch noch einmal abgespeichert werden. Später muß man es nur noch mit LOAD »name«, 1,1 laden.

Die Bedienung:
Sind die Sprites definiert. muß dem Maschinenspracheprogramm mitgeteilt werden, wo der Zeichensatz liegt, den es verwalten soll. Das geschieht mit den Befehlen POKE 677, Low-byte:POKE 678, Highbyte, in unserem Fall also POKE 677,0:POKE 678,20, da der Zeichensatz auf der Adresse 5120 beginnt.

Soll nun ein Sprite auf den Bildschirm, muß zuerst einmal in Adresse 683 die Spritenummer gePOKEt werden (Achtung, keine Zahl über 8 angeben, da sich das Programm dann selbst zerstören könnte). Schließlich werden in Adresse 673 die X-Koordinate (maximal 159) und 674 die Y-Koordinate (maximal 167) gesetzt. Dann kann das Programm mit SYS 8021 sofort aufgerufen und auf dem Bildschirm das Sprite betrachtet werden, vorausgesetzt man hat vorher mit POKE 36869,205 auf den freidefinierbaren Zeichensatz geschaltet.

Wird nun das Sprite auf eine andere Position gesetzt, so verschwindet es vollständig von der alten Position, und die Zeichen, die auf diesem Platz waren, erscheinen wieder mit ihrer alten Farbe. Will man aber das Sprite ganz vom Bildschirm löschen, POKEt man wieder in 683 die Spritenummer und ruft das Maschinenspracheprogramm diesmal mit SYS 8099 auf. PRINT »CLR/HOME« sollte man nicht verwenden, da im SCB noch die alten Bildschirmzeichen gespeichert sind und beim nächsten Setzen wieder auf ihren alten Plätzen auf dem Bildschirm erscheinen würden.

## Der Sprite-Generator

Nun zum Programm »Sprite-Definer« (Listing 2).

Dieses Programm ist ein Sprite-Generator in Basic, der bei der Erstellung von Sprites recht hilfreich sein kann. Das Programm verdeutlicht auch, wie die Definition der Sprites und die Bedienung des Maschinenspracheprogramms erfolgt.

Obwohl sich das Programm fast von selbst erklärt, hier doch einige kurze Erläuterungen:

Startet man das Programm mit RUN, erscheint als erstes die Begrüßung und die Aufforderung »Bitte warten!«. Das Programm kopiert nämlich jetzt den Zeichensatz aus dem ROM ins RAM, was in Basic naturgemäß etwas dauert.

Jedesmal, wenn man in einem Menüteil eine Eingabe gemacht hat, wird man »Richtig?« gefragt. Tippt man hier für N (Nein), so kann die Eingabe wiederholt werden. Drückt man aber den Linkspfeil, so kommt man wieder ins Hauptmenü.

Die Tastenbelegung im Editiermodus:

TODO

Bei der Funktion »Weiter« kommt man in ein zweites Menü, das weitere Funktionen zur Verfügung stellt. Aus diesem Menü gelangt man mit »zurück« wieder ins Hauptmenü. Beim Speichern werden die Sprites als reiner Speicherauszug auf Kassette gebracht, so daß das Laden im Prinzip auch mit LOAD »name«,1,1 möglich ist.

Sicherlich kann das Maschinenspracheprogramm noch weiter verbessert werden. So wäre zum Beispiel eine Spritesteuerung per Interrupt durchaus denkbar. Leider funktioniert das Maschinenprogramm nicht mit den üblichen Grafikmodulen, da diese den Bildschirminhalt auch mit dem freidefinierbaren Zeichensatz aufbauen. Sollen Sprites auch miteinander oder übereinander dargestellt werden, dann muß das Setzen und Löschen nach folgender Reihenfolge durchgeführt werden, da es sonst zu Schwierigkeiten mit dem SCB kommen kann:

Sprite 0 setzen, Sprite 1 setzen,..., Sprite n setzen. Hiernach die Berechnungen für die neuen Positionen durchführen.

Sprite n l0schen,.Sprite n-1 löschen,..., Sprite 0 löschen. Danach Vorgang von oben wiederholen.

Noch eins zum »Sprite-Definer«: Die erste REM-Zeile muß aufjeden Fall mit 16 Sternchen eingegeben werden, da sich das Programm später mit POKEs selbst verändert und andernfalls, wäre die REM-Zeile kürzer, die folgende Zeile in Mitleidenschaft ziehen würde. Doch nun wünsche ich allen, die das Programm eintippen, viel Spaß und vielleicht ein bißchen C 64-Feeling.

(Markus Leberecht/ev)

# Hex-DATA-Automat

> Der Computer programmiert sich selbst — Maschinenprogramme werden automatisch in DATA-Statements mit Prüfsumme umgewandelt.

Ein Maschinenprogramm in ein korrektes Basic-Ladepro-gramm umzusetzen, ist sicherlich eine sehr langweilige Programmieraufgabe, außerdem schleichen sich sehr schnell Fehler ein.

Soll diese Umsetzung automatisch erfolgen, müßte sich der Computer — salopp gesagt — selbst programmieren. Dies ist prinzipiell möglich; doch zuvor einige Grundlagen.

Geben Sie hierzu das nebenstehende kleine Testprogramm ein.

<pre>100 POKE 2,0
110 ZL=PEEK(2) : POKE 2,ZL+1
120 D$=STR$(ZL+1000)
130 D$=D$+"DATA ABCFDEF”
140 PRINTCHR$(147);D$
150 PRINT ”RUN 110”
160 :
180 END
</pre>

Die Programmzeile 100 setzt die Speicheradresse 2 auf Null. Anschließend wird der Wert dieser Adresse nach ZL geholt und die Adresse um eins erhöht. Der STR$-Befehl wandelt den WertZL+1000 in einen String, und die Zeile 130 erweitert den String mit »DATA ABCDEF«. Die CHR$-Anweisung löscht anschließend den Bildschirm und schreibt den String »1000 DATA ABCDEF« links oben auf den Bildschirm. Zuletzt wird in der zweiten Bildschirmzeile der Text »RUN 110« gedruckt.

Falls Sie nach RUN die Taste HOME drücken, steht der Cursor auf der Zeile »1000 DATA ABCDEF«. Drücken Sie nun die RETURN-Taste, dann wird die Zeile 1000 in das Programm aufgenommen. Der Cursor steht jetzt auf dem »RUN 110«. Drücken Sie jetzt erneut RETURN, so startet das Programm wieder, und es folgt der nächste Durchgang mit:
1001 DATAABCDEF
RUN 110

Da im ersten Durchlauf der Wert in der Speicherzelle 2 um eins erhöht wurde, lautet die nächste Zeilennummer 1001. Nun könnten Sie wieder (in Handarbeit) HOME/RETURN/RE-TURN eingeben, doch — und jetzt wird’s interessant — auch dies kann der Computer durchführen.
160 POKE 198,3
170 POKE 631,19:POKE 632,13:POKE 633,13

Geben Sie nun RUN ein. Das Programm erweitert sich nun automatisch — ab der Nummer 1000 — um DATA-Zeilen.

Dies ist möglich, da alle Commodore-Computer mit einem Tastaturpuffer arbeiten. In diesem Zwischenspeicher, der beim VC 20 und C 64 ab der Adresse 631 beginnt, kann sich der Computer bis zu neun Tastatureingaben merken. Die Anzahl der Zeichen in dem Puffer steht in der Adresse 198.

In der vorherigen Programmerweiterung wurde in der Zeile 160 der Wert 3 eingePOKEt. Der Computer meint anschließend, es seien drei Tastatureingaben erfolgt. Die POKE-Befehle in der Zeile 170 simulieren die Eingabesequenz HOME, RETURN, RETURN. Nach dem Programmende vergißt der Computer diese untergeschobenen Eingaben keineswegs, sondern führt sie nachträglich aus.

Aus derZeit des legendären PET 2001 stammt noch die Bezeichnung »selbsterhaltendes Programm«. Naja, aberso hatte das Kind wenigstens einen Namen.

Leider hat das beschriebene Verfahren den Nachteil, daß der Computer, sobald er sich selbst die Zeile einprogrammiert, die Variablen löscht. Aus diesem Grund müssen Sie wichtige Werte vor dem Programmabbruch durch POKE sichern und beim Neustart mit PEEK zurückholen. In dem vorherigen Testprogramm wurde beispielsweise der Zähler für die Zeilennummer mit der Adresse 2 weiter gegeben.

Das Programm »HEX-DATA-Automatik« arbeitet im Prinzip genau nach dem zuvor beschriebenen Verfahren. Die Umwandlungsroutine wird mit RUN 200 gestartet. Das Programm fragt dann nach der Anfangs- und Endadresse des Maschinenprogramms und wandelt es anschließend in DATA-Zeilen um. Diese haben das folgende Format:
1000 DATA 01,02,03,04,05,...,20, 1234
1001 DATA 11,12,13,14,15,...,40, 5678
1002 DATA ...

Nach jeweils 20 Hexadezimal-Daten folgt immer eine Prüfsumme.

Anschließend müssen Sie die DATA-Routine (200—720) löschen und den Schleifenzähler in Zeile 30 anpassen. Falls das Programm veröffentlicht werden soll, können Sie zusätzlich ein Copyrightstatement hinzufügen.

Für diesen Zweck wurde diese Routine auch ursprünglich erstellt. Die Zeilen 10—90 wandeln die Hex-Zahlen wieder um und schreiben das Maschinenprogramm in den entsprechenden Speicherbereich zurück (Zeile 30 beachten).

Das Programm kann in dieser Form sehr leicht abgetippt werden, da Prüfsummenfehler wie folgt angezeigt werden:
ZEILE 1000
ZEILE 1001
ZEILE 1002
ZEILE 1003 PRÜFSUMMENFEHLER !
BREAK IN 80

Anschließend müssen nur 20 Daten überprüft werden, so daß auch längere Basic-Lader vergleichsweise schnell und fehlerfrei abgeschrieben werden können.

(Heino Velder/ev)

# Joystick-Abfrage in Theorie und Praxis

> Wenn der Joystickanschluß für Sie »ein Buch mit sieben Siegeln« ist, so wird Ihnen dieser Artikel für den VC 20 weiterhelfen. Doch auch die »Profis« werden einige wichtige Informationen finden.

Ein Joystick besteht aus vier Schaltern, die im rechten Winkel zueinander angeordnet sind. Der Handgriff erlaubt neun abfragbare Positionen:

— eine Position mit allen Schaltern offen: Griff in Ruhe
— vier Positionen mit je einem Schalter geschlossen: Griff in Nord, Süd, Ost, West
— vier Positionen mit zwei Schaltern geschlossen: Griff in Nordost, Südost, Südwest, Nordwest

Ein zusätzlicher »Feuerknopf« hat einen eigenen Schalter.

Grafisch sieht das so aus:

TODO

Jeder der fünf Schalter ist mit je einer Leitung von zwei speziellen integrierten Bausteinen mit dem Namen »VIA 6522« (Versatile Interface Adapter) verbunden. Diese sind, wie der Name andeutet, programmierbare Adapter für die Ein- und Ausgabe (also auch für den Joystick).

Leider sind die fünf Schalter etwas ungleichmäßig auf die beiden VIAs verteilt:

— Schalter 0,1, 2 und der Feuer-Schalter 4 verwenden VIA 1
— Schalter 3 verwendet VIA 2

Der Kontakt des Joysticks mit den VIAs und damit mit dem VC 20 wird durch zum Teil Ihnen schon bekannte Registerzellen geregelt, welche folgende Adressen haben:

— Ein-/Ausgabe-Register A des VIA 1: 37137
— Ein-/Ausgabe-Register B des VIA 2: 37152

Der Vollständigkeit halber sei erwähnt, daß jeder VIA noch ein zweites E/A-Register hat, nämlich:

— E/A-Register B des VIA 1: 37136
— E/A-Register A des VIA 2: 37153

Für den Joystick brauchen wir diese jedoch nicht.

Die einzelnen Leitungsanschlüsse der Joystick-Schalter sind:

— Schalter 0 ... Bit 2 von 37137
— Schalter 1 ... Bit 3 von 37137
— Schalter 2 ... Bit 4 von 37137
— Schalter 4 ... Bit 5 von 37137
— Schalter 3 ... Bit 7 von 37152

Ich habe gesagt, daß 37137 und 37152 Ein- und Ausgaberegister sind, das heißt wir können sie in beiden Richtungen benützen.

Die Entscheidung darüber liegt in je einem zugeordneten »Daten-Richtungs-Register«.

— Dem E/A-Register 37137 ist das DR-Register 37139 zugeordnet.
— Dem E/A-Register 37152 ist das DR-Register 37154 zugeordnet.

Dieses Arrangement erlaubt, jede einzelne Leitung eines E/A-Registers separat auf Ein- oder Ausgabe zu schalten, völlig unabhängig voneinander.

Das geht so:

Sobald in einem Bit des DR-Registers eine 1 steht, ist die entsprechende Leitung des E/A-Registers auf Ausgabe geschaltet, bei einer 0 auf Eingabe.

Im Bild unten habe ich die notwendigen Bitmuster in die beiden DR-Register eingezeichnet.

Im Register 37139, an dem ja vier Schalter hängen, wäre die hineinzuPOKEnde Zahl 195. Da aber während der Joystick-Abfrage dieses Register für nichts anderes verwendet wird, setzen wir ruhig das ganze Register auf 0.
10 POKE 37139,0

Beim Register 37154 ist die Lage anders, dadas zugehörige E/A-Register 37152 zur Tastaturabfrage verwendet wird. Da müssen wir die Auswahl der Leitung schon genau machen.
20 POKE 37154,127

Während der Joystick-Abfrage funktionieren die Tasten in der Spalte 127 der 8 x 8-Matrix nicht.

Zeile 10 und 20 »initialisieren« die Joystick-Abfrage.

Ein Experimentier-Programm zum Testen, was jetzt bei der Bewegung des Joysticks stattfindet, ist ganz einfach:
30 PRINT PEEK(37137);PEEK(37152)
40 GOTO 30

Am Ende empfiehlt es sich, die volle Tastatur wieder einzuschalten mit
POKE 37154,255

In einem Programm können Sie also einfach die Werte in den beiden Adressen der Zeile 30 (mit IF ... THEN) abfragen.

Zur Vermeidung von eventuellen Störungen durch die Mehrfachfunktionen der Register ist es aber empfehlenswert, die einzelnen Bits direkt abzufragen. Das sieht dann so aus:
10 POKE 37139,0
20 POKE 37154,127
30 IF PEEK(37137) AND 4 THEN...   (Schalter 0)
40 IF PEEK(37137) AND 8 THEN...   (Schalter 1)
50 IF PEEK(37137) AND 16 THEN...  (Schalter 2)
60 IF PEEK(37137) AND 32 THEN...  (Schalter 4 = Feuerknopf)
70 IF PEEK(37152) AND 128 THEN... (Schalter 3)
80 POKE37154,255

(Helmuth Hauck/rg)

# Unterbrechen Sie mich bitte!

> Im Gegensatz zum Bereich zwischenmenschlicher Beziehungen, wo jemanden zu unterbrechen als plumpe Unhöflichkeit eingestuft wird, ist dies einem Computer gegenüber nicht nur ein beliebtes, sondern sogar erwünschtes Verfahren effektvoller Programmgestaltung. Für die meisten Anwender aber sind solche, »Interrupt« genannte, Methoden — leider — mehr oder weniger »Böhmische Dörfer«.

Anhand der vielseitigen Hardware des Commodore 64 wollen wir nun einmal den Schleier des Geheimnisses ein wenig lüften, Ihnen mit einem Demonstrationsprogramm einige Anwendungsbeispiele zeigen und Sie auf Ihrem Bildschirm kein blaues, aber ein buntes Wunder erleben lassen.

Wenn Sie Ihren C 64 einschalten, und der Cursor blinkt, dann haben Sie bereits einen Interrupt erzeugt. Es handelt sich dabei um eine gezielte Programmunterbrechung, die auf ein bestimmtes Ereignis fixiert ist, so zum Beispiel den Inhalt einer Speicherstelle. Tritt der erwünschte Zustand ein, so räumt die Hardware diesem Vorgang Priorität vor allen anderen Aufgaben ein. Gleich was der Computer im Augenblick macht, er wird unverzüglich seine Tätigkeit einstellen und ein spezielles Unterprogramm abarbeiten, das ihm zuvor als Interruptroutine deklariert wurde. Im Betriebssystem-ROM befindet sie sich von Adresse $EA31 (dezimal 59953) bis $ECB8 (60600). Hier wird etwa 60mal in jeder Sekunde geprüft, ob eine — und falls ja, welche — Taste gedrückt wurde; hier wird das Blinken des Cursors erzeugt und der Motor der Datasette ein- oder ausgeschaltet. Wenn der Interrupt beendet ist, setzt der Computer die Bearbeitung des laufenden Programms exakt an der Stelle fort, an der er sich vor Eintritt des Interrupts gerade befand. Gewöhnlich merkt man von solchen Intermezzi nichts, weil der Prozessor eine ungeheure Geschwindigkeit entwickelt, deren Arbeitstakte sich bereits im Bereich von Mikrosekunden (millionstel Sekunden) bewegen.

Noch eine andere Einrichtung der von Ihnen benutzten Geräte ist mit extremer Schnelligkeit ausgestattet: Der Elektronenstrahl, der vor Ihren Augen 25mal in jeder Sekunde ein neues Bild auf die Mattscheibe zeichnet. Nach diesen grundsätzlichen Überlegungen wollen wir aus solchen Voraussetzungen einen Wettstreit der Systeme entwickeln und den Computer gegen den flotten Strahl antreten lassen. Unglaublich, werden Sie jetzt wahrscheinlich sagen, aber warten Sie ab! Möglich ist das nämlich, weil der für die Bildorganisation zuständige Video-Interface-Controller (VIC) stets genau darüber »im Bild« ist, welche Rasterzeile des Monitorbildes augenblicklich geschrieben wird. Das ist die Bedingung dafür, daß auf dem Schirm auch ein Bild im geordneten Zusammenhang wiedergegeben wird. Der VIC, dessen Register unter den Adressen 53248 ($D000) bis 53294 ($D02E) erreichbar sind, führtin derSpeicherzelle 53266 ($D012) Buch über die jeweilige Zeilennummer. Darüber war schon einmal zu lesen, daß es unsinnig wäre, dort etwas hineinzuschreiben, weil man den Elektronenstrahl der Bildröhre gar nicht steuern könne. Und das ist nur zum Teil richtig, denn steuern können wir den Strahl nicht, wohl aber können wir ihn steuern lassen.

Dafür ist besagtes Register — wie übrigens viele andere auch — mit einer Doppelfunktion ausgerüstet. Abhängig von der jeweiligen Zugriffsart, Lesen oder Schreiben (PEEK oder POKE), erreicht man unter derselben Hausnummer verschiedene Adressaten. Wird das Register gelesen, so erfährt man die gerade bearbeitete Rasterzeile, wird es beschrieben, bleibt der übermittelte Wert gespeichert und dient dem internen Vergleich, ob er mit der aktuellen Zeile identisch ist. Wenn dieser Fall eintritt, so reagiert die Hardware selbständig darauf und erzeugt einen Interrupt — falls ein solcher vorgesehen war. Zuvor muß dem Computer nämlich noch mitgeteilt werden, daß dies ein Interruptauslöser sein soll. Die Anmeldestelle ist die Adresse 53274 ($D01A), das Interrupt-Masken-Register.

Diese Speicherstelle korrespondiert ständig mit ihrem Nachbarn 53273 ($D019), dem Interrupt-Request-Register. Ist die vorgewählte Rasterzeile erreicht, signalisiert 53266 dieses Ereignis durch Kippen des Bits 0 im Request-Register: Es nimmt den Wert 1 an. Ist Bit 0 auch in der Maske gesetzt, wird der Interrupt-Pin des VIC aktiv und löst die Unterbrechung aus. Im Demo-Programm schreiben wir zu diesem Zweck eine 1 in die Maske, und fortan gilt für uns die Gesetzmäßigkeit, daß Bildhintergrund und -rand unifarben dargestellt werden, nicht mehr. Wir ändern nämlich ab einer beliebigen Rasterzeile die Bildfarben, um sie einige Zeilen weiter abermals umzuschalten. Da das schneller vor sich geht, als das träge menschliche Auge es registrieren kann, resultiert daraus kein wirres Flackern, sondern ein konstantes mehrfarbiges Bild, das im Extremfall (siehe Beispiel »Regenbogen«) sogar alle 16 möglichen Farben des Randes und Hintergrunds gleichzeitig wiederzugeben in der Lage ist.

Noch aber funktioniert der neue Interrupt nicht, denn der C 64 weiß noch nichts von unserem Programmsegment, mit dem wir den Farbwechsel vornehmen wollen. Dazu müssen wir ihm die Adresse der Routine im Interrupt-Vektor ab Speicherstelle 788 ($0314) hinterlegen: Lowbyte in 788, Highbyte in 789. Aber auch jetzt wird das Ergebnis immer noch nicht unseren Erwartungen entsprechen, da uns laufend der immer noch aktivierte Systeminterrupt in die Quere kommt und nach der Vektorenänderung ebenfalls in der neuen Routine unkontrolliert arbeitet. Dieser Interrupt stammt aus einer ganz anderen Quelle, vom Complex-Interface-Adapter (CIA), auf den wir gleich noch zu sprechen kommen. Softwaremäßig können wir ihn durch Setzen der Interruptflagge (SEI) nicht unterbinden, weil damit auch der ebenfalls maskierbare Rasterzeilen-lnterrupt abgeschaltet würde. Zwei Möglichkeiten gibt es, das Problem zu lösen: Der CIA-Interrupt wird belassen, muß dann aber zu Beginn der Interrupt-Routine abgefragt (zum Beispiel durch Prüfen des Bits 0 im Request-Register 53273) und gegebenenfalls durch eine Umleitung über Sprungbefehle unschädlich gemacht werden, oder er wird eliminiert durch Schreiben des Wertes 127 in die Speicherstelle 56333 ($DCOD). Weil wir in unserem Demo-Programm weder Cursor-Blinken noch die Tastaturabfrage benötigen, entscheiden wir uns für letztere und löschen gleich zu Programmbeginn (siehe Assembler-Listing) den CIA-Interrupt völlig.

Außerdem ist zu berücksichtigen, daß der Elektronenstrahl auf allen Seiten ein Stück über den Rand des auf dem Monitor sichtbaren Bildes hinausschreibt. Dadurch entstehen Zeilennummern bis 280, so daß von Register 53266 aus bei einem Überlauf ein Highbyte nach Bit 7 des Registers 53265 übertragen werden muß. In dieser als »SCREEN« definierten Speicherstelle liegen allerdings auch einige andere Funktionen, die gegebenenfalls durch eine logische OR-Verknüpfung berücksichtigt werden müssen. Das Demo-Programm verwendet diese Funktionen indem durch Löschen des Bits 4 der Bildschirm ausgeblendet wird, so daß auf dem Schirm nur noch ein ganzflächiger Rand erscheint, obwohl auch weiterhin Texte auf den jetzt unsichtbaren Hintergrund ausgegeben werden können. Beispiel: POKE 53265, PEEK (53265) AND 255-16 läßt den Hintergrund verschwinden, POKE 53265, PEEK(53265) OR 16 zaubert ihn dann wieder herbei.

Der Rasterzeilen-Interrupt ist eine Spezialität des C 64, die ihn zu einem äußerst vielseitigen Gerät macht. Die Programmier-Profis der Videospiel-Produzenten benutzen ihn nicht allein dafür, oben blauen Himmel und unten braune Erde darzustellen, sondern auch, um ein nur partielles Scrolling zu erzielen, um Text und hochauflösende Grafik zu mischen, um gleichzeitig normale und Multicolorzeichen zu benutzen und und und... Aber damit erschöpfen sich die Interruptmöglichkeiten des Commodore 64 noch nicht. Bit 1 (Wert = 2) der Maske in 53274 erzeugt einen Interrupt, wenn ein Sprite Berührung mit einem Zeichen hat, Bit 2 (Wert = 4) wenn Sprite mit Sprite zusammenstößt, Bit 3 (Wert = 8) wenn ein Impuls vom Lightpen kommt, oder der Feuerknopf eines am Controlport 1 angeschlossenen Joysticks gedrückt wird und schließlich Bit 7 (Wert = 128), wenn eines der genannten Ereignisse eingetreten ist

Und dann ist da noch der bereits genannte CIA-Interrupt, der von einem gleich doppelt vorhandenen Baustein stammt. Beiden sind jedoch im C 64 teilweise unterschiedliche Aufgaben zugewiesen. CIA 1 hat die Basisadresse 56320 ($DC00), CIA 2 eine solche von 56576 ($DD00). Hier erfolgt beispielsweise die Tastaturdekodierung, die Abfrage von Joysticks, Paddles und Lightpen, die serielle Datenübertragung zu einer Schnittstelle, hier befinden sich die Echtzeituhren und die Timer. Wenden wir uns letzteren in CIA 1 zu.

Der Timer ist ein 16-Bit-Zählregister, das nach dem Starten ohne weiteres Zutun mit einer konstanten Geschwindigkeit dekrementiert, das heißt jeweils um 1 abwärts gezählt wird. Durch die zuvor beim VIC schon erwähnte Doppelfunktion besteht die Möglichkeit, den Timer ab einem bestimmten Wert zählen zu lassen: Lesen der Adresse 56324 ($DC04) liefert den aktuellen Stand des Lowbytes, Hineinschreiben den Startwert des Timers, ebenso beim Highbyte unter der Adresse 56325. Auf diese Weise wird der Systeminterrupt erzeugt, da der Computer in der Initialisierungsphase den Timer mit dem Wert 16421 ( = 37 low und 64 high) lädt. Wenn derTimerüber Null hinauszählt und damit einen sogenannten Unterlauf erzeugt, wird das durch Setzen des Bits 0 im lnterrupt-Control-Register 56333 ($DC0D) signalisiert. Auch dieses arbeitet wieder doppelt: Lesen ergibt die Interruptanforderung, ein Schreibzugriff erzeugt die Maske, die darüber entscheidet, welches Ereignis Interruptauslöser sein soll. Besondere Beachtung beim Beschreiben des Registers verdient Bit 7, das darüber bestimmt, ob die nachfolgend gesetzten Bits 6 bis 0 in der Maske gesetzt oder gelöscht werden. Alle übrigen bleiben unangetastet. Deshalb löscht 127 (Bit 7 nicht gesetzt!) im Demo-Programm sämtliche Maskenbits (siehe Bitmuster im Assembler-Listing, Zeile 1010), deshalb setzt 129 (Bitmuster 10000001) das Bit 0 der Maske und schaltet damit auf Interrupt durch den Timer. Erzeugen Sie doch einmal im Direktmodus auf dem Bildschirm ein längeres Zählintervall durch Heraufsetzen des Timer-Highbytes: POKE 56325, 255 läßt den Cursor sehr träge werden, POKE 56325, 5 versetzt ihn in nervöses Flattern.

Dieser Timer besitzt einen Zwillingsbruder mit den Adressen 56326 und 56327, der nicht nur gleichartig konstruiert ist und ebenfalls eigenständig einen Interrupt auf Bit 1 des Control-Registers erzeugen kann, sondern sich auch mit dem Timer A koppeln läßt. Beide Timer können nämlich auf verschiedene Taktquellen gelegt, unterschiedlich getriggert werden. Im Demo-Programm nutzen wir das aus, indem wir Timer A Systemtakte zählen lassen (Bit 5 des Registers 56334 gelöscht — Standardeinstellung), Timer B hingegen nur die Unterläufe von Timer A durch Setzen des Bits 6 im Register 56335. Dadurch erhalten wir einen 32-Bit-Zähler, der beliebige Zeitverzögerungen ermöglicht, eleganter als mitjeder ausschließlich softwaremäßig realisierten Warteschleife, weil die Timer von keinem Interrupt unterbrochen werden.

In der Warteschleife des Demo-Programms (Listing ab Zeile 9010), die als Subroutine angelegt ist, wird mit den Timern kein Interrupt erzeugt, sondern lediglich eine Zeitverzögerung erzielt. Dazu wird zunächst Timer B mit den vom Hauptprogramm im Akku und im Y-Register übergebenen Werten geladen, während Timer A konstant mit einem mittleren Wert arbeitet. Dann werden beide gestartet durch Setzen des Bits 0 im Register 56334 für Timer A und 56335 für Timer B. Aus Zeile 9030 des Listings ist ersichtlich, daß Bit 3 für Timer A gelöscht ist, was Continuous- oder Dauerbetrieb zur Folge hat. Jedesmal, wenn der Timer einen Unterlauf hat, lädt er umgehend wieder den zwischengespeicherten Startwert und beginnt erneut zu zählen. Den anderen schalten wir hingegen auf One-Shot (Zeile 9050), einen »Einzelschuß«. Bei einem Unterlauf lädt er zwar wieder den Startwert, bleibt aber stehen, wodurch sein Start/Stoppbit automatisch gelöscht wird. Wir prüfen dies, indem wir Bit 0 logisch nach rechts ins Carry verschieben, wo es bequem mit einem Branchbefehl untersucht werden kann. Erst der One-Shot-Betrieb des Timers B stellt sicher, daß ein Unterlauf auch erkannt wird, weil er im Dauerbetrieb vorübergehen könnte, während sich der Prozessor im Interrupt befindet. Außerdem verlangt ein gesetztes Bit 4 in der Warteschleife für beide Timer Force-Load, einen unbedingten Ladevorgang. Unabhängig davon, ob der Timer gerade läuft oder nicht, wird der Startwert geladen. Mit einem gelöschten Bit 4 kommt ein neuer Startwert erst dann zum Tragen, wenn er nach dem nächsten Unterlauf geladen wird.

Neben den Unterläufen der beiden Timer kann das Control-Register 56333 auf Bit 2 auch einen Interrupt erzeugen bei Übereinstimmung der Echtzeituhr 56328 bis 56331 mit einer vorgewählten Alarmzeit, auf Bit 3 durch ein volles oder leeres Schieberegister (56332) und auf Bit 4 durch den Impuls einer externen Signalquelle. Ein gesetztes Bit 7 zeigt hier an, daß mindestens eines der gesetzten Bits auch in der Maske gewählt ist, also ein Interrupt stattfindet. Das Interrupt-Flag wird aber bereits durch Lesen des Registers gelöscht.

Diese Kurzabhandlung vermag nur ansatzweise darzustellen, wie flexibel das Instrumentarium ist, das hier dem Anwender zur Verfügung steht. Speziell die zahlreichen Interruptmöglichkeiten verlangen geradezu nach Anwendung, wobei wir abschließend auf eine bisher nicht erwähnte noch zu sprechen kommen müssen. Denn das Demo-Programm läuft in einer Endlosschleife, die nicht ohne weiteres abgebrochen werden kann. Außerdem wirdja durch den lahmgelegten Systeminterrupt ohnehin kein Tastendruck mehr erkannt. Den Ausweg aus diesem Dilemma, haben die Konstrukteure geschaffen, als sie den sogenannten NMI erfanden. Das ist die Abkürzung für nicht maskierbarer Interrupt, eine hardwareseitige Unterbrechungsmöglichkeit mit so hoher Priorität, daß selbst ein gesetztes Interruptflag keine Rolle spielt. Wir können den NMI auslösen, indem wir die STOP-Taste gedrückt halten und gleichzeitig auf die RESTORE-Taste klopfen. Und schon ist alles wieder normal: Bild und Interrupt. Sie können zwar gleich wieder mitSYS49152 ins Demo-Programm starten, doch vielleicht lassen Sie sich selbst einmal etwas einfallen. Nur zu — unterbrechen Sie doch Ihren Commodore 64 bitte mal ...

(Helmut Welke/aa)

# Betriebssystem-Erweiterung für den VC 20

> Hier sind einige Erweiterungen für das Betriebssystem des VC 20, die auf Tastendruck funktionieren, wie zum Beispiel Hardcopy, Find, Relocate, Append und Beep.

Diese nützlichen Routinen werden mit dem Basic-Lader (Listing) ab Adresse $6050 in den Speicher gebracht. Ein voll ausgebauter VC 20 (+24 KByte) ist daher Voraussetzung. Um das Programm in die Tastaturabfrage einzubinden, die alle 60stel Sekunde erfolgt, wird der Zeiger für die Tastaturdecodierung (655,656) abgeändert. Damit dort nicht nach jedem STOP/RESTORE wieder der alte Wert steht, wird auch noch der BRK-Vektor (790,791) abgeändert. Zu alledem dient der SYS-Befehl in Zeile 120. Im einzelnen stehen folgende Erweiterungen zur Verfügung (die Druckroutinen sind für den Epson RX-80 mit VC-Interface):
CTRL G: Grafik auf Drucker (mit VIC 1211A)
CTRL D: Bildschirm-Hardcopy mit Zwischenzeile
CTRL H: Bildschirm-Hardcopy ohne Zwischenzeile (zum Beispiel für normale Blockgrafik)

Dabei ist zu beachten, daß das letzte Zeichen rechts unten nicht gedruckt wird, da sonst der Bildschirm gescrollt würde. Ein Bildschirm-Dump kann jederzeit erfolgen, auch während des Programmablaufs.
CTRL F: FIND mit Eingabe des Suchstrings
CTRL L: FIND weiter

FIND durchsucht ein Basic-Programm nach bestimmten Befehlen oder Zeichenfolgen und listet die Zeile, in der sich der gesuchte Begriff befindet. FIND weiter (CTRL L)bedeutet, daß das Programm weiter nach demselben Begriff durchsucht wird. Dabei ist eine Zeichenkette in Anführungszeichen einzugeben. Beispiel: Gesucht wird die Anweisung IF. Eingabe IF. Gesucht wird der String »REIF«. Eingabe »REIF«.

Im folgenden bedeutet »CTRL+Com«, daß die CTRL- und die Commodore-Taste gleichzeitig gedrückt werden.

CTRL+Com R:RELOCATE; rückgängig machen des NEW-Befehls. Diese Routine istbesonders nützlich, wenn ein Reset-Schalter existiert, da bei einem Reset ein Basic-Programm nicht zerstört wird, sondern wie bei NEW nur die ersten beiden Bytes auf Null gesetzt werden. Falls der Computer sich also mal beim Aufruf eines fehlerhaften Maschinenprogramms »aufhängt«, kann nach Reset, SYS 25600 und Drücken von CTRL+Com R ohne Verlust des Basic-Programms weitergemacht werden.

Auch nach einem »LOAD-ERROR« kann nach RELOCATE das falsch geladene Programm gelistet werden.

CTRL+Com S: Kopiert die Zeiger auf den Basic-Programm-start, die Variablen, Arrays und Strings und die ersten 65 Byte des Basic-Programms in den (hoffentlich) geschützten Bereich, in dem sich die Betriebssystemerweiterung befindet.

CTRL+Com+RETURN-Taste: Umkehrfunktion von CTRL +Com S

Falls ein Programm gelöscht und anschließend im Direktmodus mit Variablen gearbeitet wurde, dann ist der Anfang des gelöschten Programms zerstört. Das Programm kann nicht mit RELOCATE repariert werden. Wurde aber vorher zu irgendeinem Zeitpunkt, an dem das zerstörte Programm noch existierte, CTRL+Com S gedrückt, dann steht das Programm nach Betätigen von CTRL+COM+RETURN-Taste wieder mit allen Variablen, Arrays und Strings so zur Verfügung, wie zum Zeitpunkt des Kopierens.
CTRL+Com —: BEEP aus
CTRL+Com +: BEEP an

BEEP dient als akustische Rückmeldung der Tastatur, daß eine Taste gedrückt wurde. Ein momentan laufender Sound wird nicht beeinflußt.

CTRL+Com t: APPEND. Der Zeiger auf den Basic-Anfang wird auf das Ende des momentanen Programms gesetzt. So können mehrere Basic-Programme aneinandergehängt werden. Dabei wird die Größe des zur Verfügung stehenden Spei-cherplatzesausgegeben. Durch CTRL+Com -: werden das angehängte und das vorherige Programm verknüpft.

CTRL+Com W: WARTE. »Friert« den Computer ein, bis die RETURN-Taste gedrückt wird. Diese Routine ist vor allem bei LIST nützlich: Das Bildschirm-Scrollen wird verhindert.

Die Funktion der Zusatztasten wird dabei nicht beeinflußt, so daß während dieses Zustands zum Beispiel auch eine Hardcopy angefertigt werden kann.

Soll das Progamm mit der VC1211A-Supererweiterung zusammmenlaufen, dann müssen folgende Änderungen vorgenommen werden:
Zeile 25: Die letzten drei DATA-Werte lauten 55,163,0.
Zeile 43: Die ersten vier DATA-Werte lauten 0,32,13,164.
Zeile 120: SYS 25453 (muß auch beim Aufruf der Relocate-Funktion angegeben werden.

Nachdem diese Änderungen durchgeführt sind, stimmen natürlich die Prüfsummenabfragen nicht mehr. Es empfiehlt sich daher, das Programm in jedem Falle zunächst einmal probeweise unverändert (und ohne VC 1211A) laufen zu lassen, um eventuelle Tippfehler in den DATA-Zeilen herauszufinden. Danach kann man die Prüfsummenabfragen in den Zeilen 10, 30, 40, 60, 70, 90, 100 und 110 einfach löschen.

(Manfred Weigt/ev)

# Befehlserweiterung für Simons Basic

> Die Fähigkeiten des Commodore 64 sind mit dem vorhandenen Befehlsvorrat des Basic 2.0 nur sehr schwer auszunutzen. Dafür bietet Commodore eine Erweiterung an, die diesen Mangel weitgehend behebt: Simons Basic. Dieser Artikel gibt eine grobe Speicherbelegung und behebt einige Mängel.

Leider muß im voraus erwähnt werden, daß nur Besitzer der Disk-Version POKEs anwenden können, da bei der Modul-Version ein unveränderbares ROM vorliegt und somit POKEs hier unwirksam sind.

Obwohl nur 8 KByte im Basic-Speicher verbraucht werden, ist Simons Basic eine 16-KByte-Basic-Erweiterung. Die zweiten 8 KByte liegen unter dem Basic-ROM im RAM, so daß Simons Basic immer trickreich zwischen beiden Ebenen umschalten muß. Zusätzlich wird auch der Bereich von $C400-$CBFF (dezimal 50176-52223) benutzt; zum Beispiel liegt der KEY-Funktionstastenspeicher ab $C64D (50765).

Bei MEM (dem Befehl zum Kopieren des Original-ZeichenROMs ins RAM und dessen Einschalten) liegt der Zeichensatz ab $E000 (57344) im RAM unter dem Kernal, der Bildschirm von nun an ab $CC00 (52224), die Sprite-Pointer ab $CFF8 (53240) und die Sprites von $C000-$C3FF (49152-50175).

Bei HIRES und MULTI (den Grafik- und Farbgrafik-Modi) liegt der Grafik-Speicher unter dem Kernalim RAM ($EOOO-$FFFF, 57344-65535), der Farbspeicher ab $C000 (49152), und Sprites finden sich in den Blocks 48-63 (ab $CC00, 52224). Man sieht also, daß $COOO-CFFF (49152-53247) laufend belegt sind und kleine Maschinenroutinen höchstens in Sprite-Speichern plaziert werden können.

Hier erst einmal Beanstandungen zur Beschreibung einiger Befehle:

Beim **TEXT-Befehl (Einsetzen von Text in die HiRes-Grafik-Seite) müssen Zeichentyp, Größe und Abstand als Konstanten gegeben sein, da der Text sonst nicht korrekt ausgedruckt wird. <CTRL-A> und <CTRL-B> können beliebig in einem String benutzt werden. Kein CTRL am Anfang wird als Großschrift ausgelegt. <RVS ON/OFF>-Zeichen werden auch richtig ausgeführt.

Beim Befehl **FETCH** (Eingaberoutine mit bestimmbarer Zeicheneingabe-Beschränkung) fehlt die Angabe, daß die Eingabelänge über ein Zeichen (wie angegeben) hinausgehen darf. Das Limit liegt bei 88 Zeichen. Danach ist der Eingabepuffer, in den die eingegebenen Zeichen abgelegt werden, gefüllt und dahinterliegende Systemvariablen (siehe C 64-Handbuch) können zerstört werden. Ein Fehler ist außerdem, daß nach der Eingabe des letzten Zeichens keine Korrektur (mit < DEL>) mehr möglich ist. Es bleibt keine andere Wahl, als <RETURN> zu drücken.

Bei **DUMP** (Ausgabe der Inhalte aller nicht indizierten Variablen) werden die Werte leider ohne Vorzeichen ausgegeben. Dies kann man beheben mit **POKE 32953,221**. Zudem werden leere Strings (Länge 0) als Strings mit zufälligen 255 Zeichen und Integervariablen als 16-Bit-Adressen ausgegeben. Das Programm in Listing 1 beseitigt alle drei Fehler.

Im Handbuch wird bei den Bildschirmroll-Befehlen das Format leider falsch angegeben. Die Parameter werden mit der Routine geholt, die auch INV und MOVE bedient. Daher ist auch das Format das gleiche:
Richtung W/B r,c,w,d.

Die Parameter entsprechen denen im Simons Basic-Handbuch in Abschnitt 7.6.

Bei **MERGE** kann es vorkommen, daß ein Programm nicht ordnungsgemäß angehängt wird. Dieser Fehler kommt nicht mehr vor, wenn man immer **OLD** vor MERGE eingibt, da dieser Befehl das Programmende noch einmal überprüft und gegebenenfalls bereinigt.

Bei **PAGE** kann man das Listen nicht, wie in der Anleitung angegeben, durch Drücken der RUN/STOP-Taste abbrechen. Das Programm in Listing 2 behebt diesen Fehler.

Befehle, die zwar nicht im Handbuch, jedoch in der Befehlsliste im RAM zu finden sind, wurden bereits in früheren Ausgaben behandelt.
Zur Speicherung der Simons Basic-Befehle:

Die Befehle werden als Zwei-Byte-Kombination abgespeichert. Das erste Byte hat den Wert 100, und das zweite einen Wert zwischen 1 und 127. Dies ergäbe eine Befehlsmenge von 127 Befehlen, einige Tokens sind aber nicht belegt.

Um alle Befehlscodes auszugeben, kann man Listing 3 verwenden. Nach RUN wird eine Liste der Interpretercodes ausgegeben, die direkt aus dem RAM von Simons Basic und aus dem Basic-ROM entnommen wird. Setzt man in Zeile 20 für A den Wert 12 7 ein, so wird nur der normale Befehlsvorrat ausgedruckt. Mit diesem geänderten Programm kann sich jeder C 64-Anwender eine Interpretercodetabelle erstellen, die leider im C 64-Handbuch fehlt.

Nun zwei kurze Maschinenprogramme, die nach einmaligem Lauf als neue Befehle zur Verfügung stehen:
**ERROR**:

Ausgabe des Diskettenstatus auf dem Bildschirm (Listing 4).
**JOY n**:

Nach Ausführung dieses Befehls liest die Funktion JOY den Control Port n (n=1 oder 2) (Listing 5).

Die Listings 1 und 5 lassen sich zum Beispiel als Vorprogramm nach dem Start von Simons Basic laden und starten und stehen danach bis zum Ausschalten des Computers bereit.
(Dieter Temme/gk)

# Die Ebenen des Absturzes

> Nachdem ich mir den Commodore 64 gekauft hatte, schnappte ich mir das Handbuch und fing an, in Basic zu programmieren. Wenn ich einmal versehentlich in eine Endlosschleife geriet, drückte ich die Run/StopTaste, und das Programm wurde unterbrochen, damit ich den Fehler beseitigen konnte — die Computerwelt war in Ordung!

Doch wer den C 64 kennt, hat sich sicher schon an die Befehle PEEK und POKE versucht. Zum Beispiel:
100 FOR I = 0TO999
110 POKE 1024 + I,0
120 POKE55296 + I,0
130 NEXT I

Dieses kleine Programm füllt den Bildschirm mit schwarzen Klammeraffen. Doch wehe, man hat in Zeile 100 statt 999 die leicht erweiterte Version 9999 stehen! Direkt hinter dem Bildschirmspeicher liegt der Basic-Benutzerspeicher. Bei solchen Fehlern frißt sich das Programm von selbst auf. Das Programm ist teilweise, wenn nicht ganz, zerstört. Der fortgeschrittene Programmierer macht sich sicher eines Tages Gedanken, wie er seine Programme durch versehentliches Drücken der Run/Stop-Taste schützen kann.

Dieses ist besonders dann angebracht, wenn das fertige Programm von einem C 64-Unkundigen bedient werden soll.

Dieses kleine Porgramm bewirkt Wunder:
100 FOR I = 830TO834
110 READ A : POKE I,A : NEXT I
120 POKE 808,62 : POKE 809,3
130 DATA169,1,201,0,96

Weshalb? Im Betriebssystem gibt es ein Unterprogramm, welches die 8topp-Taste abfragt. Das Programm liegt zwischen 63213 ($ F6ED) und 63226 ($ F6FA). Die Anfangsadresse dieser Routine ist in den Speicherzellen 808 und 809 gespeichert; und zwar Low-Byte vor High-Byte. Nun wird diese Routine regelmäßig aufgerufen. Ist die Stopp-Taste gedrückt worden, so veranlaßt diese Routine — abgesehen von ein paar anderen Instruktionen —, daß das Zeroflag gesetzt wird. Wurde die Stopp-Taste aber nicht gedrückt, so löscht dieses Unterprogramm das Zeroflag. Wenn die Speicherzellen 808 und 809 so verändert werden, daß zu einer Routine gesprungen wird, die immer das Zeroflag löscht, dann wird nie das Drücken der Stopp-Taste erkannt. Dieses geschieht durch unser kleines Programm, welches eine Routine in den Kassettenpuffer schreibt.

Haben wir für kritische Programmteile die Stopp-Taste unterdrückt, können wirjene wieder durch den Befehl
200 POKE 808,237 : POKE 809,246
aktivieren.

Nehmen wir einmal an, uns ist folgendes passiert: Wir haben ein Programm geschrieben, das die Stopp-Taste ausschaltet (damit auch Run/Stop + Restore). Das Programm stürzt ab (zum Beispiel durch eine Endlosschleife), und wir haben es noch nicht abgespeichert. Das Programm scheint verloren, denn wir können den Computer nur noch aus- und einschalten. Doch da gibt es noch eine Rettung. Das magische Wort heißt RESET.

Falls Sie in einem Programm einen Reset wünschen, dann benutzen Sie folgenden Befehl:
100 SYS 64738

Der Bildschirm verengt sich links und rechts um ein halbes Zeichen, und dann meldet sich der Computer, als ob sie ihn gerade eingeschaltet hätten. Hardwaremäßig bewirken sie einen Reset, indem Sie Pin 1 und Pin 3 am User-Port verbinden.

Sie können aber auch Pin 2 und Pin 6 am seriellen Bus verbinden. Dazu nehmen Sie das Kabel aus dem Floppy-Laufwerk und verbinden die beiden Pins. Das Prinzip ist, die Reset-Leitung mit der GND-Leitung (Erde) zu verbinden.

Komfortabler geht es mit einem Resetschalter, der in den User-Port eingeschoben wird und per Knopfdruck einen Reset bewirkt.

Wenn Sie nun versuchen, Ihr Programm zu listen, wird Ihre Skepsis zunächst bestätigt werden. Es gibt scheinbar kein Programm mehr.

Durch das Rücksetzen (Reset) des Computers sind alle Basic-Pointer auf ihren Urzustand gebracht worden. Das Programm selbst existiert noch, denn der Basic-Benutzerspeicher wurde nicht gelöscht. Um die Zeiger (Pointer) zurückzusetzen, und somit Ihr Programm wieder sichtbar zu machen, laden Sie das Programm »UNNEW« ein, das Sie hoffentlich vorher eingetippt haben. Nun starten Sie es und — das Basic-Programm wird wieder sichtbar.

Haben Sie vor dem Reset in Maschinensprache mit einem Monitor (zum Beispiel HES-Mon oder Supermon 64) programmiert, dann starten Sie den Monitor und fahren Sie mit der Programmierung beziehungsweise dem Testen fort. Sowohl Ihr Maschinenprogramm als auch der Monitor wurden nicht zerstört.

Haben Sie sich einmal mit dem Umgang des Resets vertraut gemacht, werden Sie sicher auch gerne einmal hinter die Kulissen von Videospielen schauen wollen. Dieses konnten Sie bisher nicht, weil viele Programme die Run/Stop-Taste sperren. Funktioniert der Reset, dann können Sie mit einem Monitor das Spiel erforschen. Doch was geschieht, wenn der Reset wirkungslos bleibt? Wie kann sich ein Videospiel gegen das scheinbare Aus- und Einschalten schützen?

Die Lösung besteht in der Möglichkeit, Module anzuschließen, nämlich wenn Sie ein Modul einschieben und das Gerät einschalten, dann meldet sich keineswegs Basic V2.0 mit einem READY, sondern das Modul übernimmt das Kommando, ohne daß Sie es dazu aufgefordert hätten.

Dazu muß das Modul drei Sachen veranlassen:

1.	Den Basic-Interpreter ausblenden,
2.	sich als Modul zu erkennen geben und
3.	eine Einsprungadresse zur Verfügung stellen.

Das Wegbleiben eines ROMs, sei es der Basic-Interpreter oder das Betriebssystem, erfolgt durch Setzen beziehungsweise Löschen von Bits in der Speicherzelle 0001. Dort liegen die für uns interessanten Kanäle High-RAM und Low-RAM, die durch die beiden Bits 0 und 1 dargestellt werden. Im Einschaltzustand sind beide gesetzt. Ferner gibt es die hardwaremäßigen Kanäle GAME und ExROM. Diese liegen im Moduleinschub und sind ohne Modul auf High (1) gesetzt. Wird ein Modul eingeschoben, so bewirkt dieses, daß die Kanäle GAME und ExROM auf Low gesetzt werden. Dadurch wird das Basic-ROM ausgeblendet.

Als zweites muß sich das Modul zu erkennen geben. Im Betriebssystem gibt es eine Routine, die erkennt, ob ein Modul eingeschoben ist. Sie liegt zwischen 64770 ($ FD02) und 64788 ($ FD14). Dabei wird überprüft, ob in den Speicherzellen 32772 bis 32777 ($ 8004 bis $ 8009) das Wort »cbm80« steht. Das sind die ASCII-Zeichen: 195,194,205, 56,48. Ist das der Fall, setzt das Unterprogramm das Zeroflag. Wenn nun eine Routine im Betriebssystem (zum Beispiel die Reset-Routine) dieses Unterprogramm aufruft, und das Zeroflag wird gesetzt, dann nimmt das Betriebssystem an, daß ein Modul vorliegt. Es springt zur Adresse, die in $8002 und $ 8003 steht. Die Steuerung wird dem Modul übergeben. Will man nun ein Modul simulieren, muß man

1. $ 8004 bis 8009 mit »cbm80« belegen,
2.	eine Adresse in $ 8002 und $ 8003 eintragen (Low-Byte vor High-Byte) und
3.	durch den Befehl CLI Interrupts (IRQ) erlauben.

Mit folgendem kleinen Programm sorgt man von Basic aus dafür, daß ein Reset keinen Effekt hat:
100 FOR I=32770 TO 32778
110 READ A : POKE I,A
120 NEXT I
130 DATA 10, 128, 195, 194, 205
140 DATA 56, 48, 88, 0

Unser Ausgangsproblem war aber: Wie kann ich ein Reset verursachen, obwohl es gesperrt ist? Es gibt zwei Methoden:

1.	Man sorgt dafür, daß in $ 8004 bis $ 8009 nicht »cbm80« steht.
2.	Die Routine im Betriebssystem ändert man so ab, daß sie nicht mehr »cbm80« sondern zum Beispiel »cbm81« abfragt.

Es soll zuerst der zweite Fall behandelt werden. Da das Betriebssystem (auch Kernal genannt) im ROM liegt, läßt es sich nicht ohne weiteres ändern. Deshalb wird es zuerst in das darunterliegende RAM kopiert. Dieses funktioniert folgendermaßen:
100 FOR I = 57344 TO 65535
110 POKE I,PEEK(l)
120 NEXT I

Nun könnte, durch Löschen des Bits 1 (High-RAM) in der Speicherzelle 0001, vom ROM auf RAM umgeschaltet werden:
320 POKE I,PEEK(l) AND 253

Durch das Löschen dieses Bits wird aber auch das Basic-ROM ausgeblendet. Also müssen wir dieses auch ins RAM kopieren:
200 FOR I=40960 TO 49151
210 POKE I,PEEK(I)
220 NEXT I

Jetzt könnte man das Programm starten, es hätte jedoch keinen Effekt, weil in der Adresse 0001 immer die Zahl 55 (High-RAM gesetzt) erscheint — statt der angestrebten 53. Dieses kommt durch den I/O-Reset. Diese Routine liegt im Kernal und setzt die Kanäle in 0001 immer wieder neu. Also muß man diese Routine für unsere Zwecke ändern: 300 POKE 64982,229

Schließlich werden wir aus der »cbm80«-Abfrage eine »cbm81«-Abfrage machen:
310 POKE 64788,49

Wenn man jetzt das Programm startet und ein Reset auslöst durch: SYS 64738 wird sich die Maschine zurücksetzen, auch wenn in 32772 bis 32777 (exklusive) »cbm80« stehen sollte. Betätigt man jedoch den Resetschalter, dann wird der Reset abhängig von 32772 bis 32777 ausgelöst. Beim Reset werden nicht nur der Prozessor, sondern auch die beiden CIAs und der SID zurückgesetzt. Diese bewirken, daß in 0001 High-RAM gesetzt wird, und somit kommt die Veränderung des Betriebssystems nicht zum Tragen. Im ersten Fall wird ein POKE 32772,0 das Nötige tun, sofern nicht das Programm seinerseits dafür sorgt, daß »cbm80« immer wieder erneuert wird.

Hier das Programm UNNEW:
100 FOR I=525 TO 578
120 READ A : POKE I,A : NEXT I
200 POKE 43,525 AND 255 : POKE 44,2
210 POKE 45,578 AND 255 : POKE 46,2
220 CLR : SAVE "UNNEW" ,8 : REM bzw. ,1,1
300 DATA 160,003,200,177,043,208,251,200
310 DATA 200,152,160,000,145,043,165,044
320 DATA 200,145,043,133,060,160,000,132
330 DATA 059,162,000,200,208,002,230,060
340 DATA 177,059,208,245,232,224,003,208
350 DATA 242,200,208,002,230,060,132,045
360 DATA 164,060,132,046,096,256

Wenn Sie dieses Programm eingeben und starten, wird es ein Programm namens »UNNEW« auf Diskette schreiben. Falls sie aus Versehen NEW eingetippt haben, dann laden sie das Programm durch
LOAD "UNNEW" ,8,1 und starten es durch
SYS 525

Ihr Basic-Programm ist gerettet, selbst wenn sie ein Reset ausgelöst haben. Das Programm setzt die Zeiger in $0801 und $0802, die auf die nächste Zeile zeigen, auf den richtigen Wert. Bei NEW werden diese beiden Bytes auf Null gesetzt, und zwei aufeinanderfolgende Nullen bedeuten für den Interpreter »Ende des Programms«.

(Daniel Kossmann/aa)

# Epedemic 2

> Ein Nachtrag zu dem VC 20-Spielprogramm aus der 64er/Ausgabe 10

Nachdem der Druckfehlerteufel in der letzten Ausgabe wieder einmal zugeschlagen hatte, bringen wir hier den fehlenden Teil zum Listing »Epedemic» für den VC 20. Nachzutragen wäre auch noch, daß man sich bei derartigen Simulationsspielen immer über die Handlungsbrisanz im Klaren sein sollte. Denn die Zahlenjonglierereien auf dem Bildschirm stellen immerhin Menschenleben dar. Wem das Spiel allerdings deswegen zu makaber ist, der sollte sich vielleicht einmal die Realität ansehen... (ev)

# In die Geheimnisse der Floppy eingetaucht

> Diese Folge befaßt sich mit dem Befehlssatz der VC 1541 und deren Meldungen an den Computer. Sie werden erkennen, daß Sie neben Ihrem C 64 noch einen anderen vollständigen Computer vor sich haben, der nicht nur als einfaches und »dummes« Peripheriegerät verstanden werden will.

Sicherlich machte sich mancher Floppybesitzer, der ein schnelleres Peripheriegerät als die Datasette haben wollte, schon seine Gedanken über den Preis der VC 1541: »Die kostet ja mehr als der Computer!«. In der Tat ist die VC 1541 von dieser Seite her betrachtet nicht gerade günstig, wer sich jedoch schon intensiver mit ihr beschäftigt hat, wird eine Eigenart festgestellt haben, die sie mit allen CBM-Floppys teilt: Es handelt sich hier um sogenannte Floppystationen, nicht nur um Laufwerke. Das bedeutet, diese Geräte besitzen ein eigenes Betriebssystem (DOS) und eigene Mikroprozessoren. Sie arbeiten völlig unabhängig vom Computer und dessen Speicher. Der Vorteil liegt auf der Hand: Die Floppy beansprucht weder Speicherplatz noch Rechenzeit des Computers, außer beim direkten Datenaustausch. Als Beispiel betrachte man den Befehl »N:« (Formatieren). Während der Formatierung steht der Computer zur (fast) freien Verfügung, da dieser Vorgang nur floppyintern abläuft und sich der C 64 mit READY meldet, während die 1541 noch arbeitet.

Wir wollen uns jedoch nur den Direktzugriffsbefehlen und den Speicherbefehlen widmen; auch übergehen wir die im Commodore-Handbuch nicht erwähnte relative Datenspeicherung, über die in anderen Ausgaben schon ausführlich gesprochen wurde. Uns sollen nur die Befehle beschäftigen, die uns zur willkürlichen Manipulation von Floppystation und Disketten nützen.

Zur Beruhigung: Ein Beschädigen der 1541 durch direkte Eingriffe in das DOS ist nicht zu befürchten, auch wenn es passieren kann, daß sich die Floppy nur durch Aus-/ Einschalten wieder in den Normalzustand versetzen läßt. Haben Sie übrigens einmal, wie in der letzten Folge empfohlen, das Formatkennzeichen einer Diskette verändert? Sie werden sicherlich bemerkt haben, daß sich danach nichts mehr auf Ihre Diskette schreiben läßt. Mit diesem Trick, der die gleichen Folgen wie das Anbringen einer Schreibschutzplakette an der Diskette hat, können Sie sich also ganz einfach Ihre Diskette gegen unbeabsichtigtes Löschen sichern. ACHTUNG: Diese Methode funktioniert natürlich nicht, wenn neu formatiert werden soll; hiergegen hilft nur das Anbringen einer Schreibschutzplakette!

Die Floppystation verfügt über, außer den schon bekannten Befehlen zur Diskettenorganisation, noch eine ganze Anzahl weiterer Befehle, mit denen sich ungeahnte Möglichkeiten ergeben, zum Beispiel Herstellen eines eigenen Diskettenformats, Leseschutz von Disketten, Programmschutz, Modifikation der Lade- und Saveroutinen und, und... Dafür ist es allerdings nötig, daß wir diese Befehle Schritt für Schritt kennen lernen, bevor wir auf die Tricks der Profis, die Manipulationen des DOS und den gezielten Eingriff in den Programmablauf der Floppystation zu sprechen kommen. Dafür ist allerdings das Beherrschen des C 64 und der Maschinensprache unerläßlich. So lohnt es sich unter Umständen, nachdem man aus Basic nichts mehr herausholen kann, den Einstieg in die Assemblerprogrammierung zu wagen. Sehr gute Literatur dafür ist vorhanden. Aber diesmal wollen wir uns noch auf Basic beschränken, um Sie mit dem Befehlssatz der Floppy vertraut zu machen.

Wie schon erwähnt, handelt es sich bei der 1541 um einen vollständigen Computer, der ebenso wie Ihr C 64 RAM und ein Betriebssystem (DOS) im ROM besitzt.

Die genaue Aufteilung ist in Bild 1 zu sehen. Jetzt soll uns nur der RAM-Bereich interessieren (Bild 2). Nicht nur auf der Diskette, sondern auch im RAM werden Speicherbereiche in Abschnitte zu jeweils 256 Byte aufgeteilt. Sie heißen dann nicht mehr BLOCKS sondern PAGES (Seiten). Das RAM der 1541 umfaßt nun genau 8 PAGES, durchnumeriert von 0 bis 7, insgesamt als 2 KByte. Die Page Nr. 0 (auch Zero-Page genannt) wird hier, wie auch im C 64, vom Betriebssystem als Arbeitsspeicher benutzt und steht uns deshalb nicht zur freien Verfügung. Ähnlich verhält es sich mit den Pages 1 und 2. Die Pages 3 bis 7 stellen sogenannte Pufferspeicher dar; hier werden alle Daten, die von der Diskette gelesen beziehungsweise auf sie geschrieben werden, zwischengespeichert, da nur blockweise gelesen oder geschrieben werden kann.

Soll zum Beispiel nur ein einziges Byte auf der Diskette geändert werden, so wird erst der gesamte Block in einen der 5 Pufferspeicher gelesen, dort abgeändert und schließlich komplett wieder zurückgeschrieben. Aus diesen Gründen ist es also notwendig, daß wir uns vor einem Direktzugriff einen der Puffer reservieren, in dem dann gearbeitet wird.

Mit Hilfe des »Open«-Befehls eröffnen wir einen Direktzugriffskanal. Die Syntax lautet wie folgt:
OPENfn, gn, kn, ”#”

Hierbei bedeuten:
fn — Filenummer (1-127)
gn — Gerätenummer (norm. 8)
kn — Kanalnummer in der Floppy (2-14)

Diese Abkürzungen werden wir im folgenden immer verwenden! Ein Beispiel:
OPEN 1, 8, 2, ”#”

Diese Anweisung eröffnet im Computer ein File mit der Nummer 1, adressiert als Gerät die Floppy (Nummer 8) und reserviert in der 1541 einen Kanal (Nummer 2), dem ein Puffer zugeordnet wird. Mit den floppyinternen Kanälen verhält es sich wie folgt: Es stehen insgesamt 16 Kanäle zur Verfügung. Hierbei sind Kanal 0 und 1 für LOAD und SAVE reserviert, Kanal 15 ist der Kommandokanal, den Sie bisher immer benutzt haben, um Befehle (zum Beispiel Formatieren) an die Floppy zu senden und die Fehlermeldungen der Floppy zu empfangen.

Für unsere Zwecke stehen also noch die Kanäle 2 bis 14 zur Verfügung. In unserem Fall reserviert die Floppy den nächsten freien Puffer. Will man jedoch einen bestimmten Puffer reservieren, etwa um dort ein Maschinenprogramm abzulegen, so ist es notwendig, der 1541 mitzuteilen, welcher Puffer gewünscht wird:
OPEN1,8,2,"#1"

Es ist hier allerdings zu beachten, daß der gewählte Puffer nicht schon belegt ist; in diesem Fall gibt die Floppy eine Fehlermeldung aus. Wollen Sie an dieser Stelle mehr über das Auslesen der Fehlermeldungen und deren Bedeutung wissen, können wir Sie hier beruhigt auf das Commodore-Handbuch verweisen. Im allgemeinen sind Puffer 4 für die BAM und Puffer 3 für das Directory reserviert. Haben Sie die Wahl des Puffers der Floppy überlassen, so erfahren Sie die gewählte Nummer durch Auslesen des soeben geöffneten Direktzugriffskanals:
10 OPEN 1,8,2,”#"
20 GET#1,D$
30D = ASC (D$ + CHR$(0))
40 REM Puffernummer in D

### Die BLOCK-Befehle

a)	Der BLOCK-READ-Befehl (B-R): Mit dem BLOCK-READ-Befehl liest man jeden beliebigen Block von Diskette in einen vorher reservierten Puffer. Die Syntax lautet:
PRINT#fn,"B-R";kn;dn;t;s
dn — Drivenummer (immer 0)
t — Tracknummer
s — Sektornummer
Beispiel: PRINT#15,"B-R 2 0 18 0”

Diese Befehlsfolge liest den Block 18,0 von der Diskette in den oben reservierten Puffer. Wie man sieht, können anstelle der CHR$-Codes feste Zahlenwerte in den Befehlsstring mit übernommen werden. Das ganze hat bloß einen kleinen Schönheitsfehler. Mit dem B-R-Befehl läßt sich das erste Byte eines Blocks nicht lesen. Deshalb benutzt man normalerweise anstatt des B-R-Befehls den U1-Befehl. Dieser hat exakt die gleiche Syntax und kann in jedem Fall benutzt werden:
PRINT#15,"U1 2 0 18 0”

Auf diese USER-Befehle kommen wir später zurück. Mit einer GET#-Schleife lassen sich nun die einzelnen Bytes in den Computer einlesen.

b)	Der BLOCK-WRITE-Befehl (B-W): Hiermit lassen sich die Daten aus dem reservierten Puffer wieder auf die Diskette schreiben. Syntax:
PRINT#fn,”B-W”;kn;dn;t;s
Beispiel: PRINT#15,"B-W 2 0 18 0”
Natürlich gibt es analog zum B-R einen USER-Befehl ; U2.
Beispiel: PRINT#15,"U2 2 0 18 0".

c) Der BUFFER-POINTER-Befehl (B-P):
Für jeden Puffer gibt es einen Zeiger, den BUFFER-POINTER. Dieser zeigt auf das aktuelle Byte im Puffer und wird bei jedem Datenzugriff um Eins erhöht, damit man alle 256 Bytes eines Blocks der Reihe nach lesen kann. Dieser Pointer wird mit dem B-P-Befehl gezielt auf bestimmte Bytes positioniert, wenn man nur einzelne Werte und nicht den gesamten Block lesen will. Syntax:
PRINT# fn,"B-P"; kn; position
Beispiel:
Wir möchten in die Variable A den Wert des 123. Bytes von Block 1;16 einlesen:
10 OPEN15,8,15
20 OPEN1,8,2,"#"
30 PRINT#15,"U1 2 0 1 16”
40 PRINT#15,"B-P2 122”
50 GET#1,A$
60 A = ASC(A$ + CHR$(0))
Als weiteres Beispiel dient Listing 1. d) Der BLOCK-ALLOCATE-Befehl (B-A):
Wenn Sie im Direktzugriffsverfahren eine Diskette beschreiben, muß in der BAM danach auch verzeichnet werden, daß die entsprechenden Blocks mit Daten gefüllt sind und nicht mehr überschrieben werden dürfen. Dazu dient der B-A-Befehl, der jeden beliebigen Block in der BAM als belegt kennzeichnet. Die Syntax lautet:
PRINT#fn,"B-A";dn;t;s
Beispiel:
PRINT#15,"B-A0 1 16”
kennzeichnet Block 1;16 als belegt; war dieser Block schon belegt, meldet sich die Floppy mit der Fehlermeldung >>65,NO BLOCK,XX,YY<<; wobei XX und YY die Track- und Sektornummer des nächsten freien Blocks angeben.

e)	Der BLOCK-FREE-Befehl (B-F): Dieser ist das genaue Gegenstück zum B-A-Befehl; er deklariert einmal belegte Blöcke wieder als frei für einen weiteren Zugriff. Seine Syntax ist identisch mit der des B-A-Befehls.

f)	Der BLOCK-EXECUTE-Befehl (B-E): Dieser Befehl nimmt eine Sonderstellung ein. Er gleicht im Prinzip dem B-R-Befehl; nur mit dem zusätzlichen Effekt, daß der eingelesene Block im Puffer als Maschinenprogramm gestartet wird.

Zur Vertiefung der Block-Befehle sei noch auf die Listings 2 bis 5 hingewiesen, welche die eben besprochenen Anwendungen noch an praktischen Beispielen verdeutlichen.

### Die MEMORY-Befehle

a)	Der MEMORY-READ-Befehl (M-R): Dieser Befehl entspricht haargenau dem PEEK-Befehl in Basic. Mit ihm können Sie jede beliebige Speicherstelle der Floppy auslesen. Syntax:
PRINT#fn,"M-R";CHR$(adl);CHR$ (adh);CHR$(n)
adl = Low-Byte
adh = High-Byte
n = Anzahl (0 bis 255)

Abgeholt werden die gelesenen Daten ebenfalls über den Kommandokanal mit GET#.
Beispiel: Lesen der beiden ID-Zeichen im ASCII-Format der zuletzt initialisierten Diskette:
10 OPEN15,8,15
20 PRINT#15,"M-R"CHR$(18)CHR$ (0)CHR$(2)
30 GET#15,A$,B$
40 PRINTA$;B$

Diese Routine liest die Zero-Page Adressen 18 und 19, in denen die entsprechenden Werte gespeichert sind. In Tabelle 1 sind einige der wichtigsten Zero-Page Adressen aufgeführt.

b)	Der MEMORYWRITE-Befehl (M-W):

Dieses Kommando kann als POKE-Befehl in den Floppy-Speicher angesehen werden. Die Syntax ist hier wie folgt:
PRINT#fn,"M-W";CHR$(adl)CHR$ (adh)CHR$(n)CHR$(datal)CHR$(da-ta2)...

c)	Der MEMORY-EXECUTE-Befehl (M-E):

TODO Fortsetzung auf Seite163



















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































