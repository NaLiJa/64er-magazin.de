# Gut versorgt

Deutschen Rückstand machte die Münchener Unternehmensberatung Dr. Höfner aus: Pro Kopf der Bevölkerung seien 1983 in den USA zehnmal soviel Mikrocomputer für gewerbliche Zwecke verkauft worden wie in der Bundesrepublik.

Bei Heimcomputern stehen wir wesentlich besser da: Bis Ende 1984 hatte Commodore nach eigenen Angaben in der Bundesrepublik rund 700 000 Heimcomputer verkauft — 100000 VC 20 und 600 000 64er. In den USA wurde etwa das Dreieinhalbfache davon abgesetzt, rund 2 Millionen 64er und 1,1 Millionen VC 20. Geht man davon aus, daß die Vereinigten Staaten etwa die vierfache Bevölkerungszahl haben, und daß der Commodore-Marktanteil in beiden Ländern ungefähr gleich groß ist, dann kann man sagen: Die Deutschen sind mit Heimcomputern etwa gleich gut versorgt (oder gleich stark daran interessiert) wie die Amerikaner. Diese Schlußfolgerung läßt sich auch dann noch aufrechterhalten, wenn man berücksichtigt, daß in den USA häufig Systeme wie Apple II oder IBM-PC als »Homecomputer« verwendet werden.

Hier zeigt sich eine Tücke der Statistiken: Wir werden uns an neue Bedeutungen bekannter Begriffe gewöhnen müssen. Der Heimcomputer wird daheim, der Bürocomputer im Büro benutzt — über die Art und Leistungsfähigkeit des Grundgerätes sagen solche Bezeichnungen in Zukunft noch weniger aus als heute. Und da die Leistung der kleinen billigen Computer zunimmt (auch von Commodore soll es ja 1985 leistungsfähigere Modelle geben), wird künftig für viele berufliche Anwendungen ein »Heimcomputer« ausreichen. Damit werden sich die privat gewonnenen Erfahrungen noch sehr viel direkter als bisher auf den Computer im Betrieb anwenden lassen.

Michael Pauly, Chefredakteur

# MCI Mail: die schnelle Post

> In den USA gibt es private Postbeförderungsunternehmen mit einem erstaunlichen Angebot. Wir wollen am Beispiel der MCI Mail zeigen, was diese Firmen zu leisten imstande sind. Vor allem soll aber der C 64 über das Datex-P-Netz an diesem Service teilnehmen.

Briefe, genau genommen deren Laufzeit zum Empfänger, sind nicht nur hier in der Budesrepublik ein ständiges Ärgernis und ein Dauerthema in den Tageszeitungen. In den USA sind die (Post-) Wege naturgemäß noch länger und die staatliche US-Mail muß sich häufig vorwerfen lassen, eine »Snail-Mail«, eine Schneckenpost zu sein. Und wenn es bei uns in Deutschland darum geht, ob ein 80-Pfennig-Brief nun wirklich am nächsten Morgen vom Briefträger ausgetragen wird oder nicht, dann geht es in Amerika darum, ob der Brief mit »Federal Express Overnight Delivery« für 14,00 Dollar (43 Mark) nun wirklich über Nacht von New York nach San Francisco gelangt.

Wen wundert es da, daß in den USA das Geschäft mit der privaten Postbeförderung blüht. In TV-Werbespots stechen sie sich gegeneinander aus, einer ist schneller und sicherer als der andere.

Den Vogel abgeschossen, und man könnte fast meinen, das Wappentier der USA sei damit gemeint, hat zweifellos ein Unternehmen, das schon seit Jahren mit ihren preiswerten Telefon-Fernleitungen der großen »Ma Bell« beziehungsweise der AT & T Konkurrenz macht: MCI. Diese Gesellschaft ist inzwischen so mächtig, daß sie eine große und bekannte Kom-muniktions-Gesellschaft, die Western Union (WUI) mit ihren Telex-Netzen geschluckt hat. MCI hat also eine Tochtergesellschaft gegründet: die MCI Mail — The nation’s new postal system.

Seit rund einem Jahr gibt es MCI Mail, und die Anzahl der Benutzer vermehrt sich geradezu nach dem Schnee-ball-System. Der Grund: die Postbeförderung von MCI braucht nur Sekunden! Das Geheimnis: elektronische Postfächer, also »Mailboxen« mit den Zusatzdienstleistungen eines riesigen Kommunikations-Apparates, seinen Datenleitungen, Druckerstationen, Telegrammboten und Telexnetzen. Und das Ganze zu erschwinglichen Preisen.

In Ausgabe 10/84 von 64er hat Thomas Ober-mair über »Datex-P und ausländische Netzwerke« berichtet. Auf der Kenntnis dieses Artikels baut der folgende Bericht auf und setzt insofern Wissen über das Funktionieren von Datex-P, dem PAD, einer NUI und so weiter voraus.

Die jährliche Grundgebühr, die Annual Mailbox Fee, beträgt 18 Mark, auf den Monat umgerechnet also 1,50 Dollar oder rund 4,50 Mark.

Einen »Kurzbrief« von bis zu 500 Zeichen abzuschicken kostet 0,45 Dollar oder 1,35 Mark, ein Brief von bis zu 7 500 Zeichen (etwa 4 Druckseiten) je 1 Dollar, also 3 Mark. Eine Speicherbenutzungsgebühr gibt es nicht. Es ist also völlig egal, wie lange der Brief im Speicher »lagert«. Das »Abholen« der Briefe aus dem Speicher ist kostenlos. In den meisten Städten der USA gibt es Telefonnummern, unter denen MCI Mail zum Ortstarif erreichbar ist. Wohnt man in ländlichen Gebieten, benutzt man eine sogenannte WATS-line, eine Telefonnummer mit der Vorwahl 800, bei der der Angerufene, also MCI Mail, die Gebühren übernimmt. Dieser Service ist dann allerdings mit 15 Cents pro Minute in der nächsten Monatsrechnung wiederzufinden.

Mit diesen Gebühren ist damit innerhalb derUSA der ganz Spaß bezahlt. MCI Mail wäre aber kein typisch amerikanisches System, wenn es nicht zusätzlich eine Vielzahl von erstaunlichen Möglichkeiten böte, die der Bequemlichkeit ihrer Kunden entgegenkäme. Und zusätzlicher Service kostet natürlich Geld. Und das ist es, was man auch dort verdienen möchte, denn kein Postsystem der Welt, ob nun staatlich oder privat, arbeitet nur für den »Spaß an der Freud«.

Es fängt an mit dem Service »Mail Alert«. Für einen zusätzlichen Dollar ruft MCI Mail den Briefempfänger an, um ihn auf den Posteingang aufmerksam zu machen.

Und was ist, wenn der Briefempfänger nun gar kein »Postfach« bei MCI Mail hat? Kein Problem: Für einen Dollar mehr wird der Brief in der nächsten Großstadt ausgedruckt und mit der staatlichen Post als »First Class Mail« zugestellt. Das ist in der Regel nach 24 Stunden der Fall. Für 8 Dollar kann man sogar die Zustellung mittels Kurier am nächsten Tag verlangen, vorausgesetzt, der elektronische Brief wurde bis 23.00 Uhr eingespeichert. Und für ganz eilige Sachen gibt es noch den 4-HOUR-Service. Für sage und schreibe 30 Dollar, also 90 Mark wird die Zustellung in den ganzen USA per MCI-Mail-Boten in spätestens 4 Stunden garantiert.

Wie sehen diese gedruckten Briefe aus? Nun, im Normalfall, zum oben genannten Preis, handelt es sich um Briefpapier mit MCI-Brief-kopf. Dazu wird Name und Adresse des Absenders gedruckt, dann Name und Anschrift des Empfängers, anschließend der Text und die Unterschrift in Druckschrift. Aber: Für 20 Dollar pro Jahr kann man auch seinen eigenen Briefkopf einspeichern lassen, der sogar grafische Darstellungen enthalten kann. Und für weitere 20 Dollar wird sogar unter jeden in der Ferne gedruckten Brief Ihre Original-Unterschrift gesetzt!

Aber das ist noch nicht alles. Wenn der Brief weder in der Mailbox bleiben, noch ausgedruckt werden soll, kann man auch jede beliebige Telexnummer auf der Welt als Anschrift eingeben. Vollautomatisch wird der Brief dann als Telex abgeschickt und man erhält in der eigenen Box eine Nachricht, daß alles auch angekommen ist (mit der Kennung des erreichten Telex-Anschlusses als Beweis). Dafür muß man dann natürlich die Telexgebühren bezahlen, aber die sind verhältnismäßig niedrig. Je 400 Zeichen von den USA nach der UdSSR, kosten zum Beispiel 1,82 Dollar. Und unter jedes Telex schreibt das System die »eigene« Telex-Nummer, denn von jedem Telexanschluß in der Welt kann man Briefe an MCI-Mail schicken, die einfach in der jeweiligen Mailbox des Empfängers abgelegt wird und sofort abrufbereit ist. Als Telexnummer dienen dazu die Ziffern 650 und die siebenstellige Kennziffer (ID) des MCI-Kunden. Von Deutschland aus wählt man also inklusive der Vorwahl für die USA zum Beispiel: 023-650-2412526.

Soviel generell über das Funktionieren dieses Privat-post-Unternehmens MCI Mail in den USA. Meine Freunde in Amerika, Privatpersonen und Geschäftsleute, benutzen es täglich. Und es kam wie es kommen mußte: Man fragte mich, ob ich nicht auch zwecks schnellerer Kommunikation an MCI Mail teilnehmen könnte. Keine Frage: Ich wollte schon — aber wie? Ich schrieb also an MCI Mail, Box 1001, 1900 M Street, NW Washington, DC 20036, Tel. (0012 02) 8 33 84 84, und erhielt auf meine Anfrage, ob ich von Deutschland aus an MCI teilnehmen könne, und wie das zu machen sei, die freundliche Antwort von einer Dame namens Alice J. Campbell, daß man eine »exciting news«, eine aufregenden Nachricht also, für mich hätte: Der Verkehr mit dem Ausland sei in einer Testphase. Neben der Mitgliedschaft bei MCI Mail müsse ich nur die örtliche PTT, also die Bundespost, um Zugang zu deren Datennetz bitten. Man wünschte noch viel Erfolg. Aus. Leider kein Hinweis, ob damit nun DATEX gemeint war und welche Nummern man wählen muß. Also weitergeforscht.

Inzwischen war mir zu Ohren gekommen, daß MCI und Western Union International irgendwie identisch seien. Und ich hatte mal gehört, daß WUI ein Büro in Frankfurt/M haben sollte. Die Telefonauskunft bestätigte dies und ich riskierte ein paar Einheiten. Ein freundlicher Herr mit gleichem Namen wie ich, hörte sich meine Wünsche geduldig an und hatte auch den ehrlichen Willen, mir zu helfen. Dennoch, über MCI Mail war nichts bekannt.

## Keine Informationen bei der Post

Nun war das Leitungsmonopol der Bundesrepublik an der Reihe. Mein Brief an die Kundenberatung für Da-teldienste beim Fernmeldetechnischen Zentralamt (FTZ) in Darmstadt wurde mit interessanten Drucksachen über DATEX und mit einem langen Telefonat beantwortet. Ein Kontakt, der übrigens noch heute besteht und dem sich manche interessante Neuigkeit entlocken läßt. Ein konkretes Ergebnis, etwa in der Form, welches Netz von Datex-P aus, also zum Beispiel WUI, RCA, ITT, TYM-NET, TELENET und so weiter angewählt werden müsse, und wie dann die Teilnehmer-Nummer von MCI Mail angefügt werden könnte, ergab das Gespräch zu meinem Kummer nicht. Aber nur ein paar Tage später rief das FTZ nochmals zurück, mit einem interessanten Hinweis: Ich möge mich doch mal an die große Kommunikationsgesellschaft TYMNET wenden. Die hätten ein Europa-Büro in Paris! Gesagt, getan, ich wollte schließlich keine Chance auslassen. Gerechterweise muß ich hier einfügen, daß dieser Tip Gold wert war, und schließlich auf die richtige Spur führte. Die TYMNET-Mitarbeiter Dominique Marchad und Jean Francois Morfin kümmerten sich mit einer überraschenden Energie und einer Fülle von Nachrichten um mein Anliegen. Nicht von ungefähr, wie ich erfuhr: TYM-NET ist verantwortlich für die internationale Aufschaltung von MCI Mail, und deren »host« 004759.

Also schnell nachgeschaut in der Datex-P Bedienungsanleitung der Bundespost: TYMNET hat die Vorwahl 0 3106. Dazu 00 47 59, das müßte es also sein. Vorsorglich hatte ich mir bei der Post schon eine NUI besorgt, und nun konnte der Versuch mit meinem C 64, der 1541, dem Drucker Seikosha GB100VC und dem Tandy-Akustikkoppler AC-3 starten.

Die Hamburger Zugangsnummer für Datex-P war wie die anderer Großstädte der Datex-Bedienungsleitung zu entnehmen, also 441231. Sogleich ertönt der Carrier-Ton und ich gab vorschriftsmässig .(CR) ein. Nun wurde ich nach meiner NUI und dem von der Post zugeteilten Passwort gefragt. Das System antwortete, daß meine NUI nun »aktiv« sei — was natürlich vor allem bedeutet, daß man nun die anfallenden Gebühren berechnen würde. Ich tippte auf der Tastatur 03106004759. Nach zirka 5 Sekunden kam die Antwort: »Port 48 please log in«. Hier wurde nun der Name des MCI-Mitgliedes erwartet, und zwar in der Form, daß ein Herbert Schmidt eingeben müßte: HSchmidt/ half. Das »half« ist notwendig, um den MCI-Computer auf Halbduplex zu stellen. Sonst gibt es Echo-Probleme. Danach wurde das von MCI Mail zugeteilte Passwort erfragt.

Früher, so wurde mir gesagt, konnte man als Neuling als Name und als Passwort jeweils einfach das Wort REGISTER eingeben und sich dann als neues Mitglied eintragen. Wenn man das heute versucht, antwortet einem der MCI-Computer höflich, daß die Registrierung »online« nicht mehr möglich sei. Man möge bitte anrufen. Das gilt natürlich für Kunden in den USA. Wenn Sie aber so viel Geld haben, können Sie gern die oben genannte Telefonnummer anrufen. Das kostet pro Minute 6,67 Mark. In Washington ist es übrigens 6 Stunden früher als hier.

In meinem Fall hat übrigens der freundliche Mr. Morfin von TYMNET, Paris, bei einem Besuch in Washington die Registrierung vorgenommen. Eine Woche später hatte ich einen der auffälligen, orangefarbenen MCI Mail-Umschläge in der Hand, genannt »starter kit«, mit genauen Eräuterungen und meinem Passwort. Das war’s. Und sie waren zufrieden und gücklich bis ... bis zur ersten Rechnung?

Nun, halb so schlimm. Die 18 Dollar bei der ersten Rechnung tun vielleicht ein wenig weh. Aber das kommt ja nur einmal im Jahr. Und zwei Briefe pro Woche abgeschickt, sind 8 Dollar im Monat, also 24 Mark. Erwartet wird aber in jedem Fall Bezahlung per Scheck in US-Dollar und nicht per Euroscheck. Auf Antrag ist auch Abrechnung über eine Kreditkarte wie VISA oder MASTERCARD (hier EUROCARD) möglich. Dazu ein Tip: bei Banken und sogar bei der Post gibt es American Express Traveller Cheques zum Dollar-Tageskurs plus 1 Prozent Versicherung in Stückelungen bis herunter zu 10 $.

In den USA zahlt man Rechnungen grundsätzlich mit Scheck per Post. An jeder Rechnung aus Amerika hängt daher ein Abschnitt, den man mit seinem Scheck zurückschickt. Und da nimmt man von Deutschland aus am besten einen Traveller Scheck, mit dem nächsthöheren Wert, schickt das Ganze per Luftpost nach Washington und bei eventueller Überzahlung wird der Restbetrag bis zur nächsten Rechnung gutgeschrieben.

Und wie sieht es nun mit den Kosten für Datex-P aus? Nun, in der Kürze liegt die Würze. Wer seine Briefe erst online »komponiert« und die Verbindung so lange stehen läßt, bis alles geschrieben ist und hübsch sauber aussieht, kann schon mal anfangen Geld zurückzulegen, damit die Rechnung der Post keine zu große Überraschung bringt. Wenn man aber ein gutes Terminalprogramm besitzt, wie zum Beispiel das TERM 64 von Higginbottom für den C 64, dann kann man Briefe als Files vorschreiben, auf Diskette speichern und dann erst die Verbin-dungzu MCI Mail herstellen. Die Übertragung geht dann mit Höchstgeschwindigkeit, also 300 Baud vor sich. Umgekehrt gibt es zum Auslesen der in der Mailbox etwa vorhanden Briefe einen Befehl »PRINT INBOX«. Dann kommen alle Briefe in Höchstgeschwindigkeit und ohne Unterbrechung hier an, gehen zunächst in den Terminal-Puffer, und können dann in Ruhe nach Auftrennen der Verbindung auf Floppy geladen, auf dem Bildschirm gelesen und/ oder ausgedruckt werden.

5 Minuten Verbindung mit, sagen wir 4000 Zeichen, kosten bei Datex-P neben der monatlichen NUI-Gebühr von 15 Mark und der Telefon-Ortsgesprächsgebühr von 23 Pfenningen nach den USA:

Datex-P-Gebühr von 2,55 Mark und MCI-Mail-Gebühr von 3 Mark ergeben also 5,55 Mark für den Brief von 4 000 Zeichen... und das ist eine ganze Menge Geschriebenes. Und mit einem kleinen Trick kann man seinen Partner in denUSA schon wenige Sekunden danach veranlassen, seine Mailbox zu lesen: Man ruft ihn an, für zwei Einheiten, also 46 Pfennige, kann man schnell die Worte »MCI Mail« sagen und wieder auflegen. Das wirkt garantiert. Der Brief ist somit wenige Minuten nach dem Absenden gelesen... für runde 6 Mark. Ein Luftpostbrief, per Eilboten, 2 DIN-A-4-Sei-ten lang, dauert mit Sicherheit 5 Tage... mindestens... und kostet (18 Gramm) 5,50 Mark. Was sagen Sie nun?

Und kürzlich gab MCI Mail noch eine Neuerung für 1985 bekannt: Es wird der Postverkehr mit 40 Ländern aufgenommen! Und das bedeutet nicht nur elektronischen Zugang wie zur Zeit aus Deutschland, sondern auch Ausdruck und Zustellung der Post in den entsprechenden Ländern. Vielleicht kann man Briefe also ebenso schnell und preiswert nach Australien oder Südafrika schicken. Wenn das nichts ist? Aber das Schönste dabei ist doch: Es funktioniert alles ohne Probleme mit einem Commodore 64.

(Wolfgang R. Schulz/aa)

# SX 64 spart dem Krankenhaus viel Geld

In einem großen Krankenhaus mit einer Vielzahl weiterer angegliedeter Pflege-, Schulungs- und Wohnungseinrichtungen fallen hohe Investitions- und Unterhaltungskosten an. Rationelle Betriebsführung anhand einer zuverlässigen Betriebsdatenerfassung, führt zur erheblichen Kosteneinsparung. Eine Sache für die Groß-EDV, die selbst Millionen kostet? Keineswegs: Im Diakonie-Mutterhaus Rotenburg an der Wümme, schafft ein tragbarer Commodore SX 64 die Voraussetzung dafür. Allein die Ersparnis an Wasser beträgt im ersten Jahr schon 50000 Mark.

Dabei hatte Betriebsingenieur Ulrich Hartnick hauptsächlich die Sammlung von Betriebsdaten im Sinne, um für Neuanschaffungen im Energie- und Versorgungsbereich vernünftige Planungsdaten zu gewinnen. So soll zum Beispiel die in der Vielzahl der Kühlanlagen abgezogene Wärme zur Vorwärmung des Brauchwarmwassers verwendet werden. Dazu muß die abgezogene Wärmemenge und die Menge des verbrauchten Wassers bekannt sein. Auf dieselbe Weise müssen für jede geplante neue Einrichtung erst die genauen Bedarfsdaten ermittelt werden. Das Erfassen und Verarbeiten solcher Daten in Zusammenarbeit mit den entsprechenden Meßgeräten ist die Aufgabe des SX 64.

An sechs verschiedenen Stellen fragt der SX 64 die durchgelaufenen Wärmemengen ab. Viertelstündlich werden die Wassermengen notiert, die Daten auf Diskette abgelegt und auf Wunsch auf dem Bildschirm oder dem Drucker ausgegeben. Über eine programmierte Kalenderfunktion hält der SX 64 Monat, Tag und Uhrzeit zu jeder Messung fest. Die Meßwerterfassung erfolgt über eine einfache Ein-Aus-Abfrage an Magnetschaltern und über Haustelefon. Das verwendete Interface stammt von GSSE in Braunschweig. Das Auswertungsprogramm wurde von Ulrich Hartnick selbst erstellt. Eine Analyse des Wasserverbrauchs führte zur Identifikation ständig laufender Wasserverbraucher, die aber prinzipiell nur kurzzeitig benötigt werden. Das Abstellen dieses »Dauerlaufs« senkte den Wasserverbrauch um etwa ein Viertel — so kommt die jährliche Einsparung von etwa 50000 Mark zustande, ohne daß irgendeine Funktion des Krankenhauses im geringsten beeinträchtigt wird.

Der Hauptvorteil liegt jedoch darin, daß endlich der Bedarf an Energie und Versorgungsmitteln zu jeder Tages- und Nachtzeit genau ermittelt werden kann. Der SX 64 wertet die Ergebnisse aus, ein weiterer Computer ist nicht erforderlich.

Insgesamt zeigt der Einsatz des SX 64 am Diakonie-Kranken-haus in Rotenburg neue Chancen für eine umfassende Betriebsdatenerfassung auf. Überall existieren schon große und leistungsfähige Computer für kaufmännisches Rechnungswesen, Personalkosten und so weiter. Aber im täglichen Betrieb nutzen sie, und seien sie noch so teuer, nur selten etwas: Ihnen fehlen die entsprechenden Daten. Erst die Datenerfassung an der Basis macht den Betriebsablauf transparent, hilft Leerläufe und Verschwendungen erkennen und schafft verständliche Unterlagen für die Planung und Entscheidung. Eine Integration der am Commodore SX 64 oder auch am C 64 gewonnenen Daten in die Groß-EDV, ist sicherlich möglich und bietet auf längere Sicht die Fähigkeit, ein beliebiges Unternehmen ohne wesentlichen Leerlauf, Verschwendung und unter Verwendung der rationellen Arbeitsmittel zu führen. Der Weg ist vorgegeben, weg von der zentralen Lösung, hin zur dezentralen Erfassung von Daten mittels preisgünstiger »Heimcomputer«.

(aa)

Info: Commodore, Lyoner Str. 38, 6000 Frankfurt/M. 71, Tel. (0 69) 66 38-0

# Leser fragen – Willi Brechtl antwortet

> Mein Name ist Willi Brechtl. Nachdem mein Cousin, das Fehlerteufelchen, hier soviel Unheil angerichtet hat, habe ich mir gedacht, daß ich etwas Gutes tun kann — sozusagen als Ausgleich.

Ich werde mich daher um Leserbriefe kümmern, die nicht in das sachliche Einerlei des Leserforums passen. Zum Beispiel Fragen, die sich aus dem einen oder anderen Grund nur ganz subjektiv beantworten lassen. Oft genug tauchen auch Probleme auf, die sich nicht mit einem kurzen Antwortsatz abhandeln lassen. Und wenn selbst eine längere Antwort im Rahmen des Leserforums nicht mehr ausreichen würde, dann ist das ganz klar ein Fall für Willi Brechtl.

Natürlich habe ich mir zur Beantwortung das erste Mal auch gleich entsprechende Fragen herausgesucht. Möglicherweise sind einige Fragen darunter, überdie viele Profis schmunzeln können, aber meine Beantwortung ist — so hoffe ich — immer fair genug.

Kleine Bösartigkeiten mögen mir dabei verziehen werden (ich kann meine Verwandtschaft zum Fehlerteufelchen eben doch nicht leugnen).

Also: Wenn Sie als Anfänger Probleme mit Computer, Software oder Handbuch haben, dann wenden Sie sich in Zukunft doch vertrauensvoll an mich.

## Maschinensprache sprechen?

Ich will mit meinem C 64 RICHTIGE Maschinensprache sprechen und finde kein Trainingsbuch dazu. Ich willkeinen Assembler! Wer kann mir da helfen?

Meine definitive Antwort lautet: Keiner. Assembler ist nun mal Maschinensprache und Maschinensprache ist Assembler.

Das will ich Ihnen so erklären: Unter Assembler verstehen Sie wahrscheinlich Befehle wie LDA (Lade Akku) oder CMP (Vergleiche). Maschinensprache ist dann die Form, in der das Programm im Speicher liegt, beispielsweise als $CD für Vergleich oder $A9 für Akku laden. Aber auch das ist noch nicht die eigentliche Maschinensprache, denn die besteht aus Folgen von Nullen und Einsen.

Um aber diese Maschinensprache zu sprechen und in hex oder sogar binär zu programmieren, kommen Sie nicht umhin, die Assemblerbefehle zu lernen — oder wollen Sie wirklich auswendig wissen, daß »11001101« ein Vergleichsbefehl ist? Na sehen Sie. Und um Assembler (Maschinensprache) zu lernen, dafür gibt es genügend Trainingsbücher (und auch unseren 64’er-Assemblerkurs).

## Wieviel Strom braucht der C 64?

Welche Stromkosten verursacht ein einen Monat lang ununterbrochen laufender C 64? Bitte in DM und als Vergleich (zum Beispiel »soviel wie eine 100-Watt-Glühbirne«).

Gegenfrage: Haben Sie Ihren C 64 etwa einen Monat lang ununterbrochen laufen lassen? Und wenn ja, haben Sie etwa nebendran zum Vergleich eine 100-Watt-Glühbirne brennen lassen?

Also: Der C 64 hat genau 15 Watt Leistungsaufnahme (steht jedenfalls auf dem Computer). Die elektrische Arbeit in kWh Kilowattstunden bemißt sich aus Leistung mal Zeit. Wenn Sie das Floppy-Laufwerk auch noch mit einbeziehen (50 W), haben Sie einen Verbrauch von 46,8 kWh im Monat. Das einzige, was Sie noch tun müssen, ist, Ihr Elektrizitätswerk nach dem Preis einer kWh zu fragen. Rechnet man grob etwa 20 Pfennige pro kWh, dann kostet der Dauerbetrieb von Computer und Floppy noch keine 10 Mark im Monat. Allerdings ist darin noch nicht der Stromverbrauch des ja wohl in den meisten Fällen ebenfalls eingeschalteten Monitors oder Fernsehgerätes berücksichtigt.

## Ungeöffnete Disketten anwenden?

Die Disketten, die ich besitze, kann ich nicht anwenden, weil sie nicht geOPENt sind, deshalb bitte ich um Vorschläge, wie man auf Disketten eine sinnvolle Datei eröffnet.

Ohne Ihnen zu nahe treten zu wollen schlage ich vor, daß Sie sich das Floppy-Handbuch mal durchlesen (so schlecht ist es ja nun auch wieder nicht!). Dort finden Sie den deutlichen Hinweis, daß man die Diskette vorher FORMATIEREN muß, um sie benutzen zu können. Und ob die Datei sinnvoll ist, das hängt von Ihnen und nicht vom Datenträger ab.

## Lötkolben als Interface?

Wie kann ich mittels Lötkolben eine elektrische Schreibmaschine am C 64 betreiben? Könnte man die Treibersoftware dazu auf ein EPROM brennen?

Natürlich kann man jede Software auch auf Eprom brennen (wer sollte einen daran hindern?). Allerdings müssen Sie sich dann selbst eine entsprechende Platine zum Einstecken in den Steckmodul-Port basteln.

Das Betreiben einer elektrischen Schreibmaschine wird aber mit einem Lötkolben alleine nicht funktionieren. Vielmehr steuert man solche Dinge mit einem INTERFACE an.
Wenn Sie sich allerdings selbst ein Interface bauen wollen, kann ich Ihnen leider auch nicht weiterhelfen. Denn dabei kommt es ganz auf Ihre Schreibmaschine an, beziehungsweise auf deren internen Aufbau.

## Spektakuläre Verbindung

Wie kann ich einen ZX 81 und einen C 64 miteinander verbinden, und welchen Vorteil habe ich davon?

Nun, das mit dem Vorteil kommt ganz darauf an, aus welcher Sicht Sie das Problem sehen. Versetzen Sie sich einmal in die Lage des ZX 81. Dann haben Sie natürlich gewaltige Vorteile davon, weil Sie durch den Anschluß an den C 64 zum Supermann geworden sind. Aber denken Sie doch mal an den C 64! Was soll der mit einer als Computer getarnten Plastikkarte schon anfangen?

Nun aber mal ernst: Verbinden kann man beide Geräte durchaus. Aber Vorteile fallen mir dazu keine ein. Die Hauptspeicherkapazität des ZX 81 beträgt exakt 1024 Byte, wovon noch der Bildschirmspeicher abgeht. Bevor ich also Daten vom ZX 81 an den C 64 sende, tippe ich sie lieber gleich am C 64 ein, das geht schneller.

## Stiftung Warentest zum Thema Heimcomputer

Antwort eines Lesers auf den Test der Heimcomputer in der Oktoberausgabe von Stiftung Warentest.

Bemerkenswert schlecht kamen/kommen die Heimcomputer im Bericht und Test, Ausgabe 10/84 weg.

Aber die Heimcomputer haben es nicht verdient, denn die Redaktion von »Test« ging mit der falschen Fragestellung an diese Geräte heran. Es handelt sich nicht um Waschmaschinen oder Toaströster und auch nicht — trotz magnetischer Aufzeichnung und digitaler Technik — um Videorecorder oder CD-Plattenspieler. Beim Angeln oder Drachenfliegen fragt man so wenig nach der Nutzanwendung wie beim Kakteenzüchten oder Briefmarkensammeln.

Die schlechte Meinung über praktisch alle Geräte kann man gleichwohl weitgehend teilen — bis auf den Commodore 64.

Es wurde nach konkreter Nutzanwendung gefragt? Bitte: Beispiel 1: Ich nutze meinen Commodore 64 unter anderem als recht komfortables Textver-und bearbeitungssystem privat und semiprofessionell. So entstehen private Briefe ebenso, wie Artikel für Fachzeitschriften mit Bildschirm- und Computerhilfe. Die Investition (Computer, Floppy-Laufwerk, Farbmonitor, Textsystem, Schreibmaschine mit Interface) von etwa 3500 Mark hat sich so durch Honorare schon fast bezahlt gemacht.

Beispiel 2: Mein Sohn begann in Englisch bei den wöchentlichen Vokabelarbeiten abzurutschen: erst eine 3, dann 4, dann 5. Jetzt wurde der 64er mit einem Vokabel-Lern- und Übungsprogramm gefüttert und fleißig geübt. Das Ergebnis: nach der 5 kam eine 1! Gewiß, auch durch konventionelles Pauken hätte sich so was sicher erreichen lassen, aber mit weniger Spaß und mit sehr viel mehr Einsatz der beiden berufstätigen Eltern.

Und noch ein positiver Aspekt für einen Heimcomputer, wenn man Kinder hat: die wachsen mit einem Instrument wie selbstverständlich heran, das in vielfältigen Formen und Aufgabenstellung ihren künftigen beruflichen Alltag bestimmen wird. Wenn wir Erwachsenen an die zahllosen Probleme denken, denen wir im Beruf bei der Einführung der EDV an unseren Arbeitsplätzen ausgeliefert sind, so kann man die Jugend zumindest in diesem Punkt beneiden, weil sie ohne Hemmungen an diese neue Alltagstechnik herangeht.

Und ein letzter Punkt: Heimcomputerei ist etwas für kommunikationsfreudige Menschen. Das scheint zunächst widersprüchlich zu sein, wenn man die emsig, aber einsam vor ihren Bildschirmen Tippenden sieht. Nach meinen Erfahrungen finden sich aber bei der Computer-Gemeinde auffällig viel Leute mit Btx-Vergangenheit oder mit CB-Funk-Erfahrung. CB-Funk ist fast tot, Btx auch, es hat nur noch keiner gemerkt — auch die Btx-eifrige Stiftung Warentest nicht. Es sollten im Herbst 150000 Btx’er sein: tatsächlich sind es erst 14000. Der größte Teil davon dürften Anbieter sein oder Ex-Feldversuchsteilnehmer, die mit dem Post-Lockangebot (1000 Mark) umstiegen — so wie ich.

Aber es gibt Hunderttausende von Heimcomputern, die leicht miteinander kommunizieren könnten — und viele tun es auch schon. Da gibt es Mailboxen, schwarze Bretter und viele interessante Informationen. »Schau’n Sie doch mal rein«, aber nicht Btx ist gemeint.

Ich glaube, daß sich Btx zum größten Kommunikations-Flop entwickelt. Aber das macht nichts, das merkt ja keiner, weil man das aus den horrenden Gewinnen des größten deutschen Monopolisten finanziert. Wir alle zahlen die Rechnung. Und damit klebe ich eine halbe Mark auf den Umschlag dieses Briefes, der natürlich auch am Monitor-Bildschirm meines Commodore 64 entstand.

(Klaus-Dieter Wüstermann)

## Eine Bitte an alle Mailbox-Benutzer

Nachdem wir nun TECOS fast 7 Monate betreiben, hat uns Ihr Vergleich in der Ausgabe 12/84 mit dem CB-Funk gefallen, es deckt sich mit unseren Erfahrungen! Allerdings vor allem im Negativen: Unter dem Mantel der Anonymität werden Obszönitäten, Beleidigungen und Schwachsinn eingegeben.

Aus diesen Gründen ist TECOS sehr restriktiv geworden. In der Blockzeit zwischen Programmstart (meist 20h) und Mitternacht kann TECOS nur von PTC-Mitgliedern und eingetragenen Benutzern benutzt werden, Gäste erhalten einen entsprechenden Hinweis. Die Benutzerzeit für Gäste ist sehr gering (10 Minuten) und die Auswahl ebenfalls (nur 4 von 8 Punkten im Hauptmenü). Aber mit all diesen Sachen kann man als Box leben, wenn das Programm entsprechend reagiert und die Eingaben erst einmal »zensiert« (besser ausgedrückt: »gesichtet«) werden.

Aber ein viel größeres Problem sind nach unserer Ansicht die vielen »Hacker-Lehrlinge«, die sich einfach nicht an gewisse Betriebszeiten halten können und manchmal eine elende Plage sind. Vor allem, wenn sich außerhalb der Betriebszeiten einmal der SysOp (oder sonst jemand) »via Voice«, also per Sprache meldet. Wir haben seit einiger Zeit einen kleinen Artikel darüber mit folgendem Wortlaut in unserer Box stehen:

### Wie können Hacker Geld sparen?

Lassen Sie uns mit einem Tatsachenbericht beginnen:

Wir als PTC sind jeden Abend zwischen 17 und 20 Uhr via Voice für unsere Mitglieder erreichbar. In dieser Zeit erhalten wir zirka dreißig Anrufe, die wir in drei Kategorien unterteilen:

A) Der verschämte Aufleger Nach unserer Begrüßung via Voice: »PTC — TECOS, guten Abend« knackt es in der Leitung — aufgelegt. Zirka 20 Sekunden später das gleiche Spiel.

Warum fragt der gute Mann nicht einfach, ob da eine Box dran ist? Entweder hat er eine falsche Nummer, dann kann er das Spielchen morgen, übermorgen und so weiter wiederholen. Oder es handelt sich um eine Box, die nur zeitweise sendet, dann kann er sich die Anrufe vor 20h sparen!

B)	Der superschnelle Carrier-Sender

Nach dem Aufnehmen des Hörers knallt uns schon der Carrier entgegen und verstummt, meist automatisch, nach 20 bis 30 Sekunden. Alle Versuche, hier jemanden anzusprechen, sind witzlos. Deswegen legen wir bei Anrufen mit Carrier außerhalb der Sendezeit von TECOS sofort wieder auf. Zirka 20 Sekunden später erfolgt meist ein Anruf nach Typ A

C)	der unheimliche Entschuldiger

Man nimmt den Hörer ab und bevor man noch ein Wort herausgebracht hat, hört man: »Entschuldigung, falsch verbunden«. Manchmal klappt es noch, dem Anrufer ein »Mailbox erst nach 20 Uhr« entgegenzuschleudern, falls er dann noch nicht aufgelegt hat, hört man ein »Ach so, wußte ich nicht« und dann erst »CRCK«.

Falls das mit dem Entgegenschleudern nicht klappt, meist nach 20 Sekunden ein Anruf, Typ A!

Nun, nicht nur, daß derartige Anrufe derart geballt den freundlichsten SysOp verärgern, Sie schmeißen doch auch dem GILB das Geld in den Rachen und sind — wenn Sie sich so blöd verhalten — mit Ihrer Mailboxliste nie UP TO DATE!

Denn wenn es heute nicht klappt, versuchen Sie es doch morgen oder übermorgen wieder und schenken dem GILB wieder ein, zwei Einheiten!

Ist denn das so schwer, erst einmal kurz in jede Verbindung reinzuhören und wenn sich jemand mit Stimme meldet, einmal nachzufragen? Oder sind die Leute (Typ A-C) schon zu blöde zum Sprechen? Könnt Ihr denn nur noch Tasten kloppen? Also, versucht’s mal auf die andere Art! Zufriedene Mienen danken es Ihnen!

(Dietmar Severitt, SysOp TECOS, PTC)

## Simons Basic und Turbotape

Kann man Turbotabe und Simons Basic zusammen benutzen?
Ausgabe: 8/84
Ausgabe: 12/84 Rudolf Lehr

Es gibt jetzt eine Version von Simons Basic, bei der Turbotape integriert ist. Außerdem sind in dieser Version ein Monitor und ein Disassembler in Simons Basic enthalten.

## Mailbox mit C 64

Wer kann mir Telefonnummern nennen, unter denen ein C 64 eine Mailbox bedient? Ausgabe 12/84

Stephan Prinz

Die FIB (069-726527) wendet den C 64 als Infobox an. Ab Januar 1985 ebenso der User-Club Asperg + Tamm + Rest der Welt. Um eine Mailbox mit dem C 64 zu betreiben, braucht man aufjeden Fall ein größeres Laufwerk, zum Beispiel eine 8250 von Commodore, da sonst mit der 1541 nur zirka 40 Mailboxbenutzer mit Passwort und Mails (sen-den/empfangen) verwaltet werden können.

Steffen Gebauer, Asperg

## Wo gibt’s Lightpens?

Können Sie mir die Adresse einer Firma mitteilen, wo ich ein Lightpen plus Software (anschlußfertig an den C 64) für zirka 50 Mark bekommen kann?

Markus Lucassen, Duisburg

## List und Löschschutz

Ausgabe 12/84, Seite 85

Den im Artikel beschriebenen Listschutz kann man folgendermaßen leicht knacken: POKE2052,0:POKE2078,0

Jetzt kann man das Programm schon listen. Nun noch 0 (Return) und 1 (Return) eingeben, um die ersten beiden Zeilen zu löschen und das Programm ist wieder vollkommen ok.

Ulrich Förster, Bückeburg

## Wollen Sie antworten?

Wir veröffentlichen auf dieser Seite auch Fragen, die sich nicht ohne weiteres anhand eines guten Archivs oder aufgrund der Sachkunde eines Herstellers beziehungsweise Programmierers beantworten lassen. Das ist vor allem der Fall, wenn es um bestimmte Erfahrungen geht oder um die Suche nach speziellen Programmen. Wenn Sie eine Antwort auf eine hier veröffentlichte Frage wissen — oder eine andere, bessere Antwort als die hier gelesene, dann schreiben Sie uns. Antworten publizieren wir in einer der nächsten Ausgaben. Bei Bedarf stellen wir auch den Kontakt zwischen Lesern her.

# Plus und Minus beim Plus/4

> Computer mit integrierter Software heißt das neue Konzept von Commodore. Der Plus/4 ist der erste Commodore-Computer mit diesem Konzept. Der Weg, den Commodore mit dem Plus/4 beschreitet, hat sicher Zukunft. Ob für diesen Computer jedoch ein Preis von 1298 Mark gerecht fertigt ist, muß sich erst noch erweisen.

Von zwei Seiten sollte man den neuen Plus/4 von Commodore betrachten. Auf der einen Seite steht die Hardware und das Basic, auf der anderen die eingebaute Software.

Ein großes Plus verdienen die Hardware und das Basic des Plus/4. Dem Benutzer steht, wie bei dem C 16, mit der Version 3.5 ein sehr gutes Basic zur Verfügung. Da in dem C 16-Testbericht (Ausgabe 1/85) schon ausführlich auf diese neue Basic-Version eingegangen wurde, soll hier nur noch einmal auf spezielle Eigenschaften hingewiesen werden.

## Basic 3.5 — Das beste Commodore-Basic

Mit der Basic Version 3.5steht dem Programmierer ein gutes Werkzeug, und mit 60 KByte freiem RAM auch genügend »Spielraum« zur Verfügung. Befehle, mit denen man DO WHILE- und DO UNTIL-Schleifen aufbauen kann, unterstützen das strukturierte Programmieren. Das umständliche »herumPOKEn« für Grafik- und Tonerzeugung ist durch eine Reihe von leistungsfähigen Befehlen ersetzt worden. Einfache Grafiken können so mit wenigen Befehlen schon nach kurzer Einarbeitungszeit mit dem Plus/4 erstellt werden. Mit dem folgenden kleinen Programm kann man sehr einfach eine interessante Grafik erzeugen.

10 COLOR 0,1
20 COLOR 1,2
30 GRAPHIC1,1
40 A = RND(1)*20 + 10
50 FOR L = 0 TO 359 STEP A
60 CIRCLE 1,160,100,80,40,,,L
70 NEXT L

Sprites sind beim Plus/4 nicht zu finden. Dafür gibt es aber die »SHAPEs«. Mit den Befehlen SSHAPE und GSHAPE werden Ausschnitte aus dem Grafikbildschirm (Mehrfarben- oder Hires-Modus) als Basic-Stringvariable gespeichert beziehungsweise geladen.

Die Fehlersuche erleichtern zwei Funktionen. Zum einen ist die vierte Funktionstaste mit einem HELP-Statement belegt. Tritt im Programm ein Fehler auf, und drückt man diese Taste, erscheint die fehlerhafte Zeile auf dem Bildschirm und blinkt ab dem Befehl, bei dem der Fehler auftrat. Zum anderen stehen die Befehle TRON und TROFF zur Verfügung. Fügt man in ein Programm den Befehl TRON ein, so protokolliert der Plus/4 ab dieser Stelle den Ablauf eines Programmes. Jede Anweisung wird ausgeführt und die Zeilennummer, in der die Anweisung steht, auf dem Bildschirm ausgegeben. Der Befehl TROFF hebt diesen Status wieder auf.

Innerhalb eines Programmes läßt sich gezielt auf Fehlersituationen mit dem Befehl TRAP reagieren. Die Befehlssyntax lautet »TRAP (Zeilennummer)«. Tritt im Programmlauf ein Fehler auf, wird in die bei dem TRAP-Befehl angeführte Zeilennummer verzweigt. In der Variablen »EL« ist die Zeilennummer der Zeile abgelegt, in der der Fehler auftrat. In der Variablen »ER« ist die Fehlernummer gespeichert. Mit der String-Funktion »ERR$(ER)« läßt sich die Fehlermeldung auslesen und in der TRAP-Programmroutine verarbeiten. So kann man gezielt Fehler abfragen und auf sie reagieren, ohne einen Programmabsturz hervorzurufen. Ausgenommen sind hiervon nur der UNDEF’D STATEMENT ERROR und Fehler in der TRAP-Routine selbst. Mit der Anweisung »RESUME« kann der Programmlauf wieder aufgenommen werden.

## Das Bild im Bild

Mit dem Plus/4 ist es möglich, Teile des Gesamtbildschirms als »WINDOW« zu definieren. Ein »WINDOW« ist ein Ausschnitt des Bildschirmes, in dem von der Programmeingabe bis zur PRINT- oder Zeichenanweisung alles ablaufen kann, ohne den Bildschirminhalt außerhalb des »WINDOWS« zu beeinflussen.

Die Window-Technik des Plus/4 ist, verglichen mit der des Schneider CPC 64 etwas enttäuschend. So sind Windows nicht über direkte Anweisungen, sondern nur über die ESC-Funktionen zu erreichen. Weiterhin können nicht mehrere Windows gleichzeitig auf dem Bildschirm dargestellt werden.

## Der Monitor

Für die Maschinensprachefreunde hat der Plus/4 einen besonderen Leckerbissen bereit. Er verfügt über einen Maschinensprache-Monitor mit dem Namen TEDMON. TEDMON ist allerdings nicht nur ein Monitor, sondern in ihm ist auch noch ein Disassembler und ein Assembler enthalten. Die Erstellung von Maschinenprogrammen ist mit dem TEDMON sehr komfortabel. Der Befehlssatz ist mit dem Monitor des C 16 identisch und wurde in der Ausgabe 1 bereits veröffentlicht.

Doch nun zu dem, was den Plus/4 am stärksten von anderen Computern abhebt.

## Das neue Konzept

Der Plus/4 verfügt über eine eingebaute Textverarbeitung, eine Tabellenkalkulation, eine Dateiverwaltung und eine »grafische« Auswertung. Diese vier Programme haben dem neuen Computer seinen Namen gegeben. Faßt man das Plus im Namen als Additionszeichen auf, so kann man dem zustimmen. Alle vier Programme sind vorhanden. Als Wertung sollte man dieses Plus allerdings nicht sehen.

Alle vier Programme sind in einem 32 KByte-ROM untergebracht. Die Textverarbeitung kann mit den anderen drei Programmen Daten austauschen.

In die eingebaute Software gelangt man über die Fl-Taste. Diese bringt einen SYS1525-Aufruf auf den Bildschirm, den man nur mit RETURN zu bestätigen braucht, um in die Textverarbeitung zu gelangen (Bild 1). Die anderen drei Programme kann man nur von hier anwählen. Will man das eingebaute Softwarepaket wieder verlassen, muß man den neben dem Netzschalter angebrachten Reset-Knopfbetätigen. Ein Befehl zum Verlassen der Software ist nicht vorgesehen.

## Plus 1 — Die Textverarbeitung

Ein mit der eingebauten Textverarbeitung erstellter Text kann bis zu 99 Zeilen mit 77 Zeichen pro Zeile enthalten. Auf dem Bildschirm werden allerdings nur jeweils 22 Zeilen und 37 Spalten angezeigt. Schreibt man über die 37 Spalten hinaus, so scrollt der Bildschirminhalt nach links weg. Will man sich einen eingetippten Absatz noch einmal durchlesen, muß man mühsam hin und her springen. Die »Hilfe«, die das Programm hierzu bietet, kann man nicht ganz ernst nehmen. Mit der Fl-Taste kann man auf den linken, mit der F2-Taste auf den rechten Rand springen. Wie schon erwähnt, werden jeweils 37 Zeichen auf dem Bildschirm dargestellt. Zweimal 37 Zeichen, vom linken und vom rechten Rand aus gesehen, ergeben 74 Zeichen. Insgesamt sind in einer Zeile aber 77 Zeichen enthalten. Mit dieser Methode werden also immer die mittleren drei Zeichen abgeschnitten. Bleibt also doch nur das Scrollen über die Cursor-Tasten.

Das Zauberwort, um dieses Problem zu lösen, könnte »formatieren« lauten. 16 verschiedene Formatierungs-Befehle stehen dem Benutzer zur Verfügung. Allerdings nur zur Ausgabe auf dem Drucker. Auf dem Bildschirm sieht man davon nichts. Da man für die Druckerausgabe praktisch immer formatieren muß, hätte es für die Autoren dieser Software wohl keine Schwierigkeit bedeutet, den Text immer in 37 Zeichen pro Zeile auf dem Bildschirm darzustellen und beim Ausdrucken auf die gewünschte Zeilenbreite umzuformatieren.

Umständlich gestaltet sich auch das Einfügen und Löschen von Text. Zum Einfügen stehen dem Benutzer drei Möglichkeiten offen. Zuerst, wie auch im Programmiermodus, die INST/DEL-Taste, mit der man einzelne Zeichen einfügen und löschen kann. Benutzt man diese Funktion, so wird beim Einfügen der gesamte Text verschoben. Ist ein Absatz im Text, verschieben sich auch die Leerzeichen. Fügt man ein vierbuchstabiges Wort ein, sind die Textanfänge der folgenden Absätze jeweils um vier Zeichen eingerückt. Um beim Einfügen nicht den ganzen Text zu verschieben, steht der Befehl »SP« zur Verfügung. Die Kennzeichnung des Bereichs, der sich verschieben darf, erfolgt so: Der Cursor wird an das Ende des zu verschiebenden Bereichs gesetzt, zum Beispiel an das Ende des Absatzes, in dem das Wort eingefügt werden soll. Nun kennzeichnet man das Ende durch den »SP«-Befehl. Jetzt positioniert man den Cursor auf die Stelle, an der der Text eingefügt werden soll. Der Anfang braucht nicht extra gekennzeichnet zu werden. Hier drückt man so oft die INST/DEL-Taste, wie Buchstaben in dem einzufügenden Wort enthalten sind. Ist der Text eingefügt, steuert man den Cursor wieder auf die Ende-Position und löscht den Zeiger mit dem »EP«-Befehl. Fassen wir diese Aufgabenstellung noch einmal zusammen: In einem Brief soll in einem Absatz ein Wort eingefügt werden. Dabei soll sich der Text aber nur innerhalb dieses Absatzes verschieben. Dafür sind diese Befehle nötig:

* <Commodore> + C (um in den Befehlsmodus zu kommen
* **SP** <RETURN> (Ende-Zeiger setzen)
* Cursor auf den Anfang der Einfügung positionieren
* **INST/DEL** (Platz zum Einfügen schaffen
* Text schreiben
* Cursor auf Ende-Zeiger positionieren
* <Commodore> + C (Befehlsmodus einschalten)
* **EP** <RETURN> (Ende-Zeiger löschen)

»Die Fähigkeit, Zeiger auf eine beliebige Stelle zu setzen, ist sehr nützlich und erleichtert das Einfügen eines neuen Textes oder das Löschen sehr.« heißt es im Handbuch. Mit den acht Aktionen, die man zum Einfügen durchführen muß, ist es wirklich »sehr« einfach. Diese Umständlichkeit läßt sich mit einem kleinen Trick umgehen. Setzen Sie bei jedem Absatzende mit der »SP«-Anweisung einen Ende-Zeiger. Jetzt können Sie an jeder beliebigen Stelle einfügen und müssen nur einmal, wenn der Text endgültig fertig ist, die Zeiger löschen.

Das Einfügen ganzer Zeilen ist mit dem »IL«-Befehl zu steuern und gestaltet sich ganz ähnlich.

Die guten Eigenschaften der Textverarbeitungssoftware gehen gegenüber den Nachteilen und den Umständlichkeiten fast ganz unter. Befehle, um blockweise zu kopieren und einzelne Textteile zu verbinden zeigen zwar einen guten Ansatz, werten die Software aber nicht auf.

Die Tabellenkalkulation ruft man aus dem Textverarbeitungsprogramm mit dem Befehl »TC« auf (Bild 2).

## Plus 2 — Die Tabellenkalkulation

Ein wenig dürftig ist auch dieses Programm. Eintragungen in die Tabelle sind nicht ganz so kompliziert wie die Handhabung der Textverarbeitung, aber unter dem Begriff »benutzerfreundlich« ist auch dieses Programm nicht einzuordnen. Oftmals müssen zwei oder drei Anweisungen gegeben werden, um eine einzige Aktion auszuführen. Weiterhin läßt das Tabellenkalkulationsprogramm nur Berechnungsformeln mit einer einzigen Klammerebene zu. Will man kompliziertere Formeln verwenden, müssen sie so umgestaltet werden, daß intern nur jeweils eine Klammerebene abgearbeitet wird.

Die Kapazität der Tabellenkalkulation dürfte dagegen mit 850 Feldern, in einer festen Aufteilung von 17 Spalten und 50 Zeilen, für viele Anwendungen ausreichend sein.

Alles im allem dürfte die Tabellenkalkulation den Heimanwender und eventuell auch Kleinstbetriebe zufriedenstellen.

Positiv ist von den fest eingebauten Programmen nur die Dateiverwaltung zu bewerten.

Aufgerufen wird dieses Programm aus der Textverarbeitung oder der Tabellenkalkulation mit dem Befehl »TF« (Bild 3).

## Plus 3 — Die Dateiverwaltung

Es können 17 Datenfelder mit bis zu 32 Zeichen pro Datensatz angelegt werden. Maximal sind 999 Datensätze pro Datei möglich; dies hängt allerdings von der Anzahl und Länge der Felder ab. Sobald der Aufbau des Datensatzes vom Programm auf der Diskette eingetragen ist, wird dem Benutzer mitgeteilt, wieviele Datensätze in dieser Datei eingetragen werden können.

Das Anlegen der einzelnen Datensätze wird, wie auch bei den anderen Programmen, über den Befehlsmodus, der über <Commo-dore> + C zu erreichen ist, gesteuert. Etwas umständlich, aber hier gewöhnt man sich recht schnell an die wenigen Befehle, die hierzu nötig sind.

Man kann nach jeweils drei verschiedenen Oberbegriffen gleichzeitig sortieren lassen. In einer Adreßdatei zum Beispiel können so Listen erstellt werden, in denen erst nach dem Nachnamen sortiert wird, als zweites Kriterium nach dem Vornamen und als drittes noch nach Postleitzahlenbereichen.

Bemerkenswert ist hierbei, daß die Oberbegriffe, nach denen sortiert werden soll, frei wählbar sind. So können Listen aus demselben Datenbestand nach immer wieder unterschiedlichen Kriterien erstellt werden.

Auch die Suchbegriffe sind aus allen Oberbegriffen frei wählbar. Sucht man beispielsweise nach dem Namen »Eberhard«, spielt es keine Rolle, ob dies der Vor- oder Nachname ist. Alle Datensätze, in denen »Eberhard« vorkommt, werden ausgegeben. Lästig könnte es zwar sein, daß auch ein Datensatz mit einer »Eberhard-Krüger-Straße« mit ausgegeben wird, aber solche Gleichheiten dürften nur sehr selten vorkommen. Jeder Suchbegriff darf abgekürzt werden. Wissen Sie zum Beispiel nicht, ob sich »Eberhard« mit »d« oder »t« am Ende schreibt, so genügt die Angabe von »Eberhar«.

## Plus 4 — Die grafische Auswertung

Bei dem Grafikprogramm haben die Programmierer der Software ihr »Meisterstück« vollbracht. Eine primitivere Form der Grafik ist kaum noch zu realisieren. Betrachtet man die wirklich hervorragenden Grafikfähigkeiten des Plus/4 und sieht dann, was das Grafik-Programm aus den Zahlenkolonnen der Tabellenkalkulation macht, fühlt man sich auf den Arm genommen. Balken- und Liniengrafiken werden aus einzelnen »#« (Nummer-Zeichen) zusammengesetzt. Für die Ausgabe auf einem Drucker kann dies sinnvoll sein, da so die Grafiken auch mit einer Typenradschreibmaschine ausgegeben werden können. Doch zumindest für die Bildschirmausgabe hätte die Grafik mit den ganz normalen Basic V3.5-Befehlen leicht aufbereitet werden können.

## Ein Plus

Einige besondere Aspekte der Plus/4-Software, die man nicht vernachlässigen sollte, sind bisher noch nicht erwähnt worden.

Sehr positiv ist zu bewerten, daß die Textverarbeitung mit der Tabellenkalkulation, der Dateiverwaltung und der grafischen Darstellung zusammenarbeitet, was bedeutet, daß Daten von einem Programm in das andere übertragen werden können. Hierzu gibt es mehrere Alternativen.

Über das eingebaute Windowing, mit dem man Teile des Bildschirms nutzen kann, ohne den anderen Bildschirmteil zu beeinflussen, kann man Teile der Tabellenkalkulation in die Textverarbeitung einblenden. So können Daten, die in Schriftstücken erforderlich sind, zum Beispiel in Geschäftsberichte übertragen werden.

## Software: nur im Konzept gut

Benötigt man den gesamten Datenbestand einer Tabellenkalkulation für ein Dokument, läßt sich dies mit einem Kopierbefehl realisieren. Auch die grafische Auswertung wird auf diese Weise kopiert (Balken- oder Liniengrafik).

Serienbrieferstellung kann in Zusammenarbeit mit der Dateiverwaltung realisiert werden.

Inwieweit die positiven Elemente der Plus/4-Software die negativen Aspekte aufwiegen, muß jeder Anwender für sich entscheiden. Die Idee der eingebauten Software ist sicherlich ein großer Schritt nach vorne auf dem Homecomputer-Markt. In der Ausführung hätten sich die Programmierer aber etwas mehr Mühe geben können.

## Die Hardware überzeugt

Die Hardware des Plus/4 kann dagegen auf ganzer Linie überzeugen. Sehr gutes Basic 3.5 und 60 KByte freier Speicherplatz machen das Programmieren zum Vergnügen. Weiterhin stehen neben der guten Tastatur vier neben der SPACE-Taste angeordnete Cursor-Tasten und acht mit den gängigsten Befehlen belegte Funktionstasten zur Verfügung. Eine Version mit DIN-Tastatur wird zu einem Aufpreis von 100 Mark erhältlich sein. Neben dem Netzschalter ist ein Reset-Schalter angebracht (Bild 4), den man ja auch zum Abschalten der eingebauten Software braucht.

Ein Wermutstropfen sind die neuen Joystick- und Datasette-Anschlüsse (Bild 5). Sie sind nicht kompatibel zu denen des VC 20 und C 64. Umsteiger, die von diesen Computern kommen, müssen sich dieses Zubehör neu anschaffen. Im Gegensatz zum User-Port hat sich ebenfalls der Expansion-Port verändert. Also können auch Erweiterungs-Module und -Karten, die auf diesen Port ausgelegt sind, nicht mehr verwendet werden. Der HF-Ausgang wurde beim Plus/4 an die Seite verlegt (Bild 6).

Im Vergleich zum C 64 hat sich auch auf der Platine einiges geändert. So wurden der SID und der VIC, sowie Teile der VIA im TED integriert. Der neue 7501-Mikroprozessor ist kompatibel zu den bisher verwendeten 6502/6510 (Bild 7).

Schade, daß der Plus/4 nicht ohne eingebaute Software zu einem Preis zwischen 700 und 800 Mark zu haben ist, denn er bietet erheblich mehr als manch anderer Computer dieser Preisklasse.

(rg)

## Auf einen Blick

CPU: 7501-Mikroprozessor/1.76 MHz kompatibel zu 6502/6510
RAM: 64 KByte
ROM: 32 KByte inklusive Betriebssystem und Basic V3.5 + 32 KByte für die eingebaute Textverarbeitung, Tabellenkalkulation, Dateiverwaltung und grafische Auswertung
Maße: Breite 305 mm, Tiefe 203 mm, Höhe 63 mm
Bildschirmdarstellung: 16 Farben (mit jeweils sieben Intensitätsabstufungen), 40 Zeichen in 25 Zeilen, Hires-Auflösung 320 mal 200 Punkte, Multi-Color-Auflösung 160 mal 200 Punkte
Preis: DIN-Tastatur (1398 Mark) und ASCII-Tastatur (1298 Mark)

# Die Stimme des Meisters

> Welch ungläubiges Staunen erweckte doch die erste Phonografentrommel seinerzeit. Kaum anders geht es dem Computerbesitzer heute, wenn er die eigene Stimme aus dem C 64 hört.

Die Vielseitigkeit des Commodore 64 ist schon beinahe sprichwörtlich. Der Covox Voice-Ma-ster (siehe Bild) baut auf dieser Flexibilität auf. Er ist das erste Zusatzgerät für den C 64, mit dem es gelingt, die eigene Sprache elektronisch zu speichern und wieder abzurufen.

Im Speicher des Commodore werden die mit einem Mikrofon auf herkömmlichem Weg aufgenommenen Toninformationen als digitale Werte abgelegt. Ebenso wie alle Basic- oder Maschinenprogramme sind die Tondaten für das mitgelieferte Steuerprogrammjederzeit und vor allem sehr schnell verfügbar. Damit die aufgenommenen Tonimpulse aber auch wiedergegeben werden, bedient sich das Steuerprogramm des SIDs.

### Töne mal ganz anders

Dieser produziert dann nicht, wie so oft, Musik oder die Geräuschkulisse für Spiele, sondern die Originalstimme des Benutzers. Ein verblüffender Effekt. Bisher bekannte Programme, wie etwa der SAM, mußten oft umständlich programmiert werden. Mit Voice-Master merkt sich der Commodore einfach die in ein Mikrofon gesprochenen Worte.

Auf diese Weise finden bis zu 64 einzelne Worte auf einmal im Speicher Platz. Da die Speicherung solcher Daten recht aufwendig und platzraubend ist, sind volle 64 Worte nur bei sehr kurzen Vokabeln möglich. In der Regel stehen etwa 40 programmierbare Worte zur Verfügung. Wer sich jetzt fragt, wieviel dann noch für sein Programm übrigbleibt, fragt richtig, denn umfangreiche Basic-Programme sind nicht mehr möglich. Dies gilt für die erste Version des Voice-Masters. Die ebenfalls mitgelieferte zweite Version läßt den gesamten Basic-Speicher unangetastet, hat aber nur noch etwa acht KByte für Tondaten (was nicht viel ist).

### Einfachste Bedienung

Wer glaubt, daß ein solches Programm schwierig zu handhaben ist, wird freudig überrascht sein. Die Worte werden in einer FOR-NEXT-Schleife mit dem Befehl LEARN A eingegeben, die Variable A ist dabei die Nummer des Wortes. Zur Wiedergabe der Wörter (über den normalen Fernsehlautsprecher) genügt der Befehl SPEAK A. Ebenso simpel kann die Lautstärke (VOLUME B) oder die Sprechgeschwindigkeit (SPEED C) verändert werden. Wichtigstes BeeinfIussungsmerk-mal für die Töne ist die Aufnahmefrequenz (RATE D), die zwischen 5000 Baud und 12000 Baud einstellbar ist. Interessante und manchmal recht lustige Variationen der Worte sind das Resultat einer einfallsreichen Verkettung dieser Befehle. Mit etwas Geschick ist auch ein Echo-Effekt möglich.

### Auf der Suche nach dem Zweck

Natürlich drängt sich bei einem solchen Zusatzgerät die Frage auf, wozu das Ganze eigentlich nützlich sein kann. Vordringlich fallen einem da Anwendungen wie die Sprachunterstützung bei Spielen (Achtung! Feind von rechts!), oder die akustische Unterstützung eines Auswahlmenüs ein. Daß auch wesentlich anspruchsvollere Anwendungen denkbar sind, zeigt das beigefügte Taschenrechnerprogramm, das jede eingegebene Zahl oder Rechenoperation mit Worten bestätigt. Mit einer auch beim Commodore 64 möglich erscheinenden Speichererweiterung von 256 KByte ist so eine akustische Eingabekontrolle jeder gedrückten Taste denkbar. Für Blinde eröffnet sich so die weite Welt der Microcomputer. Aber auch für Sehende ist das Erlernen der Programmiersprache Basic mit akustischer Unterstützung sicherlich einfacher.

Besonders angenehm ist es, daß man die eingegebenen Worte auf Diskette abspeichern kann. Im Bedarfsfall steht jeder beliebige Wortschatz innerhalb kürzester Zeit zur Verfügung. Zur Wiedergabe der Worte ist das Modul des Voice-Ma-sters überflüssig, nicht aber die Software. Dieses kurze Programm muß in jedem Fall geladen beziehungsweise in ein Programm einbezogen werden. Programme mit eigener Sprachunterstützung stehen somit auch allen jenen zur Verfügung, die den Voice-Master nicht besitzen. Verändern können Sie den Wortschatz allerdings nicht mehr.

### Sprachausgabe ohne Zusatz

Die Charakteristik jeder Stimme oder eines bestimmten Geräusches bleibt erstaunlich naturgetreu erhalten. Leider entspricht das mitgelieferte Mikrofon nicht dem Stand der Technik. Ein Versuch hingegen, Musik mit einem guten Mikrofon aufzunehmen, brachte ganz erstaunliche Ergebnisse. Der Commodore als Musikrecorder, ein mögliches, aber wohl etwas zu teures Verfahren. Für die reine Sprachein- und -ausgabe ist der Preis von 298 Mark gerade noch tragbar.

### Zukunftsmusik

Wichtigste Erkenntnis ist aber die Enthüllung der ICs als Ton-Speichermedium der Zukunft. Vollkommen naturgetreue und beliebig beeinflußbare Reproduktion von Daten, seien es nun Tondaten oder Videoinformationen, sind das Ergebnis. Sollte sich die Preisentwicklung und die Leistungsfähigkeit der Speicherchips mit der gleichen Geschwindigkeit wie bisher weiterentwickeln, so wird es sicher bald Videokassetten geben, die kein-Gramm Magnetband mehr enthalten. Der Voice-Master wird bis dahin aber sicher schon ein Urahn dieser Entwicklung sein.

(Arnd Wängler/aa)

Bezugsquelle: Microton, Computerprodukte, Bahnhofstr. 2, CH-2542 Pieterlen

> 16-KByte-Erweiterung umschaltbar

> Im Gegensatz zur 8-KByte-Erweiterung ist die 16-KByte-Karte für den VC 20 auf einen Adreßbereich fest eingestellt. Mit wenig Bastelaufwand kann sie aber jedoch auch für den Steckmodulbereich genutzt werden.

Nicht wenige VC 20-Besitzer ha-bendenWunsch, ihre 16-KByte-Erweiterung VIC 1111 von Commodore auch für den Autostartbereich $A000-$BFFF (40960-49152), gelegentlich Modulbereich genannt, zu benutzen.

Der Autostartbereich bietet bekanntlich die Möglichkeit, unter gewissen Voraussetzungen sofort nach dem Einschalten an die Stelle $A000/$A001 zu springen und von dort natürlich an jede gewünschte Stelle im Programm, wobei noch besonders bemerkenswert ist, daß die Auslösung eines CPU-Resets mittels nachträglich eingebautem Taster, der beispielsweise Pin 6 mit Pin 2 an der Buchse des seriellen Ausgangs verbindet (»not connected« für Pin 6 in den diversen Büchern ist geschwindelt: Pin 6 liegt am System-Reset) dieselbe Wirkung wie das Einschalten hat: Es erfolgt ein Sprung in die Reset-Routine $FD22-$FD3C (64802-64828), Abfragen auf »A0CBM« in $A004-$A008 und gegebenenfalls Sprung indirekt über $A000/$A001 an die gewünschte Stelle. Bei Betätigung der Restore-Taste erfolgt ein Sprung indirekt über $A002/$A003.

Die immer wieder zu hörende Auskunft, die Erweiterung VIC 1111 sei nicht umschaltbar, stimmt nur bedingt. Man braucht lediglich einen geeigneten Schalter einzubauen. Es ist keine Elektronik nötig. Der Schalter hat mich 25 (fünfundzwanzig) Pfennige gekostet.

Die Erweiterung VIC 1111 ist mit durchkontaktierten Bohrungen versehen, in die man theoretisch zwei Vierfach-DIL-Schalter einbauen könnte. Dann wären die 16 KByte blockweise zu je 8 KByte überallhin (nach Block 1, 2, 3 oder 5) hin zu legen. Selbstverständlich macht man das nicht, da einerseits die Gefahr der Doppelbelegung und Zerstörung zu groß wäre und andererseits diese Stelle in der verschlossenen 16-KByte-Erweiterung ja nicht zugängig ist. Es wurde daher nur ein 8-KByte-Block umschaltbar gestaltet, und zwar zur wahlweisen Beschaltung von [nichts/$4000-$5FFF], [$2000-$3FFF/$4000-$5FFF], [$6000-$7FFF/$4000-$5FFF], oder [$A000-$8FFF/$4000-$5FFF].

Der Schalter wird mit Bohrmaschine, Feile und Lötkolben ohne großen Aufwand mechanisch recht sicher an der Stirnseite der »Cartridge« untergebracht (siehe Bild 1 und 2). Die elektrischen Anschlüsse sind Bild 3 zu entnehmen: Über die Anschlüsse 10, 11, 12 und 13 an der »Memory Expansion« werden der Erweiterung die voll decodierten Chip-Select-Signale BLK1, BLK2, BLK3 und BLK5 zugeführt. Über	eine Lötbrücke geht das Signal BLK1 beim uns interessierenden 8-KByte-Teil an den Zweifach-2-zu-4-Decoder 74LS139. Die Lötbrücke wird (mit etwas Ent-lötlitze ohne Schwierigkeiten) entfernt und die Schaltverbindungen, wie in Bild 3 gezeigt, so an den Vierfach-Umschalter herangeführt, daß keine Bereichsüberlappungen möglich sind.

Zu bemerken wäre noch, daß es eine halbe Lebensaufgabe ist, die Ummantelung der 16-KByte-Erweiterung aufzubekommen: An den Schlitzen an der Stirnseite kann man mit einem Taschenmesser oder einem feinen Uhrmacherschraubenzieher gegendrücken und so die beiden Plastikschnäpper lösen, an der Steckerseite hilft rechts und links eine zurechtgebogene Büroklammer zum leichten herausziehen. Vorsicht, Bruchgefahr! Aber keine Angst: Die 16-KByte-Erweite-rung funktioniert auch mit beschädigter Plastikhülle. Sie ist natürlich auch ohne jegliche Umhüllung hundertprozentig funktionstüchtig.

(Fred Behringer/ev)

# Richtig verbunden – Video/Audio-Kabel für den C 64

Im Bedienungshandbuch zum C 64 ist auf Seite 142 die Belegung der Video/Audio-Buchse angegeben. Dieser Anschluß wird benötigt, wenn der C 64 nicht am Antenneneingang, sondern am Videoeingang eines Fernsehgeräts oder Monitors betrieben wird.

### Neue Buchse beim C 64

Bei neueren Modellen des C 64 ist die im Handbuch beschriebene Video/Audio-Buchse durch eine andere ersetzt worden. Die Belegung der neuen Anschlußbuchse zeigt Bild 1. Die folgende Erläuterung der Signale gibt in knapper Form Aufschluß über deren Funktion.

## Die Bildsignale des C 64

> Sie müssen kein Elektronikprofi sein oder Elektrotechnik studiert haben, um einen Fernseher mit Videoeingang oder einen Monitor an den C 64 anzuschließen.<br>Wenn Sie wissen, an welchem Ende ein Lötkolben heiß wird, dann dürfte diese Bauanleitung für Sie ein klarer Fall sein.

Das Luminanzsignal, auch BAS-Signal genannt, ist ein Intensitätssignal. Es enthält die Helligkeitswerte zwischen Schwarz und Weiß und wird zur Ansteuerung eines monochromen Monitors oder SW-Fernsehgerätes benutzt.

Mit dem Chrominanzsignal (F-Signal) werden Farbinformationen übertragen. Das Chrominanz- und Luminanzsignal liefern zusammen die gesamte Farbbildinformation. Die getrennte Übertragung dieser Signale ist nicht allzu weit verbreitet. Nur wenige Monitore, wie der Commodore-Monitor 1701 oder 1702, haben getrennte Eingänge für Chrominanz und Luminanz. Getrennte Signale führen zu einer schärferen Bildwiedergabe als das FBAS-Signal.

Das VIDEO OUT-Signal ist kompatibel zum FBAS- oder PAL-Signal und setzt sich aus dem Luminanz- und Chrominanzsignal zusammen. Es enthält alle Informationen, die der Aufbau eines Farbbildes erfordert. Dieses Signal erlaubt es, einen Farbfernseher oder Monitor mit PAL-Videoeingang an den C 64 anzuschließen, ohne den Umweg über den Antennenanschluß zu nehmen. Die erforderliche Modulation/De-modulation führt dabei nämlich zu einem Qualitätsverlust.

Die Beschaltung einer Videobuchse herkömmlicher Bauart (VCR) können Sie Bild 2 entnehmen. Bild 3 zeigt die der neuen, genormten SCART-Buchse.

Über das AUDIO OUT-Signal wird der Ton des C 64 übertragen. Hat der Monitor kein Tonteil, hilft nur eine Nachrüstung oder ein externer Verstärker.

Der Vollständigkeit halber sollte der AUDIO IN-Eingang nicht unerwähnt bleiben. Über diesen werden dem Soundchip SID 6581 des C 64 externe Audiosignale zugeführt, die sich bei entsprechender Programmierung be- und verarbeiten lassen. Da dieser Eingang ungepuffert ist (nur über einen Elko 10^F/25V entkoppelt) und direkt an das SID führt, ist höchste Vorsicht geboten. Das Handbuch sagt nichts über die zulässigen Grenzwerte aus. Vermutlich ist der TTL-Pegel ( + 5V) das äußerste Limit.

## Die Verbindung

Um den Computer und den Monitor beziehungsweise das Fernsehgerät miteinander zu verbinden, benötigt man ein Verbindungskabel, das leicht aus einem abgeschirmten zweiadrigen Kabel und den passenden Steckern angefertigt wird. Die Teile gibt es im Elektronikfachhandel. Bild 4 zeigt ein Kabel für die Verbindung C 64 — monochromer Mo-nitor/SW-Fernsehgerät. Die Bilder 5 und 6 zeigen den Anschluß an einen Farbmonitor/Farbfernsehgerät mit herkömmlicher VCR-Buchse und dem neuen SCART-Anschluß.

Bei Fernsehgeräten muß zur Umschaltung auf die VCR-Buchse Pin 1 auf eine Schaltspannung von + 12V gelegt werden. Dies läßt sich mit einem Schalter über Pin 1 und 5 des VCR-Steckers realisieren. Wer auf den Schalter verzichten möchte, lötet zwischen die beiden Pins einfach eine Drahtbrücke. Soll der Fernseher dann wieder »normales« Programm empfangen, muß der Stecker gezogen werden.

Beim SCART-Stecker ist die Umschaltung nicht ganz so einfach zu verwirklichen, da keine Schaltspannung zur Verfügung steht. Die benötigte Spannung von +1 bis 3V kann allerdings am C 64 abgegriffen werden: am Pin 2 des User-Ports liegt die Spannung +5V/100mA an. Beim VC 20 wird der Pm 1 der VIDEO/ AUDIO-Buchse genommen. Über einen Widerstand von 330 Ohm legt man die Spannung an Pin 16 des SCART-Steckers. Dies hat den Vorteil, daß beim Einschalten des Computers eine automatische Umschaltung des Fernsehgerätes von »Fernseher« auf »Datensichtgerät« erfolgt.

(Dipl.-Ing. R. Kurzhals/hm)

Literatur: Funkschau 8/1983, Seite 84-85.
MC 11/1983, Seite 50. Das große Werkbuch Elektronik, Nührmann, Franzis Verlag.

# Terminal 64 – Schwer auf Draht

> Die Datenfernübertragung mit dem Commodore 64 wird immer interessanter. Seit nun auch gute Akustikkoppler mit FTZ-Nummer zu günstigen Preisen erhältlich sind, gehört eine DFÜ-Ausrüstung fast schon zur Grundausstattung eines Computers.

Es ist kaum ein halbesJahr her, als der C 64-Besitzer, ausgestattet mit einer RS232-Schnittstelle (noch vom VC 20), einem zusammengelöteten Akustikkoppler und einem kleinen, unkomfortablen DFÜ-Programm noch als Exot unter den Benutzern der verschiedenen Mailboxen galt. Damals war dies die Welt der Epsons, DECs und IBMs, heute ist das eher umgekehrt. Einen wesentlichen Beitrag zu dieser Entwicklung leisteten findige Programmierer, die dem Anwender immer komfortablere DFÜ-Programme zur Verfügung gestellt haben.

## Gute Software ist wichtig

Jede auch noch so teure Geräteausstattung bleibt ohne Wert, solange nicht die entsprechende Software erhältlich ist. Mit Terminal 64 wird nun ein Programm angeboten, das den Anspruch erhebt, komfortabel und leistungsfähig zu sein. Wir haben es im Praxisbetrieb getestet. Angeschlossen waren neben der obligatorischen RS232-Schnittstelle und dem Verbindungskabel ein Minimodem 3005.

Nach dem Laden steht dem Anwender das erste der verschiedenen Untermenüs zur Verfügung (Bild 1). Im Gegensatz zur sonst üblichen Praxis werden die Unterfunktionen nicht über Zahlen, sondern mit den Cursortasten ausgewählt. Der erste Menüpunkt dient zur Umschaltung in den Online-Modus. In dieser Funktion kann Terminal 64 von anderen Computern per Telefonleitung Zeichen empfangen und speichern.

## Viele Zusatzinformationen

Im Online-Modus ist die erste Zeile als Statuszeile ausgelegt. Neben dem Schriftzug »Online« dient die Statuszeile der Übermittlung diverser Informationen. Es handelt sich dabei um sogenannte »Statusflags«. Für alle, die ihre Telefonrechnung selber bezahlen müssen, ist die hier angezeigte Zeitinformation sicherlich sehr kostensparend, denn beim Stöbern in Datenbanken ist Zeit nur ein sehr relativer Faktor. Das zweite Flag (snd) gibt Auskunft darüber, ob der Commodore gerade aus seinem Puffer sendet. Nach dem Abschluß jedes Sendevorgangs kann am dritten Flag (end) erkannt werden, wann der Computer mit dem Senden fertig ist. Ebenso wird das vierte Flag (sto) revers geschaltet, wenn empfangene Zeichen gespeichert werden. Am rechten Rand der Statuszeile zeigt das fünfte Flag die verfügbare Restspeicherkapazität in Zeilen zu vierzig Zeichen an. Bei einer Gesamtspeicherkapazität von zirka 40000 Zeichen dauert es allerdings eine ganze Zeit, bis der Speicher gefüllt ist.

Nun ist das Empfangen und Darstellen von Zeichen natürlich nicht das einzige, was von einem guten Terminalprogramm erwartet werden darf. Je mehr der Anwender in das Geschehen, beziehungsweise auf den anderen Computer einwirken kann, desto größer ist der Nutzen des Terminalprogramms. Bei Terminal 64 wird der empfangene Text sowohl auf dem Bildschirm dargestellt, als auch in den Computer geladen. Dabei können Speicherbeginn und -ende entweder vom Benutzer selbst oder auch vom Hostrechner gesteuert werden. Beim benutzergesteuerten Speicher wird mit der Fl-Taste bestimmt, welche Textpassagen gespeichert werden sollen. Unwichtige Teile können auf diese Weise per Tastendruck ausgeblendet werden, damit der Pufferspeicher nicht unnötig vollgeschrieben wird. Oftmals kann es aber auch vorteilhaft sein, wenn der sendende Computer Speicherbeginn und -ende steuern kann, zum Beispiel bei der Übertragung von Programmen.

In diesem Fall ist der Job des Benutzers von Terminal 64 recht einfach, denn die entsprechenden Steuerzeichen werden vom Programm unterstützt und gegebenenfalls ausgeführt. Der umgekehrte Fall, in dem der Commodore zum sendenden Computer wird, ist natürlich auch denkbar. Mit CTRL B beziehungsweise CTRL C wird nun der Speicherbeginn und das Speicherende des empfangenden Computers gesteuert.

Das Senden von Zeichen kann mit Terminal 64 grundsätzlich auf drei verschiedenen Wegen realisiert werden. Zur Verfügung stehen entweder die Tastatur, die mit beliebigen Strings belegbaren Funktionstasten oder der Pufferspeicher. Die erste und zweite Methode dienen in der Regel dem direkten Dialog mit anderen Computern, bei denen sich Sender und Empfänger abwechseln. Das Senden aus dem Pufferspeicher lohnt sich meist dann, wenn längere Texte, beispielsweise Listings, übertragen werden sollen. Dabei besteht beim Übertragen des Pufferspeichers die Wahlmöglichkeit zwischen zeilenweisem oder kontinuierlichem Senden. Auch die für manche Hostcomputer gelegentlich notwendige Verzögerung der Datenübertragung, kann mit Terminal 64 in drei verschiedenen Stufen eingestellt werden.

Eines der interessantesten Anwendungsgebiete für den Modembetrieb ist die Übertragung von Programmfiles. Dies geht im Prinzip nicht viel anders vor sich, als die Übermittlung von Texten oder sonstigen Mitteilungen. Da im Modembetrieb aber eine Übermittlung gemäß dem ASCII-Standard notwendig ist, muß der Programmcode vor dem Senden in ein ASCII-File umgewandelt werden. Das geschieht vor dem Laden von Terminal 64 am einfachsten mit dem LIST-Befehl: 1. Programm laden, dann im Direktmodus OPEN 2,8,2, ’’FILENAME, S, W”: CMD2 : LIST: CLOSE2 eingeben. Dabei ist zu beachten, daß im Programm keine Commodore-spezifi-schen Steuerzeichen enthalten sein dürfen (durch CHR$-Codes ersetzen). Ein so präpariertes Programm kann nun als sequentielles File von Terminal 64 in den Pufferspeicher geladen und dann gesendet werden. Für den Empfang von im Quellcode vorliegenden Programmen stellt Terminal 64 sogar eine eigene Umwandlungsroutine bereit. Für ein empfangenes und im Pufferspeicher abgelegtes Programm wird im Untermenü Diskettenoperationen der Punkt Fileumwandlung angewählt. Nach dem Eingeben des Filenamens wird das transformierte File als Basic-Programm auf Diskette geschrieben. Der Pufferspeicher kann, ebenfalls vom Diskettenmenü aus, aber auch ohne Umwandlung zur späteren Weiterverarbeitung abgespeichert werden (Bild 2).

Mit allen seinen komfortablen Eingabefunktionen und seiner kompletten Ausstattung, sogar mit einem Standard ASCII- und einem deutschen Zeichensatz, ist der Terminal 64-Editor beinahe schon ein kleines Textverarbeitungsprogramm (Bild 3). Da auch alle Funktionen zum Speichern und Laden von Texten vorhanden sind, lohnt es manchmal, bestimmte Texte, die später gesendet werden sollen, gleich in den Pufferspeicher von Terminal 64 zu schreiben. Damit aber nicht genug, denn Terminal 64 kann alle sequentiellen Files lesen. Textverarbeitungsprogramme können zur Erstellung eines Briefes herangezogen werden.

### Flexibilität großgeschrieben

Wichtigstes Kriterium eines Terminalprogramms ist natürlich seine Flexibilität. Wer nur deshalb, weil Einstellparameter fehlen, die Hälfte aller verfügbaren Datenbanken erreicht, wird sicher bald enttäuscht sein. Terminal 64 ist in dieser Hinsicht vorbildlich. Das umfangreiche Parametermenü (Bild 4) läßt fast keine Wünsche offen. Baudraten von 150 bis 2400, Anzahl der Datenbits, Stopp-Bits, Halbduplex/Vollduplex und vieles mehr, stehen zur Wahl. Besonders interessant sind natürlich die beiden letzten Punkte, denn sie verwandeln den Commodore in einen Computer mit vollständiger DIN-Tastatur. Da Terminal 64 auch viele am Commodore anschließbaren Drucker unterstützt, entfallen im Zusammenspiel mit einem Umlautfähigen Drucker unliebsame Falschzeichen auf dem Ausdruck. Aber auch der ASCII-Zeichensatz entspricht der Norm. Die dadurch erreichte Kompatibilität mit anderen Hostcomputern kann mit Recht als fast hundertprozentig bezeichnet werden.

Datensicherheit, Leistungsfähigkeit und Komfort sind wohl die treffendsten Attribute für dieses Terminalprogramm. Bis auf die fehlende Darstellung von 80 Zeichen auf dem Bildschirm, kann Terminal 64 als Wegbereiter und neuer Standard für Terminalsoftware für den Commodore 64 gelten. Durch den großen verbleibenden Pufferspeicher ist mit diesem Programm ein effizientes Arbeiten in der Datenfernübertragung möglich.

(Arnd Wängler/rg)

Bezugsquelle: Electronic Universe, Hindenburgstr. 98, 2120 Lüneburg, Preis inklusive Schnittstelle 169 Mark.

# Nachhilfe auf Knopfdruck

> Können in Zukunft Mathematiklernprogramme den bewährten Nachhilfelehrer ersetzen? Um diese Frage zu klären, testeten wir zwölf Programme von fünf Anbietern, die den Mathematikunterricht in den unteren Klassen unterstützen sollen.

Ein Mathematikprogramm sollte danach bewertet werden, wieviel Wissen, in bezug zum jeweiligen Klassenlehrplan, vermittelt wird. Dabei spielt die Aufmachung eine große Rolle. Die Programme sollten auf psychologische und pädagogische Erkenntnisse und Grundsätze aufbauen: keine Bestrafung bei falschen, aber ein Lob bei richtigen Lösungen. Ein falscher Tastendruck darf nicht zu irritierenden Fehlermeldungen oder Systemabstürzen führen.

## Lernen mit Leopold

Der Schulbuchverlag Westermann reiht sich mit sieben Programmen in die Avantgarde der Lernsoftware ein. Wir haben zwei der drei von Westermann angebotenen Mathematikprogramme getestet: Bruchrechnung Teil 1 und Prozentrechung.

Zu Beginn des »Unterrichts« wählt der Schüler die Art und Anzahl der Aufgaben. So kann man zum Beispiel bei Prozentrechnung zwischen dem Grund- oder Prozentwert und dem Prozentsatz entscheiden. Die Aufgaben werden in zwei Schritten, wie im Schulheft, ausgerechnet. Im ersten Lösungsschritt wird das Lösungsschema verlangt , im zweiten das Ergebnis. Stimmt die Lösung, freut sich das Lektionsmaskottchen »Löwe Leopold« und zeigt kleine »Dressurakte«. Ist das Ergebnis falsch, röhrt Leopold und fragt, ob man noch einen Lösungsversuch unternehmen will. Wenn nicht, zeigt das Programm den Lösungsweg und das Ergebnis. Auf Wunsch kann man sich mit Fl das Lösungsschema anhand eines Beispiels ausführlich zeigen lassen.

Die Mathematikprogramme von Westermann sind grafisch ansprechend aufgebaut. Das Lob dürfte Kinder zum Rechnen weiterer Aufgaben animieren. Bei falschen Lösungen wird der »Schüler« von seinem elektronischen Lehrer nicht mit frustrierenden Kommentaren oder Noten traktiert, die mehr zum Ausschalten des Computers als zum Lernen anspornen.

Für 69 Mark (nur auf Diskette) pro Lektion, bekommt man also Programme von Westermann, die zur Ubung von einfachen Rechenaufgaben geeignet sind, wobei der Kopf schon mal raucht, wenn alle Aufgaben ohne Taschenrechnner erledigt werden.

## Lernen — Trainieren — Begreifen

Ein anderer Lehrmittelverlag versucht sich ebenfalls mit Lernprogrammen auf dem Markt zu behaupten: Hagemann aus Düsseldorf. Hagemann bietet verschiedene Mathelektionen an, die sich auf sieben Kassetten und sechs Disketten verteilen. Die Kassetten kosten ab 38,50 Mark, die Disketten zwischen 65 und 69 Mark.

Am besten gefiel, wie die Aufgaben zu lösen waren. Bei den vier Grundrechnungsarten erfolgen die Rechnungen wie auf einem Blatt Papier. Überhaupt nicht begeistern konnte die Art der Eingaben. Bei den Grundrechungsarten wird durch eine GET-Routine eingelesen, was Tippfehler sofort als Rechenfehler abstempelt. Bei Prozent- und Zinsrechnung läuft die Eingabe über einfache INPUTs, was dazu führt, daß das Programm unsinnige Eingaben erlaubt und der Computer dann Fehlermeldungen des Betriebssystems ausgibt. Wie Hagemann versicherte, sollen ab Dezember neue Programmversionen auf den Markt kommen, die Eingabefehler abfangen. Die optische Aufmachung der Lernprogramme für Grundrechenarten ist für die Zielgruppe der Rechenanfänger angemessen, könnte aber besser gestaltet sein. Dafür gibt es ausführliche Beispiele mit Erklärungen bei falschen Antworten. Besonders ist hervorzuheben, daß die Programme über keinen Kopierschutz verfügen. Der Schüler kann das Programm listen und anschauen, um einen Bezug zum Computer zu bekommen. Das soll auch bei den neuen Versionen so bleiben, falls es programmtechnisch möglich ist.

## Mathe für den Junior

Mit »junior mathemat« bietet Data Becker ein Spiel- und Lernprogramm an. Es soll, wie im Vorwort zum Programm steht, den Mathematikunterricht, von der Grundschule an, begleiten. Das Programm umfaßt eine Vielzahl von Aufgabenstellungen. Neben den vier Grundrechenarten soll »junior mathemat« auch beim Üben von Mengenlehre, Maßeinheiten, Zahlenbetrachtungen und Ungleichungen zur Seite stehen.

Bevor man sich ans Werk macht, muß erst langwierig für jeden Schüler eine Datei auf einer eigenen Diskette kreiert werden. Diese enthält Angaben über die Anzahl und Art der Aufgaben, die gestellt werden sollen, und den Namen des Schülers. Beim Formatieren dieser Diskette ist es dringendst zu empfehlen »junior mathemat.ma« als Diskettennamen einzugeben, um nicht beim späteren Arbeiten einen »Diskettenfehler« zu erzeugen. Wegen des vorhandenen Kopierschutzes kann die Datei mit den persönlichen Angaben leider nicht auf der Programmdiskette abgespeichert werden und macht dadurch den Schüler zum Diskjockey.

Hat man wieder die Programmdiskette eingelegt und »junior mathemat« gestartet, wird der Name abgefragt. Entspricht die Schreibweise nicht exakt der in der Datei, wird erklärt, daß der Name falsch eingegeben ist. Man erhält keinen Hinweis, wo der Fehler zu suchen ist.

Pädagogisch nicht sinnvoll ist die Art, mit der ein Schüler bei einem falschen Ergebnis konfrontiert wird: Pro falsche Antwort sind drei Fragen mehr zu beantworten. Diese Strafarbeit läßt das Programm schnell unattraktiv werden. Als Belohnung bietet das Programm ein grafisch unbedeutendes Fangspiel an, das nicht unbedingt zum Weiterüben reizt.

Hat der Schüler den Aufgabenkatalog durchgearbeitet, steht eine Erfolgskontrolle zur Verfügung, die nach jeder Übungsstunde aktualisiert wird. Wegen der frustrierenden Art, mit der dem Schüler, bei falschen Antworten, Zusatzaufgaben aufgebrummt werden und der schwachen Benutzerführung konnte »mathemat junior« nicht überzeugen. Das Programm kostet 69 Mark (nur Diskette erhältlich).

## Sucess With Math — Lernen mit Erfolg

Schon seit längerem bietet CBS-Software Lernprogramme auf dem amerikanischen Markt an. CBS will nun den deutschen Markt mit einer Serie von Mathematikprogrammen erobern.

»Sucess With Math« heißt der Slogan und die Programmserie. Das Aufgabenspektrum der Serie reicht von den Grundrechungsarten bis zu linearen und quadratischen Gleichungen. Das erste der acht Lernpakete umfaßt die Rechenarten Addition und Subtraktion. Die einzelnen Übungen werden dem Schüler lieblos vorgesetzt, so daß der Spaß am Lernen schnell schwindet. Bei bestandenen Lektionen winkt kein Lob in Form von Grafik oder Sound. Statt dessen erhält man eine trockene Fehleranalyse serviert. In jedem Schulbuch wird der Lernstoff attraktiver angeboten.

Die anderen Lernpakete wie Multiplikation und Division konnten ebensowenig überzeugen, wie die letzten beiden Lektionen über lineare und quadratische Gleichungen.

Ein zusätzlicher entscheidender Nachteil der CBS-Lernpakete ist die Tatsache, daß die Programme in Englisch abgefaßt sind und dadurch die größte Zielgruppe der Anwender, Schulkinder in den unteren Klassen, völlig verfehlen. Von Programmen dieser Preisklasse (Kassette 49 Mark, Diskette 69 Mark) sollte man mehr erwarten können.

## Im Labyrinth der Mathematik

Mit »TRI-MATH« bietet Hesware ein Lernprogramm an, das schon nach dem Laden durch die hervorragende grafische Aufmachung die Aufmerksamkeit des Schülers auf sich lenkt. Das Programm besteht aus drei Teilen: zwei Science-fiction-Teilen und einem Adventure. In jedem der Programmteile soll der Schüler, auf recht spielerische Weise, Kopfrechnen üben. Die Aufgaben entsprechen dabei den Anforderungen der unteren Schulklassen. Es werden die Grundrechenarten verlangt. Im ersten Spiel gilt es schneller zu rechnen als ein kosmischer Gegner. Im zweiten müssen für einen »Digitosaurus« Aufgaben gelöst werden, damit dieser alt und weise wird und schließlich mit seinem Helfer in der »Hall of Fame« landet. Der dritte Teil, ein Adventure, bei dem richtige Lösungen Tür und Tor öffen, besticht durch seine grafischen Fähigkeiten.

Trotz der guten Eigenschaften wird sich »TRI-MATH« schwer am deutschen Markt durchsetzen, da das Programm in Englisch abgefaßt ist und nur einfache Aufgaben stellt.

## Es war nicht immer so

Mathematiknachhilfe mit dem Computer ist eine neue Art des Lernens. Die Programme dazu können ohne weiteres als Prototypen bezeichnet werden, die noch verbesserungsbedürftig sind. Man sollte das Programmangebot gründlich prüfen, da, neben einigen brauchbaren Programmen, noch sehr viele existieren, die den Namen »Lernprogramm« nicht verdienen.

(hm)

Info:
Lernen mit Leopold
Westermann Software, Postfach 5520, 3300 Braunschweig
Lernen — Trainieren — Begreifen
Hagemann, Karlstr. 20; 4000 Düsseldorf
Mathe für den Junior
Data Becker, Merowingerstr. 30, 4000 Düsseldorf
Sucess With Math
CBS-International, Rue Chateau 1, F-92200 Neuville
Im Labyrinth der Mathematik
Hesware, Human Engineering Software, 150 North Hill
Drive, Brisbane, CA 94005

# Assembler im Test – Teil 2

> Im zweiten Teil unseres Assembler-Tests kommen die Assembler unter 100 Mark an die Reihe. Wir stellen folgende Produkte vor: Mastercode-Assembler, Profimat, Profisoft und Maschine 64. Obwohl sie in der unteren Preisklasse angesiedelt sind, können sie eine wertvolle Hilfe beim Einstieg in die Maschinensprache sein.

Bevor wir auf die vier diesmal getesteten Assembler zu sprechen kommen, vorher noch ein paar Bemerkungen über die Zielgruppe dieser Programm-Pakete.

Die in der letzten Ausgabe vorgestellten Assembler kann man sowohl vom Preis als auch von den Möglichkeiten her zu den professionellen Programmentwicklungssystemen zählen (vielleicht mit Ausnahme des T.EX.AS., der als Lehrsystem bezeichnet wird). In ihnen sind Funktionen enthalten, die selbst fortgeschrittene (Assembler-)Programmierer erst nach relativ langer Zeit und nach andauernder Benutzung beherrschen und anwenden. Dann allerdings möchte man auf den gebotenen Komfort und die mächtigen Befehle (zum Beispiel Makro-Bibliotheken, bedingte Assemblierung, etc.) nicht mehr verzichten.

Assembler, wie sie in dieser Ausgabe vorgestellt werden, wenden sich mehr an den Assembler-Anfänger und Gelegenheitsprogrammierer. Das heißt jedoch nicht, daß mit ihnen nicht auch vernünftig gearbeitet werden könnte. Für kleinere Projekte (klein bezieht sich nicht nur auf den Umfang, sondern auch auf die Komplexität) reichen diese Assembler nicht nur aus, sondern erfüllen durchaus ihren Zweck. Da es keine unnötigen Funktionen gibt, braucht man sich nicht mit einem Ballast von Kommandos herumzuschlagen. Die Geschwindigkeit ist (abgesehen vielleicht vom Mastercode-Assembler) völlig ausreichend. Mit Ausnahme vom Profimat-System sind in den anderen drei Programmen Editor, Monitor und Assembler zusammengefaßt, so daß Maschinensprache-Programme in einem Arbeitsgang geschrieben, assembliert und getestet werden können. Auch das ist ein Vorteil. Nun ist es aber nicht so, daß ein Assembler unbedingt notwendig zum Programmieren in Maschinensprache ist. Ein guter Monitor, wie zum Beispiel der SMON, stellt fast alle Hilfsmittel zur Verfügung (sehr wichtig zum Beispiel: Label). So wurde unter anderem das Programm HYPRA-LOAD aus Ausgabe 10/84 in monatelanger Arbeit, aber lediglich mit einem Monitor erstellt. Ein Assembler hat jedoch den Vorteil, daß ein Einfügen von Programmschritten einfacher und schneller möglich ist. Auch hat man die Möglichkeit, schon während der Programmierung Kommentare einzufügen, so daß man auch nach längerer Zeit seinen Entwurf noch verstehen und nachvollziehen kann. Nun aber zu den einzelnen Assemblern.

## Mastercode

Mastercode ist ein kombinierter Editor/Assembler/Monitor und wird vom Verlag Markt & Technik AG vertrieben. Er ist auf Diskette und Kassette lieferbar.

## Editor

Eine Äußerlichkeit hebt Mastercode von allen anderen Assemblern ab: Alle Funktionen werden über Menüs und Untermenüs abgewickelt. Dies ist gerade für einen Anfänger sinnvoll, der sich nicht eine Unmenge von Befehlen merken möchte.

Im Editor stehen die Unterpunkte Eingabe, Auflisten, Löschen, Umnumerieren, Speichern und Laden zur Verfügung. Dieser Editor ist völlig eigenständig, das heißt vom Basic-Editor unabhängig. Er arbeitet allerdings streng zeilenorientiert, so daß jede eingegebene Zeile mit einer Nummer beginnen muß. Man kann nicht, wie beim Editieren von Basic-Programmen, mit dem Cursor rauf und runter fahren.

Es lassen sich schon existente Bytefolgen in den Quelltext übernehmen, sie werden dann mit einem Pseudo-Opcode für Tabellen versehen. Dies ist aber nur nützlich bei frei verschieblichen Programmteilen, oder eben Tabellen, weil sonst alle Adressen von Hand angepaßt werden müßten.

Interessant ist noch, daß beim Laden von Quelltexten immer ein MERGE durchgeführt wird. Dadurch lassen sich recht einfach zwei Quelltextdateien mischen.

Der nutzbare Speicher für den Quelltext ist enttäuschend knapp gehalten. Der maximale Speicherbereich für Quelltexte beträgt nämlich 15 KByte, das entspricht maximal 1000 Zeilen Assemblerquelltext, Kommentare nicht eingerechnet. Selbst diese Zahl ist bei der Verwendung von vielen Labeln nicht erreichbar. Das wäre ja alles nicht so schlimm, wenn es möglich wäre, Quelltextfiles miteinander zu verketten. Ein nur etwas längerer Quelltext muß dann jedoch in zwei Einzeltexte aufgeteilt werden, wobei im zweiten sämtliche benötigten Label noch einmal definiert werden müssen, da beide Teile nur unabhängig voneinander assembliert werden können.

Auch die geringe Verarbeitungsgeschwindigkeit macht die Arbeit nicht gerade zum Vergnügen.

### Assembler

Label dürfen bis zu sechs Zeichen lang sein und können auch, wenn man sie als Variable, das heißt als Zwischenspeicher benutzt, erst nach dem Gebrauch definiert werden. Es dürfen maximal 100 verschiedene Label im Quelltext auftreten.

Die Ausgabe der Symboltabelle, also die Auflistung sämtlicher verwendeter Label, kann nach Beendigung des Assemblierens erfolgen.

Mastercode unterstützt die Zahlensysteme binär, oktal, dezimal und hexadezimal sowie die Eingabe im ASCII-Code. Rechnungen dürfen im Quelltext in den vier Grundrechnungsarten durchgeführt werden. Tabellen lassen sich entweder ganz normal als Byte-für-Byte-Tabellen oder als Adreßtabellen aufbauen.

Es ist möglich, den Objectcode direkt in den Speicher oder auf ein Peripheriegerät (Kassette, Floppy) auszugeben oder den Quelltext einfach nur auf Fehler zu untersuchen. Auf dem Drucker erhält man im Anschluß an die Assemblierung ein sauber formatiertes Quelltext/ Objektcode-Listing.

Als letztes sei noch erwähnt, daß Kommentare nur für sich alleine in Quelltextzeilen stehen dürfen und nicht, wie sonst üblich, auch durch Semikolon getrennt hinter einem Assembler-Befehl.

### Monitor

Mastercode hält nur die Minimalfunktionen eines Monitors bereit. Dazu gehören das Disassemblieren, der Hexdump und das Verändern von Speicherbereichen, das Starten von Maschinenprogrammen, das Laden und Speichern von Objektcode sowie ein einfacher Einzelschrittbetrieb zum Austesten von Maschinenprogrammen.

Bei einem Hexdump macht es anfangs richtig Spaß, zuzusehen, wie die einzelnen Bytes schön nacheinander auf dem Schirm erscheinen und schon nach einigen Sekunden ein paar Zeilen auf dem Bildschirm stehen. Aber schon bald beginnt die extrem geringe Geschwindigkeit aller Monitorfunktionen zu stören, da man nicht jedesmal minutenlang auf ein Disassemblerlisting oder sonstiges warten möchte. Ein kurzer Blick mit Mastercode auf Mastercode bestätigte dann den Verdacht, daß man es hier mit compiliertem Basic zu tun hat, das es wohl kaum mit irgendeinem anderen Monitor, der in Maschinensprache geschrieben wurde, aufnehmen kann.

### Dokumentation

Als »Handbuch« erhält man knappe 50 Seiten im augenermüdenden Compactkassettenformat, was wohl von der ursprünglichen Vertriebsform auf Kassette herrührt. Inzwischen ist Mastercode aber auch auf Diskette erhältlich.

Dieses, aufgeklappt noch nicht einmal eine Postkarte bedeckende, Heftchen enthält aber, sauber gegliedert, alle Informationen, die zum Betrieb von Mastercode notwendig sind, diese allerdings etwas trocken und nicht gerade mit sinnvollen Beispielen aufgelockert. Im Anhang stehen Tabellen aller Opcodes des 6510 Mikroprozessors in alphabetischer wie numerischer Reihenfolge.

Als Fazit möchte ich ziehen, daß Mastercode sich wohl nur für diejenigen eignet, die kleine Aufgaben in Assembler lösen wollen und dabei nicht unter Zeitdruck stehen. Für einen Anfänger ist, wie schon erwähnt, die Menü-Struktur von Mastercode sehr nützlich.

## Profimat

Das Assemblerpaket Profimat von Data Becker enthält den Assembler Profiass und den Monitor Profimon. Beschäftigen wir uns zunächst mit Profiass.

### Assembler

Profiass-Quelltexte werden wie normale Basic-Programme eingegeben, können sogar in Basic-Programme eingebettet sein. Ein zusätzlicher Editor oder eine Befehlserweiterung zur leichteren Eingabe wird nicht mitgeliefert. Um gleich die Zusammenarbeit mit Basic-Programmen zu verdeutlichen: Direkt vor dem Quelltext muß Profiass mit SYS 32768 aufgerufen werden, ein Rücksprung ins Basic-Programm ist dann mit dem Pseudo-Opcode »GTB« möglich.

Label dürfen bei Profimat bis zu acht signifikante Zeichen haben. Berechnungen können in den drei üblichen Zahlensystemen (Hex., Dez., Bin.) vorgenommen werden. Hier sind die Grundrechenarten sowie logische Funktionen und Schiebeoperationen erlaubt. Man scheint allerdings das logische NOT vergessen zu haben, dafür ist XOR enthalten. Klammern dürfen beliebig gesetzt werden.

Eine interessante Eigenschaft von Profiass ist, erstellte Symboltabellen speichern und wieder laden zu können. Sollten Sie öfters Routinen aus dem Betriebssystem benötigen, brauchen Sie die entsprechenden Label nicht für jedes Programm neu zu definieren, sondern können sie in die Symboltabelle laden.

Ebenso interessant ist, daß mehrere Assemblerbefehle durch Doppelpunkt getrennt in einer Zeile stehen dürfen.

Zu den üblichen Pseudo-Opcodes für Tabellen tritt ».FLP« mit dem es möglich ist, Zahlen im Commodore-Fließkommaformat im Speicher abzulegen. Dies ist brauchbar, wenn man in Assembler Fließkommaroutinen schreiben möchte.

Quelltexte können miteinander verkettet werden, das heißt, ein Quelltext ruft den nächsten zu as-semblierenden auf. Somit lassen sich auch größere Programme as-semblieren, insbesondere, weil Profiass den Objektcode direkt zur Diskette schicken kann.

Auch der Ausdruck von Listings ist steuerbar und kann auf beliebige Peripheriegeräte gesandt werden. Diese Listings werden voll formatiert und sogar seitenweise mit Kopf-und Fußzeilen ausgedruckt.

### Makros

Profiass bietet auch Makros. Ein Makro ist eine meist kurze Befehlssequenz, die man nicht jedesmal neu eintippen möchte und deshalb mit einem eigenen Namen versieht, mit dem sie dann jederzeit aufgerufen werden kann. Im späteren Objektcode steht dann anstelle des Makroaufrufes jedesmal die vorher definierte Befehlssequenz. Es ist auch möglich, dieser Befehlssequenz von Mal zu Mal wechselnde Parameter zu übergeben.

Makros bei Profimat dürfen beliebig viele interne Label verwenden. Diese müssen aber durch einen Punkt gekennzeichnet werden, dann erhalten sie automatisch eine Ordnungsnummer, so daß ein mehrmaliges Aufrufen des Makros möglich ist, ohne ein Label zweimal zu definieren. Zwei verschiedene Makros müssen aber verschiedene interne Label benutzen.

Makros dürfen hier nicht verschachtelt werden, das heißt ein Makro darf kein anderes Makro aufrufen.

Alle Makrodefinitionen müssen am Anfang des ersten zu assemblierenden Programms stehen, wenn Quelltexte verkettet werden sollen. Damit wird das Aufbauen einer Makrobibliothek sehr erschwert.
Insgesamt sind gegenüber anderen, teureren Assemblern die Möglichkeiten der Makros eingeschränkt und wenig flexibel. Meiner Meinung nach hätte dieser Programmteil ruhig einer besseren Benutzerführung zum Opfer fallen können.
Monitor
Der Monitor Profimon enthält so ziemlich alle üblichen Befehle. Es können die Register sowie Speicherstellen in Hex-Dumps oder dis-assembliert angezeigt werden. Speicherbereiche können verschoben, mit anderen Bereichen verglichen oder mit bestimmten Werten gefüllt werden. Auch das Durchsuchen nach einer Bytefolge ist möglich, ebenso wie natürlich Laden und Speichern von Programmen. Zum Austesten von Programmen ist ein Breakpoint frei definierbar, bei dessen Erreichen in den vorhandenen Einzelschrittmodus umgeschaltet wird.
Mich stört allerdings, daß hier kein einfacher Assembler wie in anderen Monitoren vorhanden ist. Es ist eigentlich zu umständlich, für jede kleine Änderung im Programm den Quelltext erneut zu assemblie-ren, insbesondere, da Profimon ja eigentlich ein eigenständiges Programm sein soll. Eine Eigenschaft ist allerdings ungewöhnlich. Mit Profimon kann man auch auf das RAM unter dem Basic- und Kernal-ROM zugreifen oder das Charakter-ROM auslesen. Insgesamt gesehen, läßt es sich mit Profimon nicht anders als mit anderen handelsüblichen Monitoren arbeiten.
Dokumentation
Es befinden sich 34 Seiten Anleitung in einem DIN-A5-Ordner im typischen Data Becker-Design. Diese Anleitung hat aber einige Mängel. So wird man beispielsweise erst bei der Erklärung der Verkettung von Quelltexten mit der Tatsache überrumpelt, daß der Assembler mit SYS 32768 gestartet wird, was vorher nicht erwähnt wurde. Wer gezielt Informationen sucht, wird sie teilweise nicht finden, da sie manchmal in thematisch anderen Abschnitten versteckt sind. Das ist eigentlich schade, weil gerade auch der Profimat wohl die Erstkäufer eines Assemblers anspricht. Der Profimat ist nach Preis und Qualität für den Anfänger mit Aufstiegsambitionen geeignet. Für fortgeschrittene Programmierer bietet er allerdings zu wenig.

## Profisoft-Assembler

Profisoft vertreibt ein kleines Programmpaket zur Erstellung von Assemblerprogrammen, das im folgenden in Ermangelung eines klangvollen Namens mit Profisoft-Assembler bezeichnet wird. Dieses Programmpaket umfaßt neben einem Assembler auch einen Re-Assembler, einen Mini-Monitor sowie einen Editor und ist sowohl auf Kassette als auch Diskette erhältlich.

### Editor

Als Editor für den Quelltext wird der normale Basic-Editor verwendet. Um die Eingabe komfortabler zu gestalten, wurden einige Toolkitähnliche Funktionen in das Programm eingebaut. Diese stehen dann auch zum Schreiben und Editieren von Basic-Programmen zur Verfügung.

Insgesamt gibt es 16 neue Befehle, die alle mit einem »~« beginnen. Darunter befinden sich neben den Aufrufbefehlen für Assembler, Re-Assembler und Monitor, Befehle für automatische Zeilennumerierung und Zeilenumnumerierung (Renumber). Es ist ein Re-New vorhanden, das auch nach einem Reset wirksam ist und den Quelltext, sofern er nicht anderweitig zerstört wurde, wieder regeneriert. Dies ist besonders in der Testphase von Programmen nützlich, da man sich das ewige Abspeichern und Neuladen erspart.

Ein weiterer interessanter Befehl ist »-F«, mit dem man nicht nur Zeichenketten im Quelltext finden, sondern auch durch andere ersetzen kann. Ebenso ist das SAVEn bestimmter Speicherbereiche möglich, wie auch die Ausgabe der genauen Speicherbelegung der Quelltexte und Tabellen. Alles in allem ist das Erstellen von Quelltext sehr komfortabel und dürfte wohl auch höheren Ansprüchen genügen.

### Assembler

Doch nun zum Assembler selbst. Hier darf ein Label aus maximal acht Zeichen bestehen, dabei sollten allerdings keine Leer- und Sonderzeichen verwendet werden. Tabellen werden mit drei Pseudo-Opcodes unterstützt, einer für Einzelbytes, einer für Texte und einer für Ädressen. Während des zweiten Durchlaufs kann ein Listing wahlweise auf Bildschirm oder Drucker (nach OPEN) ausgegeben werden. Dieses Listing wird allerdings nicht formatiert, das heißt Labels und Kommentare stehen nicht geordnet untereinander. Dies läßt sich nur durch entsprechende Eingabe des Quelltextes erreichen. Einzelne Quelltextfiles auf Diskette/Kassette können beliebig aneinandergehängt beziehungsweise nachgeladen werden.

### Re-Assembler

Ein sehr nützlicher Programmteil ist der eingebaute Re-Assembler. Dieser wird in der Anleitung fälschlicherweise als Disassembler bezeichnet. Im Gegensatz zu einem Disassembler, der Maschinenprogramme auf dem Bildschirm anzeigt oder auf dem Drucker ausgibt, erzeugt ein Re-Assembler wieder Quelltext, der dann nach Änderungen erneut assembliert werden kann. Der Vorteil liegt auf der Hand. Wenn Sie nachträglich in ein Programm etwas einfügen oder es umschreiben wollen, aber den Quelltext nicht besitzen, so können Sie sich diesen einfach regenerieren. Natürlich ist dieser Quelltext nicht gleich dem Original, denn woher sollte der Re-Assembler beispielsweise die Namen der einzelnen Labels kennen?

Bei einem vom Profisoft-Re-Assembler erzeugten Quelltext werden alle Speicherzugriffe und Sprünge über Labels abgewickelt. Um die Labels eindeutig zu halten, sehen sie folgendermaßen aus: Der erste Buchstabe ist ein L, gefolgt von der hexadezimalen Adresse des tatsächlichen Speicherplatzes, zum Beispiel LFFD2. Sollte der Re-Assembler auf einen undefinierten Opcode stoßen, so behandelt er ihn als Mini-Tabelle, bestehend aus einem Byte mit dem entsprechenden Pseudo-Opcode. In einem Durchlauf können maximal 4 bis 6 KByte re-assembliert werden; er dauert zirka 30 Sekunden.

### Der Mini-Monitor

Nun noch einige Worte zum Mini-Monitor. Mit ihm lassen sich Speicherbereiche hexadezimal anzeigen, verändern und verschieben. Damit sind seine Möglichkeiten schon ausgeschöpft. Er ist allerdings insbesondere für das Verschieben des erzeugten Object-Codes notwendig, wenn der Quelltext an eine andere Stelle als der späteren tatsächlichen Startadresse assembliert wurde.

### Dokumentation

Ein Programm, das gerade wegen seines Preises und seiner angepaßten Leistungen für Anfänger und leicht Fortgeschrittene geeignet ist, benötigt natürlich auch eine gute Anleitung. Die vorliegende ist mit 16 Seiten DIN A5 etwas knapp. Sie setzt schon Kenntnisse der Maschinensprache und des Computers voraus. Es werden alle Funktionen hinreichend genau erklärt. Leider sind nur sehr wenige Beispiele abgedruckt. Ist man allerdings erst einmal mit dem Programm vertraut, wird man die Anleitung gerne weiterhin als schnelles Nachschlagewerk benutzen.

Insgesamt hat das Programm einen sehr guten Eindruck hinterlassen. Seine Bedienung ist einfach und doch komfortabel. Auch bei Fehlern stürzt der Profisoft-Assembler nicht ab (ein Totalabsturz ist nur bei mutwilligem Überschreiben des Assemblers selbst möglich). Mit dem Re-Assembler können auch fremde Programme leicht verändert werden. Das fordert direkt zum Experimentieren heraus. Ein kleiner Schwachpunkt ist lediglich der Monitor.

## Maschine 64

Der letzte hier vorgestellte Assembler heißt Maschine 64 und wird von Dynamics vertrieben. Auch Maschine 64 erfüllt eine Vielzahl von Funktionen, es ist Assembler, Re-Assembler, Toolkit, DOS-Support, Monitor und Disk-Monitor in einem, und das bei nur 16 KByte Speicher-Verbrauch.

### Editor

Genauso wie beim Profisoft-Assembler werden Quelltexte wie Basic-Programme eingegeben. Die Eingabe des Quelltextes wird hier von einem Toolkit unterstützt. Vorhanden sind hier die Befehle AUTO, APPEND, DELETE, FIND, RENUMBER. Zusätzlich gibt es dann noch die Befehle ASSEMBLER, REASSEMBLE, MONITOR, DISKMONITOR und BYE, welche die anderen Teile des Systems aufrufen, beziehungsweise Maschine 64 abschalten.

Alle diese Befehle sind auch zum Editieren ganz normaler Basic-Programme geeignet. Zusätzlich ist im Editor, wie auch in allen anderen Programmteilen, eine Diskettenunterstützung, ähnlich dem DOS 5.1, eingebaut.

### Assembler

Über den Assembler selbst läßt sich folgendes sagen: Label dürfen beliebig lang sein, es werden allerdings nur die ersten 20 Zeichen unterschieden.

Sehr komfortabel ist das Anlegen von Texttabellen. Diese können nicht nur im ASCII-Code, wie üblich, sondern auch im Bildschirmcode und im invertierten Bildschirmcode angegeben werden. Dies ist sehr nützlich, wenn man Texte direkt in den Bildschirmspeicher schreiben und nicht über die Betriebssystemroutine »Zeichen ausgeben« arbeiten will.

Maschine 64 erlaubt auch Berechnungen im Quelltext. Diese sind allerdings auf Addition und Subtraktion sowie LO-Byte und HI-Byte-Isolierungen beschränkt. Es dürfen maximal acht Klammern gesetzt werden. Das Assemblerlisting am Ende des zweiten Pass wird teilweise formatiert und kann, ebenso wie die Symboltabelle, auch auf einem Drucker ausgegeben werden.

### Re-Assembler

Der Re-Assembler läßt kaum Wünsche offen. Er erzeugt aus Objektcode wieder Quelltext. Auch hier werden, soweit wie möglich, Sprünge und Speicherzugriffe über Label abgewickelt. Besonders komfortabel sind allerdings drei Punkte: Dem Re-Assembler kann vor dem Start mitgeteilt werden, wo Tabellen und wo tatsächliches Programm im Speicher stehen, so daß Tabellen und Programm in einem Arbeitsgang in Quelltext umgewandelt werden können. Sollte der Re-Assembler auf einen nicht als Programm identifizierbaren Bytewert treffen, wird aus ihm eine Ein-Byte-Mini-Tabelle mit angehängtem ERROR. Solche Zeilen können dann sehr schnell mit dem FIND-Befehl ausfindig gemacht werden. Als letztes ist es auch möglich, einen bestimmten Speicherbereich so zu re-assemblieren, als ob er in einem anderen Bereich stehen würde.

### Monitor

Besitzern des PET, dem Großvater der Home- und Personal Computer, wird der eingebaute Monitor unter dem Namen SUMO bekannt sein. Er kann Speicherbereiche anzeigen und ändern sowie durchsuchen, verschieben, vergleichen, füllen, laden und speichern. Ein Disassembler ist ebenso vorhanden wie auch ein einfacher Lme-by-Line-Assem-bler, der sich gerade bei kleinen Änderungen an einem Programm bezahlt macht. Auch sind Umrechnungen Dez-Hex und umgekehrt möglich. Leider fehlt hier ein Einzel-schrittmodus, mit dem man Maschinenprogramme Schritt für Schritt auf Funktionstüchtigkeit testen kann.

### Disk-Monitor

Kurz angesprochen werden soll auch noch der Disk-Monitor. Beliebige Blöcke der Diskette können in den C 64-Speicher geholt und angezeigt, verändert und wieder zurückgeschrieben werden. Dabei ist es dann auch möglich, innerhalbeines Blocks Bytefolgen zu suchen oder zu verschieben oder gar den Block zu disassemblieren. Auch hier funktioniert dann der Line-by-Line-Assembler. Leider fehlen Befehle, mit denen man blockübergreifend arbeiten könnte, so daß man immer auf einen einzelnen Block bei der Arbeit fixiert ist.

### Dokumentation

Die knapp 30 Seiten Anleitung im DIN-A5-Format machen im ersten Augenblick einen recht guten Eindruck, doch werden hier einige nützliche Details der einzelnen Programme verschwiegen, die man erst beim Probieren durch Zufall herausfindet. Ansonsten ist der Text sehr locker und leicht zu lesen. Leider sind aber auch hier die Beispiele sehr knapp gehalten. Ein Fehler im Handbuch soll nicht unerwähnt bleiben. Entgegen der Aussage, daß sich das Programm selbst starte, mußte RUN eingegeben werden. Das kann einen beim ersten Kontakt mit Maschine 64 doch leicht in Verwirrung bringen.

Insgesamt gesehen ist auch Maschine 64 ein sehr brauchbares, sicheres und bedienerfreundliches Programm. Gerade seine vielen kleinen Details und Zusatzfunktionen erleichtern die Arbeit ganz erheblich. Mit Maschine 64 wird man auch als fortgeschrittener Programmierer nicht so schnell den Wunsch nach einem anderen Assembler verspüren. (B. Schneider/gk)

### Fazit

Die vier hier vorgestellten Assembler bieten alle eine dem Preis entsprechende Leistung. Man sollte sich jedoch vor einem Kauf genau überlegen, wie weit man in die Maschinensprache einsteigen will. Zum »Reinschnuppern« in die Assemblerprogrammierung genügen diese Programme allemal.

Mastercode Assembler: Markt & Technik, Hans-Pinsel-Str. 2, 8013 Haar bei München, Preis: Kassette 48 Mark, Diskette 63 Mark
Profimat: Data Becker, MerowingerStr. 30, 4000 Düsseldorf, Preis: Diskette 99 Mark
Profisoft-Assembler: Profisoft, SutthauserStr. 50-52,4500 0s-nabrück, Preis: Kass/Disk. 75 Mark
Maschine 64: Dynamics, Postfach 112005, 2000 Hamburg 11, Preis: Diskette 79 Mark

# Basic-Programm auf Trab gebracht – Compiler im Test

> Haben Sie schon einmal daran gedacht, sich eventuell einen Compiler zuzulegen, um Basic-Program-me schneller zu machen? Sie wissen aber vielleicht noch zuwenig über Compiler, um sich den richtigen auszusuchen. Wir stellen Ihnen deshalb vier Typen vor.

Wir haben vier der bekanntesten Compiler getestet: Pet-speed, Austro-Speed, BASS-und Ex-Basic Level II-Compiler. Bevor wir uns jedoch mit den »Prüflingen« genauer beschäftigen, wollen wir erst ein wenig auf die praktischen Grundlagen der Compiler eingehen.

Wenn man Compiler hört, denkt man unwillkürlich immer zuerst an den Geschwindigkeitsgewinn, den diese Programme bringen sollen. In der Tat ist der Hauptzweck von Compilern in der zeitlichen Optimierung eines Programmlaufs zu sehen, damit die Ausführungszeit verkürzt wird. So gibt es demnach viele Compiler, deren Hauptkonzept in der Geschwindigkeitserhöhung liegt.

Uber diese Tatsachen darf man aber auch andere Eigenschaften von Compilern nicht vergessen. Compiler erhöhen zwar in der Regel die Geschwindigkeit der Basic-Pro-gramme, sie vertragen aber unter Umständen gewisse syntaktische Konstruktionen nicht, die beim Interpreter ohne weiteres funktionieren. Außerdem werden kleinere Programme in der Regel durch das Compilieren um einiges länger als sie ursprünglich waren.

Da wir gerade bei der Programmlänge sind, soll an dieser Stelle auch gleich auf die zwei verschiedenen Arten von Compilern eingegangen werden. Die erste Art ist der Assemblercode-Compiler, der echten Maschinencode erzeugt und damit maximalen Geschwindigkeitsgewinn bringt. Der Nachteil dieser Methode ist, daß das compilierte Programm (Compilat) in der Regel um einiges länger wird als das ursprüngliche Basic-Programm.

Bei der zweiten Art von Compilern (sogenannte Adreßcode-Compilern) geht man deshalb einen anderen Weg. Hier wird der Basic-Text in eine Liste von Sprungadressen umgewandelt, was Speicherplatz spart, aber andererseits wieder auf Kosten der Geschwindigkeit geht.

Wie Sie sehen, gibt es den perfekten Compiler nicht. Entweder ist ein Programm sehr schnell, dann ist es länger, oder ein Programm ist nicht ganz so schnell, dafür wird es kürzer. Einen guten Compiler erkennt man also am richtigen Kompromiß zwischen Geschwindigkeit und Länge des Compilats. Ein weiteres Qualitätsmerkmal für Compiler ist die Dauer des Compilierens. Dieser Vorgang ist zwar in der Regel einmalig, da man nur ein wirklich fertiges Programm compilieren wird, er sollte sich dennoch in vernünftigen Grenzen bewegen.

Wenn wir uns jetzt gleich einmal mit den speziellen Eigenschaften der Testkandidaten vertraut machen, sollten Sie immer an diese Merkmale denken. Das interessante an den getesteten Compilern ist nämlich, daß sie fast alle nach unterschiedlichen Kriterien entwickelt wurden.

## Der Austro-Speed-Compiler

Der erste Compiler, mit dem wir uns beschäftigen wollen, ist der Austro-Speed von Commodore. Austro-Speed ist eine verbesserte Version des Austro-Comp für die CBM-Systeme. Im Lieferumfang sind eine Diskette mit dem Programm, ein Handbuch mittleren Umfangs und ein Dongle enthalten. Ein Dongle ist ein programmschutztechnischer Hardwarezusatz, dessen Vorhandensein abgefragt wird und ohne das der Compiler nicht läuft, (in diesem Fall ein Stecker für den User-Port). Als ich mir das Inhaltsverzeichnis der Diskette anse-hen wollte, erlebte ich sofort eine Überraschung. Der ganze Compiler besteht aus einem einzigen Programm mit einer Länge von 63 Blöcken (15,75 KByte).

Als Testprogramm für den Compi-liervorgang diente der Disk-Monitor EDDI aus der 64'er, Ausgabe 10/1984. Dieses Programm hat den Vorteil, daß es nicht zu kurz ist. Außerdem ist der Programmierstil an vielen Stellen alles andere als sauber. Haben Sie übrigens bemerkt, daß sich bei EDDI ein Fehler eingeschlichen hat? In der Zeile 1070 ist die IF-Abfrage überflüssig und zeigt außerdem auf eine nicht vorhandene Zeile (1090). Diese Abfrage stört den Programmablauf nicht im geringsten, wir können jedoch gespannt auf die Reaktionen der Compiler sein, wenn sie diese Zeile abarbeiten. Jetzt aber wieder zurück zu Austro-Speed.

Bevor man den Compiler in den Computer lädt, muß man darauf achten, daß das Dongle auf den User-Port des C 64 gesteckt ist. Für den Vorgang des Compilierens ist es in der Regel notwendig, daß viel Platz auf der Diskette mit dem Basic-Programm vorhanden ist, da die Compiler eine Menge Dateien erstellen, die jedoch nach dem Compilieren normalerweise wieder gelöscht werden. Das ist besonders bei langen Programmen zu beachten.

Nachdem wir auch diese letzte Vorbereitung ausgeführt haben, starten wir den Compiler. EDDI besteht aus 14 Blöcken auf Diskette. Nach genau drei Minuten ist Austro-Speed mit der Arbeit fertig, und das Compilat steht zur Verfügung.

Während des Compilierens hat Austro-Speed sogar den Programmfehler entdeckt und angezeigt, jedoch seine Arbeit nicht unterbrochen.

Wenn wir uns die Diskette betrachten, so sehen wir, daß unser Programm an Länge ganz erheblich zugenommen hat. Es besteht jetzt aus 32 Blöcken und ist damit mehr als doppelt so lang geworden.

Zur Erleichterung einer eventuell noch folgenden Korrektur bei einem Fehler, legt Austro-Speed noch ein weiteres File ab, das die neuen Speicheradressen sämtlicher Programmzeilen enthält.

Da ein Compiler ein Basic-Pro-gramm nicht auf einmal übersetzt, sondern dafür mehrere Durchläufe benötigt, kann man auch anhand der Anzahl dieser Durchläufe (Durchlauf = Pass) einen Compiler charakterisieren. Austro-Speed benötigt für seine Arbeit zwei dieser Durchläufe; man bezeichnet ihn deshalb auch als 2-Pass-Compiler.

Unser nächstes Programm heißt BASS und kommt von gmbsoft. Der Unterschied zu Austro-Speed wird sofort deutlich, wenn man sich den Lieferumfang betrachtet. Er besteht aus drei Disketten und zwei dicken Handbüchern. Bei einer der Disketten handelt es sich um eine Demodiskette, die unter anderem ein Sortierprogramm enthält, um die Geschwindigkeit eines Compilats zu demonstrieren.

## Der BASS-Compiler

Wie bei Austro-Speed habe ich auch hier erst einmal das Directory gelistet. Hat man die Länge der Austro-Speed noch vor Augen, so trifft einen hier fast der Schlag. Bei BASS handelt es sich um den reinsten »Mammutcompiler«. Er arbeitet zwar auch nur mit zwei Durchläufen, jedoch besteht hier allein schon der Pass 1 aus einem über 100 Blöcken langen Programm, der von Pass 2 noch übertroffen wird.

Da es bei einer solchen Komplexität kaum möglich ist, einfach »drauflos« zu arbeiten, sollte man sich erst einmal eines der beiden Handbücher vornehmen (das dünnere, versteht sich). Und hier erlebt man auch gleich die erste Überraschung. Der Compiler erzeugt bei seiner Arbeit kein lauffähiges Programm, sondern nur eine stattliche Anzahl von Dateien (insgesamt 10), die editierfähig sind und noch einen Assemblierlauf benötigen, bevor ein fertiges Programm daraus entsteht.

Diese Konzipierung hat aber natürlich einen Sinn. Bei gmbsoft hat man versucht, einen Compiler herzustellen, der so offen wie möglich arbeitet; das heißt der Programmierer soll auch nach dem Compilieren noch die Möglichkeit haben, optimierende Eingriffe und Änderungen an seinem Programm vorzunehmen. Zu diesem Zweck eignet sich ein editierfähiger Code natürlich eher, als der »Spaghetticode« in einem fertig compilierten Programm.

Durch diese sehr positive Eigenschaft des Programms angeregt, geht man erneut an die Arbeit, aber — wo ist der Assembler?

Es stellt sich heraus, daß der Assembler nicht im Lieferumfang des BASS enthalten ist; er muß extra besorgt werden. Wie im Handbuch empfohlen, beschafft man sich also das Assemblerpaket ASSI von Dirk Zabel (siehe Assembler-Test in Ausgabe 1/85), um endlich ein fertiges Compilat zu erhalten.

Den gewohnten Richtlinien folgend kopiert man das Testprogramm EDDI auf eine leere Diskette. Aber es müssen noch einige Handgriffe ausgeführt werden, bis das Programm endlich fertig compi-liert sein wird. Zuerst muß noch eine Bibliothek auf die Programmdiskette kopiert werden, die der Assembler benötigt, und dann kann es endlich losgehen. Da BASS, wie schon erwähnt, ziemliche Ausmaße besitzt, lag es natürlich nahe, einmal Hypra-Load heranzuziehen, und siehe da — BASS arbeitet mit Hypra-Load einwandfrei zusammen, was die Compilierzeit insgesamt erheblich verkürzt.

Trotz aller dieser »Vorabhandgriffe« entpuppt sich der BASS als Langweiler. Für das reine Compilieren von EDDI benötigte er 7,10 Minuten. Das nachfolgende Assemblieren benötigt noch einmal neun Minuten, so daß man insgesamt mindestens eine halbe Stunde beschäftigt ist (alles eingerechnet).

EDDI wird von BASS einwandfrei verarbeitet; der Fehler in Zeile 1070 wurde jedoch während der Compilation nicht entdeckt. Er wurde erst vom Assembler registriert und äußerte sich in einem »UNDEFINED SYMBOL ERROR«. Auch in diesem Fall wurde die Arbeit jedoch ordnungsgemäß zu Ende geführt.

## Der Exbasic Level II-Compiler

Der Exbasic Level II-Compiler von Interface Age machte bei Erhalt der Lieferung wieder einen ganz anderen Eindruck als der BASS. Diese beiden Compiler sind dabei fast identisch. Was den Namen dieses Compilers betrifft, so erscheint er vielleicht etwas irreführend. Der Exbasic Level II-Compiler hat mit Exbasic Level II ebensoviel oder ebensowenigzu tun, wie fast alle anderen Compiler dieses Tests auch.

Der Name soll eine Eigenschaft dieses Compilers verdeutlichen, die Austro-Speed und BASS jedoch ebenso besitzen: die Verarbeitung von Erweiterungen (sogenannte Extensions).

Das heißt nichts weiter, als daß diese Programme in der Lage sind, auch Befehle, die im Standard-Basic V 2.0von Commodore nicht vorkommen, zu verarbeiten. Wenn diese Compiler zum Beispiel auf einen Befehl des Exbasic Level II stoßen, so wird dieser Befehl nicht compiliert, sondern im non-compiled-Code angelegt. Wird ein so compiliertes Programm jetzt zum Beispiel unter Exbasic gestartet, so übergibt das Steuerprogramm, das jedes Compilat enthält, den entsprechenden Befehl einfach dem Interpreter zur Ausführung und macht anschließend weiter.

Der Unterschied zwischen dem Exbasic Level II-Compiler und BASS besteht lediglich in der Dicke des Handbuchs, im Preis und in der Tatsache, daß der Exbasic-Compiler um den notwendigen Assembler erweitert wurde. Auf der Diskette erkennt man das an Pass 3 und Pass 4, die der BASS nicht besitzt.

Im Test zeigte der Exbasic-Com-piler demzufolge auch die gleichen Eigenschaften wie der BASS, auf die ich gleich noch zu sprechen komme.

Das Compilieren und Assemblieren wird vom Exbasic Level II-Compiler um einiges schneller erledigt, als von BASS. Außerdem spart man sich das Kopieren der Bibliothek. Für EDDI wurde eine Zeit von 12 Minuten gemessen, was jedoch immer noch viermal so lang ist, wie beim Austro-Speed. Durch das jeweilige Nachladen der einzelnen Programmteile ergibt sich außerdem noch zusätzlich ein viermaliger Diskettenwechsel.

Da der BASS- und Exbasic Level II-Compiler nahezu identisch sind, soll auch gleich einmal auf die negativen Seiten der beiden Programme eingegangen werden.

Wie Sie vielleicht wissen, kann man im Commodore-Basic sowohl mit Fließkomma- als auch mit Integerwerten rechnen. Der Unterschied zeigt sich in den Variablen-namen, wobei die Integervariablen durch ein »%« am Ende gekennzeichnet sind. Die Integerarithmetik läßt nur Zahlenbereiche von —32 768 bis 32 767 zu; hat aber dadurch den Vorteil, daß weniger Speicherplatz und geringerer Zeitaufwand beim Rechnen mit diesen Werten erforderlich ist. Im Gegensatz zu Fließkommawerten benötigen Integerzahlen normalerweise nur 2 Byte Speicherplatz pro Wert; das sind 3 Byte weniger als bei Fließkommaberechnungen.

Das Commodore-Basic hat jetzt den Nachteil, daß keine Integerroutinen existieren, die die Berechnungen durchführen. Alle Zahlen werden deshalb zuerst ins Fließkommaformat umgewandelt und dann verrechnet. Anschließend konvertiert der Interpreter diese Werte wieder zurück.

Alle Vorteile, die die Integerzahlen also haben, werden durch den Interpreter zunichte gemacht. Die Entwickler von Compilern haben dieses Manko sehr wohl erkannt, und deshalb sind alle getesteten Produkte auch mit eigenen Integerroutinen ausgestattet, die einen enormen Zeitgewinn versprechen. Es ist somit möglich, auch beim Interpreter verbotene Konstruktionen, wie eine Integerschleife, zu verwenden. FOR X% = 0 TO 1000 : NEXT X% ist zum Beispiel beim Interpreter nicht gestattet und wird mit einem »SYNTAX ERROR« quittiert.

Oben wurde schon auf Nachteile vom BASS- und Exbasic Level II-Compiler hingewiesen. Bei diesen beiden Produkten gibt es eine solche Konstruktion ebenfalls nicht. Hier muß man alle Variablen, die man als Integer verwenden möchte, mit direkten Befehlen an den Compiler als solche vordefinieren.

Als weiterer Minuspunkt zeigte sich bei diesen beiden Produkten die »Intoleranz« gegenüber der Syntax von Programmen.

Bei Basic-Programmen ist es üblich, eine Dimensionierung von Variablen, sofern das Feld nicht mehr als elf Elemente benötigt, zu unterlassen. Der Interpreter übernimmt diese Dimensionierung automatisch. Bei besagten beiden Compilern ist dies jedoch nicht der Fall und führt während des Compilierens zu einer Fehlermeldung in Form einer Nummer. Da diese beiden Compiler jedoch mit einer Fülle an Fehlermeldungen ausgestattet sind, erwies es sich bei dem Exbasic-Compiler als äußerst nachteilig, daß er keinen Fehlertext, sondern nur die Nummer der Meldung ausgibt. Wie es sich zeigte, enthält das Handbuch zwar eine Aufstellung aller Fehlermeldungen; diese aber wiederum ohne Nummer (im Gegensatz zum BASS), so daß man spekulativ schon sehr auf Zack sein muß, um zu erfahren, was für ein Fehler denn nun beanstandet wurde.

Auch das oft übliche Belegen einer Zeile mit einem Doppelpunkt »:«, um ein Programm lesbarer zu gestalten, wurde nicht toleriert und führte zu einer Fehlermeldung.

Insgesamt also eine Reihe von Nachteilen, die einem die Arbeit mit einem Compiler sicherlich schwerer machen, zumal wir an den anderen Testkandidaten feststellen konnten, daß es auch anders geht. Austro-Speed ist syntaktisch sehr großzügig. Das einzige, was er und Petspeed nicht vertragen, sind verschachtelte MID$-Statements, die man aber generell bei der Arbeit mit Compilern vermeiden sollte.

Was angenehm überrascht, ist die Tatsache, daß Austro-Speed sogar die variable Dimensionierung (zum Beispiel DIM A (B), zuläßt. Eine eigentlich gar nicht selbstverständliche Eigenschaft, da Compiler auf das feste Anlegen von Variablenfel-dern angewiesen sind und somit deren Ausmaße beim Compilieren feststehen müssen.

Doch nun zum Petspeed, dessen Lieferumfang aus drei Blättern Druckerpapier und einer Diskette bestand. Das »3-Blatt-Handbuch« strotzt nur so von Fehlern und macht einen gleich einmal auf eine nette Überraschung gefaßt. Das Directory der beigefügten Diskette ist nur über Spezialprogramme zu listen. Dieser (unnötige) »Scherz« hätte unter normalen Umständen sicher nichts ausgemacht. Das Sonderbare an Petspeed ist nur, daß man sein Basic-Programm auf die Systemdiskette kopieren muß, damit der Compiler arbeiten kann. Aus diesem Grund hat mich dieser »Gag« ziemlich verärgert, da er die Möglichkeit eines Bedienungsfehlers geradezu herausfordert.

Hat man auch hier EDDI in die compilierfähige Form gebracht, so kann es losgehen. Der Petspeed ist ein 4-Pass-Compiler, was schon einmal gewisse Erwartungen bezüglich der Leistung weckt.

Nach 7 ½ Minuten ist die Arbeit an EDDI abgeschlossen, und wir erhalten, wie schon bei Austro-Speed, zwei Programm-Files zurück. Eines der beiden Programme ist dabei wieder eine Korrekturerleichterung, die alle vorhandenen Zeilennummern mit deren neuen Adressen enthält.

## Der Petspeed-Compiler

Petspeed ist also beim Compilieren hinter Austro-Speed der zweitschnellste Compiler dieses Tests. Der einzige Nachteil besteht in der Tatsache, daß das zu compilierende Programm auf die Systemdiskette kopiert werden muß. Erstens ist damit die Wahrscheinlichkeit einer Panne mit der Originaldiskette größer, und zweitens wird der Platz zum Compilieren ganz erheblich eingeschränkt, da Petspeed schon über 200 Blöcke für sich beansprucht. So darf das zu übersetzende Basic-Programm auch nicht länger als 80 Blocks sein.

Sieht man sich die Gesamtlänge der vier Compilate aller Compiler an, so erkennt man, daß sich BÄSS-, Exbasic Level II-Compiler und Austro-Speed in etwa entsprechen. Petspeed hat mit Abstand das längste File hinterlassen, was sich auch bei der weiteren Arbeit mit diesem Compiler immer wieder zeigen wird.

Sie werden jetzt natürlich gespannt auf die Ergebnisse des Com-pilierens sein. Was ist eigentlich aus dem einstmals so langsamen Basic-Programm geworden?

Nun, ich will Sie nicht länger auf die Folter spannen. Allerdings habe ich zum Zeitvergleich nicht EDDI herangezogen, obwohl sich das Ergebnis (bei rückblickender Betrachtung) nicht verändert hätte. Es wurde ein Programm erstellt, in dem systematisch ein paar Befehlsgruppen abgefragt wurden, um die Geschwindigkeit in' verschiedenen Bereichen vergleichen zu können.

Das Ergebnis der Messungen sehen Sie in der Zusammenfassung in Tabelle 1 und 2. Es zeigt sich ganz deutlich, daß Petspeed (obwohl der »Oldtimer« dieses Tests) der eigentliche Testsieger ist. Er hat in fast allen Bereichen die Nase vorne und erreicht Geschwindigkeiten, von denen seine Konkurrenten nur träumen können.

Unser Testprogramm absolvierte er beispielsweise in 145 Sekunden. Das Original unter dem Interpreter benötigt noch 391 Sekunden. Mit großem Abstand folgt dann erst einmal das Compilat von Austro-Speed. Es erreicht immerhin eine Zeit von 173 Sekunden und ist damit um fast 20 Prozent langsamer als Petspeed.

Enttäuscht hat in diesem Test der Exbasic Level II-Compiler. Einmal davon abgesehen, daß er schon eine Reihe anderer Schwächen aufzuweisen hatte, bildete er noch zusätzlich in diesem Geschwindigkeitstest das Schlußlicht mit einer Zeit von 198 Sekunden.

Der BASS-Compiler ist zwar genauso schnell oder langsam wie der Exbasic-Compiler (198 Sekunden), er hat aber immer noch den Vorteil seines positiven Konzepts, des bedienerfreundlichen Compilats, was zumindest Maschinensprach-Spe-zialisten zu schätzen wissen dürften.

BASS überholt Austro-Speed lediglich bei der Übersetzung von PO-KEs und PEEKs. Dieser Unterschied ist jedoch sehr gering und kann an dem Gesamtergebnis nichts ändern.

## Fazit

Fangen wir mit dem Exbasic Level II-Compiler an. Dieses Produkt konnte in wesentlichen Punkten nicht überzeugen. Einige dieser Gründe sind mit Sicherheit darin zu sehen, daß dieser Compiler nur die um einen Assembler erweiterte Version des BASS ist, wobei jedoch die relativ schwache Leistung des BASS noch durch die verlorengegangenen positiven Eigenschaften dieses Programms verstärkt wurde. Der BASS ist zwar langsam, aber sein Vorteil liegt im offenen Konzept des erzeugten Codes. Damit hat der Benutzer die Möglichkeit,, auch beim Compilat noch leicht Anderungen vorzunehmen. Zu diesem Zweck ist BASS sehr umfassend dokumentiert, im Gegensatz zum Exbasic Level II-Compiler.

Die Nachteile beider Compiler waren aber die »pingeligen« Ansprüche an die Syntax des zu compi-lierenden Programms. Ein Anwender, der mit Compilern arbeitet, möchte in der Regel ein älteres Programm ohne große Änderungen am Original schnell compilieren können. Das ist aber ohne große Änderungen bei diesen beiden Compilern fast nicht möglich.

Als Kaufempfehlung kann hier also höchstens BASS gelten (198 Mark). Dieser Compiler ist jedoch nichts für Anfänger und für Änwen-der, die sich einen Compiler nur zum bequemen »Hochpuschen« von Basic-Programmen zulegen. Der Exbasic Level II-Compiler ist allein schon seines hohen Preises wegen (298 Mark) gemessen an den Leistungen, nicht ohne Vorbehalt zu empfehlen. Er besitzt keine herausragenden Vorzüge und könnte bei weniger erfahrenen Programmierern schnell ein falsches Bild von Compilern hervorrufen.

Das Nachladen von Programmen, sogenanntes Overlay, machte bei allen Compilern dieses Tests (infolge der Variablenorganisation) Schwierigkeiten. Das im Interpretermodus mögliche Nachladen von Programmen mit Variablenübergabe (Warm-Overlay) ist in der Regel mit den Compilern nicht möglich. Hier muß man normalerweise eine Speicherstelle als Flag (beim Nachladen mehrere Programme) benutzen, da die Variablen durch das Nachladen gelöscht werden (Kalt-Overlay).

Am großzügigsten bei der Änaly-se von Programmen zeigte sich der Austro-Speed. Er war beim Compilieren mit Abstand der Schnellste. Die Endgeschwindigkeit des Compilats ist zwar nicht mit der des Petspeed vergleichbar; es zeigt sich jedoch deutlich, daß dieser Compiler die wenigsten Probleme aufwirft, zumal seine Bedienung ein wahres Kinderspiel ist. Er »verdaut« die meisten Programme ohne Schwierigkeiten und zeigt sich auch in der Anwendung sehr vielseitig, da er sowohl mit einem, als auch mit mehreren Floppy-Laufwerken zusammenarbeitet. Der Preis vom Austro-Speed ist mit dem von Exbasic Level II-Compiler identisch (298 Mark); hätte man also die Wahl zwischen beiden, so dürfte die Entscheidung nicht allzu schwer fallen.

Sehr viel fürs Geld bekommt man mit Petspeed ins Haus geschickt (149 Mark). Dieser Compiler übertraf alle Erwartungen und zeigte sich auch in der Bedienung recht einfach. Die zwei negativen Aspekte dürften hier wohl die unzureichende Literatur und das notwendige Kopieren des Basic-Programms auf die Systemdiskette sein. Wenn man aber einmal die 149 Mark sieht, die der Petspeed kostet, so zeigt sich dennoch ein hervorragendes Preis/Leistungsver-hältnis, das von keinem Compiler des Tests erreicht wurde. In den Tabellen finden Sie zur besseren Orientierung noch einmal alle Test-Ergebnisse zusammengefaßt.

(Karsten Schramm/gk)

Bezugsadressen und Info:
BASS: gmbsoft, Kaiser-Friedrich Ring 55, 6200 Wiesbaden
Austro-Speed (Austro-Comp): Commodore, Lyoner Str. 38, 6000 Frankfurt/Main und für Österreich: Digimat, Arbeitergasse 48, 1050 Wien
Ex-Basic-Compiler II: Interface Age, Vohburger Str. 1, 8000 München 21
Petspeed: Infotronik, Birkenstr. 40, 4100 Duisburg

Geschwindigkeit durch Maschinencode – so arbeiten Compiler

> Programme komfortabel in Basic schreiben, aber mit der Geschwindigkeit von Maschinensprache ausführen lassen — Compiler machen’s möglich.

Es ist schon erstaunlich. Da gibt es Programme, die andere Programme als Eingabedaten verwenden und diese in reinen Maschi-.nencode übersetzen, der von der CPU direkt ausgeführt werden kann. Das ist durchaus von Vorteil:
Basic-Programme sind nämlich einfach zu schreiben, aber langsam in der Ausführung. Maschinensprache ist dagegen sehr schnell, aber schwierig zu programmieren. Compiler bilden praktisch die Brücke zwischen den beiden grundsätzlichen Anforderungen nach einfacher Programmerstellung und hoher Ausführungsgeschwindigkeit.
Auf den ersten Blick drängt sich der Vergleich mit einem Assembler auf, der ja auch in Klartext gegebene Befehle in Maschinencode übersetzt. Doch der Vergleich hinkt, denn die Aufgabe eines Assemblers ist vergleichsweise trivial. Zu jedem Klartextbefehl (Mnemonic) wie zum Beispiel LDA gibt es nämlich genau einen Opcode. Der Assembler macht daher im wesentlichen nichts anderes, als in einer zweispaltigen Tabelle das Mnemonic zu suchen und bei Erfolg aus der zweiten Spalte den zugehörigen Opcode zu entnehmen. ZwischenAssembler-Mne-monic und erzeugtem Maschinencode besteht also ein Verhältnis eins zu eins.
Bei sehr maschinennahen Befehlen wie beispielsweise beim Basic-Befehl GOTO hat es der Compiler ähnlich einfach: »GOTO (Zeilennummer)« würde von einem 6502-Basic-Compiler übersetzt in »JMP Adresse)«. Bei Befehlen wie »IF X = A + 3 THEN Z = 5« wird die Sache schon etwas komplizierter. Eine solche Anweisung kann allein schon deshalb nicht direkt übersetzt werden, weil der 6502-Prozessor keinen Maschinenbefehl »IF« kennt.
Hier muß der Compiler also wesentlich mehr leisten, als nur Opcodes zu bestimmten Schlüsselwörtern herauszusuchen. In der Regel entspricht einem Befehl in einer höheren Programmiersprache eine ganze Befehlssequenz auf der Maschinenebene. Die Aufgabe eines Compilers wird daher mit Recht als Übersetzung statt Assemblierung (Zusammenfügung) bezeichnet.
Übersetzt wird immer aus einer höheren Programmiersprache (beispielsweise Basic) in eine maschinennahe »Sprache«, meistens direkt in Maschinencode. Einer Programmiersprache liegt — wie auch jeder natürlichen Sprache — ein Vokabular und eine Grammatik zugrunde.
Auf die Grammatik kommt es an
Vokabeln der Sprache Basic sind zum Beispiel GOTO, PRINT, DATA, aber auch Zahlen und Variablenna-men gehören dazu. Daneben gibt es bestimmte »Satzzeichen« wie » = «,»:« etc.
Eine Grammatik ist ja nichts anderes als eine Menge von Regeln, die angeben, wie aus den zur Verfügung stehenden Zeichen und Wörtern korrekte »Sätze« gebildet werden. Folgende drei Regeln bilden zum Beispiel eine einfache Grammatik:
Regel 1: Ein Satz besteht aus einem Subjekt, gefolgt von einem Prädikat.
Regel 2: Ein Subjekt ist eines der Worte HUNDE, COMPUTER, MENSCHEN.
Regel 3: Ein Prädikat ist eines der Worte LESEN, RECHNEN, BELLEN, SCHLAFEN.
In der sogenannten Backus-Naur-Form, die zur Definition der Programmiersprache Algol entwickelt wurde, lassen sich die drei Regeln kürzer und eindeutiger darstellen: 1. (Satz) ::= (Subjekt) (Prädikat)
2.	(Subjekt) ::= HUNDE I COMPUTER I MENSCHEN
3.	(Prädikat) ::= LESEN I RECHNEN I BELLEN I SCHLAFEN
In spitzen Klammern stehen dabei immer Verweise auf andere Regeln, die senkrechten Striche trennen verschiedene Alternativen.
Mit dieser Grammatik können durch einfache Anwendung der Regeln Sätze erzeugt werden wie »HUNDE BELLEN« oder »MENSCHEN LESEN« und einige mehr.
Nach Regeln dieser Art ist auch die Basic-Grammatik aufgebaut. Um alle syntaktisch korrekten Sprungbefehle zu beschreiben, genügen folgende Regeln:
1.	(Sprungbefehl) ::= GOTO (Zeilennummer)
2.	(Zeilennummer) ::= {(Ziffer)]
3.	(Ziffer):: = 0111213141516171819
Regel 1 bestimmt, daß ein Sprungbefehl aus dem Schlüsselwort GOTO, gefolgt von einer Zeilennummer, besteht. Regel 2 besagt, daß eine Zeilennummer aus einer Folge von Ziffern besteht (die geschweiften Klammern deuten die Wiederholung an). Regel 3 schließlich definiert, was eine Ziffer ist. Bleibt noch zu bemerken, daß eine Zeilennummer 999999 zum Beispiel syntaktisch richtig ist, aber aus anderen Gründen nicht zulässig ist.
Häufig werden anstelle der Backus-Naur-Form Syntax-Graphen als anschaulichere Art der Darstellung gewählt. Bild 1 zeigt den Anfang einer syntaktischen Definition des allgemeinen Begriffes »Basic-Programm«, und zwar die ersten drei Regeln. Die Diagramme werden grundsätzlich von links nach rechts gelesen, jede andere Richtung muß durch entsprechende Markierungen angegeben werden.
Regel 1 aus Bild 1 besagt, daß ein Basic-Programm zunächst aus einer Programmzeile besteht. Dann kann entweder bereits Schluß sein, oder aber eine weitere Programmzeile folgen und so fort. Regel 2 definiert den Begriff der Basic-Zeile, bestehend aus Zeilennummer und einer Anweisung, worauf ein Doppelpunkt und eine Anweisung etc. folgen können.
Was hat das Ganze nun mit Compilern zu tun? Sehr viel, denn eigentlich sind wir schon mittendrin im Thema. Jeder Compiler verfügt nämlich über einen sogenannten »Parser«, ein wichtiges Teilprogramm, das die syntaktische Analyse übernimmt. Dazu ist es notwendig, daß der Parser die Syntax genau »kennt«. Das sieht dann so aus, daß der Parser bei der Programmanalyse bildlich gesprochen den Linien der Syntax-Diagramme folgt. Stößt er dabei auf ein Kästchen mit einer Syntax-Regel, dann wird sofort das entsprechende Unterprogramm zur Analyse oder Übersetzung dieser Regel aufgerufen. Die Eingabe für den Parser ist also der Programm-Quelltext, als Ausgabe liefert er einen Zwischencode, also eine Art vor-übersetztes Programm.
Bei diesem Zwischencode handelt es sich in der Regel — man höre und staune — um den Maschinenbefehlssatz eines Computers, den es gar nicht gibt. Tabelle 1 zeigt, wie der Befehlssatz eines solchen hypothetischen Computers aussehen könnte. Natürlich erzeugt der Compiler intern nicht die ASCII-Zeichenfolge für diese Befehle, sondern legt jeden Befehl in einem Byte codiert ab. Ein solches oft als »Token« bezeichnetes Byte ist im folgenden immer gemeint, wenn von einem vom Compiler erzeugten Zwischencode die Rede ist.
Intern arbeitet der »Ghost-Computer«, dessen Befehlssatz gerade der Zwischencode ist, mit einem Stack, wie er jedem Forth-Programmierer, aber auch jedem Benutzer von Hewlett-Packard-Ta-schenrechnern vertraut sein dürfte. Diesen Rechenstack kann man sich bildlich als Papierstapel vorstellen. Während der Berechnung eines mehr oder minder komplizierten arithmetischen Ausdrucks können Zettel mit Zwischenergebnissen auf den Stapel gelegt oder aber von oben weggenommen werden.
Natürlich kann man mit den Befehlen aus Tabelle 1 arithmetische Ausdrücke nicht in der gewohnten Schreibweise berechnen, sondern es muß zuvor eine Umwandlung in die sogenannte »umgekehrte polnische Notation« (UPN) erfolgen. Ein Ausdruck wie »2 + 3 x 5« würde beispielsweise folgenden Zwischencode ergeben (Stackinhalt in Klammern):

TODO

Diese Übersetzung in Zwischencode ist nun relativ einfach zu automatisieren, denn auch für arithmetische Ausdrücke gibt es eine Art Grammatik, die auch die »Punkt-vor-Strich« - Regel berücksichtigt (Bild 2). Der Compiler »kennt« diese Regeln und wendet sie an. Sobald er beispielweise innerhalb einer Formel auf eine Zahl (Konstante) stößt, erzeugt er den Zwischencode »LIT (Konstante)«, bei einer Variablen den Zwischencode »RCL yariab-lenadresse)« und so fort.
Tabelle 2 zeigt einige Beispiele für die Übersetzung von Basic-Anweisungen in Zwischencode. Natürlich ist der hier vorgestellte Zwischencode nur ein (unvollständiges) Beispiel. Sie sollten daher nicht erwarten, daß Ihr Basic-Compiler genau diesen speziellen Code erzeugt.
Ist Ihnen bis hierhin etwas aufgefallen ? In der bisherigen Beschreibung der Funktionsweise eines Compilers wurde weder darauf ein-gegangen, in welcher Sprache der Compiler selbst geschrieben ist, und vor allemnicht, fürwelchen Prozessor die Übersetzung durchgeführt wird. Der Grund dafür ist einfach: Ein Compiler ist ein Programm, das einem bestimmten Algorithmus realisiert. Es ist also völlig gleichgültig, in welcher Programmiersprache der Compiler geschrieben wurde. So kann ein Pascal-Compiler durchaus in Basic geschrieben werden, wenn das aus verschiedenen Gründen auch nicht besonders sinnvoll wäre. Außerdem haben wir bisher auch noch keinen wirklichen Maschinencode erzeugt, es ist also egal, für welchen Prozessor die Übersetzung stattfinden soll.
Einige Compiler belassen es sogar bei diesem Zwischencode. Es wird dann ein spezielles Interpreterprogramm benötigt, das diesen Zwischencode interpretiert (»Run-Time-Modul«). Derartige Compiler sind besonders bei 8-Bit-Computern verbreitet, da der Zwischencode sehr kompakt ist (ein Byte pro Befehl). Nachteilig ist natürlich, daß dieser Code immer noch interpretiert werden muß, wenngleich das wegen der sehr einfachen Struktur recht schnell geht. Derartige Zwischencode-Programme sind in der Ausführungszeit etwa zwei- bis zehnmal so schnell wie Basic, bei vermindertem Platzbedarf. Der sogenannte »P-Code«, den Pascal-Compiler erzeugen, ist übrigens ebenfalls ein solcher Zwischencode.
Die Erzeugung von Maschinencode
Die Erzeugung von reiner Maschinensprache aus dem Zwischencode ist nun relativ einfach und funktioniert ähnlich wie bei einem Assembler. Statt des Zwischencodebefehls ADD wird zum Beispiel bei einem 6502-System die Befehlsfolge für eine 16-Bit-Addition oder auch einfach nur der Code für »JSR ADD« erzeugt. Dadurch, daß der so erzeugte Code vom Prozessor direkt ausgeführt werden kann, ergeben sich sehr günstige Ausführungszeiten. Solcherart compilierte Programme laufen zwischen zehn- und hundertmal schneller als über einen Interpreter. Allerdings ist der Speicherbedarf gegenüber Zwischencodeprogrammen in der Regel um etwa das Doppelte erhöht.
Interessant ist, daß die unterschiedlichen Eigenschaften der verschiedenen Prozessoren erst bei der Erzeugung von Maschinencode aus dem Zwischencode zum Tragen kommen. Außerdem hatten wir festgestellt, daß es egal ist, in welcher Sprache ein Compiler geschrieben wird. Diese beiden Erkenntnisse haben weitreichende Konsequenzen bei der Entwicklung von Compilern.
Bootstrapping
Eine in der Praxis fast immer angewandte Methode der Compilerentwicklung beruht darauf, den Compiler in der Programmiersprache zu schreiben, die er übersetzen soll. Ein Basic-Compiler würde daher selbst in Basic geschrieben werden.
Der Grund dafür ist einfach: Hat man einmal einen (wenn auch noch sehr einfachen) in Basic geschriebenen Basic-Compiler zur Verfügung, dann kann dieser Compiler sich

TODO Fortsetzung auf Seite 163

# Impossible Mission

> Wie unmöglich die Aufgabe ist, die man zu erfüllen hat, muß jeder Spieler für sich selbst herausfinden. Schnell langweilig wird dieses Spiel bestimmt nicht.

Der berüchtigte »Elvin« droht die Weltbevölkerung mit Atomwaffen zu vernichten. Als Mitglied der Anti-Computer-Terroristen-Gruppe sollen Sie »Elvin« ausschalten. Sie müssen einen Weg durch die Räume und Tunnel seines unterirdischen Hauptguartiers finden und dabei die Roboterwachen des wahnsinnigen Verbrechers überlisten. Sechs Stunden stehen ihnen zurVerfügung. AberVorsicht! Mitje-dem »Ausfall« der Spielfigur verlieren Sie zehn Minuten. Die Zeit wird schnell knapp.

Suchen Sie nach Hinweisen, um das Paßwort zu bekommen, mit dem Sie bis zu Elvins Kontrollraum gelangen. Sie müssen schneller als die Wachen sein, sie überspringen oder sie mit gefundenen Paßworten für kurze Zeit außer Kraft setzen.

Bei jedem neuen Versuch werden der Aufbau der Räume und die Fähigkeiten der Roboterwachen geändert. War ein Raum beim letzten Versuch noch leicht zu bewältigen, ist er vielleicht dieses Mal kaum noch zu durchqueren.

»Impossible Mission« verfügt über eine eingebaute Sprachausgabe. Gleich am Anfang werden Sie von der Stimme »Elvins« begrüßt. Zu diesem Zeitpunkt scheint sich »Elvin« noch keine allzugroßen Sorgen über Ihr erscheinen zu machen, denn er ist der Meinung, Sie würden Ihr Leben verlieren.

In den einzelnen Räumen müssen Sie versuchen, Puzzle-Teile zu finden. Insgesamt sind 36 Teile versteckt. Jeweils vier Teile ergeben eine Lochkarte, auf der immer ein Buchstabe des Paßwortes für den Kontrollraum abgespeichert ist. An einigen Stellen finden Sie »Hilfspaßworte«. Diese können zwei Funktionen haben: Die einen dienen dazu, die Liftplattformen nach einer Veränderung in ihren Ausgangszustand zu versetzen. Die anderen machen alle Roboterwachen in einem Raum für kurze Zeit funktionsuntüchtig. Diese Zeit reicht meist aus, um zwei Gegenstände in einem Raum zu untersuchen.

Es gibt noch eine andere Möglichkeit, um an »Hilfspaßworte« zu kommen. In dem Labyrinth gibt es zwei Computerräume, in denen eine Konsole und eine Anzeigetafel untergebracht sind. Stehen Sie vor der Konsole und bewegen denJoystick nach vorne, erklingen drei Töne, zu denen jeweils ein Feld der Anzeigentafel aufleuchtet. Danach erscheint eine mittels Joystick zu steuernde Hand, mit der Sie die Felder anfahren können. Ihre Aufgabe besteht darin, die Töne vom tiefsten bis zum höchsten nachzuspielen. Dazu müssen Sie die Hand auf das jeweilige Feld positionieren und den Feuerknopf drücken. Haben Sie die richtige Reihenfolge gefunden wird Ihnen ein »Hilfspaßwort« gutgeschrieben, und die Anzahl der nachzuspielenden Töne erhöht sich um Eins. Mit ein wenig Geschick können Sie einige Hilfsmittel dazu bekommen.

Hervorragend ist auch die Animation dieses Spieles. Der Spielablauf gleicht einem Zeichentrickfilm, nur mit dem Unterschied, daß Sie den Ablauf steuern.

Liebhaber von Labyrinth- und Geschicklichkeitsspielen werden von Impossible Mission sicherlich begeistert sein. Die schwierigen Bilder und der sich stets ändernde Aufbau verhindern Langeweile.

Ab Mitte Januar wird Impossible Mission (Epyx) auch in Deutschland erhältlich sein. Der Preis stand bei Redaktionsschluß noch nicht fest.

(rg)

# Gordon Saga – Abenteuer in der Höhle 

> Gordon Saga ist ein deutsches Abenteuerspiel der Spitzenklasse. Selbst einen Vergleich mit »Hobbit« oder ähnlichen Spielen muß es nicht scheuen.

Begeben Sie sich in die Welt der großen Abenteuer. Schlüpfen Sie in die Rolle eines Höhlenforschers. Gordon Saga ist der erste, in sich abgeschlossene Teil einer deutschen Abenteuerspiel-Serie. Am Ende dieses Teils wird Ihnen dann die »große Aufgabe« gestellt, auf die die folgenden Teile aufbauen.
Alle Textein- und ausgaben erfolgen in Deutsch. Allein dieser Umstand hebt dieses Spiel von vielen anderen, die meist in Englisch geschrieben sind, ab. Das Spiel akzeptiert sogar ganze Sätze. So könnte eine Anweisung zum Beispiel lauten: »NIMM DAS SCHWERT UND GEH NACH NORDEN«. Wird eine Eingabe trotz des recht großen Wortschatzes nicht verstanden, so meldet dies der Computer. Anweisungen, die er versteht, im Moment aber sinnlos sind, ignoriert er. Man kann allerdings, sofern man Lust dazu hat, zum Beispiel singen, beten oder warten, ohne daß dies den Spielablauf beeinflußt.
Einer der größten Vorzüge dieses Abenteuerspiels ist der variable Spielverlauf. Wie auch beim »Hob bit« muß man auf Überraschungen gefaßt sein. Überall lauern Gefahren, die Hilfsmittel sind nicht immer an den gleichen Stellen zu finden. Jeder neue Versuch, das Geheimnis zu ergründen, konfrontiert Sie neuen Bedingungen.
Spielspaß zum Sparpreis
In manchen Situationen wird es besonders schwierig. Sie geraten unter Zeitdruck. So fällt eine Tür hinter Ihnen zu und die Zimmerdecke senkt sich oder es rollt eine große Steinkugel auf Sie zu. Hier muß der Abenteurer schnell und richtig reagieren, um sein Leben zu behalten. Aber die tödlichen Unfälle halten sich in Grenzen. Doch kann es leicht vorkommen, daß ein Monster gerade das nötigste Hilfsmittel stiehlt und irgendwo versteckt.
Ein niedriger Preis muß nicht immer ein Hinweis auf schlechte Qualität sein. So macht sich auf dem deutschen Softwaremarkt ein neuer Trend bemerkbar. Qualitativ gute Software wird immer häufiger zu einem fairen Preis angeboten. So können sich zum einen auch C 64-Besitzer, die nicht über große finanzielle Mittel verfügen, gute Programme leisten. Zum anderen wird den Raubkopierern das Hauptargument (der hohe Software-Preis) genommen. Auch dieses Abenteuerspiel kommt mit einem Preis von 39 Mark diesem Trend nach.

(rg)

Info: Markt und Technik Verlag AG, Happy Software, Hans-Pinsel-Str. 2, 8013 Haar bei München
Preis: 39 Vark

# Die Lösung von Hobbit

> Lange haben die Abenteuerspielfreunde auf die Lösung von Hobbit warten müssen. Einen der möglichen Lösungswege, der sogar ein Ergebnis von 101,5% zuläßt, wollen wir Ihnen hier vorstellen.

The Hobbit ist ein Grafikadventure, bei dem es darauf ankommt einen Schatz zu finden.

Eine Standard-Lösung dazu ist nicht möglich, da sich durch umherirrende Gestalten, ständig neue Spielsituationen ergeben.

### Befehlsliste:

Die in Klammern angegebenen Hinweise brauchen nicht mit eingegeben zu werden. Richtungsangaben, wie zum Beispiel »East«, können durch die Anfangsbuchstaben abgekürzt werden.

START:
OPEN DOOR, EAST, NORTH, NORTH, WAIT (bis »DAY DAWNS«), SOUTH, GET KEY, NORTH, UNLOCK, OPEN, GO DOOR (Rocky door), GET ROPE, GET SWORD, SOUTH, SOUTH, SOUTHEAST, TALK, SAY ELROND »READ MAP« (bis er sie liest), EAST, NORTH, NORTHEAST, NORTH, SOUTHEAST, DOWN, DOWN, DOWN, DOWN, EAST, GET KEY, UR NORTH, WEST, SOUTH, EAST, NORTH, (nun warten Sie, bis ein Goblin Sie gefangen nimmt, achten Sie aber darauf, daß Gandalf oder Thorin bei ihnen sind), DIG SAND (in »Goblins dungeon«), BREAK TRAP WITH SWORD, GET KEY, SAY THORIN »CARRY, ME« (oder zu Gandalf), SAY THORIN »OPEN WINDOW«, SAY THORIN »GO WINDOW«, SOUTHWEST, (als nächstes müssen Sie in dem Verlies der Goblins einen Ring suchen, der von Gollum bewacht wird. Haben Sie diesen, begeben sie sich zum Ausgang »GOBLINS BACKDOOR«), EAST, EAST, OPEN CURTAIN, OPEN CUPBOARD, GET, NORTHEAST, EAST, EAST, WEST, WEST, WAIT (bis »Wooden Elf« kommt und Sie in einem roten Kerker einsperrt) (Sie befinden sich nun im Kerker), WAIT (bis »SOMEONE OPEN RED DOOR«), GO DOOR, NORTH, WAIT, SOUTH, (diese »NORTH-WAIT-SOUTH<<-Kombination so lange, bis »BUTLER DRINK SOME WINE«, dann weiter bis »BUTLER OPEN TRAP DOOR«, wenn »BUTLER THROWS BARREL THROUGH TRAP DOOR«, »JUMP BARREL« eingeben), EAST, SAY BARD »CA-REFULLY, GO NORTH«, NORTH, NORTH, WAIT (bis »RED DRAGON« erscheint), SAY BARD »SHOOT DRAGON«, UR NORTH, NORTH, NORTH, GET TREASURE, SOUTH, SOUTH, SOUTH, DOWN, SOUTH, SOUTH, (am »WATERFALL« warten Sie bis Wooden-Elf kommt) so kommt man in das E1-fenverlies), WAIT (auf »SOMEONE OPEN RED DOOR«), GO DOOR, NORTH, WAIT, WEAR RING, READ MAGIC DOOR, LOOK DOOR, WAIT (irgendwann öffnet sich das magische Tor), WEST, (ein Spinnennetz behindert nun den Weg, dieses Hindernis kann durch Eingabe von SMASH WEB beseitigt werden), (nun versuchen Sie an Hand der Lagekarte zum LONELAND zurückzukehren), GO DOOR, OPEN CHEST, PUT TREASURE.
ENDE

Mit Hilfe dieser Lösung sollte es möglich sein mindestens 85% des Adventures zu lösen. Wenn man alle Räume durchlaufen hat, sind sogar 101,5% drin. Übrigens der Punktestand kann mit »SCORE« abgefragt werden.

Und nun viel Erfolg!

(Roland Selzer/rg)

# Fehlerteufelchen

Nun habe ich also ein erweitertes Betätigungsfeld. Die Redaktion bietet mir mit dem ersten Sonderheft sage und schreibe 26 Listings für meine Aktivitäten an. Zwar versuchen die jetzt mit ihrem Checksummer (und in Zukunft mit dem MSE) mir das Leben schwer zu machen, doch ich bin sehr hartnäckig und nicht so leicht von der Bühne zu kriegen. Ich schlage, wo es mir immer möglich erscheint, erbarmungslos zu. Was mich ein bißchen stört ist die Aufmerksamkeit der Leser. Die scheinen jeden Artikel von vorne bis hinten durchzulesen. Wie soll unsereins da noch eine Chance haben? Ich muß hier also meinen Einfluß im Sonderheft und im 64'er Stammagazin preisgeben.

## Sonderheft 1

### Track 18, SH1, Seite 46

Die Prüfsumme in der Zeile 2520 muß <230> lauten.

Zeile 50005: Das geSHIFTete Pi muß als < Commodore > + A eingegeben werden.

### Disksorter in Vollendung, SH1, Seite36

Zeile 3160: Auch hier muß das geSHIFTete Pi als < Commodore > + A eingegeben werden. Disketten-Meister, SH1, Seite 51

Zwei Zeilen wurden nur halb abgedruckt. Die kompletten Zeilen lauten:
1020 DATA 134,193,76,174,167,32, 76,195,32,114,195,96,174,160,192, 160
1350 DATA 255,133,253,169,0,160, 10,24,101,251,136,208,250,24,101, 252

### Toolkit für Programmierer, SH1, Seite 67

Die undeutlich gedruckten DATAs in den Zeilen 207,208 und 213 lauten: 173,133 und 19

### Hardcopy im Superformat, SH1, Seite 86

Wenn Sie dieses Programm mit dem Görlitz-Interface betreiben wollen, müssen Sie in Zeile 320 die Eins in eine Zwölf umändern. Bitte denken Sie daran, in diesem Fall auch die Prüfsumme in Zeile 600 um Elf zu erhöhen.

### Zeichen-Editor, SH1, Seite 88

In der Zeile 5020 muß die PRINT-Anweisung genauso, also mit der eckigen Klammer, eingegeben werden.

### Super Line — 80 Zeichen für den C 64, SH1, Seite 91

Nachdem der Basic-Lader sich mit »READY« gemeldet hat (beziehungsweise das Maschinenprogramm mit SYS 36864 gestartet wurde), muß unbedingt noch einmal NEW eingegeben werden, da es sonst bei der Eingabe von neuen Programmzeilen zu Schwierigkeiten kommt.

In der Beschreibung muß die Zeile 30 des Beispieles wie folgt lauten:
30 W 0,0,"64'ER DAS MAGAZIN FÜR COMPUTER-FANS"

## 64’er, Ausgabe B, 1 E Synthesizer(AdM), Ausgabe 12/84, Seite 55

Das Programm selbst ist in Ordnung, nur die SAVE-Routine weist einen kleinen Schönheitsfehler auf. Die Zeilen 140 und 150 müssen lauten:
POKE 187,681 AND 255
POKE 188,681/256

Die Folge war, daß der Objektcode zwar richtig abgespeichert wurde, aber unter einem falschen Namen! Ansonsten ist diese Routine für all diejenigen zu empfehlen, die ein File absolut abspeichern möchten, aber keinen Monitor haben.

Martin Ahlborn

### Zinseszinsrechnung, Ausgabe 10/84, Seite 72

Die Zeile 3040 muß richtig lauten:
3040 iff=3thena(16) = ((a(10)/a(9)) t(l/(all)*a(l2)))-l)*l00*a(12):d = 0 Der Faktor »a(12)« fehlte in dieser Zeile.

Frank Heidemann

### Turtle-Grafik (LdM), Ausgabe 11/84, Seite 55 ff.

Direkt nach dem IF...THEN-Befehl kann keiner der neuen Basic-Befehle verwendet werden (SYNTAX ERROR), ein Fehler mit dem übrigens auch professionelle Basic-Erweiterungen wie zum Beispiel Supergrafik 64, Screen Graphics, Ultrabasic und andere behaftet sind. Dies kann man jedoch leicht umgehen, indem man nach dem THEN einen Doppelpunkt eingibt, und dann erst den neuen Befehl. Der Fehler kommt dadurch zustande, daß nach dem IF...THEN der Vektor zur Ausführung eines Basic-Befehls übersprungen wird und so die neuen Befehle nicht ausgeführt werden können.

Die korrekte Speicheraufteilung von Turtle-Graphics lautet übrigens:

1.	Video-RAM wie normal bei $0400
2.	Hires-Farb-RAM: $CC00
3.	Hires-Bitmap: $E000
4.	Das Programm selbst: $C000-$C88B

Im Absatz »Programmierung«, Seite 49, muß es unter b) »f5« statt »fs« heißen.

Ich wurde von einigen Lesern gefragt, wie es möglich ist, die lästige Einleseroutine zu verkürzen oder zu umgehen. Dies ist sehr einfach zu bewerkstelligen, indem man den Speicherbereich in dem das Programm liegt direkt abspeichert. Dies ist unter anderem mit einem der Einzeiler in der gleichen Ausgabe möglich. Die einzelnen Werte sind: ls = 0, hs = 192, le = 140 und he = 200.

Peter Menke

### Die Ebenen des Absturzes, Ausgabe 11/84, Seite 92

Leider mußte ich feststellen, daß mir in den »Ebenen des Absturzes« ein kleiner Fehler unterlaufen ist.

Nach Erkennen von »cbm 80« springt das Betriebssystem natürlich zu den Adressen $800 und $801, und nicht wie angegeben nach $802/803.

Die Zeilen 100 und 130 sehen dann folgendermaßen aus: 100 FOR I = 32768 TO 32778 130 DATA 9, 128, 0, 0, 195, 194, 205.

Daniel Kossmann

# Das Grab des Pharao

> Ein Abenteuer im alten Ägypten erwartet Sie diesmal als Listing des Monats

Ziel des Grafikadventures ist es, die goldene Totenmaske des Pharaos zu finden, wozu eine Pyramide erforscht werden muß, in der zahlreiche Fallen gegen Grabräuber verborgen sind. Am Anfang des Spiels befindet sich der Abenteurer jedoch noch mitten in der Wüste und muß die Pyramide erst einmal finden.
Das Programm besteht aus 58 Bildern, die sich innerhalb der Pyramide aus verschiedenen Komponenten (Durchgänge, Türen, Treppen und so weiter) zusammensetzen. Aufgrund der Vielzahl und Ähnlichkeit der Räume ergibt sich ein wahrer Irrgarten. Die Bilder werden, um den Effekt von hochauflösender Grafik zu simulieren, aus über 80 neudefinierten Zeichen und 33 Sprites zur Darstellung der Gegenstände aufgebaut. Die Befehlsauswertung der Eingaben folgt getrennt in zwei »INPUT« Statements: Das heißt nach jedem eingege-benen Wort muß »RETURN« gedrückt werden, wodurch sich jedoch kein Nachteil ergibt.
Das Programm versteht folgende 18 Verben: gehe, zerstöre, öffne, klopfe, frage, hacke, töte, krieche, werfe, schiebe, drehe, nimm, verliere, ziehe, list, save, stop.
Da großer Wert auf die aufwendige Grafik gelegt wurde, wuchs die Länge des Programmes und leider auch die Unübersichtlichkeit beträchtlich an, wodurch manche Stellen möglicherweise etwas umständlich programmiert wurden. Doch ich bin sicher, daß dies der Spielfreude keinen Abbruch tun wird. Doch nun viel Spaß bei der Suche nach der goldenen Totenmaske des Pharao.

Auf der Suche nach der goldenen Totenmaske des Pharao müssen Sie hier die erste Aufgabe lösen. Eine Menge Programmzeilen sind auf dem Weg in die Wüste, in der das Grab des Pharao steht, einzutippen. Damit Sie nicht hier schon »in der Wüste der Fehlermeldungen« stehen, ist auch dieses Programm mit dem Checksummer einzugeben. Liegt diese Hürde hinter Ihnen, wird Ihnen ein freundlicher Beduine, sobald Sie Ihn gefunden haben, den richtigen Weg weisen.

(Wolfgang Rausch/rg)

<aside>
Ich wurde am 31.1.1965 in Nürnberg geboren und wohne seit 1976 in Stein. An dem Nürnberger Dürer-Gymnasium absolviere ich die 13. Klasse. Meine Programmierkenntnisse erwarb ich jedoch nicht durch einen Informatikkurs, sondern durch Selbststudium mit einem VC 20, den ich Mitte 1983 erwarb. Da ich schon bald an die Grenzen dieses Systems stieß und mir überdies bewußt wurde, daß diesem Computer keine lange Zukunft mehr auf dem Markt beschert sein würde, entschloß ich mich Anfang 1984, auf den C 64 umzusteigen. Frustriert durch mehrere Versuche, Actionspiele in Basic zu programmieren, begann ich schon kurz darauf Maschinensprache zu lernen. Nachdem ich jedoch mit großer Begeisterung einige kommerzielle Adventures gespielt hatte, reifte in mir der Entschluß, selbst ein solches Spiel zu schreiben. Da ich überdies eine gewisse Faszination für das alte Ägypten mit seinen geheimnisvollen Pyramiden empfinde, lag das Thema für mein Programm auf der Hand. Das vorliegende Grafikadventure »Grab des Pharaos« ist das Ergebnis meiner Bemühungen.

(Wolfgang Rausch)
</aside>

# Familienplanung

> In der heutigen Zeit ist Empfängnisverhütung und Geburtenkontrolle wohl etwas ganz Alltägliches. Weniger alltäglich ist allerdings der Einsatz eines Homecomputers zu diesem Zweck. Es ist dennoch ein typisches Beispiel für die statistische Auswertung von Meßergebnissen.

Nach dem Motto »Zurück zur Natur« handeln immer mehr Frauen, die auf die herkömmlichen Verhütungsmittel verzichten wollen oder diese aus gesundheitlichen Gründen nicht nehmen. Eine Pillenpause meiner Freundin brachte mich nun auf die Idee, die folgenden Berechnungen in ein Computerprogramm umzusetzen.

Die Methode der natürlichen Verhütung besteht darin, die fruchtbaren Tage eines Zyklus zu errechnen.

Zwei Ärzte, Knaus (Österreich) und Ogino (Japan) fanden voneinander unabhängig eine Verhütungsmethode heraus, die auf dem weiblichen Zyklus basiert.

Zuerst ist es wichtig, den Termin des Eisprunges zu errechnen, da eine Befruchtung nur kurze Zeit nach dem Eisprung möglich ist (etwa 6 Stunden). Knaus und Ogino fanden heraus, daß ziemlich genau 14 Tage vor der nächsten Periode der Eisprung stattfindet. Bezieht man nun die Lebensdauer der Spermen (48 Stunden) in diese Überlegung ein, so kann man die Tage der Enthaltsamkeit eingrenzen. Zählt man zum Termin des Eisprunges 266 Tage (9 Monate) hinzu, so erhält man den Termin einer eventuellen Geburt.

Konkret heißt das: Datum der ersten erfaßten Regel bis zur letzten erfaßten Regel ergibt den Beobachtungszeitraum. Daraus wird der Mittelwert für die Dauer einer Regel gebildet. Zur letzten Regel wird der Mittelwert addiert. Die Standard-Abweichung ergibt die Schwankung um diesen errechneten Termin. Schwankungsmaximum — 14 Tage = letzter Tag der Pause. Schwankungsminimum — 14 Tage — 2 Tage (Lebensdauer Spermen) = erster Tag der Pause. Mittelwert addiert zur letzten Regel — 14 Tage + 266 Tage = Termin einer eventuellen Geburt. Alle Werte werden in Stunden bezogen auf ein festes Datum umgerechnet.

Autor und Redaktion übernehmen keinerlei Haftung bei eventuellen auftretenden Komplikationen.

(Peter Sprockhoff/ev)

<aside>
## Der Programmautor stellt sich vor

Ich bin 28 Jahre alt und gehöre damit laut Statistik der Computerhersteller nicht mehr zu den potentiellen Käufern der Homecomputer. Dies hielt mich jedoch nicht davon ab, Computer zu meinem Hobby zu machen.

Nach einer Lehre als Radio- und Fernsehtechniker war ich acht Jahre bei der Bundeswehr. Zu meiner Entlassung im März 1983 war ein ZX81 das Abschiedsgeschenk meiner Kameraden. Seit April 1983 gehe ich wieder zur Schule und lasse mich zum Computertechniker ausbilden.

Durch diese Ausbildung stieß ich sehr bald an die Grenzen des ZX81, der ja auch nicht gerade der komfortabelste ist. So legte ich mir nach einem halben Jahr einen VC 20 zu. Zwar auch nicht der Weisheit letzter Schluß, aber dennoch...

Speichererweiterung und Kassetten- Interface baute ich selbst, so daß ein preiswertes, komfortables System entstand. Soweit es die finanziellen Mittel zuließen, folgten inzwischen Floppy, Drucker, Monitor, 40/80 Zeichenkarte und diverse andere Extras. Eine Systemkonfiguration mit der sich schon ganz bequem arbeiten läßt.

(Peter Sprockhoff)
</aside>

## Ein heikles Thema

> Die einzige Empfängnisverhütung, die die katholische Kirche duldet, heißt Knaus-Ogino oder realistischer Römisches Roulette. Die Methode beruht auf der Messung des Eisprungs. Näheres erfahren Sie vom Hausarzt. Der VC 20 übernimmt die Statistik, aber keine Haftung.

Immer mehr Frauen, die entweder die Pille oder andere Verhütungsmittel nicht vertragen oder nicht nehmen wollen, greifen zu Kalender und Bleistift und errechnen die »gefährlichen« Tage nach der sogenannten Knaus-Ogino-Methode, die auf dem weiblichen Zyklus basiert

Da es sich um eine statistische Methode handelt, erhöht sich die Sicherheit mit der Anzahl der Messungen. Um das Zahlenmaterial bequem zu verwalten und Rechenfehler mit Folgen weitgehend auszuschalten, bietet sich der Einsatz eines Computers an.

Das Programm ist auf einem VC 20 mit 16-KByte-Erweiterung und Diskettenstation 1541 geschrieben. Es benötigt mit Kommentaren exakt 4614 Byte RAM, kann jedoch durch Fortlassen der REM-Zeilen soweit gekürzt werden, daß es auch auf der Grundversion des VC 20 läuft.

Spezielle POKE-Befehle wurden vermieden, womit das Programm auf allen Commodore-Computern mit minimalen Korrekturen hinsichtlich der Bildschirmaufteilung, lauffähig sein sollte. Die Routinen zum Schreiben und Lesen von sequentiellen Dateien können bei Benutzung einer Datasette sehr leicht geändert werden:
1310 OPEN 2,1,0,F$
1380 OPEN 2,1,2,F$

Nach dem Starten des Programms meldet es sich zunächst mit einer Kurzanleitung. Anschließend können Daten per Hand eingegeben oder von Diskette gelesen werden. Das Datum muß mit Komma getrennt und die Jahreszahl vierstellig eingegeben werden. Die Uhrzeit ist auf volle Stunden auf- oder abzurunden. Diese Daten werden nämlich für die statistische Aufbereitung der Meßwerte benötigt.

Nach der Eingabe werden die Daten gespeichert. Darauf erfolgt die Ausgabe aller Daten mit der Dauer zwischen der ersten und der n-ten Periode in Tagen sowie der Abweichung in Stunden (Bild 1).

Bei brauchbaren Werten erscheinen jetzt die ersten Ergebnisse, wobei die Werte in Klammern die größte Abweichung nach oben oder unten angeben (Bild 2).

Nach Tastendruck erscheinen schließlich auf dem Bildschirm die wahrscheinlichen Werte der in diesem Zusammenhang interessierenden Ereignisse (Bild 3). Die Empfängniszeit ist in »Pause von ... bis« enthalten. »Nächste P.« ist der voraussichtliche Termin der nächsten Periode. Danach kommen die (voraussichtlichen) Termine des nächsten Eisprunges und einer eventuellen Geburt

Mit einer einigermaßen zuverlässigen Berechnung ist erst nach mindestens drei eingegebenen Werten zu rechnen. Wie immer bei statistischen Aussagen, so gilt auch hier: Je mehr zuverlässige Werte vorhanden sind, desto genauer wird die Aussage. Autor und Redaktion übernehmen keinerlei Garantie für das einwandfreie Funktionieren dieser Methode.

(Peter Sprockhoff/ev)

# Checksummer — keine Fehler mehr beim Abtippen von Listings

> Das Programm Checksummer wird Ihnen das Abtippen von Listings erheblich erleichtern. Eswird deshalb in dieser und in der nächsten Ausgabe noch einmal mit ausführlicher Beschreibung abgedruckt. Lesen Sie bitte die Anleitung genau durch, bevor Sie ein Listing mit dem Checksummer eintippen.

Der Checksummer 64 ist ein kleines Maschinenprogramm, das, wenn es aktiviert ist, Sie sofort davon unterrichtet, ob Sie diejeweilige Programmzeile korrekt eingegeben haben.

1.	Tippen Sie den Basic-Lader sorgfältig ein. Es gibt zwei Versionen: eine für den Commodore 64 und eine für den VC 20.
2.	Bevor Sie »RUN« eingeben, speichern Sie den Basic-Lader bitte erst ab, denn wenn Sie zum Beispiel einen Fehler bei den eingetippten POKE-Anweisungen gemacht haben, ist es möglich, daß der Rechner aussteigt. Heben Sie sich den abgespeicherten Checksummer 64 auf — Sie werden ihn immer wieder brauchen, wenn Sie ein Basic-Programm aus dem 64’er eintippen wollen.
3.	Der Checksummer 64 überprüft sich selbst. Wenn Sie einen Fehler in den DATAs gemacht haben, listen Sie die fehlerhafte Zeile einfach, korrigieren sie und starten dann das Programm neu.
4.	Nach Initialisierung des Maschinenprogramms ist der Checksummer 64 aktiviert. Er steht innerhalb des Betriebssystems und verbraucht kein einziges Byte Speicherplatz. Es sei hier für Interessierte gesagt, daß selbst alle Sprungvektoren unverändert bleiben, das Programm also mit einer Vielzahl von anderen Programmier-Spracherweiterungen wie etwa Ex-basic Level II problemlos zusammenarbeitet. Achten Sie aber darauf, daß bestimmte Spracherweiterungen das hinter dem ROM liegende RAM für Hires-Grafiken benutzen. Wird zum Beispiel eine Hires-Grafik von Simons Basic aus angesprochen, so wird der Checksummer 64 zerstört.
5.	Wenn Sie den Checksummer 64 zwischenzeitlich nicht benutzen, können Sie ihnjederzeit mit »POKE 1, 55« desaktivieren. Auch durch Drücken der Run-Stop- und der Restore-Taste wird der Checksummer 64 desaktiviert. Wollen Sie, daß der Checksummer 64 auch noch nach Drücken dieser Tastenkombination erhalten bleibt, so geben Sie bei aktiviertem Checksummer64»POKE64982,53«ein. DerChecksummer 64 ist dann nur durch »POKE 1, 55« abschaltbar.<br>Wollen Sie den Checksummer 64 wieder einschalten, so geben Sie bitte »POKE 1, 53« ein.<br>Das Maschinenprogramm bleibt solange erhalten, bis der Computer ausgeschaltet, oder wenn von anderen Programmen auf das hinter dem ROM liegende RAM zugegriffen wird.
6.	Eine Checksumme wird nurdann ausgegeben, wenn der Commodore 64 (VC 20) eindeutig erkennt, daß Sie eine Zeile bestehend aus der Zeilennummer und zumindestens einem alphanumerischen Zeichen eingegeben haben. Ansonsten reagiert der Commodore 64 normal.

Hinweis: Wenn Sie bei aktiviertem Checksummer 64 ein Programm mit »LOAD« in den Speicher holen, wird auch eine Checksumme ausgegeben. Dies liegt jedoch an rechnerinternen Routinen und hat keine weitere Bedeutung, stellt insbesondere keine Gefahr für das geladene Programm dar, da alle Pointer richtig gesetzt werden.

Nach Eingabe von RUN wird zunächst einmal das ROM in das RAM des Commodore 64 verschoben, wonach der Basic-Interpreter modifiziert wird. Dadurch hat man den Vorteil, trotz einer zusätzlichen Routine das gesamte RAM des Rechners zur Verfügung zu haben. Nach ordnungsgemässem Ablauf des Programms können Sie sofort mit Eingaben beginnen. Für Maschinensprache-Spezialisten weise ich darauf hin, daß ich ausnutze, daß die Einschaltmeldungen des Rechners nur nach einem Reset generiert wird. Der Textbereich, in dem die Meldung steht, wird von dem erzeugten Maschinenprogramm überschrieben.

Alle veröffentlichten Listings sind mit einer Checksumme versehen, die am Ende jeder Programmzeile steht. Diese Checksumme steht zwischen < und >. Sie wird beim Eintippen des Programms nicht mit eingegeben. Die Zahl zwischen den beiden Zeichen stellt lediglich eine Information für Sie dar. Wenn Sie diese Checksumme dennoch mit eintippen, werden Sie schnell bemerken, daß Sie etwas falsch gemacht haben. Bei aktiviertem Checksummer 64 wird nämlich nach Eingabe einer Basic-Zeile, die mit Return beendet wird, in die linke obere Bildschirmecke die Checksumme eingeblendet, die mit der Summe aus dem veröffentlichten Listing übereinstimmen muß. Ist das nicht der Fall, haben Sie die Zeile anders eingegeben, als sie im Listing dargestellt ist. Vergessen Sie also bitte nicht, daß die am Ende einer Zeile in < und > stehende Prüfsumme nicht mit eingegeben werden darf.

Der Checksummer 64 ist so ausgelegt, daß er abhängig von der Zeilennummer und dem Text der Zeile eine Checksumme ausgibt. Beim Bilden dieser Checksumme werden Spaces (Leertaste) überlesen, was für Sie bedeutet, daß es egal ist, wieviel Leerzeichen Sie zwischen den Worten lassen, da Sie für den Programmablauf ohnehin keine Bedeutung haben. Aber manchmal ist das richtige Setzen von Leerzeichen doch wichtig, besonders innerhalb von Strings (Zeichenketten), die gedruckt werden sollen. Seien Sie deshalb besonders genau bei Leerzeichen, die innerhalb von Anführungszeichen stehen, denn meistens ermöglichen nur die richtig gesetzten Spaces eine sinnvolle Textausgabe auf dem Bildschirm.

Beachten Sie auch, daß es durchaus erlaubt ist, Abkürzungen für die Commodore-Befehlswörter zu verwenden. So führt die Eingabe von » ? « als Kurzschreibweise für »PRINT« nicht etwa zu einem Checksummen-Fehler, sondern wird korrekt verarbeitet und dementsprechend die Checksumme generiert. Nachdem Sie ein Listing eingegeben haben, sollten Sie es aus Sicherheitsgründen vor dem Starten abspeichern. Sie brauchen hierfür jedoch nicht den Checksummer 64 zu desaktivieren.

### Hinweise zum Lesen von Listings

Die Listings haben sich ein wenig im Ausdruckformat verändert, um Ihnen das Eingeben von Programmen wesentlich zu erleichtern.

— Cursorsteuerzeichen und andere Steuerzeichen, die schwer zu lesen sind, werden von nun an in Klartext in speziellen Klammern gesetzt.<br>Tritt mehrmals hintereinander dasselbe Steuerzeichen auf, so wird diese Steuerzeichen-Sequenz zusammengefaßt, indem zuerst das Steuerzeichen und dann die Anzahl der Wiederholungen dieses Steuerzeichens in Klartext ausgegeben wird.
— alle Commodore-Grafikzeichen, die über Shift zu erreichen sind, werden nicht mehr als Grafikzeichen, sondern als Klartextzeichen dargestellt. Dabei wird aus dem Zeichen, das Sie auf dem Bildschirm sehen, wenn Sie die Tastenkombination Shift und »A« ansprechen, wieder ein »A«. Um dieses »A« vom normalen »A« unterscheiden zu können, ist es etwas kleiner als das gewöhnliche »A« und ist außerdem mit einem Unterstreichungszeichen versehen. Diese Vereinbarung gilt auch für sämtliche andere Commodore-Grafikzeichen, die über Shift zu erreichen sind.
— entsprechendes gilt für sämtliche Commodore-Grafikzeichen, die über die Commodore-Taste zu erreichen sind. Hier wird jedoch das jeweilige Klartextzeichen nicht unterstrichen, sondern überstrichen.

### Erläuterungen zu den Cursorsteuerzeichen

Cursorsteuerzeichen werden, wie schon oben erwähnt, umdefiniert. Sie sehen hier eine Liste der möglichen Ausdrücke, die für ein Cursorsteuerzeichen im Listing auftauchen können. Gleichzeitig ersehen Sie aus der Tabelle, welche Taste beziehungsweise Tastenkombination zu drücken ist, damit dieses Steuerzeichen richtig in Ihr Programm übernommen wird. Beachten Sie, daß Sie die Steuercodes nur dann als reverses Zeichen sehen können, wenn der Rechner im »Quote-Modus« arbeitet, das heißt, daß er sich im Gänsefüßchenmodus befindet.

## Checksummer VC 20

Der Checksummer VC 20 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremäßig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.

In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC20:

— da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.
— angeschaltet wird der Checksummer VC 20 mit »SYS 955«
— Abschaltung des Checksummer VC 20 wird mit »SYS 58459« vollzogen

**ACHTUNG**: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist. Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Rechner bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).

Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Rechner »aussteigt«.

Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeitaufheben, wenn man den Checksummer VC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht. Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop & Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.

— Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 20 feststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.
— bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.
— wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 63999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.

Viel Spaß beim Eintippen von Programmen mit dem neuen Checksummer!

(F. Lonczewski / gk)

# MSE – Abtippen  sicher und leicht gemacht

Ähnlich wie der »Checksummer« ist auch der MSE ein Hilfsmittel bei der Eingabe von Listings, diesmal jedoch bei reinen Maschinensprache-Programmen.

Im Gegensatz zum »Checksummer« aber ist die Eingabe nicht ohne den MSE möglich. Der MSE verringert die Tipparbeit um ein Drittel und schließt Fehleingaben vollkommen aus. Außerdem können Sie die DATAs blind eingeben, ohne andauernd auf den Bildschirm schauen zu müssen. Dies wird durch akustische Meldungen realisiert.

Sicher kennen Sie die Situation: Man hat ein langes Listing mit DATA-Zeilen abgetippt, versucht es, das erste Mal zu starten und — nichts läuft. Dann beginnt nach der mühseligen Tipperei die noch mühseligere Fehlersuche. Als letzter Ausweg bleibt dann nur noch der Anruf bei der Redaktion oder dem Verfasser, ob vielleicht doch ein Druckfehler...

Damit ist esjetzt vorbei. Ab dieser Ausgabe werden die Maschinenprogramme im 64’er mit dem MSE abgedruckt. MSE ist ein Maschinenspracheditor, mit dem ein Vertippen ausgeschlossen ist. Eine abgetippte Zeile wird nur angenommen, wenn sie richtig ist. Wie ist das möglich ? Eine Checksumme am Ende jeder Zeile prüft, ob die richtigen Werte in der richtigen Zeile an der richtigen Stelle stehen. Wenn nicht, ertönt ein Warnsignal, und man beseitigt den Fehler.

War die Zeile korrekt, erklingt ein Gong, und die nächste Zeilennummer wird ausgegeben. Damit ist also auch »blindes« Eintippen möglich; Sie können sich voll auf den Text konzentrieren.

MSE verringert die Tipparbeit um ein Drittel. Anstelle von dreistelligen DATAs brauchen Sie nur noch zweistellige Hex-Zahlen einzugeben, die direkt in den Speicher gePOKEt werden.

### So arbeitet man mit MSE

Laden und starten Sie MSE. Zuerst wird der Programmname und die Start- und Endadresse erfragt. Diese Angaben entnehmen Sie dem Kopf des jeweiligen abgedruckten Listings. MSE meldet sich dann mit der Zeilennummer der ersten Zeile. Wenn Sie die Zeile richtig eingegeben haben, erscheint die nächste Zeilennummer und so weiter bis zum Ende. Zum Schluß wird das fertige Programm mit »CTRL-S« auf Diskette oder Kassette abgespeichert. Dazu sind keine weiteren Angaben mehr erforderlich. Das Programm kann dann ganz normal wieder absolut geladen und gestartet werden. Wenn Sie nicht alles auf einmal tippen wollen, können Sie jederzeit unterbrechen und den eingetippten Teil mit »CTRL-S« abspeichern. Wollen Sie weiterarbeiten, laden und starten Sie MSE wieder. Geben Sie auf die Frage nach der Startadresse aber jetzt »L« ein, um lhrTeilprogramm zu laden. Jetzt können Sie mit »CTRL-N« die Adresse eingeben, an der Sie weitertippen müssen. Wenn Sie sich nicht gemerkt haben, wie weit Sie gekommen sind, geben Sie nach dem Laden »CTRL-M« ein.

Auf die Frage nach der Startadresse antworten Sie mit der Anfangsadresse, die links in der Kopfzeile auf dem Bildschirm steht. Nun wird Ihr Programm aufgelistet. Mit »SPACE« wird das Listen fortgesetzt, mit »STOP« abgebrochen. Das Ende Ihres Programmteils erkennen Sie sehr einfach daran, daß nur noch der Wert »AA« in der Zeile steht. Die Adresse dieser Zeile müssen Sie anschließend mit »CTRL-N« eingeben. Das Programm ist nur mit »STOP/RESTORE« zu verlassen. Speichern Sie aber vorher unbedingt immer Ihren Text ab.

Wollen Sie selbst Programme mit MSE ausdrucken, laden Sie Ihr Programm wie oben beschrieben und geben anschließend »CTRL-P« ein. Die Druckausgabe läßt sich mit »STOP« jederzeit abbrechen.

### Hinweise zum Abtippen

Vor dem Abtippen oder späteren Wiederladen des MSE-Laders müssen Sie unbedingt folgende Zeile eingeben:
**POKE 43,1: POKE 44,32: POKE 8192,0: NEW**

Beachten Sie bei der Eingabe die Hinweise im »Checksummer«. Speichern Sie den »MSE Lader« nach dem Abtippen unbedingt ab. Starten Sie das Programm mit RUN. Fehlerhafte Zeilen werden angezeigt und müssen korrigiert werden, bis der Lader zum »READY« durchläuft. Jetzt müssen Sie das fertige MSE-Programm abspeichern. Dazu brauchen Sie nur »RETURN« zu drücken, weil die erforderlichen Angaben schon auf dem Bildschirm stehen. (Kassettenbesitzer müssen in Zeile 343 die letzte Zahl in »1« abändern). Abjetzt können Sie »MSE V1.0« direkt, also ohne den DATA-Lader benutzen. MSE V1.0 wird ganz normal mit »,8« geladen. Heben Sie das Programm gut auf, Sie werden es noch häufig brauchen.

(N. Mann/D. Weineck/gk)

<figure>
**MSE-Befehle:**
DEL löscht die letzte Eingabe.
CTRL-S speichert das eingetippte Programm ab.
CTRL-L lädt ein Programm. Start- und Endadresse werden automatisch ermittelt.
CTRL-M listet den Speicherinhalt. Abbruch mit STOP-Taste, weiter mit Leertaste
CTRL-N erlaubt die Eingabe einer neuen Adresse zum Weitertippen.
CTRL-P gibt ein MSE-Listing auf dem Drucker aus.
<figcaption>Die Befehle des MSE auf einen Blick</figcaption>
</figure>

# VC 20 steuert Super 8-Kamera

> Ein kleines Programm und eine schnell aufgebaute Schaltung für alle Trickfilmer.

Beim Erstellen von Trickszenen mit der Super 8-Kamera fallen regelmäßig lästige Rechnungen an: Die Anzahl der bereits aufgenommenen Bilder muß festgehalten, die resultierende effektive Wiedergabezeit muß berechnet werden. Schließlich ist auch das Einhalten einer bestimmten Bildfrequenz bei Einzelbildaufnahmen von Hand kaum möglich.

Da fast jede Super 8-Kamera über einen Anschluß für einen elektrischen Fernauslöser verfügt, bietet sich eine Steuerung per Computer geradezu an. Der Hardware-Aufwand beschränkt sich dabei auf einen Transistor BC-238 (oder ähnlich) als Treiberstufe und ein handelsübliches 5-Volt-Relais, wie es jeder Elektronikladen vorrätig hat. Die beiden Bauteile werden an den User-Port des VC 20 geschaltet. Über die Adresse 37136, dem Ausgaberegister von Port B des User-Port-VIA, läßt sich das externe Relais dann ein- und ausschalten. Die Pin-Belegung des User-Ports kann im Handbuch nachgeschlagen werden.

Der Aufbau der Schaltung ist völlig unkritisch, sollte aber dennoch mit großer Sorgfalt erfolgen, da eine falsche Beschaltung zur Zerstörung des VIA führen kann.

Das Programm zur Kamerasteuerung ist bewußt einfach gehalten und erklärt sich weitgehend von selbst. Die Bildfrequenz kann über die Funktionstasten sehr einfach und schnell gewählt werden. Das Programm informiert ständig über die Gesamtzahl der aufgenommenen Einzelbilder, über die effektive Laufzeit und die gewählte Bildfrequenz.

(Wolf-D. Robrahn/ev)

# C 16/Plus 4 – Listings gesucht

Die neuen Commodore-Computer C 16/116 und Plus 4 sind inzwischen schon in größeren Stückzahlen verkauft worden. Gehören Sie vielleicht zu den Käufern der ersten Stunde und haben deshalb schon Erfahrungen damit sammeln können? Oder haben Sie vielleicht schon interessante Programme für diese Computer entwickelt?
Dann sollten Sie einmal zur Schreibmaschine (beziehungsweise zur Textverarbeitung) greifen und eine möglichst ausführliche Programmbeschreibung erstellen. Anschließend werfen Sie den Drucker an, um ein Pro-grammlistmg zu erzeugen und kopieren dann das Programm auf einen Datenträger (Diskette oder Kassette).
Zum Schluß entwerfen Sie noch ein kurzes Anschreiben, auf dem Sie bitte unbedingt Name, Anschrift und ’Telefonnummer vermerken und (ganz wichtig!) auch erwähnen, für welchen Computer das Programm geschrieben wurde und welche Erweiterungen und zusätzliche Geräte notwendig sind.
Auf den Briefumschlag, in den Sie diese Unterlagen stecken, schreiben Sie bitte neben Ihrem Absender noch folgenden Text:
An die
Redaktion 64’er
Markt&Technik Verlag AG Hans-Pinsel-Straße 2 8013 Haar bei München
Ein oder zwei Tage, nachdem Sie den Brief zur Post gebracht haben, kommt er bei uns in der Redaktion an. Wir freuen uns über die Zusendung, testen das Programm und entscheiden über die Veröffentlichung.
So ist allen geholfen: Unsere Leser finden ständig interessante Programme in ihrem 64’er Magazin, wir Redakteure haben Arbeit und Sie bekommen bares Geld — 100, 200, 300 oder auch 2000 Mark.

# Ohne gutes Werkzeug geht es nicht: SMON (Teil 4)

> Der Trace-Modus, also das Abarbeiten von Maschinenprogrammen Schritt für Schritt, ist das wohl wichtigste Hilfsmittel beim Austesten von Maschinenprogrammen. SMON bietet sogar drei verschiedene Trace-Möglich-keiten, die in diesem vierten Teil dargestellt werden. Außerdem erhalten Sie eine Übersicht aller Befehle, und wir zeigen Ihnen, wie Sie SMON in einen anderen Bereich verschieben können.

Einen Befehl haben wir Ihnen bisher unterschlagen, der zwar bereits vorhanden, aber noch nicht beschrieben war. Es handelt sich um den Vergleich zweier Speicherbereiche. Die Syntax ist sehr einfach:
= 4000 6000
vergleicht den Speicherinhalt ab $4000 mit dem ab $6000. Das erste nicht übereinstimmende Byte wird angezeigt, und der Vergleich wird abgebrochen.

Wenn Sie also ein Maschinenprogramm geschrieben und überarbeitet haben und Sie wissen nicht mehr genau, worin eigentlich der Unterschied zwischen der 76. und der 77. Version besteht, gehen Sie so vor: Laden Sie zuerst Version 76 und verschieben Sie diese mit dem »W«-Befehl in einen freien Speicherbereich. Laden Sie dann Version 77 und führen Sie den »=«-Befehl durch. Sofort finden Sie den Unterschied und können mit der Arbeit an Version 78 beginnen....

Wir wollen uns bei der Beschreibung der Trace-Befehle auf Anwendungsbeispiele konzentrieren. Zum Aufbau der Routine sei nur so viel gesagt: Gesteuert wird sie mit Hilfe des Prozessor-Interrupts, weil nur damit ein Eingriff ins laufende Maschinenprogramm möglich ist. Während des Trace-Ablaufs wird deswegen der Bildschirm kurzfristig aus- und eingeschaltet, weil alle anderen Interruptanforderungen wie zum Beispiel durch den Video-Chip, verhindert werden müssen. Da die Befehle eines Programms nicht nur angezeigt, sondern auch wirklich ausgeführt werden, ist der »SEI«-Befehl mit großer Vorsicht zu verwenden. Doch dazu später mehr. Wir wollen ein neues, besser geeignetes Beispiel verwenden als bisher. Tippen Sie also das folgende Miniprogramm mit dem Assembler ein (A 4000):

TODO

Starten Sie das Programm mit »G 4000«. Es muß die Zahlen von 0 bis 8 auf den Bildschirm schreiben.

### Trace-Stop

TS (Startadresse Stoppadresse)
Starten Sie nun unser Programm mit
TS 4000 4009

Die ersten Befehle werden ausgeführt (die Null ausgegeben, der Akku erhöht etc.), dann stoppt das Programm bei Adresse $4009 und springt in die Registeranzeige.

Genau genommen ist »TS« gar kein Trace-Befehl, das Programm läuft nämlich bis zur gewählten Stoppadresse in Echtzeit durch. Dort angekommen, können Sie die Register prüfen und gegebenfalls durch Überschreiben ändern. Mit »G«, »TW« oder >TB« (wird später erklärt) ohne weitere Adresseneingaben können Sie dann im Programmlauf fortfahren. SMON merkt sich nämlich, wo er stehen geblieben ist und arbeitet ab dieser Adresse weiter, wenn Sie nicht eine neue angeben.

Sinnvoll ist dieser Befehl immer dann, wenn in einem längeren Programm nur bestimmte Teile »getraced« werden sollen, der Anfang aber durchlaufen werden muß, um Variable zu setzen oder Benutzereingaben zu erfragen. Auch wenn man nicht ganz sicher ist, ob eine bestimmte Passage überhaupt jemals durchlaufen wird, kann man das mit >TS« überprüfen.

Zwei Einschränkungen gibt es allerdings wegen der Arbeitsweise dieses Befehls: SMON setzt im Programm an die Stoppadresse einen BRK-Befehl und merkt sich, welcher Befehl dort stand, um ihn wieder zurückzuschreiben. Deshalb funktioniert >TS« nur im RAM, nicht aber zum Beispiel im Basic oder im Betriebssystem. Auch darf die Speicherstelle, in der sich SMON den ausgetauschten Befehl merkt ($02BC) vom Programm nicht verändert werden, sonst ist eine korrekte Reparatur nicht mehr möglich.

Der wohl am häufigsten und vielseitigsten eingesetzte Trace-Befehl ist sicherlich »TW«.

### Trace Walk

TW (Startadresse)
Starten Sie unser Beispiel jetzt mit TW 4000

Der erste Befehl (LDA # 30 in Adresse $4000) wird ausgeführt, SMON stoppt und zeigt dann die Inhalte aller Register in der gleichen Reihenfolge wie beim »R«-Kommando sowie den nächsten Befehl an. Im Akku steht jetzt 30, der Programmzähler zeigt auf $4002. Jetzt drücken Sie eine Taste. Der nächste Befehl (JSR FFD2) wird ausgeführt, der Programmzähler zeigt auf $FFD2. Achten Sie auf den Stackpointer: Sein Inhalt hat sich um 2 vermindert, weil der Prozessor auf dem Stack die Adresse abgelegt hat, an die er nach Beendigung der Subroutine zurückspringen soll. Der nächste angezeigte Befehl ist ein indirekter Sprung über $0326. Mit dem nächsten Tastendruck wird er durchgeführt.

Und so geht es munter weiter. Verzweifeln Sie nicht, wenn Sie auch nach den nächsten zehn Tastendrücken immer noch irgendwo im Betriebssystem »herumtracen« und von unserem Beispielprogramm weit und breit nichts mehr zu sehen ist. Ausnahmsweise ist unser Liebling einmal nicht im »Land der Träume« verschwunden, sondern tut, was er soll: Er arbeitet brav einen Befehl nach dem anderen alles ab, was zur Routine $FFD2 gehört, und das ist reichlich viel. Also bewegen Sie Ihre Finger, Sie haben’sja nicht anders gewollt. Irgendwann einmal, nach mehreren hundert gedrückten Tasten, befinden Sie sich plötzlich wieder in der Registeranzeige von SMON. Das Programm ist beendet. Nun werden Sie enttäuscht fragen, was man wohl mit einem Trace-Modus anfangen soll, der schon bei kleinsten Beispielprogrammen ein völlig undurchschaubares Chaos erzeugt? Nur Geduld, die Rettung naht in Gestalt der Taste »J«.

Falls ihre Hand noch nicht in Gips liegt, starten Sie das Ganze nochmal von vorn mit >TW 4000«. Diesmal drücken Sie aber jedesmal, wenn als nächster Befehl »JSR FFD2« angezeigt wird, auf »J«. Der Effekt ist, daß die gesamte Subroutine auf einen Schlag abgearbeitet wird und Sie sofort wieder auf dem nächsten Befehl unseres Beispiels landen. Daß wir nicht gemogelt und die Befehle von »JSR FFD2« einfach unterschlagen haben, sehen Sie daran, daß der Akku tatsächlich auf dem Bildschirm ausgegeben worden ist (rechts neben FFD2). Jetzt können Sie unser Beispiel in aller Ruhe bis zu Ende durchgehen und verfolgen, wie der Akku erhöht wird, wie der Vergleich das Statusregister beeinflußt und wie dementsprechend der Rücksprung in die Schleife erfolgt.

Sie dürfen die »J«-Taste auch dann benutzen, wenn Sie schon mitten in der Subroutine sind. Aber hierbei ist äußerste Vorsicht geboten: Die Rücksprungadresse muß unbedingt oben auf dem Stack liegen, wenn Sie »J« drücken. Hat nämlich der Prozessor Werte auf dem Stack abgelegt (mit PHA oder PHP), dann erfolgt der Sprung irgendwo hin, nur nicht zurück ins Programm. Achten Sie deshalb genau auf die Anzeige des Stackpointers. Wenn dessen Wert genau so groß ist wie bei Beginn der Subroutine, kann nichts passieren. Sonst hilft nur noch der Reset-Taster, den Sie ja inzwischen hoffentlich eingebaut haben, oder eine ruhige Hand, die die Büroklammer an Pin 1 und 3 des User-Ports hält (Kostenpunkt der Reparatur bei Abrutschen zirka 100 Mark...)

»TW« bricht automatisch mit der Registeranzeige ab, wenn im Programm ein »BRK«-Befehl auftaucht. Wenn Ihnen das zu lange dauert oder Sie zwischendurch ein Register ändern möchten, können Sie den Trace-Modus jederzeit mit der Stopp-Taste verlassen. Anschließend können Sie wie bei »TS« beschrieben fortfahren.

Im Gegensatz zu »TS« können Sie mit >TW« auch im ROM herumstöbern; Sie haben es ja bei der Subroutine $FFD2 bereits getan. Einzige Einschränkung beim »TW«-Befehl: Ihr Programm darf keinen »SEI« enthalten, da dieser den Interrupt und damit auch den Trace-Modus lahmlegt. Verlassen Sie in diesem Falle »TW« mit STOP und starten erneut hinter dem »SEI«-Befehl. Allerdings müssen Sie in Kauf nehmen, daß das Programm normalerweise nicht mehr korrekt arbeitet.

Das nächste Programm soll als weiteres Beispiel für den TW-Modus dienen. Geben Sie es folgendermaßen ein:

TODO

Wenn wir dieses kleine Programm abarbeiten, müßte das X-Register auf »0« stehen, während Akku und Y-Register mit »4« geladen sind. Starten wir also das Programm mit »G 5000« und schauen uns die Register an.

Seltsamerweise enthalten alle Register eine »0«. Vorsichtig, wie wir sind, überschreiben wir die drei Register mit »FF«, um die Veränderung deutlich kontrollieren zu können.

Dann starten wir mit »G 5000« ein zweites Mal. Gegen alle Gesetze der Vernunft erscheint wieder das »falsche« Ergebnis — alle drei Register sind »0«. Hier soll uns jetzt der TW-Modus weiterhelfen, indem er uns zeigt, was in Wirklichkeit passiert.

Geben wir »TW 5000« ein. Der erste Befehl (LDA #00) ist durchgeführt, im Akku erscheint die Null. Jetzt steht der Programmzähler auf dem folgenden Befehl »5002 TAX«. Nach Drücken einer Taste wird dieser Befehl ausgeführt und es erscheint die Null im X-Register. Beim folgenden Befehl müssen wir feststellen, daß der Disassembler nicht in der Lage ist, ihn zu interpretieren — er gibt drei Sternchen aus. Hierbei handelt es sich um unser Byte »00«.

Wieder ein Tastendruck; und dann erkennen wir, daß etwas Merkwürdiges passiert ist. Der Prozessor hat augenscheinlich den nächsten Befehl (LDA #04) übersprungen und steht schon auf dem folgenden »TAY«. So also wird unser Programm abgearbeitet. Damit ist auch das »falsche« Ergebnis erklärt. Bleibt nur noch die Frage nach dem Grund für dieses seltsame Verhalten. Und der ist sicherlich in dem mysteriösen Byte »OC« zu suchen. Hierbei handelt es sich um einen der »inoffiziellen« Opcodes (auch Pseudo-Opcodes genannt), die aufgrund der Prozessorarchitektur vorhanden sind und in manchen Programmen ihr Unwesen treiben — wie wir zu unserem Leidwesen erfahren mußten. Das Byte »OC« wirkt wie ein »NOP«, der eine Länge von 3 Byte hat. Deshalb wird der folgende 2-Byte-Befehl (LDA #04) verschluckt.

Es gibt noch einiges zu entdecken am 6502 und 6510 — TW macht’s möglich.

Häufig ist es nicht sinnvoll, ein Programm von Anfang an im TW-Modus laufen zu lassen. Zum anderen sind gerade Schleifen, die per Hand mit >TW« durchlaufen werden müssen, eine ermüdende Angelegenheit. Hier bietet SMON neben dem bereits beschriebenen »TS« eine weitere Trace-Möglichkeit an:

### Trace Break

TB (Adresse Anzahl der Durchläufe)

### Trace Quick

TQ (Adresse)
Geben Sie als Beispiel folgendes Programm ein:

TODO

Bei $600E soll nun ein Text stehen, den das Programm ausgibt. Die einfachste Art, mit SMON Texte in den Speicher zu schreiben, besteht im »K«-Befehl. Geben Sie K600E ein (danach natürlich Return) und drücken Sie die STOP-Taste. Fahren Sie mit dem Cursor an das erste ausgegebene Zeichen (vermutlich ein Punkt) und schreiben Sie — ohne Anführungszeichen:
»FEHLER BEHOBEN«

Drücken Sie dann Return, um die Zeile an den Rechner zu übergeben. Wenn Sie das Programm starten, werden Sie wieder einmal Gelegenheit haben, sich in Ruhe etwas zu trinken zu holen (Prost!), denn das Programm enthält einen dummen Fehler und beschäftigt den Computer für eine lange, lange Zeit. Genauer gesagt, bis Sie ihn mit Reset (zum Beispiel durch RUN/STOP-RESTORE) erlösen.

Nun soll SMON helfen, diesen Fehler zu lokalisieren. Setzen Sie zuerst einmal einen Breakpoint bei $6002 und begrenzen die Durchläufe auf die maximale Anzahl:

TB 6002 0E und starten mit TQ 6000 den Quicktrace bei $6000: Das Programm läuft so lange, bis zum 14. Mal die Adresse $6002 erreicht wird und springt dann in den TW-Modus. Wenn Sie sichjetzt die Registerinhalte genau anschauen, müßte ihnen der Fehler geradezu ins Auge springen. Wie groß sollte denn das Y-Register sein? Welchen Wert sollte der Akku haben? NA?! (Auflösung erfolgt mit der Bekanntgabe der Gewinner des großen Preisausschreibens aus dem letzten Heft...)

Wenn Sie eine Zeitlang mit SMON gearbeitet haben, werden Ihnen eventuell einige Voreinstellungen nicht gefallen. Besitzer einer Datasette zum Beispiel müssen jedesmal mit »101« auf ihre Geräteadresse einstellen. Wenn Sie sich an unserem »Preisauschreiben« vom letzten Mal beteiligt haben, dürften Ihnen diese Speicherstellen bereits bekannt sein. Übrigens sind zirka 235.982 richtige Lösungen eingegangen; wir haben daraufhin ein Programm geschrieben, um den Gewinner zu ermitteln. Dieses läuft zur Zeit auf einem Großrechner in den USA, da der Speicher des C 64 nicht ausreichte. Wir werden Sie nach Abschluß des Programmlaufes, den wir für Mitte Juni dieses Jahres erwarten, informieren....

Sollten Sie nicht zu den glücklichen Gewinnern zählen, geben wir Ihnen im folgenden die Speicherstellen an, in denen die Voreinstellungen stehen. Diese können Sie dann mit dem »M«-Befehl Ihren Wünschen entsprechend abändern.

Vergessen Sie aber nicht, Ihre geänderte Version mit »S "@:SMON $C000” C000 CE09« abzuspeichern.
Hintergrund-Farbe	$C220
Schreibfarbe	$C228
Ger. Adr. Drucker	$C21B
Ger. Adr. F1/Cass	: $C216

### Wer steht wo ? — Wegweiser durch SMON

Wollen Sie Routinen in SMON analysieren oder verändern, müssen Sie die Einsprungadressen der einzelnen Befehle kennen. Diese lassen sich leicht finden:

Am Anfang des Programms (ab $COOB) befindet sich eine Liste aller Kommandos gefolgt von den Adressen (ab $C02B), bei denen diese Befehle beginnen. Lassen Sie sich mit »M COOB C02B« die Befehlsliste anzeigen (siehe Bild 1). Sie sehen, daß am Ende 5 Nullen stehen; hier können Sie eigene neue Befehle einbauen. Mit »M C02B C06B« erhalten Sie die Liste der Einsprungadressen, immer in der Reihenfolge Low-Byte — Hig-Byte, diesmal mit 10 Nullen am Ende, weil ja zu jedem Befehl 2 Byte für die Adresse gehören.

Wir wollen nun als Beispiel heraussuchen, wo die Routine zum Füllen eines Speicherbereichs mit einem vorgegebenen Byte steht. Der Befehl dazu ist »O«, also der 20. Befehl ($CO1E). Die zugehörige Adresse ist ebenfalls die 2Ö. in der Liste also $C9C0 (in Speicherstelle $C051/$C052). Die Routine beginnt allerdings immer erst ein Byte später, in unserem Fall also bei $C9C1.

Disassemblieren Sie jetzt diese Routine mit »C C9C1 C9D3«. Sie erhalten folgende Befehle (natürlich ohne Kommentare):

TODO

Wenn Sie nun zum Beispiel den »O«-Befehl nur zum Löschen verwenden möchten, könnten Sie die Routine so abändern, daß nur die beiden Adressen eingegeben werden müssen. Überschreiben Sie einfach den Befehl JSR C28D mit LDA # 00 im Disassemblerlisting, disassemblieren Sie erneut mit »D C9C1 C9D3« und überschreiben Sie die drei Sternchen bei C9C6 mit einem »NOP«, um die entstandene Lücke (3-Byte-Befehl wurde durch 2-Byte-Befehl ersetzt) aufzufüllen. Nun können Sie Ihre veränderte Routine ausprobieren. Geben Sie zum Beispiel »O 5000 5200« ein und überzeugen Sie sich mit »M 5000 5200« von der korrekten Ausführung. Sie können auch die so veränderte Routine mit »W C9C1 C9D3 CE09« ans Programmende kopieren und sich einen neuen Befehl »E« (Erase) schaffen. Sie brauchen dann nur in die erste Null am Ende der Kommandotabelle »45« (für »E«) und in die ersten beiden Nullen der Adreßtabelle »08« und »CE« zu schreiben (für die Adresse $CE09).

Machen Sie sich ruhig einmal die Mühe, auch andere Routinen im SMON auf diese Art und Weise zu analysieren und zu ändern. Erstens macht es Spaß und zweitens können Sie SMON Ihren eigenen Wünschen anpassen. Vielleichtfallen Ihnen ja noch Routinen ein, die in SMON fehlen. Wir würden uns über Verbesserungsvorschläge freuen.

## Das »Gedächtnis« von SMON

Wenn Sie Programme mit SMON untersuchen oder verändern wollen, müssen Sie noch wissen, welche Speicherstellen SMON verwendet. Es soll ja Monitorprogramme geben, die die Basic-Zeiger als Arbeitsspeicher benutzen, so daß ein Basic-Programm nach dem Rücksprung aus dem Monitor gelöscht ist. SMON tut so etwas nicht. Aber natürlich braucht er auch Speicherstellen, um sich Werte merken zu können. Damit Sie Konflikten von Anfang an aus dem Wege gehen können, sind die wichtigsten hier dargestellt.

In der Zeropage belegt SMON den Bereich von $00A4 bis $00B6. Dort stehen Systemvariable für die Kassettenspeicherung und die RS232-Schnittstelle. Diese werden nur während des Betriebs der Kassette oder von RS232 gebraucht, sind ansonsten aber frei. Außerdem werden die Speicherstellen $OOFB bis $OOFF benutzt, die sowieso zur freien Verfügung des Anwenders vorgesehen sind. Alle anderen Zeiger in der Zeropage, also insbesondere die Speicherverwaltung für Basic bieiben unbeeinflußt.

Als weiteren Arbeitsspeicher benutzt SMON den Bereich von $02A8 bis $02C0. Auch dieser Bereich wird vom Betriebssystem nicht benutzt, so daß keine Konflikte entstehen dürften. Beim Assemblieren wird zusätzlich noch der Kassettenpuffer als Speicher für die Labels benötigt. Dieser bleibt ansonsten aberauch unverändert; das istwichtig, wenn Maschinenroutinen dort abgelegt werden sollen.

Alles in allem ist SMON also recht verträglich.

## SMON verschieben? — Mit SMON!

Eine Reihe von Anfragen hat uns erreicht, ob man SMON nicht mit Hilfe des »W«-, »V«- oder »C«-Kommandos verschieben könne. Alle Versuche in dieser Richtung seien fehlge-schlagen. Einige Leser meinten auch, in der V-Routine müsse ein Fehler stecken. Diesmal sind wirjedoch völlig schuldlos; es gibt nämlich einige Befehle in SMON, die keine Sprungadressen sind und sich trotzdem auf den Bereich ($C000-) beziehen, in dem SMON steht.

Dazu gehören in erster Linie die oben erwähnten Einsprungadressen, deren High-Byte natürlich geändert werden muß, wenn SMON in einem anderen Speicherbereich laufen soll. Es gibt aber auch Befehle, die eine Adresse im Programm in einem Vektor ablegen müssen. Disassemblieren Sie einmal den Anfang von SMON mit »D C000 COOB«. Sie erhalten

TODO

Damit wird der Break-Vektor des Betriebssystems auf den SMON gesetzt und mit dem anschließenden — und jedem weiteren BRK-Befehl—springt das Programm in SMONs BREAK-Routine. Wenn SMON in einem anderen Bereich als $C000 laufen soll, dann müssen diese Befehle geändert werden. Heraussuchen kann man sie mit »FIC*,COOO D000«. Sie wissen doch noch, was diese Anweisung bedeutet: Suche mir alle Befehle, die ein Register unmittelbar mit einem Wert laden, der mit $C beginnt. Aber Vorsicht! Nicht alles, was da angezeigt wird, muß auch geändert werden! Um Ihnen weitere Stunden sinnlosen Herumbrütens zu ersparen, wollen wir als Beispiel zeigen, wie man SMON in den Bereich $9000 bis $A000 verlegen kann. Natürlich geht das im Prinzip für jeden anderen Bereich genauso; wir selbst haben insgesamt fünf SMON-Versionen für fünf verschiedene Speicherbereiche, von denen eine immer paßt.

1.	Wir verschieben zuerst das ganze Programm ohne Umrechnen in den neuen Bereich:<br>W C000 CE09 9000
2.	Nun lassen wiralle absoluten (3-Byte) Befehle umrechnen. Die Tabellen am Anfang von SMON bleiben verschont:<br>V C000 CE09 9000 9214 9E09
3.	Als nächstes ändern wir die High-Bytes der Befehlsadressen. Geben Sie<br>M 902B 906B<br>ein und ändern Sie in jedem zweiten Byte das »C« durch Überschreiben in »9«. Vergessen Sie nicht, am Ende jeder Zeile »Return« zu drücken, damit Ihre Änderung auch übernommen wird.
4.	Als letztes bleiben noch die oben beschriebenen Direktlade-Befehle. Sie müssen so geändert werden, daß sie sich auf den neuen Bereich $9... beziehen. Suchen Sie sie mit<br>FIC*,9000 9E09<br>heraus. Sie erhalten

TODO

Ändern Sie nur in den gekennzeichneten Zeilen das »C« in »9« um. Sie sehen, es gibt keine Regel, welche Befehle zu ändern sind und welche nicht. Aus diesem Grunde müssen Sie diese Änderungen »von Hand« vornehmen.

Speichern Sie jetzt die fertige Version unbedingt mit »S ”SMON $9000” 9000 9E09« ab. Nun starten Sie die 9000-Version mit »G 9000« oder von Basic aus mit SYS 36864 (SYS 9 x4 096). Löschen Sie dann den alten SMON mit »O C000 D000 00«. Nur so können Sie sicher sein, daß der verschobene SMON auch einwandfrei arbeitet und Sie nichts übersehen haben.

Probieren Sie nun alle Befehle durch. Sie müssen genauso arbeiten wie bisher. Vor allem können Sie jetzt auch Programme wie »DOS 5.1« oder »Turbo Tape« untersuchen, die im $COOO-Bereich stehen. Achten Sie aber, wenn Sie »SMON $9000« von Basic aus benutzen, darauf, daß das Basic ihn nicht überschreibt. String-Variable werden nämlich von $A000 nach unten hin aufgebaut und bis $9E09 ist nicht viel Platz. Schützen Sie im Zweifelsfalle den Bereich, indem Sie nach dem Laden des SMON $9000 eingeben:
NEW : POKE 56,144 : POKE 55,0

Damit ist SMON vor Überschreiben geschützt. Das ist natürlich bei dem SMON $C000 nicht nötig, weil Basic in diesen Bereich nicht hineinkommt.

Zunächst wieder ein Geständnis: Leider hat uns der Druckfehlerteufel auch in der Dezember-Ausgabe wieder erwischt, aber der arme Kerl will ja schließlich auch seinen Spaß haben. Verzeihen Sie ihm und uns

— daß er im Listing in Zeile 150 ein REM eingeschummelt hat, das dort überhaupt nichts zu suchen hat. Es verhindert nämlich, daß die Checksumme geprüft wird und Eingabefehler erkannt werden.
— daß er auf Seite 62 fälschlich behauptet hat, die »LOAD«-Routine beginne bei $C84F. In Wirklichkeit beginnt Sie bei $C84E.
— daß er auf Seite 63 bei den Hinweisen in eigener Sache empfiehlt, man möge bei»... Error in 40« (oder in 70) die DATAs kontrollieren. Natürlich tritt der Fehler nicht in den REM-Zeilen, sondern in Zeile 140 oder 180 auf.
— daß er schließlich schon vorgearbeitet hat und in der Januar-Ausgabe sein schändliches Handwerk getrieben hat. Dort steht bei der Beschreibung des 16-Bit-Vergleichs, das Zero-Flag sei gesetzt, wenn beide Werte gleich seien. Das stimmt auch, aber Sie wissen ja selbst, wo der Teufel steckt, nämlich im Detail, und der Druckfehlerteufel macht da keine Ausnahme. Er verführt uns nämlich zu dem eigentlich logischen Schluß, man könne auf die beschriebene Art und Weise prüfen, ob zwei 16-Bit-Werte gleich sind. Und genau das geht nicht. Das Zero-Flag hat nämlich die unangenehme Eigenschaft, auch dann gesetzt zu sein, wenn der erste Wert bis zu 255 größer (!) ist als der zweite. Will man also zuverlässig auf Gleichheit testen, muß man die beiden Werte voneinander abziehen und nachsehen, ob das Ergebnis Null ist.

## Hinweise zum Abtippen

Wir geloben Besserung und als Zeichen tätiger Reue haben wir Ihnen das Eintippen der DATAs leichter gemacht. An anderer Stelle in diesem Heft finden Sie das Programm »MSE«. Damit ist ein Vertippen nahezu ausgeschlossen, und schneller und bequemer geht’s obendrein auch noch. Sie finden also auf der nächsten Seite nicht mehr den gewohnten Basic-Lader, sondern statt dessen eine Art Hexdump, das Sie mit »MSE« eintippen können. Wie das genau geht, erfahren Sie in dem zugehörigen Artikel. Nach Beendigung der Tipparbeit speichern Sie Ihr Werk ab. Laden Sie nun das SMON-Maschinenprogramm vom letzten Mal und starten Sie es mit SYS 49152. Hängen Sie den neuen Teil mit
»L ”SMON TEIL 4”«
dahinter und speichern Sie das Ganze mit
S "@:SMON $0000” C000 CE09«
wieder ab. Sie haben dann das vollständige Programm (15 Blöcke auf der Diskette) zur Verfügung.

Wir hoffen, Ihnen mit SMON ein wirklich brauchbares Werkzeug an die Hand gegeben zu haben. Die vielen Zuschriften und Anrufe, die wir im Verlauf dieser Serie erhalten haben, bestätigen uns in dieser Auffassung. Viele Leser sind nach unserem Eindruck dabei, in die Maschinensprache einzusteigen und deren Möglichkeiten zu nutzen. Und genau das wollten wir erreichen.

Damit wären wir eigentlich am Ende dieser Serie angelangt und würden uns mit den üblichen guten Wünschen verabschieden. Aber die freien Bytes am Ende von SMON, immerhin von $CE09 bis $D000, also über 500 Byte, haben uns keine Ruhe gelassen. Als »Zugabe« werden wir Ihnen deshalb in der nächsten Ausgabe noch einen kleinen Diskettenmonitor vorstellen, der, in SMON eingebunden, dessen Möglichkeit nutzen kann.

(N. Mann/D. Weineck/gk)

### Hinweise zu Bild 1

Alle Eingaben erfolgen in der hexadezimalen Schreibweise. In Klammern angegebene Adreßeingaben können entfallen. SMON benutzt dann sinnvolle vorgegebene Werte. Bei allen Ausgabe-Befehlen ist gleichzeitig die Ausgabe auf einen Drucker möglich. Dazu werden die Befehle geSHIFTet eingegeben.

<figure>
Bild 1. SMON-Befehlsubersicht
— A 4000 (Assembler)
symbolischer Assembler (Verarbeitung von Labels möglich) Startadresse $4000
— B 4000 4200 (Basic-DATA)
erzeugt Basic-DATA-Zeilen aus Maschinenprogramm im Bereich von$4000-$41FF
— C 4010 4200 4013 4000 4200 (Convert)
in ein Programm, das von $4000 - $4200 im Speicher steht, soll bei $4010 ein 3-Byte-Befehl eingefügt werden. Dazu wird das Programm ab $4010 - $4200 auf die neue Adresse $4013 verschoben. Alle absoluten Adressen, die innerhalb des Programmbereichs ($4000 - $4200) stehen, werden umgerechnet, so daß die Sprungziele stimmen.
— D 4000 (4100) (Disassembler)
disassembliert den Bereich von $4000 (- $4100) mit Ausgabe der Hex-Werte. Änderungen sind durch Überschreiben der Befehle möglich.
- F (Find)
findet Zeichenketten (F), absolute Adressen (FA), relative Sprünge (FR), Tabellen (FT), Zeropageadressen (FZ) und lmmediate-Befehle (Fl)
— G (4000) (Go)
startet ein Maschinenprogramm, das bei $4000 im Speicher beginnt.
— I 01 (l/O-Gerät)
stellt die Gerätenummer für Floppy (08 oder 09) oder Datasette (01) ein.
— K A000 (A500) (Kontrolle)
zum schnellen Durchsuchen des Bereichs von $A000 (-$A500) nach ASCII-Zeichen (32 Byte pro Zeile). Änderungen sind durch Überschreiben der ASCII-Zeichen möglich.
— L (4000) (Load)
lädt ein Maschinenprogramm an die richtige oder eine angegebene Adresse ($4000)
— M 4000 (4400) (Memory-Dump)
gibt den Inhalt des Speichers von $4000 (- $43FF) in Hex-Bytes und ASCII-Code aus. Änderungen sind durch Überschreiben der Hex-Zahlen möglich.
— 0 4000 4500 AA (Occupy)
füllt den Speicherbereich von $4000 - $4500 mit vorgegebenem Byte ($AA) aus
— P 02 (Printer)
setzt Geräteadresse 2 für Drucker
— R (Register)
zeigt die Registerinhalte und Flags an. Änderungen sind durch Überschreiben möglich.
— S ’’Test” 4000 5000 (Save)
speichert ein Programm von $4000 - $4FFF unter dem Namen ’Test’ ab
— TW (4000) (Trace Walk)
führt auf Tastendruck den jeweils nächsten Maschinenbefehl aus und zeigt die Registerinhalte an. Subroutinen können in Echtzeit durchlaufen werden (J’). Wird keine Startadresse eingegeben, beginnt ’TW’ bei der letzten mit ’R’ angezeigten Adresse.
— TB 4010 05 (Trace Break)
setzt einen Haltepunkt für den Schnellschrittmodus bei $4010. Der Schnellschrittmodus wird unterbrochen, nachdem $4010 zum 5. Mal erreicht worden ist.
— TQ 4000 (Trace quick)
Schnellschrittmodus, springt beim Erreichen eines Haltepunktes in den Einzelschrittmodus.
— TS 4000 4020 (Trace stop)
arbeitet ein Programm ab $4000 in Echtzeit ab und springt
beim Erreichen von $4020 in die Registeranzeige. Von dort aus kann (nach evtl. Änderung der Register) mit »G« oder »TW« fortgefahren werden. »TS« arbeitet nur im RAM-Speicher.
— V 6000 6200 4000 4100 4200 (Verschieben)
ändert in einem Programm von $4100 - $41FF alle absoluten Adressen, die sich auf den Bereich von $6000 - $6200 beziehen, auf einen neuen Bereich, der bei $4000 beginnt.
— W 4000 4300 5000 (Write)
verschiebt den Speicherinhalt von $4000 -$42FF nach $5000 ohne Umrechnung der Adressen (zum Beispiel Tabellen)
- X (Exit)
springt aus dem Monitor-Programm ins Basic zurück
— # 49152
Dezimalzahl umrechnen
— $ 002B
4-stellige Hex-Zahl umrechnen
— % 01101010
8-stellige Binärzahl umrechnen
— ? 0344 + 5234
Addition oder Subtraktion zweier 4-stelliger Hex-Zahlen
— = 4000 5000 (Vergleich)
vergleicht den Speicherinhalt ab $4000 mit dem ab $5000.
</figure>

# Q + Bert

> Die VC 20-Version des bekannten Spielhallenhits. Nur besteht diese Variante aus drei verschiedenen Bildern.

Ziel des Spieles ist es, genau wie im bekannten Original, sämtliche Felder der Pyramide umzufärben. Das erreicht man, indem man einfach auf die noch unbeschränkten Felder springt. Damit es nicht zu einfach wird, ist noch eine Schlange mit im Spiel, mit der man nicht in Kontakt kommen darf. Wenn man es geschafft hat, alle Felder umzufärben, ohne die Schlange zu berühren, gelangt man in die nächste Pyramide. Nachdem auch die dritte Pyramide bewältigt ist, wechseln die Farben, und man fängt wieder mit der ersten Pyramide an, diesmal jedoch mit einem höheren Schwierigkeitsgrad.

Q + Bert wird mit folgenden Tasten gesteuert:
A — für einen Sprung nach links oben
F — für einen Sprung nach rechts oben
C — für einen Sprung nach links unten
Z — für einen Sprung nach rechts unten

Diese Steuerung ist etwas gewöhnungsbedürftig, eine Routine zur Abfrage des Joysticks hätte den Programmablauf jedoch stark verlangsamt. Außerdem können die Tasten in den Zeilen 320 bis 350 leicht geändert werden.

Bei den ersten beiden Pyramiden muß keine besondere Strategie angewendet werden. Zu beachten ist lediglich, daß man sich nur an der Schlange vorbeibewegen kann, nachdem sie aufgeblinkt hat. Weiter ist es hilfreich zu wissen, daß die Schlange sich nur dann bewegt, wenn sowohl deren X-Position als auch deren Y-Position nicht mit der eigenen X-Position beziehungsweise Y-Position übereinstimmt. In der dritten Pyramide kann man sich nicht an der Schlange vorbeimogeln. Aus diesem Grund muß man zuerst alle Felder umfärben, auf die die Schlange nicht gelangen kann und sie dann auf die umgefärbten Felder locken. Danach können die restlichen Felder umgefärbt werden.

Falls das Spiel so zu leicht erscheint, kann in Zeile 580 der Schwierigkeitsgrad erhöht werden, indem »S*2« durch »S*3« ersetzt wird.

(Oliver Pabst/ev)

# Gehirntraining mit Supermemory

> Den Schwierigkeitsgrad dieses kniffligen Denkspieles können Sie selbst bestimmmen. Doch Vorsicht! Es ist nicht so einfach wie es aussieht.

»Super Memory« ist ein Denkspiel für eine Person, die gegen sich selbst spielt. Aufgabe des Spielers ist es, Zahlen in einem 3 x 3-Kästchen großen Feld so zu ändern, daß sie zum Schluß alle den gleichen Wert haben. Die Schwierigkeit besteht nun darin, daß nur bestimmte Zahlengruppen verändert werden können. Diese insgesamt 9 Zahlengruppen können außerdem nur um einen Wert erhöht werden.

Wenn Sie das Programm starten, erscheint als erstes ein kleiner Vorspann mit der Anleitung zu dem Spiel. Nach dem Drücken einer Taste fragt Sie der Computer welche Zahl zum Schluß in den Kästchen stehen soll. Diese Zahl kann zwischen null und neun liegen. Angenommen Sie drücken nun die Zahl Acht (RETURN), fragt Sie der Computer als nächstes wieviele Schritte Sie minimal benötigen sollen, damit im Anzeigenfeld nur Achten stehen. Sie können nun einen bis unendlich viele Schritte angeben. Geben Sie nun als Beispiel eine Eins an (was die niedrigste Schwierigkeitsstufe bedeutet) erscheint nach einer ganz kurzen Denkpause des Computers das Spielfeld. Sie sehen nun in blauer Farbe die neun Zahlengruppen und die Buchstaben die ihnen zugeordnet sind. Der Buchstabe G bedeutet nun zum Beispiel, daß alle Zahlen in dem Feld, die dem Buchstaben G zugeordnet sind, um eins erhöht werden.

Da Sie bei dem Menüpunkt Schritte eine Eins angegeben haben, sind nun im Feld einige Siebener. Diese Siebener stehen in einem bestimmten Muster. Dieses Muster muß auch eines von den Blauen sein! Haben Sie dieses gefunden, drücken Sie die Taste die davor steht. Wenn die beiden Muster gleich waren, haben Sie gewonnen. Der Computer fragt Sie nun noch ob Sie noch ein Spiel spielen wollen. Spielen Sie noch eins! Tippen Sie nun bei »Anzahl der Schritte« eine Zwei ein, benötigen Sie schon zwei Schritte bis alle Zahlen im Feld gleich sind. Wie Sie sehen wird es nun bereits schwieriger. Durch Drücken der F1-Taste können Sie während des Spiels ein neues beginnen. Durch Drücken der F7-Taste können Sie bei einem laufenden Spiel alle Schritte zurücksetzen.

(Bernd Arnold/rg)

# Cursorsteuerung leicht gemacht

> Bei professionellen Programmen der PC-Klasse kann der Cursor meist über Eingabegeräte wie die Maus positioniert werden. Daß es auch recht gut mit dem Joystick und dem C 64 funktioniert, beweist dieses Programm.

Haben Sie den kurzen MSE-Lader eingetippt und gestartet, können Sie den Cursor mit einem Joystick in Port 2 steuern. Das Steuerprogramm befindet sich ab Adresse $C000 bis $C066 im Speicher. Die ersten 15 Bytes nimmt eine Initialisierungsroutine in Anspruch, die den Interruptvektor auf $C00F legt und das Steuerprogramm in den Kernalinterrupt einbindet. Die Routine wird mit SYS 49152 aufgerufen. Das Programm benutzt Speicherzelle $02 als Zählregister, da der Joystick nur bei jedem sechsten Interrupt abgefragt wird. In Zeile 300 des Assemblerlistings wird die Zählvariable um 1 erniedrigt. Ist die Variable 0, wird sie auf 6 gesetzt und in die Steuerungsroutine verzweigt. Ab Zeile 360 wird der Tastaturpuffer auf freien Platz überprüft. Sollte der Puffer voll sein, wird sofort in die Interruptroutine des Betriebssystems ($EA31) gesprungen. In Zeile 400 wird der Joystick abgefragt und das entsprechende Cursorsteuerzeichen in den Akku geladen. Ab 800 wird das Zeichen in den Tastaturpuffer geschrieben und der Pufferzeiger erhöht.

(P.Siepen/hm)

# Basic-Zeilen genau betrachtet

> Wenn Sie eine Basic-Zeile eingeben und anschließend RETURN drücken, legt der Interpreter die Zeile im Speicher ab. Will man Basic-Zeilen durch ein Maschinenprogramm erzeugen oder in einem Basic-Programm nach bestimmten Befehlen suchen, muß man wissen, wie und wo Basic-Zeilen gespeichert sind.

In den Speicherzellen 43/44 steht die Anfangsadresse des Basic-Speichers. Die Adresse, bei der Basic beginnt, erfahren Sie durch die Abfrage PRINT PEEK(43) + 256 * PEEK(44). Sie erhalten den Wert 2049. Das ist die Adresse, ab der die erste Basic-Zeile vom Interpreter gespeichert wird. Wie Basic-Zeilen im Speicher vorliegen, soll am folgenden Beispielprogramm erläutert werden.
10 Print "PROBE”
300 REMC-64
1200 A$ = ”A = A”
50000 END

Bild 1 und 2 zeigen, wie der Interpreter diese vier Basic-Zeilen ab der Adresse 2049 speichert. Die Werte in Klammern sind die Startadressen der einzelnen Basic-Zeilen und dienen nur dem besseren Überblick. Alle Werte sind dezimal und hexadezimal angegeben.

Die ersten beiden Bytesjeder Zeile heißen Linkpointer oder einfach Verbindungszeiger, manche sprechen auch von Koppeladressen. Der Wert dieser beiden Bytes entspricht immer der Startadresse der nächsten Zeile. Das erste Byte ist das Low- und das zweite das High-Byte der Adresse. In Bild 1 ergeben die ersten 2 Byte der ersten Zeile den Wert 15+8x256 = 2063, alsodieAdresse, beiderdiezweite Zeile beginnt. Der Linkpointer der vierten Zeile (47+8x256) zeigt auf die Speicherstelle 2095. Die beiden Null-Codes in 2095 und 2096 (der Linkpointerderfünften Zeile) signalisieren dem Interpreter das Programmende.

Byte 3 und 4 jeder Zeile ergeben die Zeilennummer der jeweiligen Basic-Zeile. In der ersten Zeile ergeben diese 2 Byte 10 + 0 x 256 = 10.

Im Beispielprogramm steht, nach dem Linkpointer und der Zeilennummer, als fünftes Byte, das Token für PRINT (99). Um Speicherplatz zu sparen und eine schnelle Programmabarbeitung zu erzielen, werden alle Basic-Befehle (PRINT, REM, END,...) in nur 1 Byte übersetzt. Ein 1-Byte-Befehlswort heißt Token. Der Interpreter holt sich die Information, welches Token einem bestimmten Befehlswort entspricht, aus einer Zuordnungstabelle im ROM. Die Tabelle beginnt ab Adresse 41118 ($A090). Bild 3 zeigt einen Überblick über alle Basic-Befehle und deren Token. Die Leerstelle nach der Zeilennummer, die nach dem LIST-Befehl am Bildschirm zu sehen ist, wird nicht berücksichtigt. Die Leerstelle zwischen PRINT und dem Anführungszeichen steht als ASCII-Code 32 im sechsten Byte. Auf die gleiche Weise werden das Anführungszeichen, das Wort PROBE und das Schlußzeichen im ASCII-Code gespeichert. Das Beispiel zeigt, daß der Interpreter alle Zeichen, außer Befehlswörtern, im ASCII-Code speichert. Das gilt auch für Befehlswörter in Anführungszeichen (’’PRINT”). Diese Unterscheidung können Sie in der dritten Zeile deutlich erkennen. Das erste Gleichheitszeichen stuft der Interpreter als Operatorein (Token 178, $B2), dasGleichheitszeichen in Anführungsstrichen als ASCII-Code 61 ($3D). Eine Aufstellung der ASCII-Codes finden Sie Ihrem Handbuch zum C 64 auf Seite 135.

Das Ende jeder Programmzeile ist durch eine Null markiert. Der Interpreter erkennt daran das Zeilenende und nimmt sich die nächste Zeile vor. Enthalten die beiden Bytes für den Linkpointer Null-Codes, ist für den Interpreter das Programm zu Ende. Im Beispiel sind es die Adressen 2095 und 2096 ($082F, $0830).

## Mehr Verständnis für den NEW-Befehl

lm Handbuch steht, daß NEW das Programm im Speipher löscht. Das ist nur bedingt richtig, denn der NEW-Befehl löscht nicht das ganze Programm, sondern schreibt nur zwei Null-Codes in die Speicherstellen 2049 ($801) und 2050 ($802). Sie können das mit einem Monitor, zum Beispiel dem SMON, überprüfen. Außerdem werden die Zeiger für Variablenanfang, Feldanfang und Feldende auf die Adresse 2051 gesetzt.
Zum Beweis dieser Aussage sollten Sie einmal das Beispielprogramm eintippen und die folgenden Direktbefehle eingeben.
NEW
POKE 2049,15
POKE 2050,8 Linkpointer
POKE 45,49
POKE 46,8 Variablen-Anfang
POKE 47,49
POKE 48, 8 Feld-Anfang
POKE 49,49
POKE 50,8 Feld-Ende
LIST

Die Werte für den ersten Linkpointer und die Variablenzei-ger werden mit diesen acht POKE-Befehlen wieder hergestellt. Sie gelten nur für dieses Beispielprogramm. Geben Sie nach NEW eine neue Basic-Zeile ein, dann kann das gelöschte Programm nicht mehr gerettet werden.

Wenn Sie nun am Ende dieses Satzes drei Nullen finden, dann wissen Sie
a)	der Satz ist zu Ende und
b)	der Artikel ist zu Ende.
000

(J.Effenberg/hm)

# Als die Bilder laufen lernten ...

> Zaubern Sie Bewegung auf Ihren Bildschirm! Mit diesem Programm können Sie bequem Blockgrafik und Text in frei definierbaren Bildschirmbereichen scrollen. Und das in vier Richtungen.

Mit einem einzigen 8YS-Befehl wird sowohl der Zeichen- als auch der Farbcode gescrollt. Dabei können Sie die Größe und Lage des Scrollbereiches frei wählen. Wenn Zeichen aus einem Bereich hinausgeschoben werden, tauchen Sie an der gegenüberliegenden Seite wieder auf.

Mit SYS 50550,r,za,ze,s,l wird das Maschinenprogramm aufgerufen. Dabei werden Parameter für Richtung (r), Zeilenanfang (za), Zeilenende (ze), Spalte (s) und Zeilenlänge (I) übergeben. Die Parameter müssen innerhalb der Grenzen von Bild 1 liegen. Angaben außerhalb dieser Grenzen fängt das Programm ab und gibt die entsprechende Fehlermeldung aus.

Listing 2 ist ein Demo-Programm, das Ihnen die verblüffende Wirkung des Scrollens in vier Richtungen zeigt.

(J. Effenberg/hm)

# Besseres Monitorbild beim C 64

> Mit dieser kleinen Bauanleitung läßt sich die Bildschirmwiedergabe des C 64 auf einem monochromen Monitor wesentlich verbessern.

Nachdem ich einen monochromen Monitor (zirka 300 Mark, 15 MHz, grün) an die Videobuchse (Luminanzsignal) meines C 64 angeschlossen hatte, konnte ich das Testergebnis der Ausgabe 12/84 nur bestätigen, »daß es nicht so einfach ist, dem Commodore 64 ein klares und kontrastreiches Bild zu entlocken«.

Da bekanntermaßen ein Signal (auf dem Monitor) nur so gut abgebildet werden kann, wie es von der Quelle (C 64) ausgesendet wird, untersuchte ich mit Hilfe eines Oszilloskops die Signalverläufe innerhalb der Modulator- beziehungsweise Videoschaltung. Dabei stellte ich fest, daß der vom VIC ll-Chip unter anderem bereitgestellte Zeileninhalt in der Videostufe durch einen Tiefpaß auf wenige MHz begrenzt wird. Das hat zur Folge, daß die Ränder der auf dem Monitor dargestellten Zeichen oder Punkte nur unscharf abgebildet, und die horizontalen Bildanteile (insbesondere bei Grafik) stark überbetont werden.

Überraschenderweise fand ich bei weiterem Durchmessen der Videostufe einen Meßpunkt (Punkt »A« in der Skizze), an dem das vollständige Videosignal (FBAS) mit nicht begrenzter Bandbreite vorliegt, und der mit dem niederohmigen Eingang (75 Q) des Monitors belastet werden darf.

Unter der Voraussetzung, daß die vier vorhandenen Abgleicheinrichtungen nicht verstellt werden (Punkte »B« in der Skizze) und die Garantieansprüche unter Umständen durch diesen Eingriff verfallen, kann das Monitorbild des Commodore 64 folgendermaßen verbessert werden:

* Öffnen des C 64-Gehäuses mit den auf der Computerrückseite vorhandenen drei Schrauben.
* Entfernen der Abschirmpappe und Abziehen der Tastaturund LED-Leitungen.
* Lösen des Lötpunktes »C« bei gleichzeitigem Abheben des Modulatorgehäusedeckels.
* Anlöten des Innenleiters eines handelsüblichen, abgeschirmten Kabels an der mit »A« gekennzeichneten Stelle. Diese befindet sich zur Kontrolle zwischen einem 120 Q und 180 Q Widerstand.
* Anlöten der Kabelabschirmung an der Gehäuseinnenwand. • Durchführen des Koaxialkabels durch die Öffnung »D« im Gehäusedeckel sowie durch eine der Öffnungen auf der Rechnerrückseite.
* Anlöten eines handelsüblichen Cinch-Steckers am Ende des zirka 1 m bis 2 m langen Koaxkabels.
* Schließen und Verlöten des Modulatordeckels, Aufstecken der abgezogenen Leitungen und Zusammenbau des C 64.

Um ein möglichst kontrastreiches Bild zu erzielen, empfiehlt sich bei monochromen Monitoren ein schwarzer Hintergrund und weiße Zeichen.

Es sei noch einmal darauf hingewiesen, daß die Versuche mit einem monochromen Monitor durchgeführt wurden. Ob sich die Qualität von Farbmonitorbildern auf die gleiche Weise verbessern läßt, müssen am besten weitere Experimente zeigen.

(Dipl.-Ing. Stephan Greitzke/aa)

# Maschinenprogramme auf Diskette speichern

> Reine Maschinenprogramme haben gegenüber einem Basic-Lader zwei entscheidende Vorteile. Sie sind wesentlich kürzer und können direkt, ohne zeitraubendes POKEn, geladen werden. Dieses Programm soll Ihnen helfen, Maschinenprogramme auf Diskette zu speichern.

Ein einfacher Basic-Lader besteht aus einer READ/POKE-Schleife, in der DATAs in den Speicher geschrieben werden. Jeder Wert, der in dieser Schleife gePOKEt wird, ist ein Byte eines Maschinenprogramms, ein Maschinenbefehl oder ein Teil davon. Anstatt die DATAs in den Speicher zu POKEn, kann ein Basic-Lader dazu benutzt werden, das Maschinenprogramm auf Diskette abzuspeichern. Der Lader wird dazu nur etwas geändert.

Ein Maschinenprogrammfile auf Diskette enthält, vor den Maschinenbefehlen, in den ersten beiden Bytes, die Startadresse des Programms. Der Computer erkennt daran, ab welcher Speicherstelle er das Programm laden soll.

Der Basic-Lader muß also ein Programmfile eröffnen, die Startadresse des Maschinenprogramms ins File schreiben und anschließend alle Werte aus den DATA-Zeilen. Wie das im einzelnen programmiert wird, können Sie am Listing des Beispielprogramms sehen, das Sie ohne weiteres an jedes Ladeprogramm anpassen können.

Der wichtigste Befehl in diesem Beipiel steht in Zeile 50130: OPEN 1,8,1, "Programmname”

Er öffnet eine Datei. Allerdings keine sequentielle, sondern eine Programmdatei. Die Sekundäradresse 1 sagt der Floppy 1541, daß nun ein Programm (NAME.PRG) geschrieben wird. Häufig findet man für diesen Befehl die Syntax OPEN 2,8,2, "Programmname,P, W”

bei der man die Sekundäradresse frei wählen darf. Hier muß jedoch nach dem Namen angegeben werden, daß eine Programmdatei (P) geöffnet werden soll, in die geschrieben wird (Write). Entsprechend kann bei sequentiellen Dateien optional »S,W« bei Schreib- oder »S,R« bei Lesezugriffen angegeben werden.

Nachdem in Zeile 50130 die Programmdatei angelegt wurde, muß die Startadresse des Maschinenprogrammes gespeichert werden. Die Startadresse wird dazu in den Zeilen 50170 und 50180 in Low- und High-Byte zerlegt und die zwei Byte in Zeile 50190 in das Programmfile geschrieben. Jetzt wird das eigentliche Programm gespeichert. Die numerischen Werte müssen dazu mit der CHR$-Funktion in die entsprechenden Strings übersetzt werden. Um die erforderliche Datendichte beim Schreiben des Files zu erreichen, muß jedem String ein Semikolon »,«folgen. Ohne Semikolon ist das Programm später nicht lauffähig. Sindalle Werte, die der Basic-Lader in den Speicher gePOKEt hätte, gespeichert, wird die Datei mit CLOSE geschlossen. Damit ist das Maschinenprogramm auf Diskette gespeichert und kann mit
LOAD ”NAME”,8,1

geladen und, wenn dies notwendig ist, mit dem entsprechenden SYS-Befehl gestartet werden.

### Laden von Maschinenprogrammen in Basic

Sie können Maschinenroutinen mit Hilfe von Basic-Programmen laden, ohne sie zu zerstören. Dabei ist zu beachten, daß nach dem Laden das Basic-Programm von Neuem startet. Die Basic-Zeile
10 LOAD ”KEIN ENDE",8,1

bewirkt deshalb eine Endlosschleife, die immer wieder das Maschinenprogramm »KEIN ENDE« lädt. Da angelegte Variablen dabei erhalten bleiben, kann mit
10 IF A=0 THEN A=1:LOAD ”KEIN ENDE"8,1
ein mehrmaliges Laden verhindert werden, da beim Neustart A=1 ist.

(S. Wengler/hm)

# RAM-Floppy

> Wer kennt das nicht: ein paar Veränderungen an einem Programm — eine Zeile rein, eine andere raus — und nichts geht mehr. Das lästige Neuladen des Originalprogramms von Diskette können Sie ab jetzt vergessen.

Ist ein Programm mal wieder zu Tode editiert, werden 8ie nun nicht mehr von den langen Ladezeiten der 1541 in Ihrem Programmierdrang gebremst. Mit »RAM-Floppy« kann ein Programm bearbeitet werden, während man eine Kopie davon im RAM hat. In Sekundenschnell kann die Kopie in den Basic-Speicher gebracht oder mit der Originalversion vertrauscht werden. Ganz einfach durch Eingabe von »@V« oder »@T«. Numerische Variablen bleiben dabei erhalten. Die »RAM-Floppy« besitzt eine Speicherkapazität von maximal 25 KByte. Der Speicher beginnt ab Adresse 40960.

Ein Problem ergibt sich im Speicherbereich des Kernal- und Basic-ROMs. Ein POKE-Befehl schreibt ins RAM, während die PEEK-Funktion auf das ROM zugreift. Noch komplizierter sieht es beim Zeichen-ROM und den I/O-Bausteinen aus. Wie Sie vielleicht aus unserem Grafikkurs wissen, gibt es in diesen Bereichen drei Speicheretagen. Der Inhalt der Zelle 1 regelt den Zugriff des Computers auf die verschiedenen Speicherebenen. Werden die Bits 0 und 1 in Adresse 1 gelöscht, sieht der Computer nur noch das RAM. Basic- und Kernal-ROM sind verschwunden. Löschen Sie diese Bits deshalb nur durch ein Maschinenspracheprogramm, wenn vorher Ein- und Ausgaben gesperrt wurden. Dies wird durch Setzen des Interruptregisters erreicht.

Das Maschinenprogramm besteht aus drei Teilen. Im Bereich von 40704 bis 40768 erfolgt die Auswertung der Befehle von »RAM-Floppy« und der Aufruf der beiden Unterprogramme, die dasTauschen oderVerschieben der Basic-Programme erledigen.

Das abgedruckte Basic-Programm POKEt das Maschinenprogramm ab Adresse 40704. Mit SYS 40704 wird es initialisiert.

Wie bereits erwähnt, hat die »RAM-Floppy« eine Kapazität von 25 KByte. Das Programm im Basic-Speicher kann zwar 38 KByte lang sein, läßt sich dann allerdings nicht mehr vollständig verschieben oder vertauschen. Der Speicherbedarf sollte auch bei Programmen mit vielen Variablen nicht außer acht gelassen werden. Bei langen Programmen mit vielen Variablen kann es durchaus vorkommen, daß die Programme zwar getauscht, die Variablen allerdings nicht mehr übernommen werden können.

(Uwe Klatt/hm)

# Hires-3 – eine Super-Grafikerweiterung zum Grafikkurs

> Diese Erweiterung bietet wesentlich mehr als ein einfaches Hilfsprogramm. Sie stellt einen umfangreichen Befehlskatalog für die Erzeugung von Grafiken zur Verfügung. Und sie liefert außerdem etliche Programmierhilfen.

Es hat ein bißchen gedauert, doch nun will ich mein Versprechen einlösen: Dornröschen ihre Behäbigkeit mit einem grafikunterstützenden Maschinenprogramm zu nehmen. Zuvor noch zwei erfreuliche und eine weniger gute Nachricht: Leider ist das Grafik-Hilfsprogramm so lang, daß es Ihnen in zwei Teilen vorgelegt werden muß. Dann die beiden frohen Botschaften: Sie bekommen etwas viel besseres als nur eine kleine Grafikhilfe und die Grafikserie wird fortgesetzt.

Viele Briefe zeigten uns, daß Sie noch mehr wissen möchten. Zu speziellen Grafikthemen soll daher in lockerer Reihenfolge weiterhin Dornröschen aufgeputzt werden. Wenn sie also spezielle Grafikwünsche haben, dann schreiben Sie. Der C 64 kann viel mehr als Sie vielleicht glauben! Was Apple kann — behaupte ich mal ganz frech — das kann unser Computer auch — nur viel preiswerter.

Wieso bekommen Sie etwas viel besseres als ursprünglich vorgesehen? Das zunächst vorgesehene Grafik-Hilfsprogramm ist Ende 1983 fertiggestellt worden und hieß Hires-1. Es war der Auslöser für diese Serie. Ich hatte es entwickelt, um meine eigenen Grafikbedürfnisse (Punkte setzen, Linien ziehen etc.) auf schnelle Art mit SYS-Aufrufen zu erfüllen. Die Entwicklung blieb aber nicht stehen. Hires-2 holte sich bereits alle nötigen Werte zum Zeichnen mit den USR-Kommandos und die SYS-Befehle wurden überflüssig. Was Sie jetzt bekommen, das ist Hires-3. Aufrufe der einzelnen Routinen (es sind über 40) erfolgen mit neu geschaffenen Basic-Befehlsworten, die sowohl im Direktmodus als auch in Programmen verwendet werden. Kenner werden feststellen, daß Hires-3 sozusagen organisch gewachsen ist, wie es halt vielen großen Programmprojekten ergeht, die immer weiter verbessert werden: Nebenbei bemerkt: Momentan arbeite ich an Hires-4.

Hires-3 wurde mit dem Gedanken entworfen, das Schreiben von Grafikprogrammen einfacher zu gestalten. Deswegen sind nicht nur ausgesprochene Grafikbefehle dabei, sondern auch OLD, MERGE, RENUMBER, AUTONUMBER, PAUSE, UHR etc. Die Grafik-Unterstüt-zung ist für alle Anwendungsbereiche gedacht, wobei der Schwerpunkt allerdings weniger auf »Spielen« und »künstlerische Anwendungen« liegt. Deswegen sind keineJoystick-, keine Lightpen- und keine Sprite-Be-fehle enthalten. Schließlich spielte es noch eine große Rolle, daß viel Speicherplatz für Basic-Programme und Daten frei bleiben sollte, ebenso wie der für Maschinensprache interessante Bereich von $C000 bis $D000.

Deswegen liegt das Programm Hires-3 ab $8000 (dez.32768) bis $89B5 (dez.35253) und von $9000 (dez.36864) bis $9DCB (dez.40395). Es fängt also dort an, wo auch Module ihren Platz haben. Der Bildschirm für hochauflösende Grafik liegt von $8000 (dez.35840) bis $8FFF (dez.36863), der für den Normalbetrieb bleibt an der gewohnte Stelle (1024...). Die 8 000 Byte lange Bit-Map kommt uns nicht mehr in die Quere: Sie ist unter dem Basic-ROM versteckt. Wir haben also trotz 44 neuer Befehle und Funktionen und einer stets präsenten hochauflösenden Grafik auf einem zweiten Bildschirm immer noch 30 KByte RAM für Basic frei und zusätzlich auch noch den Bereich $C000 bis $D000 für Maschinenprogramme.

Hires-3 wird mit dem MSE ein-gegeben (Seite 68). Nach der Eingabe des Programms empfiehlt es sich, das Ganze erstmal auf einem Massenspeicher (Kassette oder Diskette) sicher abzulegen.

Bevor Sie ein neues Basic-Programm schreiben, sichern Sie bitte noch HIRES-3 durch die in den vergangenen Grafik-Folgen vorgestellten Schutz-POKEs:
POKE52,128:POKE56,128

Mit SYS36864 starten Sie Hires-3. Außer der READY-Meldung werden Sie erstmal nichts Neues sehen. Sie haben nämlich nichts anderes getan, als den Funktionstasten Befehle zuzuteilen. Deshalb fangen wir jetzt mit der Erklärung der Befehle an und zwar mit eben diesen Funktionstasten: Vorsicht! Nicht alles gleich ausprobieren! Sehen Sie vorher noch in der Tabelle 1 nach, welche Befehle erst in der nächsten Folge von Hires-3 eingebaut werden.

Wenn Sie die vorher benutzen, stürzt das Programm wahrscheinlich ab. Es erfolgt dann ein Programmsprung ins Leere — und das wollen wir unserem Computer doch nicht zumuten!

### 1.	Hilfsfunktionen
#### 1.1	Funktionstastenbelegung

Genau genommen schaltet man durch SYS 36864 nur die Belegung der Funktionstasten ein. Ausschalten erfolgt durch gleichzeitiges Drücken der RUN/STOP- und der RESTORE-Tasten. Nun zur Belegung im einzelnen:

### F1 RUN

Startet ein im Basic-Speicher stehendes Programm sofort.

### F2 RENUMBER-Befehl

Auf dem Bildschirm erscheint SYS33256. Man schreibt nun:
SYS33256,Abz,Nbz,Sch.

Dabei bedeuten:
Abz = erste alte Basic-Zeile, von der an neu numeriert werden soll.
Nbz = erste neue Basic-Zeilennummer
Sch = Schrittweite

Dieser Befehl numeriert auch alle GOTO, GOSUB, IF..THEN..., RUN... etc. neu.
Beispiel:
SYS33256,1,10,5 numeriert ein Programm ab der alten Zeilennummer 1, welche nun 10 heißt, in 5er-Schritten neu durch.

### F3 Aktivieren der neuen Basic-Befehle

Auf dem Bildschirm erscheint SYS37498 und READY. Jetzt sind alle neuen Basic-Befehlsworte verfügbar. Verwendet man eines der neuen Befehlsworte vorher, erzeugt das einen SYNTAX ERROR. Das Abschalten der neuen Befehle geschieht mittels »AUS«.

### F4 OLD-Befehl

Auf dem Bildschirm erscheint SYS37227 und ein durch NEW oder einem RESET gelöschtes Basic-Programm wird wieder gelistet und funktionsfähig (vorausgesetzt, daß es nicht durch Überschreiben zerstört wurde). Störungen können auftreten, wenn noch kein Basic-Programm im Speicher enthalten ist. Nach der Verwendung dieses Befehls sollte überprüft werden, ob durch das vorangegangene Löschen die SchutzPOKEs 52 und 56 verändert worden sind.

### F5 AUTONUMBER-Befehl

Auf dem Bildschirm erscheint SYS37018 und eine Zeilennummer. Diese Funktion setzt automatisch nach jedem RETURN eine neue Zeilennummer, die sich an die letzte im Programm vorhandene anschließt. Im Normalfall wird dabei in 10er-Schritten gearbeitet, eine andere Schrittweite wird durch POKE37169, Sch erzeugt (dabei ist Sch die Schrittweite). Die AUTONUM-BER-Funktion wird durch Drücken von RETURN direkt nach einer Zeilennummer abgeschaltet.

### F6 MERGE-Befehl

SYS37306 erscheint auf dem Bildschirm und die Information: >>***MERGE***, BEREIT ZUM KOPPELN! READY.« Das Basic-Programm läßt sich allerdings nicht Listen oder Starten. Denn die Zeiger sind nun auf das Ende des Programms gestellt. Der Computer wartet auf das Laden des anzuhängenden Programms, was durch eine normale Ladeoperation stattfindet. Man drückt nun erneut F6 und auf dem Bildschirm erscheint: SYS37306 und der Text: >>***MERGE*** PROGRAMME GEKOPPELT! READY«. Wenn man nun listet, zeigt es sich, daß beide Programme aneinandergehängt sind. Man sollte darauf achten, daß das anzuhängende Programm höhere Zeilennummern aufweist als das erste, denn sonst kommt es bei GOTO oder GOSUB-Sprüngen zu Fehlern.

### F7 Startet Maschinenprogramme,

die bei $C000 (dezimal 49152) liegen. Auf dem Bildschirm erscheint SYS49152.

### F8 Startet Maschinenprogramme,

die bei $7000 (dez. 28672) liegen. Auf dem Bildschirm erscheint SYS 28672.

Achtung! Diese beiden Tasten sollte man nur betätigen, wenn an den Ansprungadressen auch wirklich ein Programm startet, denn sonst stürzt der Computer unter Umständen ab. Sehr praktisch sind diese beiden Funktionstasten, wenn an den Startadressen andere Sprachen verfügbar sind, zum Beispiel bei $C000 ein Maschinensprache-Monitor liegt oder ähnliches. Auch zum schnellen Starten von unfertigen Assembler-Programmen, die an einer der beiden Stellen anfangen. Für solche Tests sind F7 und F8 gut einzusetzen.

#### 1.2	Hilfsfunktionen als neue Basic-Befehle

Das sind fünf Befehle: PAU, DEEK, AUS, DUMP und UHR
**Aus**: Schaltet die Befehlserweitungen aus. Das beschleunigt den Ablauf eines Basic-Programms. Der Interpreter muß nun nicht mehr den Umweg über die hier vorgestellten Befehlserweiterungen laufen. Der Zeitunterschied ist allerdings minimal und nur bei zeitkritischen Abläufen interessant.
**DEEK**: Ist eine modifizierte PEEK-Funktion, die das RAM unter den ROM-Bausteinen ausliest und in Speicherstelle 2 ablegt. Syntax: DEEK, Speicherstelle Beispiel:
DEEK, 53272:PRINTPEEK(2) ergibt 255, den Inhalt des RAM unter dem ROM, wogegen PRINTPEEK(53272) den ROM-Inhalt 21 ergibt.
**PAU**: Pausen-Befehl. PAU,10 erzeugt eine Pause von 10 Sekunden.
**DUMP**: Gibt alle definierten Variablen mit ihren aktuellen Werten aus. Arrays werden nicht berücksichtigt.
**UHR**: Zeigt in der rechten oberen Bildschirmecke eine Uhr an.
Stellen: UHR, »hhmmss«, Zeichenfarbe
Ausschalten: UHR
Wieder einschalten: UHR

Vor der Verwendung des Hoch-auflösungs-Modus sollte die UHR ausgeschaltet werden, ebenso vor dem Aufruf des Hardcopy-Befehls.

### 2.	Grafik-Befehle
#### 2.1	Einrichten der Grafik

**HFL,Zf,Hf**: Der Befehl richtet den Hochauflösungs-Grafikmodus ein, setzt die Zeichenfarbe (Zf) und die Hintergrundfarbe (Hf) und löscht ein eventuell vorhandenes Hochauflösungsbild aus. Dabei liegt der Bildschirm von $8000 bis $8FE7 (dezimal 35840 bis 36839) und die Bit-Map unter dem Basic-ROM ($A000-$C000).
**HAN**: Schaltet nur den Hochauflö-sungs-Modus an.
**FAR,Zf,Hf**: Setzt nur die Farben im Hochauflösungsbild.
**LOE**: Löscht nur das Hochauflösungsbild.
**HOF**: Schaltet des Hochauflösungsbild aus und richtet den Normalmodus wieder ein.

#### 2.2	Zeichnen im Bildschirmsystem

(dabei x von 0 bis 319, y von 0 bis 199). Erinnern Sie sich bitte an das Bildschirmkoordinatensystem. Alle x- und y-Koordinaten, die unter 2.2 und 2.3benutzt werden, beziehen sich auf dieses System (Bild 1).
**PKT,x,y**: Zeichnet an der durch x und y angegebenen Stelle des Bildschirmes einen Punkt. Die Bedeutung der Bezeichnungen folgen aus Bild 2. Wegen der Eigenart des Bildschirmsystems ist darauf zu achten, daß x und y nie kleiner als 0, x nie größer als 319 und y nie größer als 199 werden. Koordinaten-Eingaben, die größer als 319 (beziehungsweise 199) sind, führen lediglich dazu, daß kein Punkt gezeichnet wird. Eingaben kleiner als Null ergeben einen SYNTAX ERROR.
**LIN,xa,ya,xb,yb**
Zeichnet eine Linie vom Punkt A mit den Koordinaten xa, ya bis zum Punkt B mit den Koordinaten xb, yb (siehe Bild 3). Die Richtung der Linie ist beliebig. Die Bemerkung zur Größe der Koordinaten gilt hier entsprechend.
**REC,xa,ya,xb,yb**
Zeichnet ein Rechteck, das durch den linken oberen Punkt A(xa,ya) und den rechten unteren Punkt B(xb,yb) gekennzeichnet ist (siehe Bild 4). Für die Koordinatengrenzwerte gilt dasselbe wie beim Befehl PKT.
**BLO,xa,ya,xb,yb**
Füllt ein Rechteck der angegebenen Maße (siehe REC für die Bezeichnungen) mit der Zeichenfarbe aus.
**CIR,xm,ym,rx,ry,w**
Zeichnet eine Ellipse oder einen Kreis (Sonderfall der Ellipse mit rx = ry) mit den folgenden Merkmalen: xm,ym = Koordinaten des Mittelpunktes M, rx,ry = Halbmesser in x- beziehungsweise y-Richtung.
w = Zeichenwinkel (Bogenmaß). Zur Erläuterung der einzelnen Bezeichnungen dient Bild 5. Äußer negativen xm und ym-Koordinaten sind alle Eingaben zulässig.
**RAD,xm,ym,rx,ry,w**
Zeichnet in die Ellipse einen Radius ein. Die Bezeichnungen sind dieselben wie für den CIR-Befehl. w zeigt hier aber an, an welche Stelle im Ellipsenbogen der Radius gezeichnet werden soll (siehe Bild 6).

#### 2.3	Löschen im Bildschirmsystem

**LPK,x,y**: Löscht den angegebenen Punkt x,y
**LLN,xa,ya,xb,yb**: Löscht die Linie von xaya bis xb,yb
**LRE,xa,ya,xb,yb**: Löscht das Rechteck (Bezeichnungen wie bei REC)
**LBK,xa,ya,xb,yb**: Löscht das ausgefüllte Rechteck.
**LKR,xm,ym,rx,ry,w**: Löscht die Ellipse (Bezeichnungen wie bei CIR) LRA,xm,ym,rx,ry,w: Löscht den Ellipsenradius

### 3.	Abspeichern/Laden von Hochauflösungsbildern

**HIS, ”Name”gn,sa**
SAVEn des Hochauflösungsbildes mit »Name« auf dem Gerät mit der Gerätenummer gn. Es gelten die gleichen Regeln wie beim normalen SAVE-Vorgang.
**HIL, ”Name”,gn,sa**
Laden eines Hochauflösungsbildes vom Speichermedium mit der Gerätenummer gn. Es gelten die gleichen Regeln wie für den normalen Ladevorgang.

Diese neuen Befehle sollen für diese Folge ausreichen. In der nächsten Ausgabe werden die anderen Befehle beschrieben, die HIRES-3 von allen mir bekannten Grafik-Software-Paketen unterscheidet.

Zur Praxis: Bedenken Sie bitte beim Ausprobieren dieser neuen Befehle, daß Sie alle auch im Direktmodus verwenden können. Das ist — gerade beim Testen — mitunter ganz bequem. Allerdings sind die Befehlsworte auf dem Hochauflösungsbildschirm nur als farbige Quadrate zu erkennen (Warum? Siehe vorangegangene Grafik-Folgen). Wenn Sie mal das Gefühl haben, Sie hätten sich beim Eintippen eines Befehls vergaloppiert, dann löschen Sie auch im Hochauflösungs-Modus den Bildschirm einfach mit SHIFT/CLR-HOME. Sie werden dann immer noch das Hochauflösungsbild sehen (die Bit-Map wird ja nur durch LOE gelöscht). Mit dem FAR-Befehl bringen Sie wieder neue Farbe ins Bild. Sollte ein Programm im Hochauflösungs-Modus auf einen Fehler laufen und aussteigen, dann kommen Sie mit HOF leicht wieder in den Normalmodus zurück.

Außer Hires-3 ist dieser Folge auch noch ein kleines Programm angefügt, mit dem Sie alle bisher vorgestellten Grafik-Befehle auf ihre Funktionsfähigkeit testen können. Nun noch ein Wort an die Spezialisten: In der nächsten Folge wird eine Aufstellung aller benötigten Zeropage-Plätze und der verwendeten Sub-Routinen erscheinen. Zur Selbstkritik: Einige Befehle fehlen, nämlich etwa zum Ausfüllen von umrandeten Flächen, dann eine Möglichkeit, Texte ins Hochauflösungsbild zu schreiben und anderes. Außerdem ist in puncto Geschwindigkeit noch lange nicht das Optimum erreicht... aber irgend etwas muß für Hires-4 auch noch zu tun bleiben.

(Heimo Ponnath/gk)

# Comal – Eine Einführung (3)

> In dieser Folge unserer Comal-Einführung befassen wir uns mit einem der interessantesten Aspekte dieser Programmiersprache, nämlich der Grafik.

Die Comal-Grafik kann ihre Herkunft von einer anderen Programmiersprache nicht verheimlichen. Befehle wie »SHOWTURTLE« und »TURTLESIZE« sind verräterisch: Die Sprache Logo mit ihrer bekannten Turtle-Grafik stand neben Basic und Pascal Pate beim Entwurf von Comal.

Die Bezeichnung Turtle-Grafik stammt noch aus den Anfängen von Logo. Turtle ist das englische Wort für »Schildkröte« und bezeichnete ursprünglich eine mechanische Schildkröte, die sich per Computersteuerung über ein großes Blatt Papier bewegte und dabei mit einem Schreibstift eine sichtbare Spur hinterließ. Zur Steuerung dieser »Schildkröte« wurde eine spezielle Programmiersprache entwickelt, mit Befehlen wie »FORWARD«, »BACK«, »LEFT« etc. Das funktionierte einige Zeit ganz gut, aber dann tauchten die ersten Mikrocomputer mit Grafikbildschirmen auf, und die Schildkröte hauchte ihr mechanisches Leben aus und degenerierte zu einem kleinen Dreieck auf einem Grafikbildschirm. Doch die grafische Programmiersprache Logo war geboren und ist seitdem immer weiterentwickelt worden.

Das Konzept der Turtle-Grafik wurde vollständig in Comal integriert (Tabelle 1). Daneben gibt es auch spezielle Kommandos zum Zeichnen einzelner Punkte oder Linien, und zwar unabhängig von der jeweiligen Turtleposition. Überhaupt wird der gesamte Bereich von Grafik, Farbe und Bildschirmansteuerung beim C 64 durch Comal-Befehle abgedeckt (Tabelle 2), man muß sich nicht wie im V.2-Basic mit merkwürdigen PEEKs und POKEs herumschlagen.

Comal kennt drei verschiedene Bildschirmmodi, nämlich den normalen Textmodus (»SETTEXT«), den hochauflösenden Grafikmodus (»SETGRAPHIC 0«) und den Mehrfarben-Grafik-modus (»SETGRAPHIC 1«). Der Textmodus wird auch mit der Funktionstaste fl eingeschaltet, während f5 die Grafik einschaltet. Im hochauflösenden Modus kann mit f3 zusätzlich noch ein Textfenster eingeblendet werden, was beim Experimentieren mit der Turtle-Grafik recht nützlich ist. Die oberen beiden Bildschirmzeilen bilden dann das Textfenster, mit dessen Hilfe man beispielsweise im Direktmodus mit entsprechenden Befehlen die Turtle steuern kann.

Geben Sie einmal im Direktmodus den Befehl »CLEAR« ein (um den Grafikbildschirm zu löschen) und schalten Sie danach durch Drücken der f3-Taste in die hochauflösende Grafik mit Textfenster um. Sie sehen in der Mitte des ansonsten leeren Bildschirms ein kleines weißes Dreieck, die Turtle. In der linken oberen Bildschirmecke blinkt der Cursor und zeigt damit an, daß die Turtle auf Befehle von Ihnen wartet.

### So wird die »Schildkröte« bewegt

Geben Sie jetzt »FORWARD 50« ein. Die Turtle bewegt sich damit um 50 Einheiten vorwärts und zieht dabei eine Linie längs ihres Weges. Mit »LEFT 90« erreichen Sie eine Drehung der Turtle um 90 Grad nach links. Wenn Sie jetzt nochmals »FORWARD 50« eingeben, bewegt sich die Turtle in die neue Richtung. Soll eine Bildschirmstelle angefahren werden, ohne eine Linie dorthin zu ziehen, dann wird mit dem Kommando »PEN-UP« einfach der symbolische Schreibstift von der Zeichenfläche abgehoben. Die Turtle kann dann nach Belieben über den gesamten Bildschirm dirigiert werden, ohne Spuren zu hinterlassen. Aber keine Angst, nach »PENDOWN« zeichnet sie wieder.

Wenn Sie es gerne etwas bunter hätten, bitte sehr. »PENCO-LOR« wählt die Schreibfarbe der Turtle, »BORDER« und »BACKGROUND« wählen Rahmen- und Hintergrundfarbe. Erscheint Ihnen die Turtle zu gut genährt, dann können Sie zum Beispiel mit »TURTLESIZE 5« bedenkenlos etwas Speck entfernen. Und sollte Ihnen die Turtle insgesamt nicht ganz geheuer sein, dann tippen Sie einfach »HIDETURTLE« in Ihren Computer ein. Die »Schildkröte« wird sich daraufhin schmollend von der Bildfläche zurückziehen, aber zum Glück wird ihr Wirken dadurch nicht behindert: Aus dem Unsichtbaren befolgt sie weiter Ihre Befehle und zieht fleißig ihre Linien.

### Kleine Programme mit großer Wirkung

Natürlich ist die Grafikerzeugung mit dieser sehr direkten Methode auf die Dauer entschieden zu langwierig. Wenn Sie das kleine Programm aus Listing 1 einmal ausprobieren, werden Sie feststellen, daß effektvolle Grafikprogramme in Comal weder besonders komplex noch langsam zu sein brauchen. Experimentieren Sie ruhig mit ähnlichen Programmen; Sie werden sehr schnell ein gewisses Gespür dafür entwickeln, wie Sie durch Wiederholung einfacher Grundfiguren mit jeweils einem etwas geänderten Parameter interessante grafische Effekte erzielen können.

### Zugabe: Sprites in Comal programmiert

Der große Vorteil der Turtle-Grafik gegenüber dem Zeichnen von Linien nach festen Koordinaten ist ja gerade die erstaunliche Einfachheit, mit der sich recht komplexe Strukturen vom Standpunkt der »Schildkröte« aus darstellen. Mit Comal können Sie wirklich eine »Reise durch die Wunderwelt der Grafik« antreten — auch ohne sich mit Bits und Bytes abzuplagen und mit komplizierten mathematische Formeln zu jonglieren.

Die Turtle-Grafik ist nur die eine Seite der grafischen Fähigkeiten des C 64 - Comal. Es stehen nämlich zusätzlich eine Reihe von leistungsfähigen Anweisungen zur Erzeugung und Kontrolle von Sprites zur Verfügung.

Auch bei Sprites wird zwischen Hochauflösung (Hires) und Mehrfarbendarstellung (Multicolor) unterschieden. Ein Hires-Sprite besteht bekanntlich aus 24 x 21 Punkten oder aus 21 Reihen zu je drei Byte. Bei Multicolor-Sprites haben wir nur 12 x 21 Punkte, dafür benötigt jeder Bildpunkt aber intern zwei Bit, da vier verschiedene Farben pro Punkt möglich sind. In beiden Fällen kann die in einem Sprite enthaltene Information in 63 Bytes dargestellt werden. Comal verwendet ein zusätzliches Byte, das angibt, ob es sich um ein Hires-Sprite (Byte 64 = 0) oder um ein Multicolor-Sprite (Byte 64 < > 0) handelt. Beide Spritearten werden im übrigen mit völlig gleichartigen Befehlen angesprochen.

Zur Spriteerzeugung dient der Befehl »DEFINE«. Als Parameter wird eine Definitions-Nummer sowie ein String angegeben. Die Definitions-Nummer kann irgendeine Zahl von 0 bis 95 sein, denn Comal kann bis zu 96 verschiedene Spritemuster verwalten. Der anzugebende String muß eine Länge von 64 Zeichen haben und das Punktmuster des Sprites enthalten. Das Beispielprogramm in Listing 2 zeigt, wie man in Comal mit Sprites umgeht.

Wichtig ist es, genau zwischen der Definitions-Nummer eines Sprites und der eigentlichen Spritenummer zu unterscheiden. Es können hardwarebedingt ja immer nur acht Sprites gleichzeitig auf dem Bildschirm sein. Wird die Turtle benutzt, die selber ein Sprite ist, dann verringert sich diese Anzahl auf sieben.

Mit dem »IDENTIFY«-Kommando wird die Beziehung zwischen Sprite-Nummer und Definitions-Nummer hergestellt. »IDENTIFY 1,30« bewirkt beispielsweise, daß das Sprite mit der Definitions-Nummer 30 als Sprite 1 auf dem Bildschirm dargestellt wird. So kann sehr schnell zwischen verschiedenen Sprites umgeschaltet werden, was zur Erzeugung von zeichentrickähnlichen Effekten benutzt werden kann.

Wie aus Tabelle 3 zu ersehen ist, gibt es eine Vielzahl von weiteren Comal-Befehlen speziell zur Sprite-Kontrolle. Die Wirkungsweise solcher Anweisungen wie »SPRITECOLOR« oder »SPRITEPOS« dürfte wohl jedem verständlich sein, der sich schon einmal von Basic aus an die Spriteprogrammierung gewagt hat.

### Comal oder Basic?

Wie die drei Folgen unserer kleinen Comal-Einführung hoffentlich gezeigt haben, hat Comal dem Commodore V.2-Basic einiges voraus. Die von Pascal entlehnte Programmstrukturierung mittels Prozeduren und die aus Logo stammende Turtle-Grafik haben sich mit dem aus Basic übernommenen Konzept einer benutzerfreundlichen, interaktiven Programmiersprache zu einer gelungenen Synthese zusammengefügt. Die hier besprochene Comal-Version 0.14 ist dabei nur als eine Art Vorabversion zu werten. Eine nochmals wesentlich erweiterte und verbesserte Version 2.0 wird von Commodore Dänemark bereits als Steckmodul (64 KByte ROM, 30 KByte RAM frei) vertrieben. Es ist zu hoffen, daß auch Commodore Deutschland diese zukunftsweisende Programmiersprache bald anbieten wird.(ev)

Info: Comal-Literatur:
Borge Christensen, Heiko Wolgast: Comal 0.14-Handbuch, 80 Seiten, Verlag Schmidt & Klaunig, Ringstraße, 2300 Kiel.
Borge Christensen: Strukturierte Programmierung mit Comal, 230 Seiten, Verlag R. Oldenbourg, München, ISBN 3-486-26901-1

# Assembler ist keine Alchimie – Teil 6

> In der vorangegangenen Ausgabe haben wir die relative und die Zeropage-Adressierung kennengelernt. Heute kommt die indizierte Adressierung dran und natürlich sehen wir uns wieder einige neue Assembler-Befehle an. Wir werden uns einige Gedanken machen über die sogenannten Fließkommazahlen und den Basic-Befehl USR. Auch die Speicherorganisation unseres Computers soll uns nochmal beschäftigen.

Zunächst die indizierte Adressierung. Indizieren heißt, etwas mit einem Index, also einem Zeichen oder einer Nummer, zu versehen. Beispielsweise bezeichnet man in der Mathematik die beiden Lösungen einer quadratischen Gleichung häufig als XI und X2. Dabei ist dann die Ziffer (1 oder 2) der Index und X ist eine indizierte Größe. Man geht also aus von einer festgelegten Grundmenge (Lösungsmenge X) und trifft durch den Index eine weitere Unterscheidung.

So ähnlich können wir uns auch die Funktion der indizierten Adressierung bei der Assembler-Programmierung vorstellen. Nehmen wir als Beispiel den Befehl
LDA 1500,X

Man spricht hier von einer absolut-X-indizierten Adressierung. Das Assemblerwort LDA ist uns bekannt: Lade den Akku. Woher soll der für den Akku bestimmte Inhalt geholt werden? Aus der Speicherzelle, die sich durch 1500 plus Inhalt des X-Registers ergibt. Steht also im X-Register zum Zeitpunkt des Befehlsaufrufes eine 5, dann wird der Akku aus Speicherzelle 1500 + 5, also 1505, geladen. Das X-Register kann Werte von 0 bis $FF (dez. 255) enthalten. Die Ähnlichkeit sieht also so aus:

Aus einer Gesamtmenge von 256 Adressen, die durch die Anfangsadresse (bei unserem Beispiel 1500) und die möglichen 256 Belegungen des X-Registers festgelegt sind (die Grundmenge), werden je nach X-Register-inhalt einzelne Adressen unterschieden und adressiert. Das X-Register fungiert dabei als ein Index, weswegen man auch oft die Bezeichnung »Index-Register X« in der Literatur findet.

Ebenfalls als Index-Register kann das Y-Register dienen, was zum Beispiel zum Befehl
LDX 1500,Y
führen kann. Dies ist dann eine absolut-Y-indizierte Adressierung.

Genauso wie man die normale absolute Adresse (also zum Beispiel 1500) als Basis der Indizierung durch das X- oder das Y-Register verwenden kann, ist das auch mit eine Zeropage-Adresse möglich. So gibt es zum Beispiel die Befehle
LDY 2B,X
oder
STX 19,Y

Man nennt diese Art der Adressierung dann Zeropage-absolut-X-indiziert beziehungsweise -Y-indiziert.

Weil die Zeropage aber nur 256 Adressen umfaßt, andererseits jedoch die Indexregister auch 256 Werte annehmen können, kann es geschehen (wenn man nicht aufpaßt), daß die Summe aus der Basisadresse (zum Beispiel $2B) und dem Indexregisterinhalt größer als 256 wird. Wenn zum Beispiel in dem Befehl
LDA FE,X
der X-Registerinhalt 2 beträgt, ergäbe sich $FE + $02 = $0100. In diesem Fall wird aber nicht der Inhalt von $0100 in den Akku geladen, sondern der Befehl spricht die Speicherstelle $00 an. Der Grund dafür liegt in der Tatsache, daß unser Prozessor den Befehl als 2-Byte-Befehl interpretiert — das 2. Byte ist die Zeropageadresse, die sich als Summe ergibt — und deswegen nur das LSB der Adresse beachtet. Von $0100 ist das LSB aber $00. Mit anderen Worten: Die Zero-page-absolut-indizierten Befehle lassen einen Zugriff nur auf die Zeropage selbst zu. Dieses Verhalten muß man beim Programmieren beachten.

Wir wollen nochmal zusammenfassen. Vier neue Adressierungsarten haben wir kennengelernt:
**Absolut-X-indiziert**
zum Beispiel LDA 1500,X
**Absolut-Y-indiziert**
zum Beispiel LDA 1500,Y
**Zeropage-absolut-X-indiziert**
zum Beispiel LDA 2B,X
**Zero-page-absolut-Y-indiziert**
zum Beispiel LDX 2B,Y

Die Verwendung des Y-Regi-sters als Indexregister ist stark eingeschränkt. Nur bei wenigen Befehlen ist sie erlaubt (tatsächlich nur LDX und STX bei Zeropage-absolut-indizierter Adressierung). In der Tabelle 1 sehen Sie, welche bisher behandelten Befehle wie mit der indizierten Adressierung verwendet werden dürfen.

Es gibt noch zwei weitere Arten einer indizierten Adressierung, auf die wir noch zu sprechen kommen werden.

### Einige Nachzüglicher: Die Befehle BIT, CLV, NOP und TAX, TAY, TXA, TYA

Wir wollen noch ein bißchen aufräumen: Ein paar Befehle, die bisher zu keinem Gebiet so richtig paßten, sollen jetzt behandelt werden.

**BIT**: Dieser Befehl heißt »Bit-Test« und paßt von daher eigentlich zu den in der letzten Ausgabe behandelten Vergleichsbefehlen. Die Behandlung der Flaggen ist aber völlig anders. Nehmen wir das Beispiel
BIT 1500

Folgendes passiert: Der Inhalt der Speicherstelle $1500 wird mit dem Inhalt des Akku UND-verknüpft, das Ergebnis in der Z-Flagge angezeigt und Bit 7 sowie Bit 6 von $1500 in die N- beziehungsweise die V-Flagge übertragen. Weder Akku noch der Inhalt von $1500 verändern sich dabei.

Das ging ein bißchen holterdipolter. Sehen wir uns das jetzt mal ganz langsam Schritt für Schritt an! Zunächst die UND-Verknüpfung. Bit für Bit wird der Akku-Inhalt mit dem Inhalt der adressierten Speicherstelle UND-verknüpft. Dabei gelten folgende Regeln (die Leser der Grafik-Serie kennen das ja schon):
0 UND 0 = 0
0 UND 1 = 0
1 UND 0 = 0
1 UND 1 = 1

Nur dann also, wenn die entsprechenden Bits im Akku und in 1500 gleich 1 sind, ergibt sich bei der UND-Verknüpfung eine

1.	Man stellt sowas meist in einer sogenannten Wahrheitstabelle zusammen (Tabelle 2).

Nehmen wir als Beispiel mal an, im Akku stünde $0A und in der Speicherstelle $1500 wäre $09 enthalten. Die UND-Ver-knüpfung sieht dann so aus:

TODO

Das Ergebnis ist also $08. In der Z-Flagge wird in dem Fall, daß das Ergebnis der UND-Verknüpfung ungleich Null ist (wie hier) eine Null angezeigt, sonst eine 1.

Wir haben in unserem Zahlenbeispiel mit dem BIT-Befehl überprüft, ob die Bits 1 und 3 in Speicherstelle $1500 gelöscht sind. Dazu haben wir in den Akku eine sogenannte Maske (hier also $0A) geladen. Das Ergebnis sagt uns, daß nicht beide Bits gelöscht waren. Wäre der Inhalt von $1500 beispielsweise $10 gewesen (0001 0010), hätten wir in der Z-Flagge eine 1 gefunden. Daher der Name »Bit-Test«: Durch geeignete Maskenwahl kann praktisch jedes Bit überprüftwerden. Dabeiwerdenwe-der der Akku-Inhalt noch der Inhalt der angesprochenen Speicherstelle verändert.

Der BIT-Befehl hat aber noch mehr Auswirkungen: Die Bits 6 und 7 der geprüften Speicherzelle findet man nach Befehlsausführung in zwei Flaggen nochmal:
Bit 7 in der N-Flagge
Bit 6 in der V-Flagge

Damit kann man beispielsweise überprüfen, ob sich am adressierten Ort eine negative Zahl befindet. Alle drei Flaggen können ja nun mit den Branch-Befehlen abgefragt werden. Sie erkennen sicherlich schon, wie vielseitig dieser merkwürdige BIT-Befehl einsetzbar ist.

Adressierbar ist BIT entweder absolut (wie im obigen Beispiel) oder Zeropage-absolut. Je nachdem liegt er' dann als 3-Byte-oder als 2-Byte-Befehl vor.

**CLV**: Dieser Befehl heißt »clear overflow-flag«, also »lösche die Überlauf-Flagge«. Die V-Flagge war — wie Sie sich erinnern werden — unsere rote Ampel bei Rechenoperationen (siehe Ausgabe 12/84, S. 135). Es ist ein l-Byte-Befehl mit impliziter Adressierung und interessant daran ist, daß es keinen Befehl gibt, der das Gegenteil — also das Setzen der V-Flagge — bewirkt.

**NOP**: NOP steht für »no operation«, was bedeutet »keine Tätigkeit«. Das ist der Nichtstu-Befehl. Er tut aber doch etwas: Er sorgt dafür, daß der Befehlszähler weitergezählt wird und bewirkt eine Verzögerung von 2 Taktzyklen. NOP ist ein l-Byte-Befehl mit impliziter Adressierung. Er wird in fertigen Programmen nur selten verwendet: Zur Erzeugung einer kurzen definierten Verzögerung. Meist gebraucht man ihn bei der Erstellung eines Programmes als Platzhalter oder bei der Fehlersuche, um zum Beispiel unerwünschte Sprünge zu ersetzen.

### Die Transporteure: TAX, TAY, TXA und TYA

Ab und zu ist es nötig, Registerinhalte untereinander auszutauschen. Viele Dinge (Addition, Subtraktion und so weiter) können nur im Akku geschehen. Wenn wir eine solche Operation beispielsweise mit dem Inhalt des X-Registers ausführen wollen, verschieben wir diesen Inhalt mit dem Befehl TXA. »Transfer X into accumulator« also »übertrage X-Register in den Akku« bedeutet das. Analog verwendet man TYA, um Y-Regi-ster-Inhalte in den Akku zu schieben oder für den umgekehrten Weg TAY beziehungsweise TAX (Akkuinhalt ins Y- beziehungsweise ins X-Register schieben). Genau genommen wird nicht übertragen, sondern nur kopiert: Die Register, aus denen verschoben wird, bleiben unverändert. Weil die jeweiligen Zielorte der Verschiebung (Akku, X- oder Y-Register) vom neuen Inhalt überschrieben werden, können sich auch Flaggen ändern. Betroffen sind von dieser Möglichkeit die N- und die Z-Flagge. Alle vier Befehle bestehen aus einem Byte und können natürlich nur implizit adressiert werden.

### So springen die Assembler-Alchimisten: JMP, JSR

JMP und JSR entsprechen ungefähr den vom Basic her bekannten Befehlen GOTO und GOSUB.

**JMP** kommt von »jump to ad-dress«, also »springe zur angegebenen Adresse«. Nehmen wir uns wieder ein Beispiel vor:
JMP 1500
bewirkt einen Sprung zur Adresse 1500. Das funktioniert so: In den Programmzähler werden LSB und MSB der Zieladresse geladen. Das war dann auch schon der Sprung, denn der Programmzähler ist der Pfadfinder des Computers: Die Adresse, die dort steht, wird als nächste bearbeitet. Schalten Sie doch mal den SMON ein (oder einen anderen Monitor) und sehen Sie sich das mit folgenden Befehlen an:
**1400 JMP 1500**
Dort unterbrechen wird den Computer mit
**1500 BRK**

So weit, so gut: Wir starten mit dem SMON-Kommando G 1400 und erhalten eine Registeranzeige mit dem Programmzählerstand 1501. Genau das hatten wir ja erwartet.

Weniger durchschaubar ist das folgende Beispiel:
**1400	LDA	#00
1402	LDX	#16
1404	STA	1300
1407	STX	1301
140A	JMP	(1300)**
Dazu gehört dann noch die Programmzeile:
**1600 BRK**

Wenn Sie das genauso eingegeben haben und dann mittels G 1400 starten, erhalten Sie eine Registeranzeige mit dem Programmzählerstand 1601.

Schon an der neuen Schreibweise des Argumentes in Zeile 140A werden Sie bemerkt haben, daß hier nicht mehr die normale absolute Adressierungwie zuvor angewendet wird. Dies ist eine neue Form: Die **indirekte Adressierung**. Indirekt deswegen, weil wir nicht mehr direkt die Zieladresse angeben, sondern einen sogenannten Vektor. Ein Vektor besteht aus zwei aufeinander folgenden Speicherzellen (hier also 1300 und 1301), die in der Form LSB/MSB die eigentliche Zieladresse enthalten. Das LSB von $1600 ist $00. Das haben wir über den Akku nach $1300 geladen. Das MSB $16 kam durch das X-Register an seinen Platz $1301:

TODO

Zieladresse 16	00
MSB	LSB
↑	↑
Vektor	1301	1300

Das ist die Methode der toten Briefkästen, die in Kreisen der Assembler-Alchimisten anscheinend genauso beliebt ist wie bei Agenten. So wie diese im hohlen Baum die Treffpunktanschrift hinterlegt finden, verläßt sich unser Computer auf die Speicherstellen 1300 und 1301 für die Angabe der Zieladresse.

Diese Art der Adressierung ist im wahrsten Sinn des Wortes ein Unikum: Es gibt sie nämlich nur für den JMP-Befehl! Davon wird allerdings dann auch recht häufig Gebrauch gemacht, zum Beispiel im Betriebssystem unseres Computers. Aber darüber und über die Vektoren, die dazu verwendet werden, soll ein andermal berichtet werden.

Wir dürfen nämlich nicht den anderen **Sprungbefehl JSR** vergessen. JSR steht für »jump to subroutine«, was eingedeutscht etwa bedeutet »springe zurn Unterprogramm«. Genauso wie m Basic Unterprogramme durch GOSUB (Zeilennummer) aufgerufen werden, kann das auch hier geschehen durch JSR Adresse. Hier ist nur die absolute Adressierung möglich. Das erste Beispiel soll uns zeigen, wie dieser Befehl funktioniert:
**1400 JSR 1500**
Dort soll dann erstmal stehen:
**1500 BRK**

Noch nicht starten!! Zunächst einmal verzeihen Sie mir diese Programmierer-Todsünde: Aus einem Unterprogramm heraus den Programmablauf zu beenden! Ich werd’s auch nie wieder tun. Hier geschieht das nur zu Lehrzwecken. Was läuft ab: Der Programmzählerinhalt plus 2 wird auf den Stapel gelegt und dann die Adressse 1500 in den Programmzähler geladen. Ebenso kurz wie unklar! Was ist denn ein Stapel? Also langsam, Schritt für Schritt.

Der Sinn von Unterprogrammen ist ja, daß der Computer nach Ende der Bearbeitung wieder ins aufrufende Hauptprogramm zurückkehrt. Er muß sich aber dazu irgendwo merken, von wo aus er zum Unterprogramm gesprungen ist. Dazu verwendet er den Stapel. Das ist em Speicherbereich ($0100 bis $01FF), der direkt vom Prozessor aus verwaltet wird. Die genaue Architektur und Handhabung dieses »Prozessor-Stack« werden wir noch in einer späteren Folge kennenlernen. Uns soll hier nur interessieren, daß es einen Zeiger gibt, der auf den nächsten freien Platz im Stapel weist und daß dieser Speicher von oben nach unten gefüllt wird (wie in Basic bei den Strings). Wenn Sie mit Hilfe des SMON mal in den Stapel hineinsehen wollen, dann geben Sie doch mal ein M 0100 01FF. Was nun genau bei Ihnen drin steht, ist sehr von der vorherigen Nutzung Ihres Computers abhängig. Der Mikroprozessor nutzt den Stapel bei sehr vielen Tätigkeiten. Es kommt auch nur auf den Teil des Stapels an, der durch den Stapelzeiger als gefüllt bezeichnet wird. Der Stapelzeiger wird beim SMON in der Registeranzeige als SP angezeigt. Wenn Ihr Stapelzeiger (prüfen Sie das doch mal durch Eingabe von R) nun zum Beispiel F6 zeigt, dann bedeutet das, daß alle Stapelplätze von $01F6 an abwärts frei und die oberhalb bis $01FF besetzt sind. Beim Nachsehen mit M 01F0 01FF finden Sie dann beispielsweise:

TODO

**:01F0 20 00 20 AA C1 FA <u>C0</u> 46**
**:01F8 E1 E9 A7 A7 79 A6 90 E3**

Die Speicherstelle, auf die der Stapelzeiger weist, ist unterstrichen. Nun starten wir mit G 1400 unser kleines verbotenes Testprogramm. Es meldet sich die Registeranzeige. Im Stapelzei-ger steht jetzt F4 (oder eben Ihr vorhergegangener SP minus 2). Wenn wir nun wieder im Stapel nachsehen mit M 01F0 01FF, dann finden wir im Gegensatz zur obigen Anuzeige nun:

TODO

**:01F0 20 AA 01 FA <u>C0</u> 02 14 46**
 - 11 11
**:01F8 E1 E9 A7 A7 79 A6 90 E3**

Unterstrichen ist wieder das Ziel des Stapelzeigers, der jetzt zwei Plätze weitergerückt ist, um der durch Pfeile gekennzeichneten Adresse 1402 (als LSB/MSB) Raum zu schaffen. $1402 ist das letzte Byte des JSR-Befehls. Wie wir den Programmzähler kennen, ist er im allgemeinen immer einen Schritt voraus. Hier liegt er aber einen zurück, falls er nach Beendigung des Unterprogrammes an der notierten Adresse weitermacht. Dazu kommen wir gleich noch. Was wir am Programmzähler aber auch noch nach Ablauf unseres kurzen Beispielprogrammes ablesen können, ist die Tatsache, daß die Sprungadresse 1500 in ihn geschrieben wird, somit der Sprung dann also stattgefunden hat.

Nun bauen wir das kleine Progrämmchen etwas um:
**1400 JSR 1500**
**1403 BRK**
Das Unterprogramm soll nur aus dem Rücksprung bestehen:
**1500 RTS**

Verlangen Sie nun noch vor dem Start eine Registeranzeige mit R und merken Sie sich den Wert des Stapelzeigers. Dann starten Sie das Programm mit G 1400 und achten Sie auf die neue Registeranzeige. Zwei Dinge interessieren uns:

1)	Der Wert des Stapelzeigers ist unverändert geblieben.
2)	Der Programmzähler weist nun auf $1404.

Wenn Sie nun nochmal mit dem M-Befehl des SMON in den Stapel sehen, werden Sie unter Umständen zwar noch die Adresse 1402 dort finden (dann nämlich, wenn wir den Stapel seit dem letzten Programm nicht verändert haben). Wie Sie aber inzwischen wissen, hätte durch den neuen JSR-Befehl nochmal 1402 dort eingetragen sein müssen. Das stand da auch einige Mikrosekunden lang... bis der RTS-Befehl wirksam wurde. RTS macht ziemlich viel:

1)	RTS holt die auf dem Stapel gespeicherte Adresse ab, und schreibt sie in den Programmzähler.
2)	RTS vermindert dabei den Stapelzeiger um 2.
3)	RTS addiert zum Programmzähler eine 1.

Deswegen kann das Programm also bei $1403 weiterlaufen und der Programmzähler nun hinter dem BRK-Befehl stehen.

Machen Sie doch mal etwas anscheinend total Verrücktes: Starten Sie mit G 1500. Es gibt da zwei Möglichkeiten, was geschehen kann: Entweder stand da noch vom ersten unterbrochenen Testprogramm die Adresse 1402. Dann endete nun alles mit einer Registeranzeige, bei der der Stapelzeiger um 2 höher gerutscht ist.

Oder da stand diese Adresse nicht mehr. Dann befinden Sie sich nun wieder im Basic. Wieso eigentlich? Als nächste Adresse finden Sie auf dem Stapel $E146 (dez.57670). Diese Adresse + 1 wird ja durch RTS in den Programmzähler gerufen. Ein Sprung an diese Adresse ist ein Sprung m ein Programm des Betriebssystems. Haben Sie ein ROM-Listing? Dann sehen Sie mal nach: Dort steht der Be-fehl...RTS. Dieses neuerliche RTS holt nunjedenfalls die nächste Adresse vom Stapel: $A7E9 (dez.42985). Diese Adresse + 1 im Programmzähler führt unseren Computer in die Basic-Interpreter-Schleife, also ins Basic zurück.

Wir haben so viel über den Stapel gehört, daß wir JSR fast schon wieder aus den Augen verloren haben. Deswegen nochmal eine kurze Übersicht:
a) JSR speichert den Programmzählerwert des letzten Bytes des Befehls auf dem Stapel<br>zum Beispiel 1402
b)	stellt dabei den Stapelzähler um 2 zurück<br>zum Beispiel von $F6 nach $F4
c) schreibt in den Programmzähler die angegebene Zieladresse, zum Beispiel 1500
d)	Das Unterprogramm wird abgearbeitet bis der RTS-Befehl auftaucht.
e)	Dann wird die gemerkte Adresse +1 in den Programmzähler geschrieben<br>
zum Beispiel 1402 +1 = 1403
f) und dabei der Stapelzähler wieder um 2 erhöht,<br>zum Beispiel von $F4 wieder zu $F6
g)	Das Programm läuft nun wieder nach dem JSR-Befehl weiter,<br>zum Beispiel also bei 1403.

Nun sollte eigentlich auch klar sein, warum ein Aussprung aus einem Unterprogramm oder ein Abbruch im Unterprogramm eine Programmierer-Todsünde ist: Der Stapelzeiger wird nicht zurückgestellt. Die gemerkte Rücksprungadresse versauert allmählich aufdem Stapel. Noch schlimmer sind solche Sachen in einer Schleife, wo mehrfach aus dem Unterprogramm ausgebrochen wird: Hier ist der Stapel bald voll Müll und der Computer beendet seine Zusammenarbeit mit dem Programmierer. Weil aber Basic-Programme nichts anderes sind als eine Folge von Maschinenprogrammen, die je nach Befehl durch den Interpreter aneinandergereiht werden, ist das auch in Basic eine Todsünde. Wir wollen aber nicht so hart mit uns umgehen: Wenn wir gelernt haben, wie man mit speziellen Assembler-Befehlen im Stapel herumschaufeln kann, dann haben wir bei richtiger Anwendung von vorne-herein jedenfalls in diesem Punkt die Absolution erhalten.

## Alles fließt: Fließkommazahlen

Jeder, der tiefer in die Geheimnisse der Assembler-Alchimie eindringen will, muß sich vertraut machen mit der häufigsten Art der Zahlenverarbeitung in unserem Computer. Das ist die Handhabung von Fließkommazahlen (auch Gleitkommazahlen genannt). Wir werden dazu folgende Fragen zu klären haben:

1)	Was sind Fließkommazahlen?
2) Wie sehen sie im binären Zahlensystem aus?
3)	Wie behandelt unser Computer positive und negative Fließkommazahlen?
4)	Wie können wir als Programmierer Einfluß nehmen auf die Verarbeitung dieser Zahlen im Computer?

Die Behandlung dieser vier Fragen wird uns eine ganze Weile beschäftigen. Fangen wir mit der ersten an: In Standardwerken der Mathematik werden Sie lange suchen müssen, um den Begriff »Fließkommazahl« zu finden. Im deutschen Sprachraum gibt es häufiger die Bezeichnung »wissenschaftliche Zahlendarstellung«. Das klingt sehr hochgestochen und ist eigentlich ganz einfach. Leser der Grafik-Serie werden sich vielleicht noch erinnern: Die Zahl 1000 kann man auf verschiedene Weise darstellen:

1000 = 10 * 10 * 10 = 10↑3 ect.

Die hochgestellte Zahl (in Computerschreibweise: Die Zahl hinter dem Hochpfeil) ist hier gleich der Anzahl der Stellen minus 1 (1000 hat vier Stellen, also ist die Hochzahl eine 3). Diese Hochzahl nennt man Exponent (vom lateinischen exponere = anzeigen, herausheben). Nehmen wir nun einige andere Zahlen:
200 = 2 * 100 = 2 * 10↑2
oder
2500 = 2,5 * 1000 = 2,5 * 1013

Ich glaube, jetzt beginnt es Ihnen klarzuwerden, daß man auf diese Art wohl alle Zahlen irgendwie darstellen kann. Man dröselt die Zahlen auseinander, bildet ein Produkt, von dem der eine Multiplikator durch 10 teilbar ist (durch die Basis unseres normalen Zahlensystems). Genauer gesagt: Ein Faktor (also in den Beispielen 1000 oder 100) ist darstellbar als Potenz von 10. Der andere Faktor (in den Beispielen 1 oder 2 oder 2,5) wird Mantisse (vom lateinischen manitissa = Zugabe, Anhang, Schleppe) genannt. Sehen wir uns nochmal 2500 an:

TODO

Das letzte war nur der Vollständigkeit halber, denn irgendeine Zahl hoch 0 ist immer 1. Man kann auch aus der 2500 folgendes machen:

TODO

Dabei bedeutet:
10↑-2 = 1/10↑2 = 0,01

Man kann sich das merken, indem man die Anzahl der Stellen zählt, um die man das Komma verschiebt. Diese Anzahl addiert man dann zur Hochzahl. Zur Erläuterung:
0,12345 = 1,2345 * 10↑-1

Wir haben das Komma um eine Stelle nach rechts gerückt, weshalb wir die Hochzahl —1 schreiben müssen (vorher war da nämlich unsichtbar die Hochzahl 0: und 10↑0= 1).
0,12345 = 123,45 * 10↑-3

Hier wurde das Komma um drei Stellen nach rechts verschoben. Daher der Exponent —3. Sie sehen folgenden Zusammenhang:

Komma eine Stelle nach rechts verschoben: Exponent + (—1). Zum Beispiel 0,1234*10↑-2= l,234*10↑-3

Komma eine Stelle nach links verschoben: Exponent +1. Zum Beispiel 3,14*10↑2 = 0,314*10↑3

Verstehen Sie nun, warum man diese Art der Zahlendarstellung Fließkomma- oder Gleitkommazahlen nennt?

Vielleicht sehen Sie aber noch nicht den Sinn der Fließkommazahlen ein. Dazu gebe ich Ihnen zwei einsichtige Beispiele. Der Atomkern eines Heliumatoms wiegt etwa (halten Sie sich fest): 0,000 000 000 000 000 000 000 000 006 643 kg.

Sehr unbequem, diese ganzen Nullen immer mitzuschleppen. Wir verschieben deshalb das Komma um 27 Stellen nach rechts und schreiben dann 6,643*10↑-27 kg.

2. Beispiel: Wir haben einen Ballon mit diesem Gas gefüllt. Bei normalen Temperatur- und Luftdruckbedingungen befinden sich in einem Kubikzentimeter im Ballon ungefähr (nochmal festhalten!):
26 900 000 000 000 000 000 Heliumatome

Wieder eine recht unangenehme Nullschlepperei. Wir verschieben das Komma um 19 Stellen nach links und erhalten 2,69*10il9 Heliumatome. Fein, nicht wahr!

Abgesehen von der höheren Bequemlichkeit: Der Computer müßte allerhand Speicherplatz zur Handhabung der vielen Nullen bereitstellen. Mit BCD-Zahlen könnten wir zwar jede Zahl erfassen, hätten aber immer unterschiedlich viele Bytes zu verarbeiten. Wenn wir Fließkommazahlen verwenden, können wir — wie Sie noch sehen werden — jede (na sagen wir mal: fast jede) Zahl in der gleichen Anzahl Bytes aufbewahren.

Vom Basic her kennen Sie Fließkommazahlen auch (hier wird das Komma allerdings durch den Punkt ersetzt, entsprechend der angloamerikanischen Schreibweise). Das sind die, wo man zum Beispiel schreibt 6.02E23 oder 6.02E + 23, was dann bedeutet 6,02*10123. E steht dort für Zehnerexponent. Durch die Art, wie Fließkommazahlen im normalen Computerdasein gespeichert werden, ergeben sich obere und untere Grenzen. Die höchste in Basic verarbeitbare Zahl im C 64 ist + 1.70141183*10E38

Größere Zahlen verursachen in Basic einen OVERFLOW ERROR. Was in Maschinensprache mit größeren Zahlen geschieht, ist weitgehend unsere Sache. Die dem Betrag nach kleinste verarbeitbare Zahl ist ± 2.93873588*10E-39

In Basic arbeitet bei Unterschreitung der Computer einfach mit einer Null weiter. Für die Behandlung in Maschinensprache sind ebenfalls wir als Programmierer verantwortlich.

Für diesmal sei’s genug der Zahlenspiele: In der nächsten Ausgabe werden wir uns weiter mit Fließkommazahlen befassen.

## Die USR-Funktion

Wieder einmal soll uns das Zusammenspiel von Basic und Maschinensprache beschäftigen. Einen Aufruf von Maschinenroutinen — nämlich den mit SYS — haben wir schon kennengelernt. Wir POKEten die zu übergebenden Werte an die Abrufspeicherstellen. Bei diesen Werten hat es sich um einfache Integerzahlen gehandelt, zum Beispiel die Anzahl der Glieder einer zu summierenden arithmetischen Reihe. Was tun wir aber, wenn wir Fließkommavariable an ein Maschinenprogramm übermitteln wollen? Gewiß, werden Sie sagen, lernen wir das ja in den nächsten Folgen und können dann entsprechende POKE-Kommandos geben. Damit haben Sie auch recht, nur ist das dann der »harte« Weg. Es gibt auch einen problemlosen »weichen« Weg, nämlich das USR-Kommando.

USR ist ein Basic-Befehl und rührt her von »User callable machine language subroutine«, also »durch den Benutzer aufrufbares Maschinensprachunterprogramm«. Darin liegt eigentlich noch nichts Neues gegenüber dem SYS-Befehl. Im Gegensatz zu SYS — wo das Argument die Einsprungadresse des Maschinenprogrammes ist — übergibt USR als Argument eine beliebige Fließkommavariable in festgelegter Form an eine sehr nützliche Speicherstellenkombination, den Fließkomma-Akkumulator 1, von uns künftig einfach FAC genannt. Der FAC belegt die Speicherstellen 97 bis 102 ($61 bis $66). Wenn das eventuell in Basic benötigte Ergebnis dort auch in der vorgeschriebenen Form abgelegt wird, kann es im Basic-Pro-gramm weiterverwendet werden. Keine Angst, dazu kommen wir bei der weiteren Behandlung der Fließkommazahlen noch ganz ausführlich zu sprechen. Heute soll uns das noch nicht belasten. Als Argument kann man nämlich auch irgendeine bedeutungslose Größe, ein sogenanntes Dummy angeben, das dann gar nicht weiter verwendet wird. Der USR-Be-fehl dient in diesem Fall lediglich dem bequemen Ansteuern eines Maschinenprogrammes.

Woher weiß unser Computer beim USR-Befehl, welche Maschinenroutine er im 64-KByte-Speicher bearbeiten soll? Beim SYS-Befehl ist das klar: Das Argument sagt es:
SYS 24345
läßt den Programmzähler auf dez.24345 zeigen. Aber wenn wir eingeben:
USR(24345)
dann packt der Computer die Zahl 24345 als Fließkommavariable in den FAC und meldet dann einen SYNTAX ERROR. Das liegt daran, daß der Basic-Interpreter beim USR-Befehl einen der oben kennengelernten indirekten Sprünge vollführt:
JMP (311)

$311/312 (in dezimal 785/786) ist also ein Vektor, und der weist im Normalfall zu einer Routine, die den SYNTAX ERROR ausgibt (dez. 45640). Bevor wir also den USR-Befehl geben, müssen wir in diesen Vektor die Startadresse unserer Maschinenroutine schreiben:
dez. 24345 = $5F19
LSB $19 = dez. 25 in Speicher 785 mit POKE 785,25
MSB $5F = dez. 95 in Speicher 786 mit POKE 786,95

Jetzt weiß der Computer, wohin er beim USR-Aufruf springen soll, und solange, bis wir den Vektor wieder ändern, führt er bei jedem USR-Befehl unser bei 24345 stehendes Maschinenprogramm aus. Wir müssen nur noch dafür sorgen, daß dort dann auch wirklich eines anfängt. Ein Beispiel werden wir nachher noch behandeln.

### Der harte Kern: Nochmal Speicherfragen

Die Struktur des C 64-Speichers ist vereinfacht schon in der Grafik-Serie und zu Beginn dieses Kurses gezeigt worden. Dabei tauchten zwei ROM-Be-reiche auf, die wir Basic-Interpreter und Betriebssystem genannt haben. Diese Unterteilung ist nicht ganz korrekt. Wenn Sie über ein ROM-Listing verfügen und beispielsweise das Ende des ROM-Bereiches von $A000 bis $BFFF sowie den Anfang des oberen ROM ($E000 bis $FFFF) untersuchen, dann stellen Sie fest, daß ab dez. 49087 ($BFBF) die Basic-Funktion EXP bearbeitet wird. Der letzte Befehl vor $C000 beendet diese 'Funktion aber nicht etwa, sondern dort steht:
JMP E000

Tatsächlich läuft ab $E000 bis $E042 die Bearbeitung der EXP-Funktion munter weiter, und auch danach finden sich allerlei Basic-Befehle (SIN, COS und so weiter). Da liegt also keine klare Trennung vor, sondern ein Mischmasch. Wir sollten uns vielleicht angewöhnen — statt vom Interpreter und dem Betriebssystem —, vom unteren und oberen ROM-Bereich zu sprechen.

Eine andere Unterscheidung ist dagegen sinnvoll: Wie einige Besitzer neuerer Commodore 64 sicherlich bemerkt haben, sind Teile der ROM-Routinen im Laufe der Zeit verändert worden. Hauptsächlich geht es bei den aktuellen Neuerungen dieser internen Maschinenprogramme um die Farbgebung der Zeichen. Man kann eigentlich nie so recht wissen, was den Software-Planern von Commodore noch alles einfällt. Jedenfalls können deren Ideen manchmal recht dramatische Folgen haben, nämlich dann, wenn Sie ein fabelhaftes Maschinenprogramm gebaut haben, welches ROM-Routinen direkt verwendet. Der Programmierer spielt auf diese Weise eine milde Form des russischen Roulette. Glücklicherweise halten sich die Änderungen in Grenzen, und wir dokumentieren unsere Programme ja auch immer gut (Sie etwa nicht??). Notwendige Umbauten können also leicht vonstatten gehen.

Ganz ohne ROM-Routinen-Verwendung kommt man eigentlich kaum aus. Es gibt aber einen ROM-Bereich, für den Commodore verspricht, keinerlei Änderungen durchzuführen: die KERNAL-Sprungtabelle.

Das ist ein Programmbereich ($FF81 bis $FFF5), in dem 39 JMP-Befehle enthalten sind (zum Teil in absoluter, aber auch in indirekter Adressierung). Jeder dieser Sprungbefehle weist auf die Einsprungadresse eines Maschinenprogrammes. Da finden sich alle wichtigen Ein/Ausgabe-Operationen, Systemtakt-und Uhrsteuerungen und anderes mehr. Wir werden uns nach und nach damit vertraut machen. In der Tabelle 3 sind die KERNAL-Adressen und ihre Funktion aufgeführt. Manche davon können ohne jede Vorbereitung benutzt werden, andere brauchen bestimmte Routinen oder Angaben, um sinnvoll zu arbeiten.

Die Absicht von Commodore ist es, daß jeder Aufruf von zum Beispiel FFD2 die Ausgabe eines Zeichens bewirkt, und zwar unabhängig davon, welchen Computer in welcher Version wir benutzen. Das Programm, welches diese Zeichenausgabe letztendlich ausführt, kann sich ändern, kann in ganz andere Speicherbereiche gelegt werden. An der Stelle $FFD2 wird aber immer ein JMP mit der Einsprungadresse stehen. Leider ist diese Sprungtabelle viel zu knapp gehalten. Es gibt so viele interessante ROM-Routinen, die wir alle ohne diese schöne Sicherheit anspringen müssen.

## Die Urzelle eines Programmprojektes

Wir sind jetzt soweit, daß wir die Urzelle eines Programmprojektes, welches uns eine lange Zeit begleiten wird, aufbauen können. Wir wollen etwas unter den Teppich kehren. Der Teppich, das sind die uns bislang nicht zugängigen RAM-Bereiche unter den ROMs. Haben Sie das nicht auch schon mal erlebt, daß Sie während einer Programmarbeit plötzlich feststellen, Sie benötigen zum Beispiel für eine Zwischenrechnung ein weiteres Programm, oder Sie wälzen Listen und denken sich, ein kleiner Hilfsbildschirm wäre jetzt von Nutzen, oder....

Mit diesem heute zu startenden Programm wäre all das und noch viel mehr realisierbar. Es soll auf einfache Weise beliebige Speicherbereiche unters ROM schieben und sie wieder hervorholen können.

Natürlich braucht die Entwicklung dieses Projektes einige Zeit, zumal wir noch vieles lernen müssen. Deswegen sind wir in dieser ersten Urzelle noch sehr eingeschränkt: Wir verschieben zuerst einmal nur eine Bildschirm-Kopfzeile unter den oberen ROM-Bereich. Auch in dieser einfachsten Version gibt es noch einige Programmteile, die Sie erst nach der nächsten Ausgabe verstehen werden. Aber irgendwann müssen wir ja mal anfangen, Nägel mit Köpfen zu machen.

Unser Maschinenprogramm soll durch die USR-Funktion aufgerufen werden. Wie wir es in dieser Ausgabe gelernt haben, muß deshalb vor dem ersten Aufruf eine Initialisierung durch Belegen des USR-Vektors mit unserer Startadresse stattfinden. Die Startadresse soll $02B6 (dez. 694) sein, denn dort gibt es einen freien RAM-Bereich bis inklusive $02FF (dez. 767), der weder andere Programme noch Kassettenoperationen stört. Das MSB $02 ist dezimal auch 2 und wird nach 786 gePOKEt:
POKE786,2

Das LSB $B6 ist dezimal 182 und soll in 785 geschrieben werden:
POKE785,182

Damit ist der USR-Vektor gestellt und wir brauchen uns nicht mehr weiter darum zu kümmern: Jeder USR-Aufruf wird nun den Start des Programmes bewirken. Nun zum Programm selbst. In Bild 1 finden Sie ein Flußdiagramm dazu.

Zunächst konstruieren wir den Teil, der die erste Bildschirmzeile nach $E000 und folgende Speicherstellen schiebt. Das X-Register verwenden wir als Index und laden es mit dez.40 = $27.

Schalten Sie also den SMON ein und starten Sie den Assembler mit:
A 02B6
Dann geben Sie ein:
**02B6 LDX #27**

Nun packen wir das letzte Zeichen der obersten Bildschirm-zeile in den Akku:
**02B8 LDA 0400,X**

In das Y-Register legen wir die dazugehörige Farbe aus dem Bildschirmfarbspeicher:
**02BB LDY D800,X**

Den Akkuinhalt — also die Bildschirminformation — legen wir nach $E000 + $27:
**02BE STA E000,X**

Dasselbe tun wir mit dem Farbcode, der ab $E028 + $27 abwärts gespeichert wird. Leider kann man STY nicht X-indi-ziert-absolut adressieren (siehe Tabelle 1). Deshalb schieben wir zuerst denY-Registerinhalt in den Akku:
**02C1	TYA**
**02C2	STA E028,X**

Damit ist das letzte Zeichen der Kopfzeile verschoben. Wir zählen das X-Register um 1 herunter:
**02C5 DEX**

Der X-Index weist nun auf das vorletzte Zeichen, mit dem sich alles ab $02A9 wiederholt. Wenn das X-Register bis 0 heruntergezählt ist, weist es auf das erste Zeichen der Kopfzeile. Die Schleife muß dann noch einmal durchlaufen werden und ein weiteres Herabzählen des X-Registers erzeugt $FF, was zum Setzen der N-Flagge führt. Das ist dann unser Signal, daß die gesamte Kopfzeile übertragen wurde. Die N-Flagge wird durch den BPL-Befehl getestet:
**02C6 BPL 02B8**

So weit, so gut. Wir hätten natürlich auch das X-Register von 0 an hochzählen können. Zum Beenden der Schleife wäre dann aber ein CPX-Befehl erforderlich gewesen, der jedesmal den X-Registerinhalt mit der Zahl $27 vergleicht.

**MERKE**: Indexregister in Schleifen abwärts zu zählen, kann Rechenzeit einsparen!

Ab $02CE soll der umgekehrte Vorgang, also das Zurückschieben der vorher gespeicherten Kopfzeile in den Bildschirmspeicher geschehen. Das einfachste wäre es sicherlich, diesen Programmteil mit einem weiteren USR-Kommando zu starten. Das sähe dann so aus:

1.USR-Befehl - schiebt Kopfzeile unter oberes ROM
2.USR-Befehl - holt Kopfzeile zurück in Bildschirmspeicher
3.USR-Befehl - schiebt wieder Kopfzeile unter ROM
4.USR-Befehl - holt sie wieder zurück und so weiter.

Weil aber das Umstellen des USR-Vektors durch POKEs vom Basic aus lästig ist, tun wir das einfach immer am Ende des betreffenden Maschinenprogrammabschnittes. Wir schreiben also das LSB der Programmfortführung ($CE) nach $311. Das MSB bleibt unverändert $02.
**02C8	LDA #CE**
**02CA	STA 0311**
**02CD	RTS**

Mit dem RTS sind wir wieder im Basic-Programm gelandet, welches nun normal weiterverarbeitet wird. Erst ein neues USR-Kommando — im Programm oder im Direktmodus — startet den zweiten Teil unseres Maschinenprogrammes (weil in $0311, — der Einsprungpunkt des USR-Befehls — die Startadresse der auszuführenden Routine steht).
Einfache Befehle mit großer Wirkung
In diesem 2. Teil müssen wir erst einige Befehle geben, die Sie jetzt vielleicht noch nicht verstehen. Das hängt damit zusammen, daß zum Herauslesen des RAM unter dem ROM das ROM ausgeschaltet werden muß (entspricht POKE 1,53): 02CE	LDA 01
02D0	PHA
02D1	LDA #35
02D3	STA 01
(Der PHA-Befehl dient hier zur Zwischenspeicherung des Akku-Inhaltes). Das ist hiermit geschehen und wir kommen wieder in bekannte Gefilde mit der Ausleseschleife:
02D5	LDX	#27
02D7	LDY	EOOO,X
02DA	LDY	E028,X
02DD	STA	0400,X
02E0	TYA
02E1	STA	D800,X
02E4	DEX
02E5	BPL	02D7
Damit ist die gesamte gespeicherte Kopfzeile wieder zurückgeholt und wir können das ROM wieder einschalten:
02E7	PLA
02E8	STA 01
Falls nun wieder ein USR-Kommando auftaucht, soll die Kopfzeile mit dem 1. Programmteil unter das obere ROM gelegt werden wie am Anfang. Wir müssen deshalb den USR-Vektor auf $02B6 zurückschreiben: 02EA	LDA	#B6
02EC	STA	0311
02EF	RTS
Das wärs! Wenn nun im Programm oder im Direktmodus wieder ein USR-Befehl auftritt, kann das Ganze von vorne beginnen. In dieser Version wird jedesmal eine neue Kopfzeile hin- und wieder zurückgeschoben. Wenn Sie eine einmal festgelegte Kopfzeile immer wieder benutzen möchten, dann stellen Sie den USR-Vektor einfach nicht mehr zurück: Lassen Sie also die Befehle bei 02EA und 02EC weg. Das Programm endet in dem Fall mit:
02EA RTS
Eine wichtige Bemerkung noch: So bequem der Ort auch ist, an dem unser kurzes Programm steht, er hat einen gravierenden Nachteil: Falls Sie mittels einer RESET-Taste oder per Software einen Basic-Kaltstart durchführen, geht unser Programm flöten! Dieser Speicherbereich wird im Reset-Programm nämlich mit lauter Nullen überschrieben. Deswegen speichern Sie es bitte bald ab.
Damit sind wir für diesmal am Ende. Sie finden noch als Listing 1 ein kleines Testprogramm für unsere Verschieberoutine, und in Tabelle 4 wie immer, eine Zusammenfassung aller wichtigen Daten der neuen Befehle. In der nächsten Folge greifen wir noch-einmal das Thema Fließkomma auf, werden die einfachsten und kürzesten Kurzspeicher-Befehle kennenlernen und beginnen mit den leistungsfähigsten Befehlen des 6502, den indirekt-indizier-ten-Befehlen.
(H. Ponnath/gk)
