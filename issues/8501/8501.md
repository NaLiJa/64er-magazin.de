# Lohnen sich Clubs?

Commodore 64-Clubs sind in den letzten zwölf Monaten wie Pilze aus dem Boden geschossen. Ihre Ziele sind weitgehend ähnlich: Erfahrungs-, Literaturund Programmaustausch — hin und wieder kommen dazu Fortbildung, gemeinsamer Einkauf oder Bildung von Arbeitsgruppen zum Schreiben bestimmter Programme oder für gemeinsame Hardware-Bastelei.

Lohnen sich solche Aktivitäten eigentlich für die Mitglieder? Kann man durch Sammelbestellungen — und wennja, bei welchen Produkten — wirklich wesentlich günstigere Preise herausholen, als durch Vergleich der Preise mehrerer Einzelhandelsgeschäfte und Versandhändler? Lohnt sich der Versuch, mit einer bestimmten Firma einen Rabatt für Clubmitglieder auszuhandeln oder achtet man lieber darauf, wo es gerade das eine oder andere Sonderangebot gibt? Wo sind Beispiele für besondere Erfolge, die in einer Arbeitsgruppe erzielt wurden? Welche ausländischen Benutzergruppen sind wegen ihrer Programmbibliothek oder aus anderen Gründen besonders interessant? Solche Fragen drängen sich dem Benutzern auf.

Ich würde mich freuen, wenn Sie uns Ihre Erfahrungen schreiben würden. Wir werden in einer der nächsten Ausgaben in einem Bericht darauf eingehen.

Michael Pauly, Chefredakteur

# Neues Jahr fast neues 64'er

> Das Jahr 1985 steht vor der Tür, und wie das so üblich ist, nimmt man sich für ein neues Jahr immer etwas vor. Sei es, sich das Rauchen abzugewöhnen, oder freiwillig auf der Autobahn nicht schneller als 100 km/h zu fahren oder sonstige, unmögliche Dinge. Auch wir haben natüriich eine Menge guter Vorsätze.

Einer dieser Vorsätze ist eigentlich nicht neu, denn wir praktizierten ihn schon 1984, nämlich ein rundum zufriedenstellendes Magazin für Commodore-Änwender zu machen. Zu beurteilen, ob uns das gelungen ist, bleibt letztendlich eben diesem Anwender, also Ihnen, überlassen. Wir als Redaktion meinen — nein. Sicherlich, es sind schon einige Schritte in die richtige Richtung zu erkennen, trotzdem, es bleibt noch viel zu tun. Und das haben wir uns für das Jahr 1985 vorgenommen.
Sowarein '84er-Schritt, die Listings für den Commodore 64 im 40 Zeichen-Format abzudrucken. Dadurch konnte ein direkter Vergleich des eingetippten Programms auf dem Bildschirm mit der abgedruckten Version vollzogen werden. Bei Programmen mit vielen DATA-Zeilen bauten wir relativ sichere Prüfsummen ein. Doch all das erwies sich als noch nicht ausreichend, wie uns die vielen Anrufer bestätigten, die immer noch Schwierigkeiten beim Eintippen der Programme hatten. Probleme gab es hauptsächlich bei der Identifizierung der Steuer- und Grafikzeichen, bei DATA-Zeilen und den VC 20-Listings.

## Sichere Listings

Deshalb sind ab dieser Ausgabe alle Listings ohne Steuer- und Grafikzeichen abgedruckt sowie mit einer zeilenweisen Prüfsumme versehen. Wie das im einzelnen aussieht, und vor allen Dingen wie in Zukunft unsere Listings abzutippen sind, lesen Sie bitte in dem Artikel »Checksummer — nie mehr Probleme beim Abtippen«. Eins ist auf jeden Fall gewährleistet. Sie wissen nun nach jeder Zeile, ob sie richtig eingegeben wurde. Damit gehört das unvermeidlich scheinende SYNTAX ERROR IN nach dem ersten Start der Vergangenheit an. Die Lupe für die Steuerzeichen kann man sich fürderhin auch sparen, die Herzchen und Strichlein gibt’s nicht mehr. Also nicht vergessen, zuerst den Checksummer eintippen (entweder für C 64 oder VC 20) und dann erst all die anderen interessanten Listings in dieser Ausgabe.

In vielen Zuschriften ist immer wieder zu lesen: »Macht weiter so!«. Genau das haben wir nicht vor. Denn würden wir auf unserem heutigen Stand verharren, der zugegebenermaßen nicht schlecht ist, bliebe kein Platz fürweitere Verbesserungen. Und das ist es, was wir noch anstreben.

## Lange lebe der C 64

Denn wen stört es nicht, die ewigen DATA-Wüsten abzutippen. Wir arbeiten zur Zeit an einem System, das das Eintippen von Maschinenprogrammen erheblich vereinfacht. Nur noch Zweidrittel des Volumens und etwa die Hälfte der Zeit werden in der neuen Form benötigt. Lassen Sie sich überraschen.

Der Übersichtlichkeit soll auch die neue Gestaltung der einzelnen Rubriken dienen. Die kompaktere Form der Kurse ermöglicht es uns, mehr Information auf gleichem Raum unterzubringen. Wie auch im vergangenen Jahr bitten wir unsere Leser um rege Mitarbeit. Nur wenn wir wissen, wo der Schuh drückt, können wir entsprechend darauf reagieren.

Speziell unsere VC 20-Leser sind besorgt, daß wir den VC 20 bald vergessen werden. Die VC 20-Anhänger können beruhigt sein, solange ihr Computer in großen Stückzahlen auf dem Markt ist, bleibt er in der Berichterstattung. Die Art der Artikel wird sich aber nach dem abzusehenden Einsatzgebiet als preiswerter Meß-, Steuer- und Regelcomputer richten.

Der Nachfolger für den VC 20, der C 16/116 ist mittlerweile in den Läden. Dies ist der ideale Einsteigercomputer mit einem sehr mächtigen Basic, der sich ebenfalls zu einem Renner entwickeln könnte. Wieder in Relation zu den verkauften Stückzahlen wird er von uns in Zukunft mit entsprechenden Beiträgen bedacht werden.

So wie der C 16 als direkter Nachfolger des VC 20 angesehen werden kann, sind viele auch der Auffassung, der Plus/4 wäre der Nachfolger des C 64. Diese Meinung ist nicht ganz richtig. Der Plus/4 soll den C 64 weder ersetzen noch erweitern. Er richtet sich an eine andere Zielgruppe, wie die Leistungsmerkmale und der Preis erkennen lassen. Man sollte also den Plus/4 völlig unabhängig vom C 64 sehen. Zum C 64 mehren sich mittlerweile die Anfragen, ob dieser Computer schon veraltet sei und sich ein Kauf noch lohnen würde. Ähnliche Fragen wurden, den VC 20 betreffend, bereits vor zwei Jahren an Computer persönlich gerichtet. Die Antwort können Sie aus dem langen Zeitraum schließen, den der VC 20 von da an noch »überlebt« hat. Zudem besitzt der C 64 wesentlich bessere Voraussetzungen, im harten Konkurrenzkampf zu bestehen. Erst wenn es Heimcomputer mit 16 Bit-Prozessoren unter 1000 Mark gibt, lohnt sich die Überlegung, den C 64 nicht mehr zu kaufen. Bis dahin dürfte aber auch oder gerade Commodore reagiert haben.

(aa)

## 64-Erweiterungen

XL80 heißt eine 80-Zeichen-Karte für den C 64, die General Automation vertreibt. Im Preis von zirca 400 Mark ist außerdem ein Textverarbeitungs- und ein Tabellenkalkulationsprogramm enthalten. Außerdem wurde ein Wafertapelaufwerk für den C 64 angekündigt, das bei Lade- und Speichervorgängen 10- bis 20mal schneller als die Datasette und immerhin noch dreimal so schnell wie das 1541-Diskettenlaufwerk sei. Zwei dieser Wafertape-Laufwerke könnten hintereinander geschaltet werden. Mitgeliefert wird zum Preis von zirka 200 Mark pro Laufwerk auch die notwendige Software einschließlich Kopierprogrammen. Auf ein Endlosband (Wafertape, Preis: zirka 9 bis 10 Mark) passen 128 KByte. (sc)

Info: General Automation, Hagenauer Str. 42, 6200 Wiesbaden, Tel. (0 6121) 2 30 93

## Die ersten 500 000 Commodore 64 verkauft

Am 15. November gab es im Karstadt-Computer-Center in Dortmund ein Jubiläum zu feiern. Der fünfhunderttausendste in Deutschland verkaufte C 64 wurde dort seinem Besitzer, Dr. Wolfgang Kuhn aus Recklinghausen, übergeben. Der Jubiläumskunde erhielt dabei nicht nur den Kaufpreis des Computers erstattet, sondern auch noch Disketten-Laufwerk, Farbmonitor und einen großen Sack voll Software geschenkt. Darüber hinaus spendete Karstadt zehn weitere C 64 für den Informatik-Unterricht an zwei Dortmunder Schulen. Mit 500 000 verkauften C 64 alleine in der Bundesrepublik und mehr als drei Millionen weltweit verkauften Geräten, ist der C 64 der erfolgreichste Computer aller Zeiten, gefolgt vom VC 20 mit insgesamt 1,5 Millionen verkauften Exemplaren. Dr. Kuhn, selbst Lehrer an einer berufsbildenden Schule, begründetete seine Entscheidung für den C 64 mit dem Hinweis, daß er endlich einmal den Wissensvorsprung seiner Schüler auf diesem Gebiet aufarbeiten wolle. Immer häufiger habe er von seinen Schülern Sätze zu hören bekommen wie »Aber Herr Kuhn, warum machen Sie das so umständlich? Mit meinem C 64 löse ich das viel schneller«.
Eine Aussage, die vermutlich symptomatisch für die derzeitige Situation im Schulwesen sein dürfte.

(ev)

## Commodore an Schulen

Nachdem der G 64 an vielen Gymnasien bereits der Standardcomputer für den Informatik-Unterricht ist, plant Commodore nach Aussage von Alwin Stumpf, Geschäftsführer Vertrieb Deutschland, nun die Einführung des C 64 speziell an Haupt-, Real- und berufsbildenden Schulen. Dabei ist allerdings nicht daran gedacht, an diesen Schulen einen Informatik-Unterricht einzuführen (»Wir brauchen kein Volk von Informatikern«), sondern es geht darum, auf die praktische Arbeit mit dem Computer vorzubereiten. Dazu gehört in erster Linie auch, den zukünftigen Lehrlingen und Praktikanten die Scheu vor dem Computer zu nehmen.
In Zusammenarbeit mit dem Westermann-Schulbuch-Verlag, der entsprechende Lernsoftware entwickelt, werden derzeit die Grundlagen für die breite Einführung des C 64 an Haupt- und Realschulen geschaffen.

Der Computer soll ähnlich Diaprojektoren, Film und Video, einfach ein weiteres technisches Medium zur Vermittlung von Unterrichtsinhalten werden, (ev)

## Ein wenig mehr fürs 64’er

Zum Jahresbeginn müssen wir den Preis fürs 64’er den gestiegenen Papier- und Herstellungskosten anpassen: Ab Ausgabe 1/85 beträgt der Einzelpreis 6,50 Mark; die Kosten für das Abonnement (12 Ausgaben) betragen ab 1. Januar 78 Mark. Vorteil für Abonnenten: Sie bekommen die Zeitschrift regelmäßig ins Haus geschickt und sind damit sicher, daß Sie keine Ausgabe verpassen.

# Commodore gestern heute morgen

> Wer hätte das vor zwei, drei Jahren zu denken gewagt? Ein Hersteller hält 50 Prozent des Marktes bei den Heimcomputern. Commodore hat es geschafft. Angefangen hat das mit Schreibmaschinen. Was jedoch noch viel interessanter ist, wie wird es weitergehen?

Er war eigentlich schon längst überfällig, der Bericht über die Entstehungsgeschichte von Commodore. Zum Jahreswechsel sollen deshalb der Werdegang und die Zukunftsaussichten dieses faszinierenden Unternehmens beschrieben werden.

Vor rund 26 Jahren wurde ein kleiner Verkaufs- und Reparaturladen für mechanische Schreibmaschinen in Toronto, Kanada, in Commodore International Limited umbenannt. Damit war der Name für den erfolgreichsten Personal- und Heim-Computer-Hersteller geboren. Inhaber dieser kleinen Firma war Jack Tramiel. Tramiel ist polnischer Abstammung, überlebte das Konzentrationslager und wanderte nach Nordamerika aus. Im Jahre 1958 hat er dann den kleinen Schreibmaschinenladen aufgemacht. Diesem Tramiel dürfte auch der Erfolg der ersten 25 Jahre zu verdanken sein. Er wird als ein Mann beschrieben der die Fähigkeit hat, im Bereich der Elektronik für Heim und Beruf die zukünftigen Bedürfnisse zu erkennen, und was noch viel wichtiger ist, rechtzeitig darauf zu reagieren. Das ist der Punkt, der Commodore auch heute noch auszeichnet.

Während dieser ersten Jahre entwickelte sich Commodore von einem Verkaufs- und Reparaturladen durch den Zukauf einer Berliner Firma, zum Hersteller für eben diese Schreibmaschinen. Anfang der 60er Jahre bot die Firma eine große Palette an Büroausrüstungen an, zudem übernahm sie den Vertrieb von Büromöbeln.

1965 kaufte Commodore die Möbelfirma, deren Distributor sie bisher war, auf und zog in deren Bürogebäude ein. Commodore stellt übrigens immer noch Büromöbel her, hauptsächlich Schränke und Tische sowie die Gehäuse für die CBM-Serie. Im selben Jahr lernte Tramiel den kanadischen Rechtsanwalt und Bankier Irvin Gould kennen, den jetzigen Präsidenten von Commodore. Diese beiden machten Commodore zu der Firma, die sie heute ist. Eines der ersten Aktionen dieses Führungsteams war es, die Firma für mechanische Addiermaschinen zu verkaufen, mit der Absicht sich einen japanischen Hersteller zu angeln, für den sie den Vertrieb übernehmen könnten. Während seines Aufenthalts in Japan bekam Tramiel dabei zum erstenmal eine elektronische Addiermaschine zu Gesicht. Er erkannte sofort, daß dieses Ding das Aus für die mechanischen Addiermaschinen bedeuten würde. Mit der auch heute noch gültigen Commodore-Philosophie »Wenn Du nicht Dein eigener Konkurrent bist, werden es andere für Dich sein« gab Tramiel die Suche nach dem mechanischen Addiermaschinenhersteller auf, fand dafür aber eine Firma die bereit war, unter dem Namen Commodore elektronische Rechner herzustellen.

1969 lief die Produktion in eigenen Werkstätten an. Man benötigte allerdings die ICs von Texas Instruments dafür. Damit gelang es Commodore aber, auch den ersten »richtigen« Taschenrechner — C108 genannt — mit sage und schreibe den gesamten vier Grundrechenarten auf den Markt zu bringen. Interessanterweise kostete dieser Taschenrecher damals genausoviel wie der C 64 heute. Bis 1974 weitete Commodore die Produktpalette der Taschenrechner kontinuierlich aus. Es kamen spezielle technisch-wissenschaftliche Rechner, »richtige«, programmierbare Computer und Speichereinheiten hinzu. Zu dieser Zeit war Commodore extrem abhängig von Zulieferungen der IC- und Anzeigenhersteller.

## Schritte zur Unabhängigkeit

Dann kam auch noch hinzu, daß 1975 Texas Instruments mit der Produktion von eigenen Taschenrechnern begann und damit als direkter Konkurrent des früheren Kunden auftrat. Zur selben Zeit setzte der Preisverfall bei den Chips ein und Commodore sah sich einem großen Lagerbestand an (teuer eingekauften) ICs und Rechnern gegenüber, während die Marktpreise fielen und die Konkurrenz wuchs. Diese Situation führte bei Tramiel zu der Entscheidung, nie wieder von Dritten abhängig zu sein. 1976 erwarb Commodore deshalb MOS Technology, einen ehemaligen Halbleiterzulieferanten. 18 Monate später folgte der Kauf des Chip-Herstellers Frontier in Los Angeles, dessen Produktspektrum eine ideale Ergänzung zu den Erzeugnissen von MOS darstellte. Zur Komplettierung diente dann noch der Erwerb von Micro Display Systems, einem Hersteller von Flüssigkristall-Anzeigen in Dallas. Durch diese Zukäufe sammelte sich bei Commodore mehr Know-How und Produktionskapazität in den wichtigsten Schlüsseltechnologien an, als es bei wesentlich größeren Konkurrenten der Fall war. Dieses Alles-in-einem-Haus-Konzept ermöglichte es Commodore, speziell für die eigenen Bedürfnisse zu entwickeln und zu produzieren. Dadurch hatte und hat Commodore einen nicht unerheblichen Zeitvorsprung bei der Entwicklung neuer Produkte und der Kosteneinsparung durch rationelle Produktion, die sich natürlich im Preis/Leistungsverhältnis zu Gunsten des Verbrauchers niederschlugen.

1977 kam dann der große Durchbruch, der erste richtige Personal Computer mit dem Namen PET wurde vorgestellt. Der PET (Personal Electronic Transactor) besaß bereits den von MOS konstruierten 6502-Prozessor, den auch einige Mitbewerber in ihre Systeme einbauten. Dieser PET kann als der Großvater des heutigen Heim- und Personal-Computermarktes angesehen werden. Der PET wurde weltweit vertrieben und erreichte gerade in Europa durch Schulen, Universitäten und den heimischen Wohnzimmern eine große Akzeptanz. Es folgten die Serien CBM 4000 und CBM 8000, die sich durch einen größeren Speicherplatz auszeichneten. Sie waren jedoch mehr auf den Profi-Markt ausgelegt, und zielten nicht so sehr auf den Heimbereich.

Dieser wurde 1981 von dem »Volkscomputer« VC 20 abgedeckt. Über den Erfolg des weltweit mehr als zweimillionenmal verkauften VC 20 braucht eigentlich nichts gesagt zu werden.

Mit dem Erfolg des VC 20 gab sich Commodore aber noch nicht zufrieden. 1982 stellte man den C 64 vor. Ein System, das erstmals mit der magischen Zahl 64-KByte RAM-Speicher zu einem vertretbaren Preis aufwarten konnte. Auch über dieses System zu schreiben ist müßig, die meisten Leser wissen bestens bescheid über diesen Computer.

Anfang 1984 gab es dann ein großes Zerwürfnis bei Commodore. Jack Tramiel verließ »seine« Firma. Die Gründe sind vielfältiger Natur. Die Fähigkeiten von Tramiel sind unbestritten. Er war es in der Vergangenheit, der Commodore zu dieser Weltstellung verhalf. Auf der anderen Seite, hatte er sein Unternehmen mehr oder weniger als Diktator geleitet. Entscheidungen wurden grundsätzlich in der Firmenspitze getroffen, also von Tramiel. Als er aber versuchte seine Söhne in die höheren Posten bei Commodore einzuschleusen regte sich Widerstand, nicht zuletzt von Irvin Gould. So kam es zu dem großen Bruch, Tramiel verließ Commodore. Er kaufte sich die marode Abteilung Atari von Warner Corporation und versucht seitdem diesem Computer- und Spielemodulhersteller wieder auf die Beine zu helfen. Man munkelt aber bereits von erheblichen Finanzierungsschwierigkeiten. Dennoch herrscht in den USA die Meinung vor, man sollte Tramiel nicht unterschätzen und könne gespannt sein, was in Zukunft von Atari zu erwarten sei.

Zu erwarten ist von Atari sicherlich nicht mehr der Amiga-Computer. Atari stand mit der Firma Amiga in Verhandlungen, deren Neuentwicklung, einen Macintosh-ähnlichen Computer zu vertreiben. Dieser Absicht ist Commodore mit dem kompletten Aufkauf der Firma Amiga zuvorgekommen. Es wird erwartet, daß dieser »Amiga« bereits im Herbst 1985 in Deutschland erhältlich sein soll. Die angekündigten Leistungsmerkmale lassen einiges erhoffen: höhere Bildschirmauflösung als der Macintosh und das bei farbiger Darstellung, schnellerem Prozessor, größerer Speicherkapazität und einem Preis der nur die Hälfte des Mac betragen soll. Dem hat Atari nichts gleichwertiges entgegenzusetzen. Im Gegenteil, der Ausverkauf des 800 XL mit Dumping-Preisen beweist, daß Atari momentan in erheblichen Schwierigkeiten steckt.

Zu den neuen Computern C16/C116 und Plus/4 von Commodore hat sich der Commodore-Guru Jim Butterfield äußerst positiv ausgelassen. In einem Interview anläßlich der CFA (Commodore Fachausstellung in Frankfurt) vertrat er die Auffassung, daß diese Computer durchaus ihre Chance auf dem Markt haben werden. Der C 16/C 116 ist der direkte Nachfolger für den Veteran VC 20. Warum sich die Anschaffung dieses Einsteiger-Computers lohnt, können Sie im Testbericht in dieser Ausgabe nachlesen. Zum Plus/4 werden wir einen ausführlichen Testbericht in der nächsten Ausgabe bringen. Eine weit verbreitete Meinung ist, daß der Plus/4 der direkte Nachfolger des C 64 sei, wie dies der C 16 für den VC 20 ist. Man ist, als Anhänger dieser Meinung, dann natürlich enttäuscht. Der Plus/4 hat ja im Vergleich zum C 64 wesentlich weniger in Bezug auf Grafik (keine Sprites) und Ton (nur eine Stimme) zu bieten. Die eingebauten Programme sind zwar bei Commodore ein Novum, aber er ist nicht einmal kompatibel zum C 64.

Das soll er wohl auch nicht sein, denn er ist nicht der Nachfolger des C 64. Der Plus/4 soll den Anwenderbereich nach oben hin ergänzen, und den C 64 nicht ersetzen. Er ist also nicht für den typischen Heimbereich konzipiert, sondern mehr für die semiprofessionelle Anwendung in Betrieben kleiner und mittlerer Größe. Wahrscheinlich hat Commodore bei diesen Anwendern noch eine Marktlücke entdeckt, und gedenkt diese mit dem Plus/4 abzudecken. Ob dem so ist, wird die Zukunft zeigen.

Während sich für den C 16/C 116 eine glänzende Zukunft voraussagen läßt, bleibt beim Plus/4 eine gewisse Skepsis angebracht. Vor allen Dingen die Nicht-Kompatibilität mit dem C 64 steht dem wohl im Wege.

Doch wie ich Commodore kenne, wird mit einen einwandfrei zu bestimmenden Nachfolger für den C 64 im Jahre 85 oder 86 zu rechnen sein. Diese Ausssage gilt natürlich nur für den amerikanischen Markt. Es kann durchaus noch dieses »neue« Jahr in Deutschland verstreichen, bis der »Nachfolger» auch bei uns in Stückzahlen erhältlich ist. Ob er dann kompatibel zum C 64 ist, welche Leistungsmerkmale ihn auszeichnen, wieviel er kosten wird, bleibt abzuwarten. Wird er 128 oder 256 KByte RAM zur Verfügung stellen, welcher Prozessor ist eingebaut, ist er hundertprozentig kompatibel oder gar CP/M- beziehungsweise MS-DOS-fähig? Das bringt wohl alles das Jahr 1985 zutage.

Was ist also 1985, im Jahr nach der berühmten orwellschen Wendemarke, zu erwarten? Auf jeden Fall der »Amiga«, ein Computer, der dem Macintosh oder gar der Lisa das Leben schwer machen wird. Dann der C 16/C 116 mit glänzenden Zukunftschancen als Einsteigercomputer. Der Plus/4, von dem man noch nicht genau weiß, was man von ihm halten soll. Und schließlich der sehnlichst erwartete Nachfolger des C 64. Kommt er oder kommt er nicht? Das ist hier die Frage.

(aa)

## Floppy-Laufwerk: Zweiter Anlauf

Das in der Ausgabe 9/84 vorgestellte Floppy-Laufwerk YL-55Sl-CM von expuls durfte aus lizenztechnischen Gründen nicht auf den Markt eingeführt werden. Die Gründe sind bekannt. Expuls hat daher eine Alternative für das 1541-Alternativ-Laufwerk entwickelt, das Floppy-Laufwerk EPH 1001. Die Laufwerke stammen von NEC, der intelligente Controller ist ein deutsches Erzeugnis und auch die Endmontage und Qualitätskontrolle findet in diesem unserem Lande statt. Durch das Doppelkopf-Laufwerk ergibt sich eine wesentliche höhere Speicherkapazität von 408 KByte (formatiert, beidseitig beschrieben). Zwei LEDs zeigen an, auf welche Diskettenseite gerade zugegriffen wird. Der Controller besteht aus zwei Prozessoren, 6502 und µPD 765, letzterer ist direkt ansprechbar. Eine Diskettenseite wird einschließlich Formatieren und VERIFY in zirka zwei Minuten kopiert. Programme die im 1541-Format abgespeichert wurden, lassen sich mittels eines mitgelieferten Umkopierprogramms auf das EPH 1001-Format überspielen.

Der Preis für den Endverbraucher liegt bei 1498 Mark. Ein ausführlicher Testbericht folgt.

(aa)

Info: expuls, St.-Anton-Straße 31, 4150 Krefeld 1, Tel. 02151-801300

## Kaufhof und Quelle steigen voll ins Computergeschäft ein

Der Kaufhof will in einer bundesweiten Aktion in 42 Filialen Computer-Studios einrichten. Ein Beweggrund ist das Medium Computer »publikumsnah« der breiten Bevölkerung vorzustellen. Ein andererwohl, sich einen Teil vom Kuchen des Computer-Markts abzuschneiden. Die Angebotspalette reicht von dem kleinen Heimcomputer bis zum professionellen Personal-Computer. All diese Systeme kann man in den Computer-Studios testen. Das Fachpersonal soll gewillt sein, auch »dumme« Fragen zu beantworten. Um das Prinzip »Alles aus einer Hand« zu verwirklichen, gibt es neben der Hardware auch Software, Peripherie-Geräte und die passende Literatur. Der kostenlose Katalog »Computer-Studio« soll dem Interessierten die Entscheidung in Ruhe zu Hause treffen lassen.

Ohne Gedränge und Zeitnot konnte man sich bisher auch bei Quelle per Katalog und Versand seinen Computer aussuchen und kaufen. Dem Trend der Zeit folgend, hat nun auch Quelle Computer-Shops in den Vertriebs-Filialen eingerichtet.

(aa)

## 256-KByte-Speichererweiterung für den C 64

Von Softline wurde eine Speichererweiterung für den C 64 angekündigt, deren 256 KByte auch als RAM-Floppy verwendbar sind. Serienmäßig ist die Erweiterung mit 64 KByte bestückt, läßt sich aber in 64-KByte-Schritten ohne Lötarbeiten bis auf die besagten 256 KByte ausbauen. Bei Verwendung als RAM-Floppy (32 KByte werden in einer Sekunde geladen oder gespeichert!) sorgt ein Batterie-Back up bei einem Stromausfall für die Datensicherheit (bis zwei Stunden). Die mitgelieferte Software emuliert eine 1541-Floppy-Station und übernimmt die Verwaltung des größeren Speichers.

Der größere Speicherplatz ist natürlich besonders interessant bei Tabellenkalkulations- und Textverarbeitungsprogrammen. So soll die Erweiterung kompatibel zu Calc Result, Multiplan, WordPro, Paper Clip, Logo, Hesmon und anderen professionellen Programmen sein. Geräte, die am seriellen Bus und am User-Port angeschlossen sind, werden weiterhin voll unterstützt. Ein Testbericht folgt in einer der nächsten Ausgaben.

(aa)

Info: Softline R. Alverdes, Schwarzwaldstraße 8a, 7602 Oberkirch, Tel. 0 78 02-37 07

## Commodore weiter im Aufwind

Ungehemmtes Wachstum kennzeichnete das vergangene Geschäftsjahr (1.7.83 bis 30.6.84) der Commodore Büromaschinen GmbH in Frankfurt. Diese positive Entwicklung setzte sich auch im ersten Quartal des neuen Jahres fort. So konnte der Gesamtumsatz um 104 Prozent auf 250,2 Millionen Mark gesteigert werden. Damit hat der Mikro-Marktführer seit seinem Bestehen das bisher beste Vierteljahres-Ergebnis erzielt. Die Resultate sind sogar deutlich besser als im legendären Weihnachtsquartal ’83, als der Heimcomputer den endgültigen Durchbruch schaffte, erläuterte ein Firmensprecher. Die Zuwächse sind in erster Linie wohl auf die weiterhin ungebrochene Nachfrage nach den Commodore-Heimcomputern zurückzuführen. So wurde zum Beispiel am 15.11.1984 in Dortmund der 500 000ste C 64 verkauft. Neben den Computern will Commodore auch das Angebot an Lernmedien, Begleit- und Arbeitsmaterial erheblich ausweiten.

(aa)

## Neuer 128-KByte-ROM-Speicher für den Commodore 64

Eine Platine für insgesamt 128 KByte ROM wurde dieser Tage von Frank Computertechnik, München vorgestellt. Die Platine ist für die Aufnahme von 8- bis 32-KByte-EPROMs vorgesehen. Es können so Speicherstufungen in 8-, 16-, 32-KByte-Schritten vorgenommen werden. Die Steuerung der einzelnen Speicherbereiche übernehmen zwei Register. Die Bedienung dieser Register kann in der Form eines Auswahlmenüs programmiert werden. Ein Directory mit dem Inhalt der Platine wird so angezeigt und das gewünschte Programm mit Knopfdruck gestartet. Da die Platine vollständig abgeschaltet ist, sollte einer dieser Wahlpunkte auch aus dem Sprung in das normale Basic bestehen. Die Platine beeinflußt dann das Laden von Basic- und Maschinenprogrammen in keiner Weise. Ein Verlust an Speicherplatz tritt in diesem Fall nicht auf. Die Beschreibung zur Platine ist sehr ausführlich und geht auch auf verschiedene Programmierschritte (Autostartkennung, Betriebssystem- und Basic-Initialisierung) ein. Die Platine ist sehr solide aufgebaut und wird mit einem stabilen Gehäuse geliefert. Der Preis soll bei zirka 100 Mark liegen, (gk) Info: Frank Computertechnik, Metzstr. 8, 8000 München

Commodore 64 Super-Plus aus Holland Commodore 64 Super Plus nennt sich eine erweiterte und verbesserte Version des C 64, die von der Rotterdamer Firma H&P-Computers angeboten wird. Sie beinhaltet schnellere Lade- und Speicher-Routinen sowohl für die Kassette (zehnmal schneller) als auch für die Floppy 1541. Durch ein geändertes Betriebssystem — es belegt keinen zusätzlichen Speicher — ist die Ladegeschwindigkeit fünffach höher und auch das Speichern von Programmen wurde auf ein Drittel der Zeit gekürzt. Dabei soll es weder bei Autostart noch bei mehrteiligen Programmen Schwierigkeiten geben. Insgesamt soll eine zirka 99prozentige Kompatibilität erreicht werden.

Ein Eingriff in die Floppy ist nicht notwendig, deswegen bleibt der serielle Port erhalten. Durch einen zusätzlichen Schalter auf dem C 64 kann ein Reset ausgelöst werden, der ein Basic-Programm nicht zerstört. Ebenfalls durch einen Schalter ist der normal- oder Super-Plus Modus schaltbar. Die Funktionstasten sind mit DOS-Befehlen belegt. Zu haben ist der C 64 Super-Plus fürzusätzlich 250 Mark. Auch bereits vorhandene Computer können zum gleichen Preis nachgerüstet werden.

(gk)

Bezugs- und Infoquellen für Deutschland, Österreich und Schweiz: v. Donkersloot, Verl. Parkweg 6, 6717 GN Ede, Tel. (08380) 32146

# Leserforum

## Wer hilft?

Wir sind eine kleine Gruppe von Computerfans und haben uns vorgenommen, einen Computerclub zu gründen. Leider wissen wirnicht, was man hierbei besonders beachten sollte (zum Beispiel, ob der Club angemeldet werden muß).

Harald Heckner Spessartstr. 24 8400 Regensburg

## Forth real hochauflösend?

Ich besitze mehrere Forth-Versionen für den C 64 und suche eine Möglichkeit, Real-Zahlen zu implementieren. Wer weiß, wo ein solches Real-Vökabular erhältlich ist, oder wer hat selbst ein solches geschrieben?

Nach vielen Versuchen mit verschiedenen Forth-Versionen stellt sich mir die Frage, ob es in Forth überhaupt möglich ist, in hochauflösender Grafik zu arbeiten. Welche Forth-Version ist hierfür geeignet, und wasmuß man eingeben?

Alois Schneider

## C 64 im IBM-Gehäuse?

Wo bekomme ich ein IBM-ähnliches Gehäuse für den Einbau des C 64, Netzteil, Interface und Floppy?

Stefan Ullmann

## Fragen Sie doch!

Selbst bei sorgfältiger Lektüre von Handbüchern und Programmbeschreibungen bleiben beim Anwender immer wieder Fragen offen. Viel mehr Fragen ergeben sich bei Computer-Interessenten, die noch keine festen Kontakte zu Händlern, Herstellern oder Computerclubs haben. Sie können der Redaktion Ihre Fragen schreiben oder Probleme schildern (am einfachsten auf der Karte »Lesermeinung«). Wirveranlassen, daß sie von einem Fachmann beantwortet werden. Allgemein interessierende Fragen und Antworten werden im Rahmen des Leserforums veröffentlicht.

## Unvermeidbare Garhage Collection?

Ich habe ein Tabellenwerk mit zirka 1000 Zeilen aufgebaut und gebe es formatiert (mit RIGHT$ und so weiter) auf dem Bildschirm beziehungsweise Druckeraus. Leiderbenutzt der C 64 zu jedem neuen Zeilenaufbau wegen des RIGHT$ jedesmal freien Speicherplatz. Da kann man über die Zellen 51,52 zusehen, wie der freie Bereich »verbraten« wird und die Garbage Collection dann (fürchterlich!) zuschlägt. Meine Frage: Wie kann man das Betriebssystem dazu zwingen, zum Beispiel in Schleifen immer denselben Platz zu benutzen? Die ausgefallensten POKEs wären mir geraderecht, da ich der Ansicht bin: »Das Herrchen bin ich«

Hans Peter Kastner

Die Lösung des Problems werden Sie sicherlich nach intensivem Studium unseres neuen Kurses über Strings (und Programmierung im allgemeinen) finden.

## Umleitung?

Anläßlich eines Kaufs einer Schreibmaschine/Printer mit RS232-Anschluß ist folgende Frage aufgetaucht:

Da ich sehrhäufig umfangreiche Maschinensprache-Programme verwende, in denen eine Ausgabe auf Drucker vorgesehen ist (zum Beispiel Vizawrite, Wordpro, Multiplan und andere), ergibt sich die Notwendigkeit, sämtliche Ausgaben, die fürdie Geräteadresse 4 vorgesehen sind, auf Adresse 2 (RS232-Port) umzuleiten. Denn was nützt mir das beste Textverarbeitungssystem, wenn die Ausgabe auf meiner Schreibmaschine nicht möglich ist? Daher meine Frage an die Maschinensprache-Experten: Gibt es eine Möglichkeit der Umleitung von Adresse 4 auf 2, eventuell durch Ändern der Vektoren für die Routinen CHKOUT, CHROUT oder Ähnliche? Wie finde ich die Stellen im Programm, die umgeschrieben werden müssen?

Michael Fiedler

## Grafikprobleme mit dem VC 20?

Ist das Grafik-Subsysteme der Graf-Elektronik-Systeme GmbH, Kempten an den VC 20, eventuell über VC 1011 B (Interface RS232), anschließbar? Wer hat einschlägige Erfahrungen?

Friedrich Dormeier

## C 64 extern anhalten

Wie kann man den C 64 über externe Beschaltung beliebig anhalten und wieder starten?

Ausgabe 10/84, Ulrich Lang

Das Anhalten des C 64 ist theoretisch sehr einfach möglich, da es computerintern andauernd durchgeführt wird. Hier ist es der VIC, der zur Bildaufbereitung mehr Zeit benötigt, als es der Systemtakt erlaubt. Zu diesem Zweck hält er den Prozessor alle paar Millisekunden an, um die nötige Zeit zu bekommen. Die Leitung am Prozessor, die dies ermöglicht, ist das RDY-Pin. Wird dieses auf LOW-Pegel gehalten, so stoppt der Prozessor beim nächsten Lesezyklus und fährt erst bei RDY = 1 mit der Arbeit fort. Sie müßten also nur einen Zugriff auf dieses Pin durchführen, um das gewünschte Resultat zu erreichen. Wie Sie dem Handbuch entnehmen können, ist am Expansion-Port eine Leitung mit der Bezeichnung »BA« herausgeführt. Diese stellt das schon erwähnte Stopp-Signal vom VIC dar und ist direkt mit der RDY-Leitung des Prozessors verbunden.

Karsten Schramm

## List-Stop kollidiert mit DOS 5.1

Das Programm »List-Stop« von Manfred Selke, Ausgabe 9/84, Seite 97, benutzt die »←«-Taste, die auch das DOS 5.1 für sich beansprucht. Welche Änderung ist nötig, um ein anderes Zeichen zu wählen?

Heinz Wagner, in Vertretung für viele andere

Die Pfeil-links-Taste hat den CHR$-Code 95. Sehen Sie im C 64-Handbuch auf Seite 136 nach. Wenn Sie in Zeile 112 des Listings die Zahl 95 in eine andere ändern, ist dieses Problem schon gelöst. Für zum Beispiel das »Pfund-Zeichen« ändern Sie in 92, für die F1-Taste in 133 um.

## Der C 64 an der Stereoanlage

Wie schließe ich meinen C 64 an eine Stereoanlage an?

Kann man Maschinenspracheprogramme im Diskettenpuffer ablegen und dort laufen lassen?

Ausgabe 10/84 Thomas Denner

Der Anschluß des C 64 an eine Stereoanlage ist kein Problem und erfolgt am besten über den TAPE-Eingang. Stecken Sie ein Stereo-DIN-Kabel ein, so wie es ist, dann hören Sie den Ton nur auf einem Kanal. Um den Ton ohne Umschalter aufbeide Kanäle zu bringen, müssen Sie den Stecker des Kabels öffnen und die Anschlüsse 3 und 5 miteinander verbinden (den Anschlußplan des Steckers können Sie aus dem Commodore-Handbuch Seite 142 ableiten). Danach sollten Sie alle Leitungen, bis auf die Erdung (2) kappen, um Störungen zu vermeiden. Probieren Sie das Kabel jetzt, so müßte der Ton über beide Lautsprecher der Anlage kommen.

Ohne weiteres ist es möglich, Programme in die Puffer der Floppy zu schreiben und sie dort auszuführen. Verwendung finden dabei die Befehle:
M-W ADL ADH Anzahl Datal Data2 ...
M-E ADL ADH

Die Werte werden hierbei als CHR$-Codes übergeben; sie bedeuten:
ADL-LO-Byte der Adresse
ADH-HI-Byte der Adresse
Anzahl-Anzahl der Bytes
Data-Werte, die geschrieben werden sollen

Ich möchte hierbei auf den Floppykurs verweisen, der in der Ausgabe 10 begann; er beschäftigt sich mit solchen Problemen.

Karsten Schramm

## Vielsaitig für C 64

Gibt es das Programm »Vielsaitig« auf für den C 64?

Ausgabe 10/84 Oliver Kreuzahler

Ich bin der Autor des Programms »Vielsaitig« für den VC 20. Es gibt jetzt auch eine sehr viel umfangreichere Version für den C 64 unter dem Namen »Gitarre 64«. Das Programm liegt ebenso wie mein Programm »Synthesizer 64« (Test in Happy Computer, Ausgabe 11/84) seit einem Jahr bei der Firma Commodore, Frankfurt in der Schublade und ich zweifle noch, ob es bei den dortigen Verhältnissen in der Software-Abteilung je in den Handel kommen wird. Da ich durch einen Vertrag gebunden bin, kann ich die Programme nicht anderweitig vertreiben lassen. Interessenten sollten also bei ihrem Computerhändler nachfragen, ob das Programm schon erschienen ist.

Ansonsten sollten Sie sich an mich wenden, gerade wenn Sie an der neuesten Version interessiert sind. Meine Adresse:

Werner Kracht, Espellohweg 38, 2000 Hamburg 52.

## Drucker-Test: Itoh 8510

Ausgabe 11/84, Seite 22

Der Test über den Drucker Itoh 8510 schließt mit einem sehr guten Gesamtergebnis, das leider durch einen kleinen Fehler getrübt zu sein scheint. Auf Seite 161 bemängelt Herr Wängler, daß einzig eine gedehnte Schrift fehlt. Dem ist aber nicht so. Die Steuerzeichen für Breitschrift ein beziehungsweise aus sind CHR$(14) beziehungsweise CHR $(15).

Die Besprechung einzelner Artikel der verschiedenen Zeitschriften Ihres Verlages ist fester Bestandteil in unseren Clubabenden. Für die 64’er Zeitschrift können wir Ihnen das Testurteil »sehr gut, besonders empfehlenswert« ausstellen.

Peter Koch, 1. Vorsitzender, Computer-Club Bruchsal e.V., Spöckweg 27, 7520 Bruchsal

Zunächst einmal Dank für die Ergänzung zu dem Drucker-Test und für das ausgesprochene Lob.

Dies möchten wir noch einmal kurz zum Anlaß nehmen, um uns bei all den Lesern zu bedanken, die durch ihre rege Mitarbeit an der inhaltlichen Gestaltung geholfen haben, das 64’er zu dem zu machen was es heute ist. Nämlich eine Fachzeitschrift, aus der Heimcomputer-Anwender viele nützliche Tips, Anregungen, Programme und Entscheidungshilfen beziehen können.

Es soll aber auch als Anregung dienen, weiterhin die Redaktion tat- und schreibkräftig zu unterstützen.

<aside>

## Wollen Sie antworten?

Wir veröffentlichen auf dieser Seite auch Fragen, die sich nicht ohne weiteres anhand eines guten Archivs oder aufgrund der Sachkunde eines Herstellers beziehungsweise Programmierers beantworten lassen. Das ist vor allem der Fall, wenn es um bestimmte Erfahrungen geht oder um die Suche nach speziellen Programmen. Wenn Sie eine Antwort auf eine hier veröffentlichte Frage wissen — oder eine andere, bessere Antwort als die hier gelesene, dann schreiben Sie uns. Antworten publizieren wir in einer der nächsten Ausgaben. Bei Bedarf stellen wir auch den Kontakt zwischen Lesern her.

</aside>

## Textverarbeitung mit Seikosha GP-700A

Wie kann ich meinen Text durch Einfügen von Formatierungsbefehlen farbig gestalten?

Ausgabe 10/84
Conny Scharfenberg

Das Interface Typ 9200 ist ein Universaltyp, mit dem die verschiedensten Drucker an den C 64 angeschlossen werden können. Da praktisch alle Druckertypen unterschiedliche Steuercodes besitzen, ist dieses Interface nicht auf einen speziellen Typ angepaßt. Speziell für die Verwendung mit dem Farbdrucker GP-700A liefert Data Becker ein Interface, das auf diesen Drucker angepaßt ist und daher wesentlich mehr Funktionen bietet.

Reinhard Wiesemann

## Horizontales Scrolling

Wie kann man beim C 64 ein horizontales Fine-Scrolling auf der Textseite simulieren?

Ausgabe 10/84
Christoph Bergmann

Die Voraussetzung für mein kleines Demo-Programm bietet das VIC-Register 22, in dem das kontinuierliche Setzen der ersten 3 Bits eine Verschiebung der gesamten Textseite um jeweils einen Punkt ermöglicht, wenn der Wert mit 248 geordert wird. Werden auf diese Weise insgesamt 7 Bits verschoben, so folgt darauf die Verschiebung um ein Byte, was durch die Basic-Funktion CHR$(20) simuliert wird.

Startet man das Demo-Programm, so kann es vorkommen, daß der einzeilige Text beim Verschieben flackert, was darauf zurückzuführen ist, daß die Verschiebung der Textzeile mit CHR$(20) einfach zu langsam ist. Abhilfe bietet hier eine Maschinensprachroutine, die das Byte-für-Byte-Scrolling übernehmen müßte. Hier nun das kleine Programm:

1 PRINT CHR$(147)
2 FOR A=1TO8:PRINT:NEXTA
3 PRINT "64'ER MAGAZIN”
4 PRINT CHR$(145),,
5 VIC = 53248
6 FORA = 1TO20
7 POKEVIC+22,(PEEK(VIC+22)AND248)OR7
8 PRINT CHR$(20);
9 FOR B=6TO0STEP-1
10 POKEVIC+22, (PEEK(VIC+22)AND248)ORB
11 FORC=1TO10
12 NEXT C,B,A
READY

Martin Althaus

## Hier gibt’s Mailboxnummern

Gesammelt von unserem Leser Andre Steden (EMS). Bei den hervorgehobenen Nummern bedient ein C 64 die Mailbox.

TODO

## Hier gibt’s Clubs

Star-Computer
Schlüterstr. 6
2000 Hamburg 13
Mo.-Fr. 14.00-18.00 Uhr
Tel. 0 40/45 20 90

C 64 Club Bramsche
Lutterdamm 13 a
4550 Bramsche 1

VC 20 Club
Rainer Plapst
Haydnstr. 39
8906 Gersthofen

# Generationswechsel – Test C16

> Schon seit geraumer Zeit ist ein Nachfolger für den überalterten VC 20 im Gespräch. Jetzt ist er da – und das gleich doppelt, nämlich als C 16 und 116.

Mit dem C 16 stellt Commodore nicht nur einen neuen Computer vor, sondern ein ganzes System (Bild 1, 6 und 7). Computer, Datasette und Joysticks präsentieren sich im schwarz-grauen »Profi-Look«, Drucker und Floppy-Laufwerk des VC 20/C 64-Systems passen auch an denC 16. Gleichzeitig mit der Markteinführung des neuen Gerätes ist auch erste Software — zunächst auf Kassette — erhältlich. Commodore trägt damit der Tatsache Rechnung, daß angesichts eines umkämpften Marktes ein neuer Computer ohne Peripherie und Softwareangebot kaum noch erfolgreich einführbar ist.

Um es vorweg zu sagen: C 16 und 116 sind hard- und softwaremäßig völlig identisch. Der einzige Unterschied besteht bei Gehäuse und Tastatur. Während der C 16 hier der durch VC 20 und C 64 vorgegebenen Linie folgt, ist der 116 mit seiner Radiergummi-Tastatur und dem Miniatur-Gehäuse wohl eher als direkter Angriff auf den Sinclair Spectrum zu werten.

Doch sehen wir uns zunächst den C 16 etwas genauer an. Ein erster Blick auf die Tastatur (Bild 2) offenbart schon einige Unterschiede zum VC 20/C 64. Aus den beiden Cursortasten des Vorgängers wurden beim C 16 deren vier, die aber leider etwas ungünstig rechts oben in einer Reihe in den Tastaturblock integriert wurden. Um für diese Anordnung Platz zu schaffen, mußten einige andere Tasten verlegt werden. So findet der an die VC 20-Tastatur gewöhnte Programmierer die häufig benötigten Tasten »+«,»-«, »\*«,»↑« und »=« nicht mehr an ihrem gewohnten Platz, was zu Anfang recht lästig ist. Insbesondere die Anordnung der »=«-Taste ganz rechts unten ist sehr unglücklich gewählt.

Die unterste Funktionstaste ist jetzt mit »HELP« beschriftet und hat eine spezielle Bedeutung bei der Fehlersuche. Drückt man nämlich diese Taste, nachdem der Computer eine Fehlermeldung angezeigt hat, dann wird die fehlerhafte Zeile sofort aufgelistet und der Abschnitt, in dem der Fehler auftrat, blinkt mit der Cursorfrequenz. Eine feine Sache bei der Programmentwicklung, allerdings wäre es schön, wenn man das mit der Zeit doch etwas nervende Blinken auf irgendeine einfache Art abstellen könnte.

Eine Restore-Taste gibt es nicht mehr, die Linkspfeiltaste des VC 20 / C 64 ist jetzt mit »ESC« (mehr darüber später) beschriftet und im Vordergrund fallen zwei neu beschriftete Tasten, »FLASH ON« und »FLASH OFF«, ins Auge. Zusammen mit der CTRL-Taste wird dadurch ein Blink-Modus ein- beziehungsweise ausgeschaltet (analog zu RVS ON/OFF).

Die Funktionstasten sind mit Basic-Befehlen belegt. Sonst entspricht sowohl die Tastatur als auch der Zeichensatz dem »Commodore-Standard«, man wird als »Umsteiger« wenig Schwierigkeiten haben.

## Kompatibel um keinen Preis?

Ein erster Blick an die rechte Seite des C 16, wo man ganz richtig den Einschaltknopf vermutet, und sofort fallen zwei Dinge ins Auge (Bild 3). Als erstes, und zwar sehr positiv, ein kleiner Reset-Schalter — unverständlich, daß es Computer gibt, die keinen haben. Links daneben zwei winzige Buchsen, darüber steht etwas geschrieben. Man liest es, reibt sich die Augen, schaut nochmals hin — tatsächlich, es ist wahr: Die Mikro-Buchsen sind mitJOY 1 undJOY 2 beschriftet. Endlich einmal ein Computer, an den garantiert kein Joystick außer einem ganz speziellen Commodore-Stick mehr paßt. Diese neuen Joystickanschlüsse sollen über eine verbesserte Abschirmung verfügen, aber es bleibt die Frage, ob man den gleichen Effekt nicht auch mit Standard-Buchsen hätte erreichen können.

Was macht nun jemand, der zum Beispiel vom VC 20 auf den C 16 umsteigt, mit seinen vorhandenen Joysticks ? Nun, vermutlich das gleiche wie mit seiner Datasette, denn auch der Datasettenanschluß wurde geändert. Da hilft alles nichts, entweder wird im Eigenbau ein entsprechender Zwischenstecker hergestellt, oder die alte Datasette wandert zusammen mit dem Lieblingsjoystick in eine Verkaufsanzeige. Eine dritte Möglichkeit: Auf ein Angebot aus dem Zubehörhandel warten. Ob so etwas aber gerade ein besonders gutes Argument ist, auf den C 16 umzusteigen, das mag dahingestellt bleiben.

## Problemlos erweiterbar?

Ein ängstlicher Blick auf die Rückseite des Computers (Bild 4) zeigt, daß wenigstens der serielle Bus nicht mit Spezialbuchsen versehen wurde. Floppy und Drucker sind also weiterhin problemlos anzuschließen. Ein Video-Modulator ist wie beim C 64 fest eingebaut. Auffällig ist das Fehlen eines User-Ports, bisher Kennzeichen aller Commodore-Computer.

Der Expansion-Port dient zum Aufnehmen von Steckmodulen mit fertiger Software, sowie zum Anschluß einer (noch nicht erhältlichen) Speichererweiterung. Zu diesem Thema wäre zu bemerken, daß das Betriebssystem mit zwei Speicherbanks arbeitet. Zwischen den 32 KByte ROM von Betriebssystem und Basic und den (noch) 16 KByte RAM wird mittels Bank-Switching hin- und hergeschaltet. Dadurch kann man mit PEEK nicht ins ROM »hineinschauen«, sondern bewegt sich nur auf der RAM-Ebene. Nach Einbau einer 64-KByte-RAM-Erweiterung sollten daher tatsächlich fast 60 KByte für Basic-Programme zur Verfügung stehen.

Eine solche RAM-Erweiterung hätte übrigens bequem noch im Gehäuse des C 16 Platz. Ein Blick dort hinein auf die Platine (Bild 5) offenbart ein sehr aufgeräumtes Innenleben. Die großen integrierten Bausteine, insbesondere die neue CPU 7501 (kompatibel mit 6502/6510) und der ebenfalls neuentwickelte TED 7360, stellen Eigenentwicklungen von Commodore dar und werden nicht frei gehandelt. Informationen über diese Bausteine gibt es daher — ganz nach Art des Hauses — praktisch keine.

Auffällig ist das Fehlen weiterer Peripheriebausteine wie VIA oder CIA. Die Funktionen dieser Bausteine wurden in den TED integriert, der sich auch um die Video-Darstellung und die Tonerzeugung kümmert und so den Prozessor entlastet.

Betriebssystem und Basic sind in je einem 128 KBit ROM untergebracht, die 16 KByte RAM befinden sich in zwei TMS 4416-Chips. Zur besseren Wärmeableitung und Abschirmung ist über der Platine eine gelochte Metallplatte angebracht (im Bild 5 entfernt), von der ein Ausleger direkt mit dem scheinbar besonders kühlungsbedürftigen TED-Baustein Kontakt hat.

Besonders bemerkenswert: Bei unserem Testgerät waren alle hochintegrierten IC gesockelt. Es bleibt abzuwarten, ob diese gute Technik auch bei größeren Stückzahlen beibehalten wird. Und größere Stückzahlen werden von diesem Computer mit Sicherheit verkauft werden, dafür sorgt schon das bemerkenswert gute und umfangreiche Basic 3.5, das den C 16 zum idealen Computer für alle diejenigen macht, die wenig mit Maschinensprache im Sinn haben, aber trotzdem gute Programme schreiben wollen.

Gute Programme für C 64 und VC 20 zeichnen sich im wesentlichen dadurch aus, daß man sie nicht mehr lesen kann. Nach LIST flimmert dort, zumindest bei Programmen, die mit Grafik und Tonuntermalung arbeiten, ein unergründliches Gemisch von POKE, PEEK, SYS und sehr viel DATA über den Bildschirm, ab und zu auch einmal ein »normaler« Basic-Befehl (in der Regel ein »GOTO«), Wenn man sich einmal vor Augen hält, daß POKE, PEEK und SYS die Verbindung zwi-

## Programmieren ohne POKEs

schen Basic und Maschinensprache herstellen, dann kann man ruhigen Gewissens sagen, daß die bisherigen Commodore-Heimcomputer im wesentlichen in Maschinensprache programmiert werden mußten — unverständlich für den Einsteiger, schwer erträglich abgr auch für den Profi, der kostbare'Programmierzeit damit vergeudete, sich seine eigene Basic-Erweiterung zu basteln, um überhaupt erst vernünftig arbeiten zu können.

Mit dem Basic 3.5 beschreitet Commodore jetzt ganz offensichtlich einen anderen Weg. Von der simplen Farbwahl über die Tonerzeugung bis hin zur hochauflösenden Grafik läßt sich alles mit entsprechend leistungsfähigen Basic-Befehlen programmieren. Daneben wird natürlich auch die strukturierte Programmierung unterstützt. Sprachkonstruktionen wie IF...THEN ...ELSE, DO WHILE oder DO UNTIL machen die dem Programm zugrunde liegende Idee im Listing sichtbar und vermeiden umständliche (und langsame) GOTO-Sprünge.

Natürlich ist Basic 3.5 vollständig aufwärtskompatibel zum altertümlichen V.2.0-Minimal-Basic des VC 20/C 64. Insgesamt ist das Basic 3.5 so leistungsfähig, daß alleine eine genaue Beschreibung aller Befehle und Funktionen leicht ein ganzes Sonderheft füllen würde (Tabelle 1). Beschränken wir uns daher auf die Betrachtung einiger wichtiger Aspekte.

## Die Grafik

Der Bildschirm des C 16 hat eine Aufteilung von 25 Zeilen zu je 40 Zeichen. Jedes Zeichen wird in einer 8x8-Matrix dargestellt. Damit gibt es insgesamt also 320 Punktpositionen (40x8) pro Zeile, und 200 Punktpositionen (25x8) in vertikaler Richtung. Genausoviele Punkte, nämlich 320 mal 200, können im hochauflösenden Grafik-Modus einzeln angesprochen werden. Mit insgesamt 64000 Einzelpunkten erreicht der C 16 damit die Grafik-Auflösung des C 64, was in etwa einer Verdopplung gegenüber dem VC 20 gleichkommt.

Daneben ist noch ein Mehrfarbenmodus mit halbierter Auflösung vorgesehen, bei dem jeder der dann 32000 Einzelpunkte eine von vier möglichen Farben annehmen kann.

Bis hier herrscht noch eine völlige Übereinstimmung zum Grafik-Konzept des C 64. Der große Unterschied ist nun, daß die C 16-Grafik vom Basic voll unterstützt wird.

Um beispielsweise mit dem C 64 (ohne Erweiterung!) einen Kreis oder eine Ellipse in hochauflösender Grafik zu zeichnen, und zusätzlich noch einen Text einzublenden, benötigt man neben fundierten Kenntnissen über die interne Organisation seines Computers und einigen Jahren Programmiererfahrung mindestens einige Dutzend Basic-Zeilen und jede Menge Geduld — denn Basic-Grafik ist langsam, wenn die primitivsten Dinge mühselig simuliert werden müssen. So werden ganze Kurse und Bücher damit gefüllt, auf dem C 64 das zu erreichen, wofür man beim C 16 drei Basic-Befehle und — als absoluter Neuling — maximal einige Minuten blättern im Handbuch braucht:

10 GRAPHIC 1,1 : CIRCLE, 160,100, 60,30 : CHAR,18,12, »HALLO«

Mit GRAPHIC 1,1 wird in den hochauflösenden Grafikmodus geschaltet. Der erste Parameter gibt den gewählten Modus an (0 für Text, 1 für Hochauflösung, 2 für Hochauflösung mit Textfenster, 3 für Mehrfarben-Modus, 4 für Mehrfarben-Modus mit Textfenster). Als Textfenster sind dabei die untersten fünf Bildschirmzeilen vorgesehen. Dieses Textfenster ist dann mit normalen PRINT-Befehlen ansprechbar. Will man Text direkt in die hochauflösende Grafik hineinmischen, dann bedient man sich des CHAR-Befehls. Der erste Parameter bestimmt im Mehrfarbenmodus die Textfarbe (und wird daher in unserem Beispiel für hochauflösende Grafik durch ein einzelnes Komma ersetzt). Die beiden folgenden Parameter kennzeichnen die Cursorposition, an welcher der Text ausgegeben werden soll. Als letztes muß noch ein Textstring angegeben werden, der dann ab der spezifizierten Position in die Grafik eingeblendet wird. Ein fünfter Parameter ist optional, nämlich die Angabe, ob der Text normal oder revers erscheinen soll.

Bleibt nur noch der CIRCLE-Befehl, der mit bis zu neun Parametern sehr komplex sein kann. Der erste Parameter gibt wieder die Farbzone an und ist nur im Mehrfarbenmodus zu verwenden. Dann folgen die Mittelpunktkoordinaten und der Radius in X- und Y-Richtung. Die letzten beiden Werte sind bei einem Kreis natürlich gleich groß, und daher reicht es, nur den ersten davon anzugeben. In unserem kleinen Beispiel haben wir jedoch eine Ellipse gezeichnet, und zwar mit Mittelpunkt in (160,100) und den Halbachsenabmessungen 60 beziehungsweise 30 Punkte.

Aber der CIRCLE-Befehl ist noch weitaus leistungsfähiger. Weitere Parameter regeln das Zeichnen nur einzelner Segmente sowie eine Drehung der ganzen Figur um einen beliebigen Winkel. Neben dem Zeichnen von Kreisen und Ellipsen kann der CIRCLE-Befehl auch für beliebige Vielecke verwendet werden.

Daneben steht noch eine Anzahl weiterer leistungsfähiger Grafik-Befehle zur Verfügung. DRAW zeichnet Einzelpunkte oder Linien, BOX zaubert blitzschnell alle möglichen Rechtecke auf den Bildschirm. LOCATE dient zum Positionieren des Grafikcursors, mit PAINT werden geschlossene Flächen ausgefüllt. SCALE schließlich dient zur Skalierung der Zeichenfläche und SCNCLR löscht den Bildschirm unabhängig vom eingestellten Grafikmodus.

## Shapes statt Sprites

Im Gegensatz zum C 64 sind beim C 16 keine Sprites vorgesehen. Dafür gibt es jedoch leistungsstarke Basic-Befehle, um Bildausschnitte aus der hochauflösenden Grafik — sogenannte »Shapes« — in Stringvariable abzuspeichern oder wieder auf den Bildschirm zu bringen. Zum Beispiel wird mit »SSHAPE A$,100, 100,120,130« der Inhalt des Rechtecks mit linker oberer Ecke (100,100) und rechter unterer Ecke (120,130) auf dem Grafikbildschirm in der Stringvariablen A$ abgelegt. Mit »GSHAPE A$, 60,70« wird die Grafikinformation aus A$ wieder als Rechteck mit linker oberer Ecke (60,70) abgelegt. Über einen zusätzlichen (optionalen) Parameter kann der Wiedergabemodus bestimmt werden: Shapes können genauso wie aufgenommen auch wieder eingeblendet werden (und überschreiben dabei den Hintergrund), sie können revers dargestellt und schließlich wahlweise auch ODER, UND oder EXKLUSIV-ODER mit dem Hintergrund verknüpft werden.

Mit diesen Shapes eröffnen sich natürlich speziell bei der Spieleprogrammierung ungeahnte Möglichkeiten. Basic-Spiele in hochauflösender Grafik sind keine Utopie mehr. Unter diesem Gesichtspunkt verzichtet man gerne auf ein paar kümmerliche Sprites, die sich über einem Blockgrafik-Hintergrund bewegen. Dies um so leichter, als sich Sprites mit dem Shape-Konzept leicht simulieren lassen: Man arbeitet einfach mit zwei Stringvariablen. Die eine enthält die Spielfigur, die andere den zugehörigen Hintergrund (der ja durch die Figur verdeckt ist). Durch wechselseitiges Laden und Speichern von Hintergrund und Spielfigur lassen sich sehr einfach die entsprechenden Bewegungseffekte erzielen — und das sowohl in hochauflösender Grafik als auch in Mehrfarbengrafik.

## Farbe und Sound

Der C 16 hat eine Grundpalette von 16 Farben zur Verfügung, von denen jede (bis auf Schwarz) noch in acht verschiedenen Intensitätsstufen dargestellt werden kann. Das ergibt insgesamt eine beachtliche Auswahl von 121 Farbtönen. Wer bietet mehr für 398 Mark?

Mit dem COLOR-Kommando können dabei die Farben für Bildschirmrahmen, Hintergrund, Mehrfarbenmodus und auch die Zeichenfarbe gewählt werden.

Zur Tonerzeugung stehen zwei unabhängige Tongeneratoren zur Verfügung, von denen einer auch für Geräuscheffekte eingesetzt werden kann. POKE-Befehle sind auch hier nicht nötig. Mit dem SOUND-Befehl werden sowohl der gewünschte Tongenerator angewählt als auch Tonhöhe (Notenwert) und Klangdauer angegeben, mit VOL wird die Lautstärke eingestellt.

Das Besondere dabei ist, daß bis zu zwei SOUND-Befehle (einer pro Kanal) parallel zum Basic-Programm ausgeführt werden. Der Programmablauf wird durch einen SOUND-Befehl also nicht etwa aufgehalten, bis der Ton zu Ende gespielt wurde; das Programm läuft normal weiter, während der Ton entsprechend der gewählten Tondauer erklingt. Man kann sich wohl vorstellen, wie diese Fähigkeit ein Programm beschleunigt, wenn man sich vor Augen hält, daß Computer der Vorgängergeneration (VC 20/C 64) die Tondauer über leere FOR... NEXT-Schleifen bestimmten.

## Komfortable Programmierung

Bei der Entwicklung von eigenen Programmen und der in der Regel notwendigen Fehlersuche kommen die eingebauten Programmierhilfen des 3.5 Basic erst richtig zur Geltung. Eine Reihe von Befehlen und speziellen Funktionen stehen zur Verfügung, die bisher bei Commodore-Computern unter der Abkürzung OGNV (oft gebraucht, nie vorhanden) liefen.

Eine automatische Zeilennumerierung mittels AUTO ist ebenso selbstverständlich wie ein RENUM-BER-Befehl zum Neunumerieren des Programms (wobei wahlweise auch nur Programmteile numeriert werden können und der Zeilenabstand sowie die Startzeile natürlich frei wählbar sind).

Diskettenkommandos, die man früher umständlich mit »OPEN 1,8,15...« an die Floppy senden mußte, sind jetzt als Basic-Kommandos integriert. SCRATCH löscht beispielsweise ein File auf der Diskette. Das Laden und Speichern von Diskettenprogrammen geschieht jetzt mit DLOAD beziehungsweise DSA-VE. DIRECTORY holt das Inhaltsverzeichnis der Diskette auf den Bildschirm, selbstverständlich ohne Programmverlust.

Für das häufig benötigte Warten auf einen Tastendruck gibt es den Spezialbefehl GETKEY A$, wodurch man sich das lästige »IF A$ = ””THEN...«spart.

Hinter RESTORE kann eine Zeilennummer angegeben werden, was das einfache Hantieren mit mehreren unabhängigen DATA-Blöcken erlaubt.

Formatierte Ausgabe ist mit PRINT USING möglich. Die dabei verwendeten Zeichen lassen sich mit dem PUDEF-Kommando umdefinieren. Beispielsweise kann man für die formatierte Ausgabe den (amerikanischen) Dezimalpunkt durch das in Europa übliche Komma ersetzen. Mit ZONE kann die Weite der TAB-Bereiche geändert werden.

Die häufig gebrauchte INSTR-Funktion (hat als Ergebnis die Position eines Teilstrings in einem anderen String) ist ebenso vorhanden wie die Funktion JOY zur einfachen Joystickabfrage.

Bemerkenswert ist auch, daß die MID$-Funktion jetzt auch auf der linken Seite einer Wertzuweisung stehen kann. Sei beispielsweise A$ = "HALLO". Nach Ausführung des Befehls »MID$(A$,2,1) = ”E’i ist A$ dann gleich der Zeichenfolge »HELLO«.

Für die Umrechnung zwischen Dezimal und Hexadezimal sind die beiden Funktionen DEC und HEX$ vorhanden.

## Strukturierte Programmierung

Basic 3.5-Programme sind in der Regel um einiges übersichtlicher (und dabei schneller) als VC 20/C 64-Programme. Der Grund ist einleuchtend: Durch zusätzliche Schleifenbefehle werden GOTO-Anweisungen eingespart, und damit entfällt auch die Suchzeit, um die Zeilennummer zu finden.

Daneben wurde auch die IF-Anweisung um die ELSE-Klausel erweitert, was die Programmierung in vielen Fällen vereinfacht.

Der Kern der neuen Schleifenstruktur besteht aus den Anweisungen DO und LOOP. Ähnlich wie FOR...NEXT umklammert DO... LOOP einen Programmteil. Die Wirkung ist die folgende: Bei Erreichen eines DO merkt sich der Basic-Interpreter die Adresse dieses DO-Befehls als Schleifenanfang. Wird dann im weiteren Verlauf das zugehörige LOOP gefunden, erfolgt sofort ein Rücksprung zur Position des DO-Befehls. Das ergibt eine »unendliche« Schleife, was allerdings in den meisten Fällen nicht erwünscht ist. Daher ist die EXIT-Anweisung vorgesehen, die ein Verlassen der Schleife und eine Fortsetzung des normalen Programmablaufs hinter dem LOOP-Befehl ermöglicht. In der Regel wird man das EXIT von einer bestimmten Bedingung abhängig machen. Beispiel:
10 DO
20 GET A$ : IF A$=»X« THEN EXIT
30 LOOP

Dieses Programm wartet, bis die Taste X gedrückt wird.

Die (unbedingte) DO...LOOP-Schleife kann unter Verwendung von UNTIL oder WHILE in eine bedingte Schleife abgewandelt werden. DO WHILE (Bedingung) ... LOOP wird ausgeführt, solange die (Bedingung) erfüllt ist. Durch UNTIL wird praktisch der umgekehrte Fall erzeugt. DO UNTIL (Bedingung) ... LOOP wird solange durchlaufen, bis die Bedingung erfüllt ist. Natürlich können auch bei bedingten Schleifen zusätzliche EXITs eingebaut werden. Das ermöglicht sehr effiziente Programme, insbesondere, wenn mehrere Bedingungen beachtet werden müssen.

Gemäß der Parole »wer viel programmiert macht viele Fehler« ist jedes Basic nur so gut wie seine Hilfen zur Fehlersuche und Fehlerbehandlung. Und hier hat der C 16 einiges zu bieten.

Die HELP-Funktion wurde bereits anfangs erwähnt und ermöglicht die schnelle Lokalisierung eines Fehlers innerhalb einer Programmzeile.

Für den nicht seltenen Fall, daß keine Fehlermeldung erfolgt, das Programm jedoch unsinnige Sachen macht (also irgendwo noch ein logischer Fehler steckt) kann man mit TRON eine Trace-Funktion einschalten. Dabei wird die Zeilennummer der gerade abgearbeiteten Zeile angezeigt, wodurch man so manchem Fehler leichter auf die Spur kommen kann. TROFF schalten den Trace wieder ab.

## Debugging leicht gemacht

Für die Fehlerbehandlung innerhalb des Programms ist der TRAP-Befehl vorgesehen. Zum Beispiel wird mit der Anweisung »TRAP 1000« beim Auftreten eines Fehlers das Programm nicht mit entsprechender Meldung abgebrochen, sondern es wird in eine Fehlerbehandlungsroutine gesprungen (hier ab Zeile 1000). Die Nummer der Zeile, in der der Fehler auftrat, wird dabei in der Systemvariablen EL gespeichert. Die Variable ER enthält die Fehlernummer, und ERR$ die Fehlermeldung im Klartext. Mit diesen Informationen kann man in der Fehlerbehandlungsroutine entsprechende Maßnahmen ergreifen und schließlich mit RESUME den normalen Programmablauf wieder aufnehmen lassen. Übrigens wird auch das Drücken der Stop-Taste mit TRAP abgefangen.

## Window-Technik

Bei soviel Licht fällt gelegentlich auch ein Schatten. Die für den C 16/116 angekündigte moderne Window-Technik, also das Arbeiten mit verschiedenen Bildschirmfenstern, ist leider nicht in einer vollends überzeugenden Form implementiert.

Es kann überhaupt nur ein einziges Window erzeugt werden, und das nicht etwa per Basic-Befehl (wie man es an sich erwarten würde), sondern über eine ESC-Funktion. Damit kommen wir gleich zur Bedeutung der ESC-Taste auf der Tastatur.

Es gibt nämlich 26 ESC-Funktionen, die durch Drücken von ESC, gefolgt von einer Buchstabentaste, aufgerufen werden (Tabelle 2).

Um das eine mögliche Fenster zu erzeugen, muß man den Cursor in die linke obere Ecke des vorgesehenen Windows bringen, dann ESC T drücken, anschließend in die rechte untere Ecke fahren und ESC B betätigen. Dadurch ist das Fenster definiert. Alle Ein- oder Ausgaben spielen sich jetzt ausschließlich hier ab.

Durch zweimaliges Drücken der Home-Taste wird das Window wieder gelöscht.

So fortgeschritten das Konzept auch gegenüber dem VC 20/C 64 ist, es bleibt einiges zu wünschen übrig. Die Methode der Window-Definition ist viel zu umständlich und zu langsam, zumal ein Befehl zur direkten Cursorpositionierung nicht vorhanden ist. Das fällt um so schwerer ins Gewicht, als immer nur ein einziges Window definiert werden kann, was aber in der Regel nicht sehr sinnvoll ist. Wenn man den Bildschirm aber in verschiedene Bereiche aufteilen will, dann wirkt sich das ständige umständliche Definieren der Fenster doch zum einen auf die Programmlänge, zum anderen auf die Abarbeitungsgeschwindigkeit negativ aus.

Dennoch ist das Windowing ein Schritt in die richtige Richtung, hin zum benutzerfreundlichen Computer. Für eine übersichtliche Bildschirmaufteilung besteht jedenfalls in fast jeder Programmiersituation ein Bedarf. Wo man sich früher damit behalf, den gesamten Bildschirm bei jeder Veränderung neu aufzubauen, ist es jetzt möglich, nur den wirklich zu ändernden Bereich anzusprechen, ohne dabei die übrigen Informationen zu beeinflussen.

## Maschinensprache-Monitor eingebaut

Für Maschinensprachefreunde — und solche, die es werden wollen — hält der C 16 noch einen ganz besonderen Leckerbissen parat. Er verfügt nämlich über einen fest im ROM vorhandenen Maschinensprache-Monitor, genannt TEDMON,

TEDMON ist genau genommen sogar mehr als nur ein Monitorprogramm für Maschinensprache. Er enthält nämlich einen Disassembler und auch einen kleinen Assembler. Maschinenprogramme können mit TEDMON sehr komfortabel entwickelt und anschließend als schnelle Unterroutinen von Basic aus aufgerufen werden. Tabelle 3 zeigt den TEDMON-Befehlssatz.

## Fazit

Neben dem C 16 bietet Commodore noch den 116 an, also praktisch den gleichen Computer, nur im anderen Gehäuse (Bild 8). Der Preisunterschied zwischen den Geräten (real 398 Mark für den C 16, 348 Mark für den 116, der empfohlene Verkaufspreis liegt jeweils 50 Mark höher) ist so gering, daß wohl kaum jemand für 50 Mark die Nachteile der Gummitastatur beim 116 in Kauf nehmen wird (es sei denn, ein hartnäckiger Spectrum-Freund, aber für den ist das dann eh der falsche Computer).

Der mit 16 KByte zu kleine Anwenderspeicher (nach Einschalten der hochauflösenden Grafik bleiben noch exakt 2045 Byte zum Programmieren) dürfte bereits in naher Zukunft mit entsprechenden RAM-Modulen erweiterbar sein. Man sollte aber nicht vergessen, daß man bei der Leistungsstärke des C 16 Basic in 2 KByte etwa das gleiche an Grafik-Programm unterbringen kann wie beim C 64 in 8 KByte.

Der C 16 jedenfalls ist insbesondere vom Basic her in der Tat mindestens eine ganze Generation weiter als der VC 20 und der C 64. Durch sehr komfortable Programmierhilfen und ein umfangreiches, praxisnahes Basic ist er nicht nur der ideale Einsteiger-Computer; auch Profis fahren in der Regel lieber einen Rolls Royce, als daß sie wirklich jede Strecke zu Fuß gehen.

(ev)

# Hardware-Interface ganz weich

> Zusammen mit dem Epson-Software-Interface EC-64 erhält man eine exzellente Ansteuerungssoftware, die noch einiges mehr kann als herkömmliche Epson-Interfaces.

Die Bezeichnung »Soft-Interface« besagt, wie Sie sicher schon vermuten, daß die Treibersoftware nicht wie bei herkömmlichen Hardware-Interfaces in ROMs auf der Platine enthalten ist, sondern extern auf Diskette mitgeliefert wird. Die Verbindung zum Drucker wird dabei durch ein einfaches User-Port-Centronics-Kabel hergestellt.

Das hat natürlich alles seine Vor- und Nachteile. Einerseits muß man erst die Software nachladen, die dann auch noch Speicherplatz verbraucht. Andererseits muß man aber zugeben, daß mit diesem »Softinterface« eine äußerst preisgünstige Alternative zur bestehenden Masse der Hardwareinterfaces geboten wird. Außerdem bietet das EC-64 einige Besonderheiten, die andere Epson-Interfaces nicht haben.

### Das Speicherplatzproblem

Die Routinen zum Ansteuern des Druckers benötigen zirka 1 KByte RAM — nicht viel, aber oft störend, wenn man Programme benutzen will, die vielleicht gerade diesen bestimmten Speicherbereich benutzen. Aus diesem Grunde wurde bei der Software darauf geachtet, daß die Ansteuerungsroutinen in verschiedene Speicherbereiche gelegt werden können. Am C 64 stehen vier verschiedene Bereiche zur Verfügung, die einen problemlosen Betrieb mit Simons Basic, Textomat und diversen anderen Programmen ermöglichen. Bei der VC 20-Version, die auf der selben Diskette gespeichert ist, stehen fünf verschiedene Bereiche zur Verfügung. Eine Speichererweiterung wird allerdings vorausgesetzt. Die Warmstartadressen für diese Routinen sind, falls aus Versehen die Schnittstelle mit Stop/Restore ausgeschaltet wurde, in der mitgelieferten Bedienungsanleitung enthalten.

### Vielseitige Möglichkeiten

Im Gegensatz zu vielen Hardware-Interfaces, die nur eine Geräteadresse benutzen, werden von diesem Softinterface vier Geräteadressen benutzt. Die Ansteuerung geschieht wie auch bei den Commodore-Druckern über OPEN X,Y: PRINT#X	wobei X die logische Filenummer und Y die verwendete Geräteadresse ist. Belegt werden die Geräteadressen #4, #5, #6 und # 7. Die Bedeutung der einzelnen Adressen wollen wir einmal genauer unter die Lupe nehmen.

Bei Ansprechen der Geräteadresse # 4 können sämtliche Möglichkeiten der Epson-Drucker genutzt werden. Da der Zeichensatz des C 64 nicht mit dem StandardASCII-Zeichensatz übereinstimmt, werden hier die Codes entsprechend umgewandelt. Sämtliche Epson-Steuerzeichen für Auswahl der Schriftarten, Superscript, Subscript etc. können dabei benutzt werden.

Die Adresse #5 hat die gleiche Funktion wie die Geräteadresse #4, es findet jedoch keine Code-Umwandlung statt.

Die wohl interessanteste Adresse ist Geräteadresse # 6: Wenn Sie diese Adresse benutzen, dann druckt der Epson-Drucker in Commodore-Schrift und ist in der Lage, alle Commodore-Steuerzeichen auszugeben. Haben Sie auf Ihrem Bildschirm einen anderen Zeichensatz, so spuckt der Drucker seine Texte wie selbstverständlich mit diesem Zeichensatz aus — gleichgültig, in welchem Speicherbereich dieser liegt.

Die Geräteadresse #7 eröffnet dem Benutzer eine Möglichkeit, die eine Hardwareschnittstelle praktisch nie bieten kann (außer wenn Zusatzsoftware wie beim Print 64 geliefert wird). Gibt man über diese Adresse einen CHR$(0) aus, fängt der Epson-Drucker an, eine Hardcopy des Bildschirms zu drucken. Man könnte meinen, der Computer würde auf dem Bildschirm nachsehen, was er auf den Drucker ausgeben soll: Die Hardcopy sieht immer so aus wie der Bildschirminhalt, gleichgültig ob Multicolormodus, geänderter Zeichensatz, HiRes oder sonst irgend etwas. Das einzige, was nicht ganz einwandfrei ausgedruckt wird, sind Bilder, die mit dem Koalapad gemalt wurden. Das liegt aber wohl mehr an der etwas seltsamen Farbspeicherbenutzung des Koalapainters und nicht am Interface.

Das Senden eines CHR$(1) an den Drucker bei Geräteadresse # 7 erzeugt eine invertierte Hardcopy. Wird über diese Adresse ein anderes Zeichen als CHR$(0) oder CHR$(1) gesendet, wird gedruckt, als würde Geräteadresse #5 verwendet.

### Reißfeste Verbindung

Die »Hardware« besteht, wie schon erwähnt, aus einem Verbindungskabel zwischen dem User-Port des C 64 oder VC 20 und dem Centronics-Anschluß der Epson-Drucker RX-80 oder FX-80 beziehungsweise FX-100. Lobenswert ist dabei, daß nicht die billigsten Anschlußstecker und -kabel verwendet wurden, sondern wirklich stabiles Material die Ausgangsbasis für das EC-64 ist.

### Ein tolles Ding

Das Epson EC-64-Softinterface ist eine der vielseitigsten und zugleich billigsten Möglichkeiten, einen Epson-Drucker an den C 64 oder VC 20 anzuschließen und sinnvoll zu nutzen. Besonders die Möglichkeit, eigene Zeichensätze und bildschirmgetreue Hardcopys auszudrucken, beeindruckt doch sehr, besonders im Hinblick auf die einfache Bedienung. Störend war nur, daß der Commodore-Zeichensatz auf Geräteadresse #6 liegt und deshalb Programme, die Commodore-Zeichensatz ausdrucken sollen, von Geräteadresse #4 auf #6 umgeschrieben werden müssen.

(M. Kohlen/aa)

Info: Epson Deutschland, Am Seestern 24, 4000 Düsseldorf 4, Tel. (0211) 5 95 20, Preis: 128 Mark.

# Digitalisierte Bilder mit dem C64

> Eine interessante Entwicklung für den C 64 sind die Videodigitalisierer. Diese Geräte gestatten, Videobilder in digitale Signale umzuwandeln, um sie auf dem Bildschirm oder dem Drucker in Schwarzweiß oder Farbe auszugeben.

Einer dieser Digitalisierer ist das Gerät von Print Technik, das als Bausatz etwa 460 Mark kostet.

Als Signalquelle benötigt diese Erweiterung ein beliebiges Videosignal über eine BNC-Buchse. Es kann direkt von einer Videokamera, einem Videorecorder oder einem entsprechenden Ausgang des Fernsehgeräts kommen. Die einzige Voraussetzung ist, daß das Bild zirka fünf Sekunden zur Verfügung steht. Diese Zeit braucht der Digitalisierer, um das Eingangssignal in 64 000 Einzelinformationen zu zerlegen.

Die mitgelieferte Software bietet im Hauptmenü folgende Funktionen: Bild darstellen, Bild einlesen, Bild drucken, Bild von der Diskette laden und Bild auf der Diskette speichern. Fünf Sekunden nach dem Start des Einlesevorgangs erscheint das Bild auf dem Bildschirm. Ist man mit dem dargestellten Ausschnitt nicht zufrieden, kann man das Bild mit den Cursor-Steuertasten horizontal und vertikal verschieben. Zu Beginn erscheint das Bild in Schwarzweiß. Mit den Funktionstasten Fl bis F8 kann den vier verschiedenen Graustufen dann jeweils eine Farbe zugeordnet werden. Kommt man dann doch zu dem Schluß, daß eine Schwarzweiß-Darstellung günstiger wäre, genügt ein Druck auf die »$«-Taste und der Ursprungszustand ist wieder hergestellt.

Das Innenleben dieses Gerätes ist durch den Einsatz integrierter Schaltkreise recht einfach aufgebaut, jedoch setzt die kurze Bauanleitung Kenntnisse im Aufbau elektronischer Schaltungen voraus.

Die Einsatzgebiete eines Videodigitalisierer sind recht vielseitig. Sie können von der Auswertung von Satellitenbildern bis hin zur Alarmanlage reichen. Bei dem Einsatz als Alarmanlage kann man ein einmal eingelesenes »Sollbild« mit später aufgezeichneten Bildern durch den C 64 vergleichen und bei einer Veränderung ein Signal aussenden lassen.

Ein Ausdruck mit einem Farb- oder Schwarzweißdrucker ist vom Menü aus anwählbar. Hierbei kann man vor dem Druckvorgang den Druckertyp bestimmen.

Als vorrangiges Anwendungsgebiet der Digitalisierer bietet sich der technisch-wissenschaftliche Bereich an, wobei der C 64 mit diesem Zusatzgerät auch hier als preiswerter Computer eingesetzt werden kann.

(Rainer Schönrock/rg)

# Speichertuning für VC 20

> Eine neuartige 64 KByte-RAM-Karte für den VC 20 stelK 32 KByte freien Basic-Speicher zur Verfügung und ermöglicht Änderungen am Betriebssystem. Wird der VC 20 damit dem C 64 ebenbürtig?

Es gibt Computer wie den Sharp MZ-700 oder die meisten CP/M-Systeme, die sich dem Benutzer nach dem Einschalten völlig nackt präsentieren, das heißt fast der gesamte Speicherbereich besteht aus freiem RAM. Lediglich ein kleines Betriebssystem im ROM sorgt für das Laden der eigentlichen Programmiersprache.

Dieses Prinzip der reinen RAM-Maschine fand auch bei der Konzeption der Speichererweiterungskarte MR 64 von Roßmöller Verwendung (Bild 1). Die Organisation ähnelt der des C 64, der ROM-Bereich des Computers wird nämlich mit RAM überlagert.

Diese Erweiterungskarte für den VC 20 unterscheidet sich also sowohl von der Verwaltung des Speichers, als auch von der Art des Einbaus von den anderen beiden, in Ausgabe 9/84 getesteten, 64 KByte-Erweiterungen. Sie wird nämlich nicht in den Expansionsport eingesteckt, sondern in den Computer eingebaut. Damit bleibt der Erweiterungsanschluß für Module frei.

## Einfacher Einbau

Zum Einbau wird das Gehäuse (freilich erst nach Ablauf der Garantiefrist) geöffnet und die CPU mit Hilfe eines Schraubenziehers aus ihrem angestammten Sockel entfernt. An deren Stelle steckt man den Verbindungsstecker ein, der über ein Flachbandkabel mit der MR 64-Platine verbunden ist.

Die 6502-CPU wird danach einfach wieder in den neuen Sockel auf der Speicherplatine eingesteckt — kinderleicht. Wer sich jedoch nicht auf den Umgang mit ICs versteht, kann die CPU durch falsche Polung in den Tod schicken, denn weder in der etwas mageren Beschreibung noch auf der Platine ist die Polungsrichtung der CPU angegeben. Also habe ich die 6502-CPU in der Richtung eingesteckt, wie ich sie aus dem Sockel gehebelt habe, und die war glücklicherweise richtig.

Nach dem Einschalten zeigt die Initialisierungsanzeige 28159 freie Bytes an, welches die größtmögliche — herstellerseitig vorgesehene Ausbauversion — ist. In diesem Punkt ist die MR 64 also identisch mit den üblichen Speicherweiterungen.

Einzelne Speicherbereiche wie zum Beispiel 3, 8, 16 KByte oder Modulspeicher können über DIL-Schalter ein- beziehungsweise ausgeschaltet werden. Bei eingebauter Karte ist dies sicherlich ein diffiziles Unterfangen; Roßmöller schlägt deshalb vor, Schalter ins Computergehäuse einzubauen (gehören nicht zum Lieferumfang).

## Der Zugriff auf den Speicher

Wie — so wird sich mancher fragen — bewerkstelligt man den Zugriff auf andere Speicherbereiche?

Wie anfangs erwähnt, lehnt sich die Organisation des RAM an die des C 64 an. Damit kann man auch im ROM-Bereich Daten abspeichern, was Bild 2 verdeutlicht.

Über die Adresse 40959 (vergleichbar mit Speicherstelle 1 beim C 64) können bestimmte ROM-Abschnitte auf Schreib-/Lesespeicher softwaremäßig umgeschaltet werden. Im Umgang mit dieser Speicherstelle ist jedoch Vorsicht geboten, denn wird beispielsweise das Basic-ROM ausgeblendet, dann befindet sich an dieser Stelle nur noch leeres RAM. Dies hat in etwa den gleicher Effekt, wie das Absägen eines Astes, auf dem man gerade sitzt. Aus diesem Grund ist auch gleich ein Reset-Taster mit eingebaut worden.

Somit hat man also die Möglichkeit, den gesamten — vom Prozessor adressierbaren — Bereich auf RAM umzuschalten. Ohne erhebliche Erfahrung in Maschinensprache sollte man damit aber vorsichtig sein.

Zum Beispiel kann man den Basic-Interpreter und das Betriebssystem ins RAM kopieren und in diesem Bereich die Änderungen vornehmen. Dies kann über folgendes Programm geschehen:
FOR 1= 49152 TO 65535: POKE I, PEEK (I): NEXT

Diese Zeile sieht auf Anhieb etwas seltsam aus, denn warum POKEt man in eine Speicherstelle einen Wert, der sich sowieso schon dort befindet? Ganz einfach. Mit PEEK liest man den Inhalt des ROMs aus und schreibt ihn mit POKE ins darunterliegende RAM. Da diese Übertragung in Basic sehr langsam ist (man muß ja immerhin 16 KByte kopieren) gehört zum Lieferumfang dieser Karte ein Maschinenprogramm, das diese Aufgabe in Sekunden erledigt.

Die gesamte Systemsoftware liegt nun im RAM und kann beliebig abgeändert werden. So kann beispielsweise der ASC-Befehl mit PO-KE 55183,5 entschärft werden, damit bei einem Leerstring (” ”) nicht »Illegal Quantity Error« — wie es normalerweise der Fall ist — sondern eine Null ausgegeben wird.

Natürlich sind auch weitergehende Ergänzungen und Änderungen auf diese Weise realisierbar. Lediglich beim Abspeichern gibt es Probleme, denn dieser Adreßbereich wird vom Betriebssystem nicht ohne weiteres auf Band aufgezeichnet. Commodore wollte damit verhindern, daß ein Spielmodul abgespeichert werden kann.

Diese Karte überlagert aber nicht nur die Systemsoftware ($C000 bis $FFFF) wie eben beschrieben, sondern auch den Zeichengenerator und den Ein-/Ausgabe-Bereich mit RAM.

## Zusätzlicher Basic-Speicher

Mit dem 4 KByte-Zeichengenerator-ROM hat es eine besondere Bewandtnis. Wer denkt, daß man auch hier die Zeicheninformationen wie die Betriebssoftware überschreiben kann, der irrt. Aufgrund des eigenständigen Zugriffs des Video Interface Chip auf den Charactergenerator, der sich (wie in Bild 2 zu sehen) direkt an den Basic-Speicher anschließt, ist dies nämlich nicht möglich. Dafür kann man diesen Bereich für Basic nutzen, denn der Basic-Interpreter läßt sich dementsprechend ändern. Daher meldet sich der VC 20 nach dem Starten des beigefügten Maschinenprogramms mit 32255 freien Bytes.

Schließlich ist auch der I/O-Bereich ($9000-$9FFF), der die VIC-Register, den Farbspeicher und die Ein-/Ausgaberegister enthält mit RAM-Speicher überlagerbar. Da dieser Speicherabschnitt bei meinem Testmodell nicht funktionierte, konnte ich nicht mit ihm arbeiten. Nach Auskunft des Herstellers kann man ihn sowieso nur mit einem bestimmten Programmiertrick nutzen, da der Prozessor während des Interrupts ständig auf diesen Bereich zugreift.

Da zu diesem Speicherabschnitt auch das Umschaltregister (Adresse $9FFF) gehört, kann es bei Bedarf über den mitgelieferten Schalter in eine ganz normale Speicherstelle umgewandelt werden.

An fertiger Software ist nach Angaben des Herstellers ein Forth-Compiler in Vorbereitung. In erster Linie ist man aber wohl auf seine eigenen Programmierkünste angewiesen. Prinzipiell kann man auch daran denken, Programme von C 64 auf den so erweiterten VC 20 umzuschreiben (wobei unterschiedliche Grafik- und Tonerzeugungsmethoden beachtet werden müssen).

Fazit: Will man diese Speicherweiterung voll ausnutzen, so benötigt man fundierte Maschinensprachekenntnisse. Unter diesem Gesichtspunkt gesehen bietet sie für Otto Normalbenutzer kaum Vorteile gegenüber den herkömmlichen 64 KByte-Karten. Werjedoch das erforderliche Wissen besitzt, dem eröffnen sich mit dieser Karte völlig neue Aspekte der Programmierung, denn man hat — wie beim C 64 — die Organisation des ganzen Systems in der Hand.

(Christoph Sauer/ev)

Vorteile:

- Epansionsport bleibt frei
- vergrößerter Basic-Speicher
- Betriebssoftware ist änderbar
- Speicher-ICs sind gesockelt
- Alle Ausbaustufen des VC 20 können simuliert werden

Nachteile:

- Polungsrichtung für die CPU nicht angegeben
- nur für Maschinensprachenprofis voll nutzbar

Preis: 295 Mark
Roßmöller GmbH, Finkenweg 1, 5309 Meckenheim

# GBasic – alles drin!

> GBasic 64 ist eine relativ neue Basic-Erweiterung für den C 64. Sie ist wohl die leistungsfähigste, die es zur Zeit auf dem Markt gibt. GBasic 64 unterstützt sowohl Grafik als auch Sound. Verfechter der strukturierten Programmierung kommen ebenso zu ihrem Recht wie Anwender, die großen Wert auf Programmierhilfen legen. Dabei wird nicht nur Basic, sondern auch Assembler unterstützt.

GBasic ist noch relativ unbekannt, wahrscheinlich auch deswegen, weil es nur in einer Modul-Version vorliegt, die eine spezielle Hardware beinhaltet, und es somit praktisch kopierunfähig macht.

Das Modul macht einen sauberen soliden Eindruck. Goldkontakte, Standfüße, sowie einen eingebauten Reset-Taster sollte eigentlich jedes Modul haben. Mitgeliefert werden noch ein Handbuch, auf das ich noch zu sprechen kommen werde, sowie eine Diskette oder Kassette mit Demo-Programmen und Utilities. Nach dem Einstecken des Moduls in den Modulschacht und dem Einschalten des C 64 meldet sich dann auch sofort GBasic. Aus der Meldung wird ersichtlich, daß Sie nun 8 KByte weniger Speicherplatz für Basic-Programme zur Verfügung haben. Das Modul selbst hat allerdings 16 KByte ROM-Speicher. Daß trotzdem nur die Hälfte davon Basic-Speicherplatz belegt, liegt an einer ausgeklügelten Technik im Modul, die als »Memory-Mapping« bezeichnet wird. Modulintern werden die Speicherplätze so verwaltet, daß immer nur 8 KByte von GBasic für den Computer sichtbar sind. Sogar diese 8 KByte kann man sich freigeben lassen. Der Befehl EXIT schaltet nämlich das Modul softwareseitig aus! Nach EXIT haben sie wieder einen ganz normalen C 64 mit 38 KByte Basic-Speicher, ohne das Modul herausziehen zu müssen. Das schont sowohl Computer wie auch Modul. Einschalten läßt sich GBasic jederzeit wieder über den eingebauten Reset-Taster.

Tabelle 1 zeigt eine Befehlsübersicht, daher werden wir im folgenden nur die Besonderheiten von GBasic gegenüber anderen Erweiterungen aufzeigen.

## Toolkit

GBasic besitzt einige Funktionen, die beim Programmieren sehr nützlich sind: Programmlistings können sowohl nach unten als auch nach oben gescrollt werden. Somit ist ein komfortables Editieren von Programmen möglich. Zwei nützliche und oft hilfreiche Befehle des Toolkits sind FIND- und der REN(umber).

FIND listet alle Basic-Zeilen, die eine bestimmte Zeichen- oder Befehlsfolge enthalten. Allerdings ist es nicht möglich, die Suche auf bestimmte Programmteile zu begrenzen. Bei häufigem Auftreten des gesuchten Begriffs leidet die Übersichtlichkeit etwas.

Dagegen ist der REN-Befehl komfortabel. Es werden beim Umnumerieren nicht nur alle GOTO, GOSUB, RESTORE-Befehle an die neuen Zeilennummern angepaßt, es kann auch bereichsweise umnumeriert werden. Wenn man zum Beispiel in einem Unterprogramm von Zeile 1000-2000 Änderungen vorgenommen hat, kann man es mit REN 1000,10,1000-2000 sauber in Zehnerschritten numerieren, während das restliche Programm bis auf die Anpassung der Sprungbefehle unverändert bleibt.

Positiv aufgefallen ist auch die hohe Geschwindigkeit beim TRACE-Befehl, die mit der Control-Taste zum Mitlesen herabgesetzt werden kann.

## Extended Basic
Unter diese Kategorie fallen die Befehlserweiterungen, die für alle Programme nützlich sind, und sich somit nirgends richtig einordnen lassen. Benutzer von Simons oder ExBasic werden hier wohl den einen oder anderen Befehl ihrer Erweiterung wiedererkennen. Hervorstechend bei GBasic ist, daß die

Befehle GOTO, GOSUB wie auch RESTORE nun auch mit Labels möglich sind. Diese Labels werden vor eine anzuspringende Zeile gesetzt. Schön wäre es noch gewesen, wenn man, wie in Simons Basic, globale und lokale Variablen zur Verfügung hätte.

Befehle wie IF..THEN..ELSE..,RE-PEAT..UNTIL, PRINT AT, PRINT USING, das Abfangen von ERRORs und so weiter, gehören schon fast zur »Standardausrüstung« von Basic-Erweiterungen und sind auch in GBasic enthalten.

## Stringbefehle und Funktionen

Die Stringbefehle, die es in GBasic gibt, gleichen in ihrer Wirkung denen in Simons Basic. Man braucht keinen Haufen Unterprogramme, um Strings zu ersetzen, zum Einfügen und Suchen von Textteilen innerhalb eines Strings und so weiter. Neben dem EXOR-Befehl, der durch eine unübliche und unhandliche Syntax auffällt, wäre der BIT-Befehl zu erwähnen. Wenn man bestimmte Bits, zum Beispiel am Joystickport, auf gesetzt testen will, ist das mit einem Befehl möglich. BIT ist eine logische Funktion und kann somit direkt in IF-Abfragen eingesetzt werden.

Als sehr flexibel und nützlich erweist sich der FUNCTION-Befehl. Mit ihm kann der Inhalt eines Strings berechnet werden. So kann man mit einem INPUT-Befehl Formeln eingeben, die FUNCTION auswertet. Im normalen Basic ist das nur mit großen Schwierigkeiten möglich. Zum Beispiel ergibt PRINT FUNCTION ”12/4 + 3” die Ausgabe 6. FUNCTION arbeitet mit allen Basic-Funktionen und auch Variablen im Funktionsstring. Erleichtert wird die Programmierarbeit auch dadurch, daß jederzeit Hexadezimal- und Binär-Zahlen verwendet werden dürfen.

## Peripherie

GBasic unterstützt nicht nur Diskettenoperationen, sondern auch Joystick, Lightpen und Paddle. Sehr interessant sind dabei DEV und BLOAD. DEV stellt die Standardgeräte-Adresse um, DEV8 zum Beispiel auf die Floppy. Jedes LOAD, SAVE und VERIFY bezieht sich jetzt, so lange nicht ausdrücklich anders angegeben, auf die Floppy-Disk. Sogar die Tastenkombination SHIFT-RUN/STOP lädt das erste Programm anstelle von der Datasette von der Floppy und startet es automatisch.

Mit BLOAD können Maschinenprogramme, Grafikbilder oder Spritedaten, kurz alles was nicht Basic ist, in den C 64 geladen werden. Wenn Sie sagen, »Das kann ich mit LOAD,X,1 auch«, dann werden Sie merken, daß im Gegensatz dazu BLOAD keinerlei Pointer verändert! Ein BLOAD-Befehl in einem Programm führt nicht zu einem Neustart nach erfolgtem Ladevorgang, sondern das Programm läuft ganz normal weiter. Auch der häßliche OUT OF MEMORY ERROR nach dem Nachladen von Maschinenprogrammen in den $C-Bereich tritt nicht mehr auf.

Noch ein paar Worte zum HCOPY-Befehl. Mit ihm kann hochauflösende Grafik ausgedruckt werden. HCOPY arbeitet mit jedem (!) grafikfähigen Acht-Nadel-Drucker zusammen. Diese Flexibilität mußte damit erkauft werden, daß Sie HCOPY erst mit einigen POKEs an ihren Drucker anpassen müssen. Eine Hardcopy der Textseite ist mit HCOPY nicht möglich.

## Grafik

Kommen wir nun zu dem Teil von GBasic, der die meisten von Ihnen interessieren wird: die Grafik. GBasic verfügt über drei Grafikseiten, von denen zwei allerdings Basic-Speicherplatz belegen. Eine vierte kann noch als Zwischenspeicher verwendet werden. Bei ihr ist allerdings keine Farbsetzung möglich, da der Farbspeicher hier im GBasic-Modul selbst liegen müßte.

Zwischen diesen drei Seiten kann beliebig hin und her geschaltet werden, man kann sogar eine Seite bearbeiten, während eine andere oder die Textseite angezeigt wird. Es ist aber nicht möglich eine Multicolorseite anzeigen und eine »normale« Seite zu bearbeiten. Die Seiten können auch beliebig gemischt oder übereinander kopiert werden. Alle üblichen Zeichenbefehle sind implementiert: Punkte, Linien, Rechtecke und Blöcke können in sehr hoher Geschwindigkeit gesetzt, gelöscht oder invertiert werden.

Auch der CIRCLE-Befehl ist sehr vielseitig. Nicht nur Kreise, sondern auch Ellipsen, Vielecke, Kreisbögen und so weiter können gezeichnet werden. Dies allerdings in einer fast sensationellen Geschwindigkeit, vor allem, wenn man die Voreinstellung der Schrittweite ändert und erhöht. Die Kreise werden dadurch eckiger, aber sehr viel schneller gezeichnet. Hier hilft Experimentieren, bis man den optimalen Wert herausgefunden hat.

Ungewöhnlich, aber sehr nützlich ist der VECTOR-Befehl. Mit ihm kann man Linien zeichnen, die enden, sobald sie auf einen anderen gesetzten Punkt beziehungsweise Kreis, Linie oder sonstiges treffen. Schraffuren sind damit ein Kinderspiel. Der letzte gezeichnete Punkt wird in zwei Variablen gespeichert, so daß Sie volle Kontrolle über den Zeichenvorgang haben.

Nun aber zum gelungensten Befehl in GBasic. Gemeint ist PRINT. Ja, Sie haben richtig gelesen, PRINT. Sollten Sie jetzt den Kopf zweifelnd schütteln, so muß ich Ihnen sagen, daß ich in keiner Basic-Erweiterung einen solchen Komfort gefunden habe. Vergessen Sie TEXT (zum Beispiel aus Simons Basic) und seine Kollegen, mit denen Sie Texte in Grafiken eingebracht haben. Warum nehmen Sie nicht einfach PRINT? In GBasic funktioniert das, und zwar so gut, daß PRINT"shift-clr/home” tatsächlich die Grafikseite löscht. Alle Cursorbewegungen, Farbcodes, Groß/Klein-Umschaltungen und Revers-Schrift funktionieren wie auf der normalen Textseite, mit zwei kleinen Einschränkungen. Erstens ist das Ganze verständlicherweise etwas langsamer, und zweitens ist kein Scrolling nach oben möglich, wenn in die letzte Zeile geschrieben wird.

Doch damit nicht genug. Sie können mit PSN den Cursor fein, das heißt einzelpunktweise, positionieren. Nach PSN 0,1 steht der Cursor (bitte bedenken Sie, daß er während der Programmausführung nicht zu sehen ist) um eine Einzelpunktzeile tiefer als nach PRINT"clr/home" und am linken Rand. Mit PSN ist zum Beispiel Schrägschrift oder ein Funktionenplotter mit Print-Befehlen möglich. Eine weitere Manipulationsmöglichkeit ist mit SIZE gegeben. Sie können damit die Zeichengröße in X- und Y-Richtung beliebig vervielfachen, bis aufs 38x24 = 912-fache. Das wäre dann allerdings bildschirmfüllend.

Schließlich kann noch der Zeichenabstand manipuliert werden, dies allerdings nur mit POKE-Befehlen. So läßt sich eine Engschrift, oder gar Proportionalschrift realisieren. Alle diese Möglichkeiten des PRINT-Befehls habe ich in Bild 1 ausgeschöpft. Aber das ist immer noch nicht alles. Mit der GBasic-Demo-Diskette/Kassette erhalten Sie noch eine Befehlserweiterung zu GBasic, die auf einfache Art und Weise 3D-Grafik ermöglicht. Dazu müssen Sie ersteinmal Shapes erstellen und im Speicher ablegen. Ein Shape ist, salopp gesagt, ein dreidimensionaler Linienzug beliebiger Länge und Komplexität. Haben Sie solch ein Shape erstmal definiert, können sie es mit drei zusätzlichen Befehlen beliebig um die Raumachsen drehen beziehungsweise vergrößern, um es danach im hochauflösenden Grafik-Modus zeichnen zu lassen. Gezeichnet wird aus Geschwindigkeitsgründen parallelperspektivisch im Drahtgittermodell, das heißt, eigentlich unsichtbare Linien werden mitgezeichnet. Ein Beispiel sehen Sie in Bild 2.

## Sprites

Ähnlich reichhaltig wie der Grafikbefehlssatz ist der für die Sprites. Das fängt schon mit einem ebenfalls auf der Demo-Diskette/Kassette befindlichen Spriteeditor an, dessen Spritedaten Sie in GBasic direkt weiterverarbeiten können. Alle Spriteparameter sind über Befehle erreichbar. Es ist auch möglich, Sprites interruptgesteuert und unabhängig vom Basic-Programm bewegen zu lassen. Sprite-Sprite- und Sprite-Hintergrund-Kollisionen können auch jederzeit in GBasic abgefragt werden. Dies ist allerdings auch interruptgesteuert möglich, bei einer Kollision wird dann in ein Basic-Unterprogramm gesprungen. Hier kann sogar nur auf bestimmte Kollisionen, wie Sprite drei mit Sprite sieben oder ähnliches, geprüft werden.

## Musik

Der letzte Bereich von neuen Basic-Befehlen betrifft den Sound-Chip. Auch hier zeigt sich GBasic als praktisch. Es kann auf jeden Parameter des Sound-Chips zugegriffen werden, ohne zu POKEn. Sogar der Filter ist in GBasic voll steuerbar. Aber damit nicht genug. Für Soundeffekte reichen die normalen Soundbefehle voll aus, aber sobald man längere Musikstücke spielen möchte, hört der Spaß auf. Deswegen wurde in GBasic noch eine Programmiersprache, MUSIC, integriert. MUSIC hat 14 Befehle, die das Programmieren von Musikstücken zum Kinderspiel machen. Diese sind nicht in Tabelle 1 aufgeführt! Ein in MUSIC programmiertes Lied wird irgendwo im Speicher abgelegt. Es kann dann mit dem PLAY-Befehl gestartet werden und läuft interruptgesteuert bis zum Ende oder endlos, je nach Programmierung. Während die Musik spielt, kann ein Basic-Programm unbehindert nebenher laufen. Die Eingabe von MUSIC-Programmen würde allerdings wieder zur POKEerei werden, wenn Omikron nicht auch noch einen MUSIC-Editor mitliefern würde. Der ist ebenfalls auf der Demo-Diskette/Kassette.

## Monitor

Und um das Maß und die 16 KByte Speicher voll zu bekommen, ist in GBasic auch noch ein Maschinensprachemonitor implementiert. Er beherrscht so ziemlich alles, was man von einem komfortablen Monitor erwartet, den man sich einzeln, also ohne Basic-Erweiterung zulegen würde. Einziger Kritikpunkt ist die ungewöhnliche Bedienung über die Funktionstasten. Deswegen wurde auch hier keine genaue Befehlsauflistung gegeben. Alle Fähigkeiten des Monitors finden sich aber in Tabelle 1. DieserMonitoristwohlfür jeden normalen Anwendungsfall ausreichend.

## Dokumentation

Das mitgelieferte Handbuch muß hier ausdrücklich gelobt werden. Es werden nicht nur alle Befehle gut und genau erklärt, auch sind sehr viele Hintergrundinformationen enthalten, wie zum Beispiel eine Speicherbelegung von GBasic. Es wird auf die mitgelieferten Programme genauso stark eingegangen wie auf GBasic selber. Eine Befehlsübersicht und einige wichtige Tabellen runden das Gesamtbild ab. Ich vermisse nur noch eine Zeropagebelegung von GBasic. Warum? Nun, GBasic läßt sich vom Benutzer beliebig erweitern. Wenn Sie einen neuen Befehl in GBasic einbauen wollen, müssen Sie ihm nur ein ”!” voranstellen. Findet GBasic ein ”!”, springt es nach $C000, wo Sie dann Ihre Befehlsauswertung vornehmen können. Ein Beispiel für eine solche Erweiterung ist die nachladbare 3D-Grafik.

Wie Sie sehen, bietet GBasic eine ganze Menge, und zwar nicht nur von jedem etwas, sondern jeder seiner Befehlsbereiche ist in sich geschlossen und vollständig. Beim Test habe ich nur einen Fehler entdecken können. Wenn Sie mit DISK ein Kommando an die Diskette senden wollen, diese aber nicht eingeschaltet ist, hängt sich GBasic auf, und läßt sich nur noch mit RUN/STOP-RESTORE wiederbeleben. Ähnliches passiert bei DIR. Es wird kein DEVICE NOT PRESENT ERROR ausgegeben, sondern einfach nur READY. Diese beiden Fehler sollen aber in einer neuen Version, die gerade bei Omikron fertiggestellt wird, beseitigt werden. Zusätzlich will man dort ein schnelleres Laden von Diskette, ähnlich Hypra-Load (64’er, 10/84), einbauen. Trotzdem soll volle Kompatibilität zu der alten GBasic-Version bestehen bleiben.

Abschließend kann ich sagen, daß mich GBasic überzeugt hat. Ausschlaggebend waren die enorme Befehlsvielfalt, wie auch die hohe Geschwindigkeit der meisten Funktionen. Ich hoffe, daß diese Erweiterung etwas bekannter, und vielleicht, ähnlich wie für Simons Basic, fertige Software dafür geschrieben wird. Auch die Erweiterbarkeit von GBasic kann ein Anreiz für andere Programmierer sein. Insgesamt ein Paket, das seine 259 Mark wert ist.

(Boris Schneider/gk)

Bezugsquelle:
Omikron Software, Erlachstr.15, 7534 Birkenfeld 2

# Assembler? Assembler!

> Wer die Fähigkeiten seines Computers voll und ganz ausnutzen möchte, kommt um den Einsatz der Maschinensprache nicht herum. Schließlich ist sie die einzige, die der Computer wirklich versteht. Allerdings hat sie den entscheidenden Nachteil, daß der Mensch mit einer Anhäufung von Nullen und Einsen kaum etwas anfangen kann. Kluge Köpfe haben deshalb die Assembler-Sprache erfunden, einen Kompromiß, mit dem beide, Mensch und Computer, zufrieden sein können.

Mein Weg zur Maschinensprache begann mit den vielen, vielen DATAs, die sicherlich jeder von uns einmal eingegeben hat, ohne überhaupt zu wissen, welche Bedeutungsie hatten. Diese Unmenge an Zahlen verschwand dann in der Tiefe des Rechners, wurde nicht mehr gesehen und vollbrachte wahre Wunderdinge.

Also entschloß ich mich eines Tages, einen in Basic geschriebenen Maschinensprach-Monitor abzutippen und damit zu arbeiten. Plötzlich erschienen gar seltsame Zahlen und Buchstaben auf dem Bildschirm:
**4000 A0 00 B9 00 41 F0 06 20**

So ungefähr muß es in grauer Computer-Urzeit auf meinem Bildschirm ausgesehen haben.

Nun, Sie müssen zugeben, daß diese »Hieroglyphen« sicherlich nicht gerade aufschlußreich erscheinen. Mit einer Befehlsliste für den 6502 ging ich nun daran, das »Zahlenrätsel« zu lösen. Zum ersten Mal konnte ich meinem Computer direkt in das Innerste — also geradezu in die Eingeweide — schauen. Allerdings war dieses Verfahren der Übersetzung auf die Dauer sehr eintönig und sehr, sehr zeitraubend. Also wie geschaffen für einen Computer.

Sehen wir uns noch einmal das obengenannte Beispiel genauer an:

Bei der ersten Angabe (4000) handelt es sich um die Adresse, in der der folgende Wert (A0) steht. Dies ist ein Befehl oder »Operationscode«, der eine Operation in der CPU des Rechners bewirkt: Er lädt das Y-Register (im Englischen abgekürzt — LOAD Y) mit der folgenden Zahl (00).

Da »unser« C 64 einen Befehlsvorrat von 50 Befehlen kennt, können Sie sich vorstellen, daß es sehr anstrengend ist, sich diese Anzahl an Befehlen in Form von Hex-Zahlen zu merken. Hinzu kommt noch, daß durch die verschiedenen Adressierungsarten die Gesamtzahl auf 150 Befehle ansteigt, so daß es selbst für einen Geistesakrobaten schwierig wird. Deshalb kamen findige Tüftler auf die Idee, Mnemonics (= Gedächtnishilfen) zu »erfinden«, die in 3 Buchstaben das Entscheidende des Befehls ausdrücken:

Aus A0 (LOAD Y) wird als Mnemonic LDY. Aus B9 (LOAD AKKU) wird LDA!

Wenn wir uns jetzt diese Erleichterung zu Nutze machen, können wir unser Maschinen-Programm auch folgendermaßen schreiben:
LDY #00
LDA 4100,Y
BEQ 400D
JSR FFD2

Nun fällt uns auch die Übersetzung des Programmes viel leichter:

1. lade das Y-Register mit dem Wert 00,
2.	lade den Akku mit dem Wert, der in Adresse 4100+Y steht,
3.	springe, wenn dies eine Null war, nach 400D,
4.	springe ansonsten in das Unterprogramm (JSR = JUMP SUBROUTINE), das bei FFD2 beginnt.

Sie werden bemerkt haben, daß wir uns immer mehr von der »reinen« Maschinensprache entfernen, da wir bemüht sind, das Programmieren für uns Menschen verständlicher zu machen.

Wir benötigen also ein Programm, welches in der Lage ist, einen so eingegebenen Text zu übersetzen. Solch ein Programm, das einen in Mnemonics (zum Beispiel LDA..., STA...) vorliegenden Text in Maschinencode übersetzt, nennt man einen **Assembler**.

Entsprechend wird ein umgekehrt arbeitendes Programm als **Disassembler** bezeichnet. Dieser hat also den Vorteil, daß er unsere Programmzeile nicht in reinen Hexadezimalzahlen (A0, B9, ...), sondern in Mnemonics (LDY #00, LDA 4100, Y ...) ausdruckt.

Leider heißt auch die Programmiersprache, bei der Mnemonics benutzt werden, **Assembler(-Sprache)**, so daß hierbei leicht Verwechslungen auftreten.

Neben dieser reinen Übersetzungstätigkeit besitzen fast alle Assembler(-Programme) aber noch weitere Möglichkeiten, die Arbeit zu erleichtern. Alle guten Assembler erlauben den Einsatz von **Labels**. Dabei handelt es sich um freigewählte Namen, die anstelle der absoluten Werte gesetzt werden. In unserem Beispiel könnten wir die absoluten Adressen hinter LDA und JSR durch einen beliebigen Namen ersetzen. Unser Beispiel könnte also etwa so aussehen:

  	LDY	#
  LOOP	LDA	TEXT,Y
  	BEQ	ENDE
  	JSR	AUSGEBEN
  	INY	
  	BNE	LOOP
  ENDE 	

Ein Vorteil dieser Prozedur liegt vor allem darin, daß diese Namen schon beim Lesen des Quelltextes erkennen lassen, welche Funktion zum Beispiel das Unterprogramm »Ausgeben« hat. Anders als in Basic, wo ein GOSUB 12600 nichts darüber aussagt, was dort geschehen soll. Ein weiterer Vorteil ist, daß wir uns beim Schreiben des Textes (auch als **Quelltext**, Quellcode beziehungsweise Sourcecode bezeichnet) nicht von vornherein über sämtliche Sprungziele im Klaren sein müssen. Wo zum Beispiel der Text steht, ist erst einmal völlig gleichgültig. Wir könnten auch noch später einige Befehle zwischen LOOP und ENDE einfügen, kurz, der Quelltext ist ohne großen Aufwand beliebig veränderbar. Wären statt dessen absolute Adressen verwendet worden, müßten diese beijeder Änderungebenfalls angepaßt werden. Bei längeren Programmen ist das nahezu unmöglich. Die Rechnerei übernimmt nun der Assembler: Dazu arbeitet er den Quelltext in — normalerweise — zwei Schritten (**Pass**) durch. Im ersten Pass werden alle Sprungziele etc. berechnet und in einer **Symboltabelle** abgelegt, im zweiten Pass wird das Maschinenprogramm (**Objectcode**, Maschinencode) im Speicher abgelegt.

Wenn in einem Programm verschiedene Teile mehrfach auftau-'chen, ist es sicherlich nicht sinnvoll, diese jedesmal neu eingeben zu müssen. Deshalb bieten verschiedene Assembler die Möglichkeit, solche Teile als »**Makro**« zu definieren. Anstelle der gesamten Befehlsfolge genügt es, nur den vorher definierten Makronamen einzusetzen. Unser Beispielprogramm ließe sich mit dem Makro-Namen »Textaus« versehen und dann an jeder Stelle im Programm aufrufen, die einen Text ausgeben soll.

Als weitere Bequemlichkeit nehmen die meisten Assembler dem Programmierer das Umrechnen der verschiedenen Zahlensysteme ab. Sie verarbeiten Binärzahlen ebenso wie Dezimal- oder Hex-Zahlen. Häufig kann man auch Texte als Buchstabenfolge und nicht in ASCII-Codes eingeben. Darüber hinaus sind beim Operanden einfache Rechen- beziehungsweise logische Operationen erlaubt, zum Beispiel:
LDA #53280 AND 255 oder
STA TEXT + 7,X

Um dem Assembler Anweisungen beim Übersetzen zu geben, werden **Pseudo-Opcodes** eingesetzt. So bedeutet zum Beispiel: .BA $C000

Beginne die Assemblierung bei $C000. (Bisweilen wird hierfür auch der Pseudo-Opcode »ORG« benutzt. ».BY« oder »WORD« signalisiert dem Assembler, daß die folgenden Zeichen nicht als Befehl, sondern als Byte-Folge im Speicher abgelegt werden sollen. Ebenso gibt es Pseudo-Opcodes, die die Ausgabe eines Assemblerlistings auf dem Drucker steuern. In der Anzahl und den Möglichkeiten der Pseudo-Opcodes unterscheiden sich die verschiedenen Assembler stark voneinander.

Zur Eingabe des Quelltextes wird ein **Editor** benötigt. Im einfachsten Falle ist dies der von Basic gewohnte Editor. Gute Assembler bieten hier jedoch weitaus mehr. Befehle zum Suchen (FIND) und Ändern (EDIT) bestimmter Befehlsfolgen gehören eigentlich zum Standard. Befehle zum Blättern im Quelltext, zum Einfügen, Kopieren und Verschieben von Textteilen, wie man sie aus Textverarbeitungssystemen kennt, bieten ein Höchstmaß an Komfort. Auch hierin unterscheiden sich die Assembler ganz erheblich. Der Editor erlaubt meistens auch, Teile des Programms separat abzuspeichern und sich so eine Bibliothek von häufig benötigten Unterprogrammen anzulegen. Damit wären die wichtigsten Begriffe, die im Zusammenhang mit Assemblern auftauchen (zum Beispiel in den Testberichten in dieser Äusgabe) erläutert. Eine Zusammenfassung finden Sie in unserem »Kleinen Assemblerlexikon«.

(N. Mann/D. Weineck/gk)

<aside>
**Monitor**
Programm zum Bearbeiten von Maschinenprogrammen. Enthält mindestens HEX-DUMP, DISASSEMBLER sowie LOAD- und SAVE-Befehle. Bessere Monitore bieten zum Beispiel die Möglichkeit, Programme unter Kontrolle der Register ablaufen zu lassen.
**Hex-Dump**
(Memorydump, Speicherdump). Auflisten eines Maschinenprogrammes in Hex-Zahlen.
**Disassembler**
listet ein Maschinenprogramm in Form von MNEMONICS auf.
**Assembler**
übersetzt einen in Assemblersprache geschriebenen QUELLTEXT in OBJECTCODE.
**Mnemonic**
Aus drei Buchstaben bestehende »Gedächtnishilfe«, Abkürzung eines Assemblerbefehls.
**Label**
(Marke), ein (sinnvoller) Name, der bei der Assemblierung in eine feste Zahl umgerechnet wird. Labels können Sprungziele, aber auch Operanden sein.
**Makro**
Häufig auftretende Programmteile werden unter einem Namen zusammengefaßt. Der Quelltext enthält nur den Namen, beim Assemblieren wird die Befehlsfolge eingesetzt.
**Quelltext**
(Sourcecode) ist der Text, den man mit Hilfe des EDITORS in Assembler-Sprache schreibt. Er wird später vom Assembler übersetzt.
**Objectcode**
(Maschinencode) ist das vom ASSEMBLER erzeugte, fertige Maschinenprogramm.
**Pseudo-Opcode**
enthält Anweisungen an den Assembler.
**Symboltabelle**
wird vom Assembler im ersten Pass erstellt. Sie enthält die absoluten Adressen aller LABELs.
</aside>

# Assembler im Test

> Wer in Maschinensprache programmieren möchte, benötigt einen Assembler. Und da gerade aus dem C 64 mit Maschinensprache sehr viel herausgeholt werden kann, haben wir die interessantesten Assembler für Sie getestet. Sie lassen sich in zwei Preisgruppen einteilen, die unter und die ab 100 Mark. Im ersten Teil ist die obere Preisgruppe mit AS-64, MAE, T.EX.AS und ASSI/M an der Reihe.

Mit dem AS-64 von Roßmöller erhält man nicht nur einen Assembler, sondern ein ganzes Assemblerpaket: Eine EPROM-Karte enthält in 16 KByte den Editor, den Assembler und einen einfachen Monitor. Dazu gibt es eine Diskette mit weiteren Hilfsprogrammen: Einen Re-Assembler, einen Monitor mit Disk-Monitor und einen Demo-Quelltext. Damit gehört AS-64 sowohl vom Umfang, allerdings auch vom Preis her zu den »besseren« Assemblersystemen für den C 64.

### Fast ein Textsystem: Der Editor

Der Text wird so editiert wie man es von Textprogrammen her gewöhnt ist: Man schreibt einfach drauflos. Eine (abschaltbare) Tabulatorfunktion sorgt dafür, daß der Text schon beim Schreiben formatiert ausgegeben wird, das heißt Labels stehen am Anfang der Zeile, die Befehle beginnen in Spalte 12. Die zur Formatierung notwendigen Leerzeichen werden allerdings nicht mit abgespeichert, sondern nur bei der Ausgabe auf Bildschirm oder Drucker eingefügt. Dies spart natürlich enorm Speicherplatz. Änderungen erfolgen durch einfaches Überschreiben des alten Textes.

## AS-64: auf Modul und Diskette

Ansonsten gibt es alles, was man von Textverarbeitungenherkennt: »Cursor up« und »Cursor down« ermöglichen zeilenweises, »Home« und Fl seitenweises »Blättern« vorwärts und rückwärts. Mit »SHIFT Home« gelangt man an den Anfang des Textes, mit F2 ans Ende. Mit F3 wird eine ganze Zeile eingefügt, mit F4 gelöscht. Die Tasten F7 und F8 erfüllen eine Spezialfunktion für Labels. Mit F7 werden sechs Leerzeichen eingefügt, mit F8 kann man von der Cursorposition bis zum linken Rand löschen. Damit lassen sich bequem zusätzliche Labels einbauen oder löschen. Wie der Assembler ist auch der Editor auf maximale Geschwindigkeit ausgelegt. Der Quelltext wird als Bildschirmcode im Speicher abgelegt, so entfällt eine dauernde Umrechnung in ASCII. Die damit erreichte Geschwindigkeit ist enorm. 30 KByte, das entspricht zirka 35 A4 Seiten Quelltext, kann man mit Fl in weniger als 10 (!) Sekunden durchblättern. Ich kenne kein Textsystem, mit dem das möglich wäre.

Natürlich hat dies seinen Preis: Schreibt man bei einer Änderung nämlich über ein Zeilenende hinaus, ohne vorher mit »Insert« die erforderliche Anzahl Leerzeichen einzufügen, springt der Editor in die nächste Zeile und überschreibt den dort stehenden Text. Eingewöhnung ist also nötig. Besser wäre hier eine Art »Insert-Modus«, mit dem man automatisch Text einfügen könnte.

Mit »CTRL-Z« werden Zeilen oder Textteile markiert, die anschließend verschoben, kopiert, gedruckt oder gelöscht werden können. Mit »CTRL-\*« lassen sie sich auch auf Kassette oder Floppy abspeichern, nützlich, wenn man sich eine Bibliothek häufig benutzter Unterprogramme anlegen will.

Alle weiteren Editorkommandos entsprechen den Funktionen komfortabler Textsysteme. Neben einem »FIND«-Modus, der beliebige Zeichenketten sucht, gibt es eine »EDIT«-Funktion. Damit lassen sich ganze Worte durch andere ersetzen (zum Beispiel Label durch *Label, wenn man ein Label nachträglich in die Zeropage verlegen möchte.) Auch hier ist auf extreme Geschwindigkeit geachtet worden.

Besondere Erwähnung verdient auch der Umgang mit Peripherie-Geräten: Ein am User-Port angeschlossener Drucker wird automatisch erkannt und über eine eingebaute Centronics-Schnittstelle angesprochen. Commodore-Drucker werden wie üblich über die serielle Schnittstelle versorgt.

Als externe Speicher können Floppy oder Datasette angeschlossen werden. Beim Umgang mit der Floppy steht selbstverständlich eine Directory-Funktion zur Verfügung, ebenso können Kommandos an die Floppy ausgegeben werden. Eine Spezialität ist das »Backup«: Damit wird auf der Diskette eine Sicherheitskopie des letzten Textes erzeugt und gleichzeitig der neue gespeichert. So hat man immer die beiden (!) letzten Versionen zur Verfügung.

### Der Assembler

Er kann erst einmal alles, was man von einem guten Assembler erwartet: Labels mit maximal elf Zeichen werden verarbeitet, Operand-Eingaben können dezimal, hexadezimal, binär und auch als ASCII-Zeichen erfolgen. Allerdings muß die Zeropage-Adressierung dem Assembler mit einem »\*« vor der Adresse angezeigt werden, sonst wird sie als absolute Adressierung, also als 3-Byte-Befehl, assembliert.

Daneben gibt es eine Reihe von Pseudo-Opcodes, die Anweisungen an den Assembler enthalten. So kann man zum Beispiel »auf Probe« assemblieren, ohne den erzeugten Maschinencode (Objektcode) gleich in den Speicher zu schreiben. Man ist dadurch zumindest vor Syntax-Fehlern sicher und überschreibt nicht aus Versehen den Quelltext. Mit .LS und .LC können beliebige Teile des Programms während der Assemblierung auf Bildschirm oder Drucker aufgelistet werden. Ein besonders bequemes Kommando: Die .BY-Anweisung gestattet nicht nur die Eingabe von einzelnen Bytes — etwa einer Tabelle —, sondern vor allem auch die bequeme Eingabe von Texten. Diese werden einfach als Buchstabenfolgen abgelegt und beim Assemblieren in die zugehörigen ASCII-Werte umgerechnet. Damit entfällt das lästige Wälzen von ASCII-Tabellen.

Weitere Pseudo-Opcodes unterstützen dies: So ist es möglich, bei der Assemblierung bestimmte Teile des Quelltextes zu überspringen (bedingte Assemblierung). Man kann damit ein und dasselbe Quellprogramm für verschiedene Rechnertypen benutzen. Bei der Adreßeingabe sind nicht nur Labels, sondern auch noch umfangreiche Rechenoperationen gestattet. Es stehen die vier Grundrechenarten sowie logische Verknüpfungen (AND, OR, EOR) zur Verfügung. Damit läßt sich ein Quelltext sehr flexibel halten, nur wenige Adressen müssen fest vorgegeben werden, der Assembler selbst rechnet den Rest aus und paßt ihn automatisch an. Im Normalfall genügt dann die Änderung der Programmstartadresse (.BA) und das Programm läuft in einem anderen Speicherbereich. Alle bisher genannten Funktionen sind auch schon früher in guten Assemblersystemen vorhanden gewesen. Auch die Syntax der Befehle dürfte jedem, der mit einem MAE, ASTEX oder ähnlichen Assembler für den 6502 bereits gearbeitet hat, geläufig sein. Zwei Merkmale aber sind es, die AS-64 herausheben: Das eine und zweifellos wichtigste ist die fast unglaubliche Geschwindigkeit. Zwei Beispiele:

Einen 14 KByte langen Quelltext (Super Copy) assembliert AS-64 in fünf (!) Sekunden. Der bisher schnellste mir bekannte Assembler (MAE) braucht dafür immerhin 65 Sekunden. Aus einem 29 KByte langen Quelltext macht AS-64 in 11 Sekunden zirka 5 KByte Objektcode.

Erhöhter Zeitbedarf ergibt sich nur dann, wenn die Quelltexte länger als 30 KByte werden. Dann müssen nämlich Teile von Diskette nachgeladen werden. Auch diese Art der Assemblierung unterstützt AS-64: Wird ein Quelltext nicht mit ».EN«, sondern mit »CT "name’« abgeschlossen, wird automatisch das Quelltextteil »name« von Diskette geholt und assembliert. Damit ist die Verarbeitung von beliebig langen Maschinenprogrammen möglich. Allerdings dürfte das nur in den seltensten Fällen nötig sein. Durch geschickte Speicherverwaltung sind bei AS-64 nämlich Quelltexte bis zu 30 KByte Länge möglich. Beim Assemblieren wird der Editor abgeschaltet, so daß im darunterliegenden RAM die Labeltabelle angelegt werden kann. Der erzeugte Objectcode kann mit dem Pseudo-Opcode ».MC« zum Beispiel nach $E000 unter das Betriebssystem gelegt und von dort später mit einer Spezialfunktion des Monitors wieder an die richtige Adresse verschoben werden. Dies ist das zweite große Plus von AS-64.

Fehlermeldungen bei der Assemblierung werden übrigens im Klartext und auf Deutsch ausgegeben (Sprung zu weit, Label doppelt etc.). Der Assembler stoppt dann die weitere Assemblierung. Allerdings erhält man keinen Hinweis darauf, an welcher Stelle im Quelltext der Fehler aufgetreten ist, vielmehr ist man auf die »FIND«-Funktion des Editors angewiesen. Angenehmer wäre es, wenn bei einem Fehler automatisch der Editor angesprungen und die fehlerhafte Zeile markiert würde.

Apropos Programmabsturz: Mir ist es noch nie gelungen, auch nur das kleinste Maschinenprogramm auf Anhieb so zu schreiben, daß es sich nicht beim ersten Probelauf »verabschiedet«. Bisher zog das eine recht umständliche Prozedur nach sich. RESET drücken, Assembler neu laden, Quelltext neu laden, neu probieren. Mit AS-64 sieht das anders aus. Da sich das Programm im EPROM befindet, kann man es auch bei noch so »geschickter« Programmierung nicht zerlegen. Nach RESET befinde ich mich wieder im Anfangs-Menü und kann einen »Softstart« durchführen. In den meisten Fällen ist dann der Quelltext sogar noch vorhanden, und es kann sofort weitergehen.

### Der Monitor

Ein kleiner Monitor ist direkt ins System integriert. Seine Funktionen erlauben Disassemblieren und Verschieben des Objektcodes sowie das Laden und Abspeichern fertiger Programme. Braucht man mehr, zum Beispiel Such-Funktionen oder einen Trace-Modus, muß man den »großen« Monitor von Diskette laden. Ebenfalls auf der Diskette befindet sich ein Re-Assembler, mit dem man fertige Maschinenprogramme wieder in editierfähigen Quelltext zurückverwandeln kann. Auch Labels werden wieder gesetzt, aber natürlich nicht mit sinnvollen Namen versehen. Mit dem Re-Assembler kann der Anwender nach Belieben Maschinenprogramme seinen eigenen Wünschen anpassen, was bisher nur bei Basic-Programmen möglich erschien.

Makros sind aus Speicherplatzgründen nicht im EPROM untergebracht, sondern müssen ebenfalls bei Bedarf von Diskette geladen werden. Mir lag dieser Programmteil leider noch nicht vor, er soll aber bei Erscheinen dieser Ausgabe vorhanden sein. Außerdem kündigt der Hersteller an, daß eine erweiterte Version (mit 32 KByte EPROM) geplant ist, in der dann auch Makros und ein leistungsfähiger Monitor integriert sein werden. Der Besitzer von AS-64 kann später seine Version aufrüsten lassen.

### Fazit

AS-64 ist ein sehr guter Assembler. Zwar gibt es noch Schwachpunkte (Zeropage-Adressierung, Fehlerquelle schlecht zu finden, kein Insert-Modus), aber das sollte noch zu beheben sein. Auf die noch fehlenden Makros wurde bereits hingewiesen.

Auch die mitgelieferte »Dokumentation« (10 Seiten, DIN A5) ist ein Schwachpunkt. Es wird vorausgesetzt, daß der Benutzer schon Erfahrungen mit vergleichbaren Assemblern besitzt und sie bedienen kann. Ein Anfänger wird völlig alleine gelassen.

Noch ein Wort zum Service: Der Hersteller bietet an, daß man »gegen Einsendung des Moduls mit einem frankierten Rückumschlag kostenlos (!) die aktuellste Version von AS-64 abrufen« kann. Leider ist solcher Service in der Branche noch lange nicht selbstverständlich.

In puncto Geschwindigkeit und Bequemlichkeit beim Assemblieren bleiben kaum Wünsche offen. Setzt man die Kosten (295 Mark) zur Leistung ins Verhältnis, schneidet AS-64 immer noch sehr gut ab. Immerhin erhält man Hardware im Werte von zirka 100 Mark. Das eigentliche Programmpaket ist mit knapp 200 Mark seinen Preis wert. Natürlich gibt es billigere Systeme, kaum aber preiswertere.

(D. Weineck/gk)

Bezugsquelle:
Roßmöller GmbH, Finkenweg 1,
5309 Meckenheim

## MAE — ein bewährter Oldtimer

Schon 1978 konnte man den MAE von SM-Software für die damaligen Commodore-Computer kaufen. Seit einiger Zeit ist auch eine C 64 Version auf Diskette erhältlich.

MAE ist eine Abkürzung für Makro-Assembler/Editor. Wie der Name schon sagt, wird ein spezielles Editor-Programm zum Erstellen des Quelltextes benötigt. Dieser Editor arbeitet ähnlich dem Basic-Editor. Es müssen einzelne Zeilen eingegeben werden, die jeweils eine vierstellige Zeilennummer tragen. Diese Zeilennummern bestimmen dann die Reihenfolge der einzelnen Anweisungen.

Natürlich gibt es hier gegenüber dem normalen Basic-Editor erweiterte Möglichkeiten. So ist beispielsweise der Speicherbereich, in dem sich der Quelltext befindet, beliebig vom Benutzer festlegbar. Dies gilt ebenso für den Speicherbereich der Symboltabelle.

Ein eingegebener Quelltext läßt sich beliebig im Quelltextspeicher verschieben, um nachträglich die Reihenfolge von Zeilen zu ändern. Die Zeilennummern können auch, ähnlich einem Renumber, verändert, oder bei der Eingabe automatisch erzeugt werden.

Sehr komfortabel ist hier der Such- und Ersetzbefehl gehalten. Er ermöglichst nicht nur die Angabe von Zeilenbereichen, in denen gesucht werden soll, sondern es kann auch mit Jokerzeichen gesucht werden. Jede gefundene Zeile kann gelistet und dann auf Wunsch verändert oder gelöscht werden.

Die Symboltabelle kann jederzeit aufgelistet, leider aber nicht gespeichert oder geladen werden. Das Floppy-Laufwerk wird mit einigen Befehlen unterstützt, Kassettenbetrieb ist nicht vorgesehen.

Vom Editor kann auch ein Listing des gesamten Quelltextes oder einzelner Zeilennummernbereiche zu einem Drucker gesandt werden.

Der Quelltext kann jederzeit über einen weiteren Befehl formatiert werden. Dabei werden Labels, Opcodes und Kommentare in schön lesbarer Form ausgegeben. Gleichzeitig ist die maximale Länge eines Labels einstellbar.

### Assembler-Grundfunktionen

Der eigentliche Assembler arbeitet wahlweise in zwei oder drei Durchgängen (Passes). Im dritten Pass wird ein relatives Lademodul erzeugt, auf das ich noch zu sprechen kommen werde.

Labels können beim MAE maximal 31 Zeichen lang sein. Dies dürfte wohl eindeutige Labelbezeichnungen auch bei sehr langen Programmen ermöglichen. Leider sind die Rechenmöglichkeiten im Quelltext stark eingeschränkt: Es stehen nur Addition und Subtraktion zur Verfügung.

Dem Programmierer steht eine große Zahl von Pseudo-Opcodes zur Verfügung, darunter auch einige, die den Ausdruck eines formatierten Assemblerlistings in Pass 2 steuern. Labels können entweder im Quelltext selbst vor der ihr zugeteilten Anweisung stehen, es ist allerdings auch möglich, Label als intern und extern durch einfache Ausdrücke zu definieren. Externe Label bezeichnen normalerweise Adressen außerhalb, interne Adressen innerhalb des Objektcodes.

Besonders komfortabel ist, daß Labelwerte auch während des ersten Passes eingegeben werden können, so daß man einen Quelltext durch solche Eingaben für verschiedene Speicherbereiche oder Computer nutzen kann.

Auch eine bedingte Assemblierung ist implementiert. Bedingte Assemblierung bedeutet nichts anderes, als daß ein Quelltextblock nur unter bestimmten Bedingungen assembliert wird. Somit ist es leicht, den Objektcode während des Assembliervorganges an bestimmte Spezifikationen anzupassen.

Ein Quelltext kann auch auf seine Syntax getestet werden, während des Assembliervorgangs wird der Objektcode dann nicht gespeichert. Genauso gut ist es möglich, den Objektcode direkt auf Diskette zu leiten, so daß er keinerlei Speicherplatz im Computer benötigt.

### Oas Modulkonzept

Der MAE geht beim Assemblieren längerer Quelltexte anders vor, als andere Assembler. Wollen Sie einen Quelltext, der länger als der Arbeitsspeicher ist, assemblieren, so können Sie ihn nicht, wie üblich, in mehrere Teile teilen, die sich nacheinander aufrufen. Beim MAE müssen Sie ein Kontroll-Modul definieren, das stets im Speicher vorhanden ist. Dieses lädt dann nacheinander die Quelltextteile in den Speicher und assembliert diese. Das Kontrollmodul besteht ebenfalls aus ganz normalem Quelltext, sollte jedoch zweckmäßigerweise nur die Aufrufe der einzelnen Quelltextteile beinhalten. Dieses Modulkonzept hat den Vorteil, daß Sie einen in mehreren Programmen benötigten Quelltext nur einmal schreiben müssen und dann jedesmal über das Kontrollmodul abrufen können.

### Makros

Wichtig bei einem Makroassembler ist natürlich die Makro-Behandlung. Makros dürfen beim MAE beliebig viele Übergabeparameter haben, die dann in die Makrosequenz eingesetzt werden. Auch makrointerne Label sind möglich. Diese müssen mit drei Punkten gekennzeichnet sein. An deren Stelle setzt der MAE beim Assemblieren dann eine Nummer, die von Aufruf zu Aufruf wechselt. So kann es nicht zu einem Fehler aufgrund doppelter Makros kommen. Makros dürfen hier bis zu 32mal ineinander verschachtelt werden.

Sollten Sie einige Makros in großen Programmen ständig benötigen, so müssen Sie ein globales Makro-Modul aufbauen. Dieses steht dann, ähnlich dem Kontrollmodul, ständig im Speicher, so daß jeder Teil des Quelltextes auf das Makro zugreifen kann.

### Relative Lademodule

Eine sehr nützliche Einrichtung ist der mitgelieferte Relativlader. Möchte ich einen Quelltext in einem Bereich erzeugen, der schon anderweitig belegt ist, kann ich ihn in einen anderen Speicherbereich assemblieren und dann den dritten Durchlauf starten, der ein relatives Lademodul auf Diskette erzeugt. Dieses Modul kann dann mit einem zusätzlichen Programm, dem Relativlader, an jede beliebige Stelle im Speicher geladen werden. Dabei sind die Speicherbereiche für Programm und Daten frei wählbar. Danach steht das Programm ablauffähig im Speicher und kann absolut gespeichert werden. Der Speichervorgang wird aber vom MAE nicht unterstützt. Dieser Relativlader wird sowohl ablauffähig, als auch selber als relatives Lademodul mitgeliefert. Damit kann der Relativlader an jeder beliebigen Stelle im Speicher stehen. Mit dem MAE ist es nicht möglich, Objektcode direkt zur Diskette zu leiten. Will man längere Objektcodes, die man im Speicher nicht mehr unterbringen kann, erzeugen, muß man einen sehr unkonventionellen Weg gehen. Sie müssen sich Schnittstellen zwischen den einzelnen Programmen definieren, das sind Adressen, über die Daten ausgetauscht werden. Zwei zu verbindende Teilprogramme werden dann durch zweimaligen Aufruf des Relativladers zusammengebunden.

### Dokumentation und Sonstiges

Das mitgelieferte Handbuch ist sehr unübersichtlich und unklar. Möchte man zum Beispiel Informationen über den Relativlader haben, stellt man fest, daß dieser an drei verschiedenen Stellen im Handbuch erklärt wird, so daß man ständig vor- und zurückblättern muß. Ebenso verhält es sich mit fast allen Themenbereichen. Das Handbuch einmal in Ruhe durchzulesen ist deswegen kaum möglich.

Schade finde ich es auch, daß bei Fehlermeldungen immer nur Codezahlen und keine Klartexte erscheinen.

Teilweise ist die Bedienung etwas umständlich geraten. Anfängern wird es wohl schwerfallen, sich mit MAE zurechtzufinden, insbesondere mit Blick auf das Handbuch. Aber MAE soll ja schließlich ein Handwerkszeug für professionelle Programmierer sein. Die werden allerdings einige Möglichkeiten anderer Assembler vermissen. Insbesondere stört da die Tatsache, daß man sich zusätzlich zum MAE (Kostenpunkt zirka 140 Mark) noch einen guten Monitor zulegen muß, da man in der Testphase vom MAE allein gelassen wird.

(Boris Schneider/gk)

Bezugsquelle:
SM Software AG, Scherbaumstr. 33, 8000 München 83

## T.EX.AS. — mit guter Dokumentation

Ein weiteres Produkt der »Extended« Serie von Interface Age ist der Terminal Extended Assembler, kurz T.EX.AS.

Der T.EX.AS. erfüllt mit einem Programm gleich mehrere Funktionen. Es ist sowohl ein Monitor, ein Direktassembler, ein Reassembler wie natürlich auch ein Makroassembler.

Ein Editorprogramm ist nicht enthalten. Bei T.EX.AS. müssen Quelltexte über den Basic-Editor eingegeben werden. Interface Age schlägt zwar vor, Exbasic Level II zur komfortablen Quelltexteingabe zu verwenden, dies würde aber den Kaufpreis (298 Mark für T.EX.AS.) mehr als verdoppeln und diesen damit wohl über die Kaufkraft vieler Privatanwender stellen.

### Der Assembler

In diesem Assembler dürfen Labels biszu 16Zeichenhaben. Berechnungen sind leider nur auf Addition und Subtraktion beschränkt, was ein nicht unwesentliches Manko dieses Assemblers ist.

Auch ansonsten ist T.EX.AS. nicht gerade mit Pseudo-Opcodes gesegnet. Weder ist eine bedingte Assemblierung vorhanden, noch können Labels umdefiniert werden, was bei Assemblern dieser Preisklasse Standard sein sollte.

Symboltabelle und Quelltext können im zweiten Pass ausgedruckt werden. Der Quelltext wird dabei aber weder formatiert, noch sonst irgendwie verändert, so daß Sie ihn einfacher von Basic aus listen können. Es ist allerdings möglich, den erzeugten Objektcode direkt auf Diskette abzulegen, oder ihn gar nicht auszugeben; dann wird nur die Syntax des Quelltextes überprüft.

Das Einbinden schon geschriebener Quelltextteile ist sehr einfach gelöst. Wird ein solcher Teil benötigt, kann er während des Assembliervorganges nachgeladen und eingefügt werden. Auch hier ist eine modulartige Programmierung wie beim MAE denkbar.

### Makros

Auch bei den Makros hapert es ein wenig. Es ist zwar eine beliebige Verschachtelung von Makros erlaubt, (bis auf Selbstaufrufe), aber es gibt keine Möglichkeit, in einem Makro lokale Label zu definieren, ohne sie nicht als Parameter zu übergeben. Also schon eine einfache Schleife in einem Makro, die über einen Labelsprung erfolgen soll, ist äußerst kompliziert und unübersichtlich zu programmieren. Jedes Makro mit internen Labeln dürfte nur einmal aufgerufen werden, soll kem LABEL DECLARED TWICE-Fehler auftreten. In diesen Fällen sollte man bei T.EX.AS. lieber auf Makros verzichten. Dafür ist der Aufbau einer Makrobibliothek sehr einfach, weiljedes Makro als Einzelfile auf der Diskette stehen und bei Bedarf aufgerufen werden kann.

### Monitorähnliche Funktionen

In diesem Bereich zeigt T.EX.AS. seine Stärken, da es sich nicht um einen starren Monitor, sondern um eine Art Editiersystem für Objektcode (nicht Quelltext) handelt. Insbesondere die Analyse fremder Programme wird extrem erleichtert.

Als allererstes fällt auf, daß der Bildschirm in zwei Fenster, links und rechts, aufgeteilt ist. Den Cursor kann man mit der Control-Taste vom einen ins andere Fenster springen lassen. Dieses Fensterkonzept ist eine nicht zu unterschätzende Hilfe bei der Programmanalyse. Was machen Sie normalerweise, wenn Sie beim Disassemblieren eines Programmes den Sprung JSR$3000 entdecken? Sie müßten nachschauen, was dort abläuft, um dann später die Stelle mit dem Sprungbefehl wiederzufinden. Beim Disassemblieren mit T.EX.AS. genügt ein Druck auf F6, und schon wird im anderen Bildschirmfenster ab $3000 disassembliert, während im ersten der Programmteil, den Sie gerade untersuchen, stehenbleibt.

Natürlich lassen sich die zwei Fenster auch anders nutzen, zum Beispiel Hexdump im einen und ASCII-Dump im anderen Fenster oder ähnliches.

Selbstverständlich kann in beiden Fenstern unabhängig nach oben und unten gescrollt werden. Aber was bietet T.EX.AS. denn außer diesen Fenstern? Den schon angeführten Dump-Möglichkeiten muß noch die des Adressen-Dumps angefügt werden. Alle Dumps können auch zum Drucker hin erfolgen. Hier wird die Workspace-Konzeption notwendig. Für die meisten Befehle lassen sich Arbeitsbereiche angeben, die in einer Tabelle zwischengespeichert werden. Soll zum Beispiel mehrmals ein bestimmter Bereich disassembliert werden, reicht eine einmalige Definition. Bei anderen Befehlen ist diese Bereichsfestlegung allerdings sinnvoller, zum Beispiel beim Speichern von Bereichen auf Disk. Wenn Sie kurz hintereinander öfters denselben Bereich speichern wollen, weil Sie ihn gerade bearbeiten, müssen die entsprechenden Adressen nicht jedesmal angegeben werden.

Zusätzlich zum Makroassembler ist auch ein Direktassembler vorhanden. Dieser ist insbesondere in der Testphase nützlich. Er kann auch in beschränktem Maße mit Labels arbeiten.

T.EX.AS arbeitet üblicherweise im Dezimalsystem, da man der Meinung war, daß dies einfacher für den Benutzer sei. Unverbesserliche können natürlich auch alle Ein- und Ausgaben ins Hexadezimale umschalten.

Zwei noch erwähnenswerte Kommandos sind der Verschiebe- und der Suchbefehl. Zusätzlich zum normalen Verschieben von Speicherblöcken können Programme einfach an neue Adressen angepaßt werden.

Der Suchbefehl läßt kaum Wünsche offen. Es ist zum Beispiel möglich, im Objektcode alle Befehle zu suchen, die etwas in den Bereich von $3459 bis $7777 schreiben, sich alle indirekten Sprünge heraussuchen lassen, und so weiter. Beim Suchen von Kommandos kann der Suchbereich und der Bereich, auf den sich die gesuchten Befehle beziehen, angegeben werden. Außerdem sind Joker für den Befehlscode, das Argument und die Adressierungsart möglich. Leider ist diese Suchroutine nicht auch für den Quelltext verfügbar.

Dem Benutzer stehen zehn adreßdefinierbare Breakpoints zur Verfügung, bei deren Erreichen ein T.EX.AS. Warmstart durchgeführt wird. Dadurch können einzelne Informationen (Akkuinhalt und ähnliches) verlorengehen.

Nur kurz angesprochen werden soll hier der Reassembler, der aus Objektcode wieder Quellcode machen soll. Dieser Programmteil ist mit absoluter Vorsicht zu genießen. Mir ist T.EX.AS. zweimal abgestürzt, als er einen OUT OF MEMORY ERROR gab. Außerdem ist dieser Reassembler außerst unpraktisch. Eine Redefinition von Labels ist nicht vorgesehen.

Trifft der Reassembler auf einen nicht als Opcode definierten Wert, so wird im Quelltext nicht etwa das entsprechende Byte, sondern einfach zwei Fragezeichen ausgegeben. All diese kleinen Macken machen den Reassembler praktisch nutzlos.

### Dokumentation

T.EX.AS. ist der wohl einzige Assembler, der auch mit einem, auf ihn abgestimmten, Assemblerlehrbuch ausgeliefert wird. Es ist ziemlich ausführlich und fängt wirklich bei Null an. Auch die Anleitung selbst ist nicht schlecht. An manchen Stellen, die Anfängern Schwierigrkeiten bereiten könnten, wird auf die entsprechenden Kapitel im anderen Buch verwiesen. Wenn ich ein ehrliches Fazit ziehen soll, muß ich sagen, daß T.EX.AS zu teuer ist. Mit 298 Mark ist T.EX.AS. zwar ein gutes Lehrsystem, aber professionelle Programmierer, und solche die es werden wollen, werden bei T.EX.AS. einiges vermissen. (Boris Schneider/gk) Bezugsquelle:

Interface Age Verlag GmbH, Vohburgerstr. 1, 8000 München 21, Preis: 298 Mark

## ASSI/M

Mit allen Wassern gewaschen ist der ASSI von D. Zabel.

ASSI/M ist ein ganzes Programmpaket, bestehend aus einem Editor (FSE), dem Assembler (ASM) und einem Monitor (DEMON). Alle drei Programme werden gemeinsam auf einer Diskette geliefert. Es gibt auch eine Version die alle drei Programme vereinigt, dafür aber enorm viel Speicherbedarf hat. Durch die konsequente Aufteilung in Editor, Assembler und Monitor konnte jedes einzelne Programm sehr umfangreich geschrieben werden, ohne daß bei ASSI weniger freier Speicherplatz als bei anderen Assemblern zur Verfügung steht.

### Der Editor (FSE)

FSE steht für Full-Screen-Editor, er arbeitet also bildschirmorientiert und ohne Zeilennummern. Aufgrund seines umfangreichen Befehlssatzes gleicht er schon fast einem Textverarbeitungsprogramm. Die vorhandenen Befehle sind jedoch immer am Ziel orientiert, Programme perfekt schreiben und editieren zu können.

Fast der ganze Bildschirm steht zur Eingabe des Quelltextes zur Verfügung. Unten wird er durch eine Statuszeile begrenzt, die stets die Position des Cursors, den Arbeitsmodus und den noch freien Speicherplatz angibt. Nach oben und unten kann mit sehr hoher Geschwindigkeit gescrollt werden. Angefangen beim einfachen Löschen und Einfügen von Buchstaben, Wörtern, Zeilen und ganzen Textteilen, reicht der Befehlssatz über freisetzbare Tabulatoren bis hin zum komfortablen Such- und Ersetzbefehl. Man kann die Suche auf bestimmte Zeilen oder Spalten beschränken, Groß- und Kleinschreibung ignorieren, und Joker beim Suchen und beim Ersetzen (!) angeben.

Der FSE merkt sich automatisch die Stelle, an der die letzte Veränderung im Text vorgenommen wurde. So können Sie schnell mal etwas nachschauen und später mit einem Tastendruck zum Ausgangspunkt zurückkehren. Daß Diskette, Kassette und Drucker voll unterstützt werden, ist da schon fast selbstverständlich. Die Funktionstasten sind belegt, es gibt vom Benutzer frei definierbare Tasten und, und, und...

Es würde den Rahmen dieses Tests sprengen, alle Möglichkeiten, die der FSE bietet, aufzuzählen.

### Der Assembler (ASM)

Der leistungsfähige Editor läßt natürlich auf einen ebenso leistungsfähigen Assembler hoffen. Und diese Hoffnungen werden vom ASM voll erfüllt.

Der Quelltext wird entweder von Kassette oder Diskette während des Assemblierens gelesen. Bei Kassettenbetrieb muß deswegen mindestens einmal zurückgespult werden. Dadurch ist allerdings auch eine ziemlich lange Assemblierzeit bedingt. Dafür ist wiederum sehr viel Speicher für den Objektcode und die Symboltabelle verfügbar.

Labels dürfen bis zu 250 Zeichen lang sein. Außerdem gibt es eine Vielzahl von Rechenfunktionen: Alle vier Grundrechenarten, Bitschiebeoperationen, logische Funktionen (AND, OR,XOR,NOT) und logische Vergleiche dürfen beliebig miteinander kombiniert werden. Die Hierarchie wird durch Klammern festgelegt. Angenommen werden Zahlen im Hexadezimal-, Dezimal, Oktal-, und Binärformat sowie ASCII-Zeichen.

Als besonders großer Vorzug muß hier das Block-Konzept erwähnt werden. Teile des Quelltextes können jederzeit als Block definiert werden, und alle in ihnen definierten Labels sind dann lokal. Zum Beispiel können zwei verschiedene Programmteile das Label LOOP verwenden, wenn die eine Sequenz als Block definiert wurde und dort die eine Definition von LOOP erfolgte. Somit kann man jederzeit Quelltext aus anderen Programmen übernehmen und braucht sich keine Sorgen um etwaige doppelt definierte Label zu machen. Auch der Aufbau einer Unterprogrammbibliothek ist kein Problem. Denn neben dem einfachen Verketten von Quelltextfiles, kann man Unterprogramme, die auf Diskette vorhanden sind, mit einem Pseudo-Opcode einbinden. Sie werden dann zur Assemblierung nachgeladen. Die Ausgabe von Listings während des zweiten Pass verläuft hier ähnlich wie bei anderen Assemblern, wahlweise auf Drucker, Bildschirm, Floppy oder mehreren Ausgabegeräten gleichzeitig. Der Objektcode kann entweder beliebig im Speicher plaziert, oder aber auch direkt auf Diskette geschrieben werden.

Natürlich ist auch ein bedingter Assembliermodus vorhanden. Ebenso können beim ASSI Eingaben von Labels während des ersten Pass gemacht werden.

### Makros

Der ASM beherrscht natürlich auch Makros. Bei allen Makroaufrufen wird automatisch ein Block um das Makro herum gelegt. So sind die in einem Makro definierten Parameter wieder lokal, das heißt unabhängig von Parametern anderer Programmteile universell verwendbar. Makros dürfen andere Makros oder auch sich selbst aufrufen; letzteres ist jedoch nur bei bedingter Assemblierung sinnvoll, da sonst der Speicher überläuft. Eine Besonderheit ergibt sich noch bei den Übergabeparametern. Neben normalen Ausdrücken können auch Strings oder Befehle übergeben werden, die dann in das Makro eingebaut werden.

Und weil die Definition von Makro-Bibliotheken genauso einfach geht, wie die schon oben erwähnte von Unterprogrammen, werden zwei Makrobibliotheken mitgeliefert. Die eine enthält 17 Makros, die hauptsächlich der 16-Bit-Arithmetik dienen, sowie einen User-Stack definieren, auf dem, ähnlich dem normalen Stack, Daten nach dem First in/Last out Prinzip gespeichert werden können.

Die andere ist fast schon sensationell zu nennen, denn sie ermöglicht strukturierte Assemblerprogrammierung. Es stehen dann Befehle wie IF..THEN..ELSE..,REPEAT..EXIT, REPEAT. UNTIL und ähnliches in Assembler zur Verfügung. Da diese Bibliotheken jederzeit erweitert werden können, bilden sie einen idealen Grundstock für jeden Assemblerprogrammierer.

### Der Monitor (DEMON)

Und auch das dritte Programm fügt sich nahtlos in das System ein. DEMON ist ein sehr komfortabler Maschinensprachemonitor. Er ist ideal zum Austesten von Programmen geeignet. Schwerpunkte sind die hervorragende Breakpointbehandlung und die Trace-Modi.

Beim Austesten eines Programmes können bis zu fünf normale Breakpoints gesetzt werden. Gelangt der Programmcounter an einen Breakpoint, so wird automatisch in den Einzelschrittmodus des DEMON gesprungen, wo Sie sich den weiteren Verlauf des Programms Schritt für Schritt anschauen können. Zusätzlich ist ein User-Breakpoint definierbar. Sie stellen zum Beispiel den Fehler fest, daß Ihr Programm bestimmte Speicherstellen überschreibt, die wichtig sind. Nun schreiben Sie ein kleines User-Breakpointprogramm, das nach Abarbeitung jedes Befehls angesprungen wird und diese Speicherstellen überwacht. So können Sie in wenigen Minuten Fehler ausfindig machen, an denen Sie sonst Stunden herumknobeln würden. Auch ganz verrückte Abfragen wie: »Wann ist die Summe von X und Y Register kleiner als $93 ?«sind als Userbreakpoint realisierbar. Schon kurz angesprochen wurde der Einzelschrittmodus. Außer dem normalen Abarbeiten und Anzeigen jedes Befehls ist es möglich, Sprünge, die über eine bestimmte Adresse hinaus gehen, direkt ausführen zu lassen. Das spart ernorm Zeit, wenn viele ROM-Routinen verwendet werden.

Natürlich sind sämtliche Monitor-Standardfunktionen wie Hex-Dumps, Disassemblieren, Suchen von Bytes und Zeichenketten, Laden und Speichern, Vergleichen und Verschieben von Speicherbereichen (auch mit Adreßangleichung bei Programmen), ein Mini-Assembler, Registeranzeige etc. integriert.

Außerdem können Rechnungen im hexadezimalen, dezimalen und binären Zahlensystem vorgenommen werden, die fast so komfortabel wie im ASM sind. Ein spezieller Suchbefehl findet alle die Zeropage betreffenden Befehle. Damit können auch die vier von DEMON benötigten Zeropageadressen beliebig verändert werden. Überhaupt ist DEMON im Speicher frei verschieblich, so daß Sie niemals mit einem auszutestenden Programm in Konflikt kommen können.

Alles in allem läßt auch DEMON keine Wünsche offen.

### Dokumentation

Das Handbuch macht auf mich einen sehr guten Eindruck, da alle Befehle in einer vernünftigen Reihenfolge leicht verständlich und mit einigen Beispielen erklärt werden. Einzig beim FSE wird die logische Reihenfolge durch einen Anhang, der die Erweiterungen mancher Funktionen nachträglich beschreibt, durchbrochen. Allerdings werden auch hier Assembler-Kenntnisse vorausgesetzt. Zusätzlich werden zu allen drei Programmen alle wichtigen Einsprungpunkte und Speicher beschreiben, so daß eine Modifikation durch den Benutzer sehr leicht möglich ist. Die Transparenz der drei Programme, gekoppelt mit ihrer Befehlsvielfalt und Nützlichkeit, machen das Programmpaket ASSI (Preis: 220 Mark) zum fast idealen Assembler. Einzig und allein die geringe Arbeitsgeschwindigkeit kann ein Kritikpunkt sein.

(Boris Schneider/gk)

Bezugsquelle:
Dirk Zabel, Stresemannstr. 50, 1000 Berlin 61

# Soft Learning – die weicle Welle des Lernens

> Entspannen und Lernen heißt die Devise bei der Softlearning-Reihe von SM, die auf Erwachsenen-Fortbildung ausgelegt ist. Aber auch ältere Schüler ab den Klassen neun bis zehn, dürften diese Software schon sinnvoll einsetzen können.

Grundlage dieser neuen Lernidee ist die in Bulgarien und der UDSSR entwickelte Suggestopädie. Diese Methode nutzt als wesentliches Element die Wirkungen eines ganz bestimmten Musikhintergrundes und besonderer Sprachtechniken, die im Zusammenhang mit Entspannungsübungen zu einer tiefen Entspannung und gesteigerter Konzentrationsfähigkeit führen.

In den westlichen Ländern wurde diese Methode mit Elementen der Autosuggestion und Yoga verbunden und erweitert. Das Ergebnis dieser Verknüpfung heißt Superlearning, und ist in den USA schon längere Zeit in der Praxis erprobt worden.

## Softlearning

Softlearning baut auf den Erkenntnissen von Superlearning auf, und nutzt zudem die speziellen Eigenschaften des Computers. Die Kosten für diese Kurse sind mit 198 Mark noch erschwinglich.

Die Grundausstattung, die man für diese Lernsoftware benötigt, besteht aus dem Commodore 64, einem Floppy-Laufwerk, einem Audiokassettenrecorder und der »Systemeinheit S«. In ihr ist eine Diskette mit den Programmteilen, die für alle Kurse gleich sind, ein Audio-Adapter und eine Audio-Kassette enthalten. Der Audio-Adapter wird zur Synchronisation zwischen C 64 und Audio-Kassettenrecorder eingesetzt. Die Audio-Kassette der Systembasis S enthält auf der einen Seite Entspannungsübungen, auf der anderen Seite einen Probekurs mit der Plansprache Esperanto.

## Der Englisch-Grundkurs

Der Englisch-Sprachkurs besteht aus einer Kursdiskette, vier Audio-Kassetten und einem Lehrbuch. Das Lehrbuch sollte allerdings nur zum Nachschlagen verwendet werden. Die Kassetten sind sowohl für Stereo- als auch für Mono-Recorder geeignet.

Der Kurs beginnt mit einer Entspannungsübung. Zu einer für das Auge angenehmen Grafik wird barocke Musik gespielt, und durch zwei Stimmen werden Hilfen zur Entspannunggegeben. Schonhierwird die Suggestion angewandt. Die barocken Klänge sollen nach Forschungsergebnissen besonders entspannen. Auch Ohren, die bisher nicht an klassische Musik gewöhnt waren, stellen sich sehr schnell darauf ein. Die zwei Stimmen, eine weibliche und eine männliche, sprechen ihren Text in Deutsch und Englisch. Die Entspannungsübung soll zirka eine Woche lang trainiert werden, bevor man mit dem eigentlichen Kurs beginnt.

An die Entspannungsphase schließt sich ein englischer Textteil an, der vorgelesen wird und auf dem Bildschirm erscheint. Auch hier soll man sich an den Klang der Sprache und an das Schriftbild gewöhnen. Ein Verstehen ist vorerst nicht notwendig. Wie auch bei der Entspannungsübung spielt im Hintergrund ständig Musik. Sobald der Text der ersten Lektion erledigt ist, schließt sich eine zweite Entspannungsphase an. Während dieser Übung werden die unbekannten Vokabeln und ihre Übersetzung geliefert.

Ist dieser Kursteil durchlaufen, schließen sich die Vokabel-Trainingsprogramme an. Das Training beginnt mit einem Multiple-Choice-Test. Dies bedeutet, daß man aus mehreren Übersetzungen eines Wortes die richtige zuordnen soll. Während dieses Tests werden als »Erfolgserlebnis« Punkte vergeben. Maximal werden drei Punkte verteilt. Für jeden Fehlversuch bekommt man einen Pluspunkt weniger. Ist man bei null Punkten angelangt, zeigt der C 64 die richtige Lösung an. Minuspunkte werden nicht vergeben, denn auch hier soll der »Entspannungszustand« nicht durch Leistungsdruck beeinflußt werden. Der nächste Punkt inp>Softlearning-Lehrplan« ist ein Silbenrätsel. Die deutsche Bedeutung von Vokabeln muß aus vorgegebenen Wortbruchstücken zusammengesetzt werden.

Weitere Programmteile sind Lückentextdiktate, die Übersetzung ganzer Sätze, Grammatik-Übungen und »Zettelkasten-Abfrage«. Dabei werden Vokabeln einer Lektion in zufälliger Reihenfolge. abgefragt. Wird eine Vokabel richtig übersetzt, bekommt sie für die interne Verarbeitung eine Markierung. Vokabeln ohne Markierung haben bei der zufälligen Auswahl Priorität, so daß falsch übersetzte Vokabeln nach kurzer Zeit erneut abgefragt werden. Vokabeln die häufig richtig übersetzt worden sind, haben nach diesem Schema soviele Markierungen, daß sie nur sehr selten erneut abgefragt werden. Dieser Aufbau wiederholt sich bei jeder neuen Lektion.

Der Weg, den SM-Software mit dieser neuen Form der Lernsoftware eingeschlagen hat, muß sich in der breiten Anwendung erst noch bewähren. Nach einer kurzen Eingewöhnungszeit kam ich mit diesem System sehr gut zurecht. Besonders gut haben mir die verschiedenen Vokabeltrainingsmöglichkeiten gefallen. Diese Art der Lernprogramme ist in der Erwachsenenfortbildung in Verbindung mit einem Computer sicherlich ein großer Schritt nach vorne. (rg)

Info: SM Software AG, Scherbaumstraße 33, 8000 München 83, 089/6371211

# Basic ist out – es lebe Forth

> Viele sind des Basic überdrüssig geworden. Die Sprache Forth ist eine Afternative. Unsere Einführung in Forth beginnt an einem konkreten Beispiel: der Programmierung des Decompilers.

Vor einiger Zeit erhielt ich ein Programm, das sich nach dem Starten mit »FIG-FORTH« meldete.
Forth, soviel wußte ich schon, soll eine neue, ungewöhnliche Programmiersprache sein. Nichts Genaues weiß ich nicht. Also gebe ich ein: LIST und RUN und PRINT 5\*3 und NEW und ... nichts passierte, außer, daß mein Computer antwortet: »MESS # 0« oder »MESS # 1« oder manchmal auch »OK«. Also erst einmal zur Seite damit ...

Aber diese Sprache läßt mich nicht los — eben weil ich nicht weiß, was ich damit anstellen kann. Bis ein Freund anruft: »Versuch mal VLIST. Ich habe da was gelesen ...« Der Bann ist gebrochen: Nun flitzen plötzlich Worte über den Bildschirm: AND und BASE und BUFFER und CONSTANT und IF und HEX und noch viel mehr, über 200 Worte. Das ist offensichtlich die Befehlsliste von Forth. Und dann bekomme ich die Fotokopie einer Kopie einer Kopie der Kurz-Befehlsbeschreibung eines FIG-Forth-Systems, kaum lesbar, in englisch, aber immerhin. Ich lese die Beschreibung — nein, ich buchstabiere sie beim ersten Mal, zu neu ist das Konzept dieser Sprache. Beim zweiten Lesen fasziniert mich Forth schon; nach dem dritten Lesen steht für mich fest: Basic ist out, Forth ist die Sprache der Zukunft.

Dies war vor etwa einem Jahr. Seitdem ist mir der Aufbau von Forth um einiges klarer geworden. Forth ist, so merkwürdig das klingt, zum großen Teil in Forth geschrieben. Zum Verständnis ist es deshalb wichtig, die Forth-Befehle zu rekonstruieren. Im Computer-Speicher steht aber nicht der Quelltext, sondern das compilierte, also übersetzte Programm. Forth läßt es jedoch zu, den Quelltext aus dem Speicher fast vollständig zu »decompilieren«. Deshalb wird ein interaktiver und einfacher Decompiler vorgestellt, der alle Forth-Worte als Quelltext listet. Das hilft auch bei der Optimierung und der Fehlersuche in eigenen Programmen. Für die folgenden Abschnitte sollte man jetzt seinen Computer einschalten und die — hoffentlich vorhandene — jeweilige Forth-Version laden. Es wird stillschweigend vorausgesetzt, daß man bereits einige erste Tippversuche in Forth hinter sich hat.

## So arbeitet Forth

Forth ist eine Programmiersprache, die sowohl einen Interpreter als auch einen Compiler enthält. Nach dem Start eines Forth-Systems ist der Interpreter eingeschaltet. Er wartet auf »Eingangspost« (Input-Stream), die normalerweise von der Tastaturkommt. DieseEingangspost liest der Interpreter und isoliert daraus das erste »Wort« (WORD), das heißt, eine Zeichenfolge, die durch Leerzeichen begrenzt ist und versucht, dieses Wort auszuführen. Ein solches Wort kann ein Befehl, eine Zahl oder auch eine sinnlose Zeichenkette sein.

Zunächst durchsucht der Interpreter sein »Wörterbuch« (DICTIONARY) nach dem isolierten Wort. Findet er es, so steht in dem zum Wort gehörigen Absatz des Wörterbuches, was zu tun ist. Diese Arbeitsanweisung wird dann von einem Kollegen des Interpreters ausgeführt (EXECUTE). Anschließend kehrt der Interpreter zurück zum Lesen der Eingangspost, isoliert das nächste Wort und blättert wieder im Wörterbuch.

Kann er ein Wort aber nicht finden, so versucht ein anderer Kollege (NUMBER), die Zeichen des Wortes in eine Zahl zu wandeln. Ist das gelungen, so wird die Zahl oben auf den »Stapel« (STACK) gelegt, wo sie für weitere Operationen zur Verfügung steht.

Kann der Interpreter das Wort weder im Wörterbuch finden, noch eine Zahl wandeln, so beschwert er sich mit einer Fehlermeldung, wirft die Zahlen auf dem Stapel und die noch ungelesene Eingangspost weg und wartet auf neue Post von der Tastatur.

Mit diesem interpretierenden Forth könnten wir Programme schreiben, indem wir eine sinnvolle Folge von Befehlen ausführen ließen. Jedoch, jeder Basic-Programmierer weiß, daß Interpretieren, also Lesen des Programmtextes, Nachsehen in einer Befehlsliste und das Wandeln in Zahlen während der Programmausführunglange dauert. Wollen wir schnelle Ausführung haben, so müssen wir unser Programm compilieren.

Im Forth ist der Compiler schon eingebaut. Es gibt einige Worte, deren Ausführung unter anderem darin besteht, den Interpreter aus- und den Compiler einzuschalten. Eins dieser Worte ist der Doppelpunkt»:« (COLON). Es nimmt das nächste Wort aus der Eingangspost und macht daraus den Kopf eines neuen Eintrags im Wörterbuch. Dann wird der Compiler eingeschaltet. Die folgenden Worte der Einganspost werden nun nicht mehr ausgeführt, sondern der Compiler trägt »Zeiger« ins Wörterbuch ein. Diese Zeiger sind 16-Bit-Adressen, also 2 Byte langund heißen Compilationsadressen. Sie weisen auf die entsprechenden Arbeitsanweisungen im Wörterbuch.

Das Eintragen von Zeigern macht der Compiler so lange, bis er wieder ausgeschaltet wird. Auch für diesen Zweck gibt es Worte: »;« schließt Worte ab, die mit»:« angefangen wurden. Es schaltet den Compiler wieder ab und den Interpreter ein. Im Wörterbuch ist jetzt ein neues Wort eingetragen, dessen Arbeitsanweisung aus einer Liste von Zeigern auf andere Worte besteht.

Ein praktisches Beispiel: Wir wollen von zwei Zahlen auf dem Stapel die oberste behalten, die zweite jedoch wegwerfen. Offenbar erfüllt die Befehlsfolge »SWAP DROP« genau diese Forderung, was der Leser bitte selbst prüfen mag. Wir wollen jedoch ein neues Wort NIP einführen, das unsere Forderung erfüllt:
: NIP (N1 N2 - N2) SWAP DROP;

Wir drücken RETURN, und Forth meldet sich nach dem Compilieren mit »OK«. Nun sehen wir uns an, was der Compiler aus diesem »Kurzbrief« gemacht hat. Dazu dumpen wir den Speicherinhalt mit der Befehlsfolge:
CR HEX ’ NIP NFA 0E DUMP
und erhalten das folgende Listing:
83 4E 49 D0 37 58 3F 10 . NIP7X? .
86 F 7D F 33 E 4 44 . . . . 3 . . D

Das sieht zunächst etwas wirr aus, doch sind die Bytes bei näherer Betrachtung sinnvoll. Ordnen wir den Speicherdump anders an und ergänzen ihn durch einige Kommentare, dann erhalten wir einen Aufbau wie in Bild 1. Im ersten Byte ist das höchstwertige Bit 7 immer gesetzt, Bit 6 und 5 haben besondere Bedeutung und die Bits 4 bis 0 enthalten die Länge des Namens, hier 3 (Bild 2). Die nächsten drei Byte enthalten dann tatsächlich auch den Namen NIP, nur das Bit 7 des letzten Buchstabens ist wieder gesetzt. Diese 4 Byte bilden das Namensfeld von NIR gekennzeichnet durch die Namens-Feld-Adresse NFA. Die nächsten beiden Bytes sind das Linkfeld, markiert durch die Link-Feld-Adresse LEA. Im Linkfeld steht ein Zeiger auf das Namensfeld eines vorhergehenden Wortes. Die nun folgenden zwei Bytes bilden das Codefeld, adressiert durch die Code-Feld-Adresse CFA. Im Codefeld befindet sich ein Zeiger auf Maschinencode des jeweiligen Mikroprozessors.

Diese drei Felder bilden den Kopf des Wortes. Das Namensfeld dient dem Interpreter zum Wiedererkennen von »NIP«. Mit Hilfe des Linkfeldes findet der Interpreter zum vorhergehenden Wort, und von dort handelt er sich auf die gleiche Art weiter durch das Wörterbuch. Der Inhalt des Codefeldes schließlich bestimmt den Charakter von »NIP«. Es gibt nämlich außer »normalen« Forth-Worten (die durch»:« eingeleitet und mit»;«beendet wurden) noch andere, zum Beispiel »Konstanten« (CONSTANT), »Variable« (VARIABLE) und reine Maschinencodeworte (CODE), wie zum Beispiel »SWAP« und »DROP«. Bei allen »normalen« Worten zeigt der Inhalt des Codefeldes jedoch immer auf denselben kurzen Maschinencode, der bewirkt, daß die im Speicher folgende Liste von Arbeitsanweisungen abgearbeitet wird.

An den Kopf mit seinen drei Feldern schließt sich der Rumpf nahtlos an, beginnend bei der Parameter-Feld-Adresse PFA. Das Parameterfeld ist die Liste von Arbeitsanweisungen und enthält bei unserem Wort NIP drei Zeiger zu 2 Byte; einen auf »SWAP«, einen auf »DROP« und einen Zeiger auf ein Wort »;S«. Bei der Ausführung von NIP beendet das »;S« das Abarbeiten dieser Liste. Wer hat das »;S« ins Wörterbuch geschrieben? Hier hat sich das »;« verewigt, das ja selbst noch einiges mehr tun muß (zum Beispiel den Compiler abschalten). Ganz und gar fehlt die Buchstabenfolge (N1 N2 — N2); dies ist auch gut so, denn mit einer öffnenden Klammer eingeleitete Texte sind Kommentare, der Text wird bis zur schließenden Klammer einfach überlesen.

Die Zeiger auf »SWAP«, »DROP« und »;S« weisen nun nicht auf deren Namensfeld, sondern auf deren Codefeld. Dies beschleunigt die spätere Ausführung von »NIP« ganz erheblich, erschwert uns jedoch das Wiedererkennen der Worte beim Speicherdump. Die Zeiger in »NIP« sind nicht nur computerabhängig, sondern auch abhängig von der Forth-Version und von der Stelle, an der »NIP« compiliert wurde. (Deshalb ist der oben gezeigte Speicherdump auch nur ein Beispiel.) Viel komfortabler wäre es, wenn wir statt Zeigeradressen zu dumpen, gleich die Wortnamen listen könnten, aus denen »NIP« sich zusammensetzt. Wir müßten dazu den Zeiger, der zum Beispiel auf die CFA von »SWAP« zeigt, so verbiegen, daß er auf die NFA von »SWAP« weist. Dann könnten wir feststellen, wie lang dieser Name ist und die vier Zeichen SWAP einfach ausdrucken. Diese Aufgabe erfüllt ein Decompiler.

## Das Baukasten-Prinzip

Forth ist ein Baukasten, der die wichtigsten Funktionen schon als Bausteine enthält — sie müssen nur noch richtig zusammengesetzt werden. Also basteln wir uns ein Wort, das aus der CFA eines Wortes seinen Namen druckt. Zur Verfügung haben wir ein Wort »ID«, das aus NFA eines Wortes seinen Namen druckt. Das Problem reduziert sich also auf das Verbiegen der CFA auf die NFA, da die Namen verschieden lang sein können, Forth läßt bis 31 Zeichen zu. Auch hierfür gibt es schon ein Bauklötzchen, das verschieden lange Namen berücksichtigt: Habe ich eine PFA, so kann ich sie in die NFA umwandeln mit dem sinnfälligen Wort »NFA«. Unser Problem reduziert sich also weiter auf die Umwandlung einer CFA in die PFA. Das Codefeld enthält immer einen 16-Bit-Zeiger, ist also immer 2 Byte lang. Das Parameterfeld schließt sich immer an das Codefeld an. Also addieren wir zwei zur CFA, auch dafür gibt es ein Klötzchen namens »2 +«, und erhalten die PFA, führen dann »NFA« aus und erhalten die NFA; danach drucken wir den Namen mit »ID« und ein trennendes Leerzeichen mit »SPACE«. Diesen neuen Befehl nennen wir »= =« (Listing 1).

Nun können wir schon ein bißchen decompilieren: Wir suchen uns die Rumpfadresse von NIP mit:
’ NIP
sichern uns die Adresse, holen uns den ersten Zeiger mit:
DUP @
und drucken aus der geholten CFA den zugehörigen Namen mit:
= =

Auf dem Bildschirm erscheint »SWAP OK«. Jetzt erhöhen wir die Adresse um 2, damit sie auf den nächsten Zeiger weist, mit:
2 +
und decompilieren das nächste Wort mit:
DUP @ = =

So könnten wir uns weiter durch NIP oder andere Worte tasten.

Tasten ist hier im doppelten Sinn treffend: Wir müssen viele Tasten drücken und kommen eben deshalb nur langsam voran. Etwas komfortabler muß es schon gehen.

Zunächst fassen wir die immer wieder benötigte Befehlsfolge »DUP @ = = 2 +« zusammen zum Wort ».NAME« (Listing 1).

Bei ».NAME« sind immerhin fünf Zeichen zu tippen, das ist jedem Forth-Programmierer zuviel. Außerdem hätten wir noch gerne gewußt, wo wir uns im Speicher gerade aufhalten und das ewige »OK« am Ende wollen wir uns beim Decompilieren auch sparen. Die Folge dieser Gedanken ist das Wort »N« aus Listing 1. Das »DUP U.« druckt uns die Adresse, die wir gerade decompilieren (ohne Vorzeichen), das ».NAME« den Namen und das »QUIT« am Ende unterdrückt die OK-Meldung. Es macht aber noch mehr, es bricht die Ausführung von Worten sofort ab, wirft den Rest der Eingangspost weg und kehrt in den Interpreter zurück. Nur der Zahlenstapel bleibt unangetastet.

Nun können wir NIP schon komfortabel decompilieren:
’ NIP findet den Rumpf von NIP,
Ausgabe: OK
N decompiliert Namen,
Ausgabe: adrl SWAP
N decompiliert Namen,
Ausgabe: adr2 DROP
N decompiliert Namen,
Ausgabe: adr3 ;S

Versuchen wir ein anderes Beispiel: Wir wollen uns ein Wort bilden, das zu einer gegebenen Adresse auf dem Stapel genau 1024 hinzuzählt, so daß wir uns in l-KByte-Schritten durch den Speicher bewegen.
DECIMAL
: 1024+ (ADR-ADR + 1024)
1024 + ;

Decompilieren wir nun unser Wort »1024 +«, so erhalten wir als ersten Namen die Buchstabenfolge »LIT«, als zweiten Namen irgendwelchen Unsinn, als dritten Namen ein » + « und als vierten Namen ein »;S«. Das»+«und »;S« bedürfen keiner Erklärung, aber woher kommt das »LIT« und das, was sich da als Name nicht decompilieren läßt? Es ist unsere Zahl 1024, die sich durch das vorangestellte »LIT« als 16-Bit-Zahl zu erkennen gibt. Die Zahl selbst steht in den beiden Bytes, die der CFA von »LIT« folgen. Würde beim Compilieren die Zahl einfach nur ins Wörterbuch geschrieben, könnte bei der späteren Ausführung nicht mehr erkannt werden, daß es sich dabei eben nicht um die CFA eines Wortes handelt, sondern um eine Zahl, die auf den Stapel zu legen ist. Die praktische Folge: Stoßen wir beim Decompilieren auf »LIT«, so dürfen wir die nächsten beiden Bytes nicht als Name auffassen, sondern müssen sie als 16-Bit-Zahl einfach ausdrucken.

Basteln wir uns wieder die dazu nötigen Worte, zunächst ein
.LIT(ADR-ADR + 2)
das die Adresse, die wir gerade bearbeiten, rettet und die beiden Bytes holt, die unter dieser Adresse zuhause sind. Diese beiden Bytes müssen dann als Zahl (mit Vorzeichen) ausgedruckt und anschließend die Adresse um 2 erhöht werden. Weiterhin ein kurzes Wort
L(ADR-ADR + 2)
das ».LIT« benutzt (siehe wieder Listing 1).

Da sich Zahlen von 0 bis 255 in einem Byte darstellen lassen, compiliert Forth solche Zahlen, um Platz zu sparen, mit dem besonderen Wort »CLIT«. Dessen CFA folgt dann die Zahl in nur einem Byte. Auch dafür brauchen wir passende Worte (siehe Listing 2).
.CLIT(ADR-ADR + 1)
und
C(ADR-ADR + 1)

Nun gibt es noch eine Reihe von Worten, denen bei der Compilation eine nachfolgende 16-Bit-Zahl mitgegeben wird. Das sind die Verzweigungs-Befehle BRANCH, 0BRANCH, (LOOP) und ( + LOOP). Die mitgegebene Zahl ist die Sprungadresse; jedoch ist sie nicht absolut angegeben, sondern als Offset zur Adresse, an der der Befehl compiliert wurde.

Schwierig? Wir müssen uns nur den Offset holen und die gerade laufende Adresse, an der wir decompilieren, addieren. Dies macht das Wort:
.BRANCH (ADR - ADR+2)
als Grundlage für:
B(ADR-ADR + 2)
(siehe Listing 2).

Noch ein Wort würde uns beim Decompilieren Schwierigkeiten bereiten, wenn wir uns nicht ein »Gegenwort« basteln würden: das »."«. Ihm folgt ein Forth-String, der zur Ausführungszeit ausgedruckt wird und den wir ebenfalls ausdrucken und die laufende Adresse entsprechend erhöhen müssen. Ein Forth-String ist ähnlich aufgebaut wie das Namensfeld eines Forth-Wortes: Das erste Byte enthält die Länge des Strings, in den folgenden Bytes befinden sich die ASCII-Codes des Strings. Zum Ausdrucken von Strings bietet Forth zwei häufig benutzte Worte an: Haben wir die Adresse, bei der die ASCII-Zeichen des Strings beginnen und wissen wir die Länge, so druckt
TYPE (ADR Länge -)
den String aus. Haben wir jedoch nur die Adresse, unter der wir das Längenbyte eines Forth-Strings finden, so liefert
COUNT (ADR - ADR + 1 Länge)
uns die um 1 erhöhte Adresse und das benötigte Längenbyte, so daß ein folgendes »TYPE« richtig vorbereitet ist. Diese beiden Worte benutzen wir in unserem
.STRING (ADR1 - ADR2)
aus Listing 2. Wir dürfen dabei nicht vergessen, die laufende Adresse um die Länge des Strings zu erhöhen, damit wir richtig weiter decompilieren können. Diesem Zweck dient das »2DUP« und das»+«am Ende von ».STRING«. Die Länge des Strings drucken wir uns vor dem String selbst aus. Das bedienerfreundliche Wort S (ADR1 — ADR2) aus Listing 2 benutzt dann wieder ».STRING«.

Werfen wir nochmals einen Blick auf das »CLIT«. Dort finden wir auch unser »COUNT« wieder. Nun geht es bei »CLIT« überhaupt nicht um Strings, das zweckentfremdete »COUNT« erfüllt aber genau das Geforderte: Das Byte unter der laufenden Adresse wird geholt, und die Adresse wird um eins erhöht.

Nun haben wir uns einen einfachen Satz von Worten geschaffen, der sämtliche Forth-Worte interaktiv decompiliert. Dies ist ein erheblicher Fortschritt gegenüber einem Speicherdump. Aber besonders komfortabel ist dieses Decompilieren immer noch nicht. Im zweiten Teil dieses Artikels wird deshalb ein automatischer Decompiler erscheinen, der sämtliche Standard-FIG-Forth Worte erkennt und vollständig decompiliert.

Der automatische Decompiler wird die hier vorgestellten grundlegenden Worte .NAME, .LIT, CLIT, .BRANCH und .STRING benutzen, die Worte N, L, C, B und S sind durch das in ihnen enthaltene »QUIT« dem interaktiven Betrieb vorbehalten. Das interaktive Decompilieren fördert das Verständnis von Forth jedoch sehr und sollte von keinem Leser ausgelassen werden.

(Georg Rehfeld/ev)

<aside>
### Das Stapeln ist ein Forth-Prinzip: Bemerkungen zum Stapel.

Betrachten wir den Daten-Stapel etwas näher. Forth-Worte, die Eingangsvariable brauchen oder Ausgangsvariable liefern, benutzen in der Regel den Stapel, um diese Zahlen zu übergeben. Der Additions-Befehl » + « zum Beispiel nimmt die beiden obersten Zahlen vom Stapel, addiert sie und legt die Summe wieder oben auf den Stapel. Dies führt zu einer besonderen Schreibweise von Formeln, der Umgekehrten Polnischen Notation (UPN), wie sie auch bei den Taschenrechnern einer bekannten Firma in Gebrauch ist. Die Basic-Schreibweise »PRINT 2 + 3« liest sich in Forth: »2 3 + .«

Der Einfluß eines Forth-Wortes auf den Daten-Stapel wird im Quelltext bei jedem Wort als Kommentar angegeben. Das Wort » + « hat demzufolge den Stapel-Kommentar:
+ (N1 N2 - N3)

N1 und N2 sind dabei die Summanden, die vom Stapel genommen werden, die drei Bindestriche deuten die Operation an und N3 ist die Summe, die auf dem Stapel hinterlassen wird. Das oberste Element des Stapels (TOS) steht bei dieser Schreibweise rechts, vor der Ausführung von »+«ist also N2 Stapel-Spitze, danach N3.
Wichtige Befehle zur Stack-Kontrolle sind:
DUP (N - NN) dupliziert TOS
DROP (N — ) entfernt TOS vom Stapel
SWAP (N1 N2 - N2 N1) vertauscht die beiden obersten Werte des Stapels
OVER (N1 N2 - N1 N2 N1) kopiert zweites Stapelelement als neuen TOS
ROT (N1 N2 N3 - N2 N3 N1) rotiert die obersten drei Stapelelemente
</aside>

# The Quest – Mit dem C 64 auf der Suche nach dem Drachen

> Die Geschichte dieses Grafik-Adventures liegt lange Zeit zurück, an einem Ort weit, weit weg. Eine Geschichte aus vergangener Zeit von Königen, Rittern, Zauberern und Drachen. Eine Geschichte, deren Verlauf Sie als Spieler beeinflussen und verändern.

Ihre Geschichte beginnt im Königreich »Balema«. König »Galt« gibt gerade einer adligen Landsherrin eine Audienz, die ihn bittet, Gnade über Ihr Volk walten zu lassen, das seine Steuern nicht zahlen kann. Schnell stellt sich heraus, daß die Ursache für die Armut ein böser, feuerspeiender Drache ist, der alles zerstört, was ihm in den Weg läuft.

## Eine verantwortungsvolle Aufgabe

Der König, weise wie er ist, zeigt Verständnis: Er beauftragt seinen Champion der Kämpfer, den starken Gorn, den Drachen zu suchen und zu vernichten.

Gorn ist zwar groß und stark, hat aber nicht gerade viel Verstand. Das ist auch der Grund, warum Sie ihn begleiten sollen: Sie sind der Berater von Gorn und müssen ihm sagen, wohin er zu gehen hat und was zu tun ist — wenn Gorn nicht gerade starrköpfig ist.

## Ein interessanter Spielverlauf

Als erstes sollten Sie sich mit wichtigen Dingen ausrüsten, die Sie auf dem Weg durch das gefährliche Land Balema gut brauchen können. Dazu gibt es einen sogenannten »Provisioner«, bei dem es solche Dinge gibt wie zum Beispiel eine Karte des Landes, eine Lampe, ein Seil, eine Rüstung, etc.

Hat man sich genügend ausgerüstet, dann kann es losgehen. Balema ist ein großes Land, und viele Gefahren treffen dort (und eventuell auch außerhalb des Landes) auf Sie. Es ist immer wieder der Fall, daß hungrige Krokodile oder sogenannte »Lizardmen« Hunger auf Menschenfleisch haben. Auch vor Dieben sollten Sie auf der Hut sein.

Im Verlauf des Spieles werden Sie aber auch auf Freunde treffen, die Ihnen helfen (zum Beispiel der alte Hermit, der sich für eine kleine Gefälligkeit sehr dankbar zeigen kann).

Die Starrköpfigkeit Gorns wird sich übrigens sehr bald zeigen, nämlich sobald eine neue Gefährtin (ein hübsches rothaariges Mädchen) hinzukommt.

Wenn Sie sich nicht dumm anstellen, wird es Ihnen vielleicht sogar gelingen, den Drachen zu finden — und den Grund für seine Zerstörungswut. Was der Grund ist, wollen wir hier natürlich nicht verraten; das soll der Spieler ja schließlich selbst herausfinden.

## Versteht ganze Sätze

»The Quest« ist ein Grafik-Abenteuerspiel, das ganze Sätze versteht, also einen relativ guten Parser hat (Parser = amerikanisches Fachwort für Sprachinterpretationsroutine). Das Verstehen ganzer Sätze ist für Grafik-Adventures eine außergewöhnlich seltene Sache, da eine solche Routine viel Speicherplatz verbraucht und auch nicht so ohne weiteres gleichzeitig mit der Grafik und dem Hauptprogramm in den Speicher eines kleinen Homecomputers gequetscht werden kann. Das ist wohl auch der Grund, warum der Wortschatz von »The Quest« etwas kleiner geraten ist, so daß man in einigen Stellen des Abenteuers nur durch Raten weiterkommt.

Eine nützliche Option des Spiels ist das An- und Abschalten des Grafikbildschirms. Wer will, kann das Abenteuer auch als reines Textadventure durchspielen. Zumindest wird der Spieler es an den Stellen tun, an denen er schon einmal war und nicht die Ladezeit für die (schon gesehene) Grafik abwarten will.

## Recht guter Eindruck

Insgesamt gesehen macht »The Quest« einen recht guten Eindruck, der nur dadurch leicht getrübt wird, daß der Wortschatz dieses Abenteuerspiels an einigen Stellen nur Raten zuläßt. In einer Notenskala zwischen 1 (überdurchschnittlich gut) und 6 (ist sein Geld nicht wert), würde ich »The Quest« die Note 2 (für professionelle Abenteuerspielefans durchaus seinen Preis wert) geben.

(M. Kohlen/aa)

# Tom + Zaga

> Neue Variationen des Themas Labyrinth bieten die beiden deutschen Spiele Tom und Zaga. Schießen ist out, Geschicklichkeit ist Trumpf.

Als erstes fallen einem bei beiden Spielen die angenehm kurzen Ladezeiten auf: Obwohl beide Programme sehr lang sind, werden sowohl die Kassette als auch die Diskette sehr schnell geladen. Das Geheimnis heißt Turbolader, das heißt Kassetten werden mit 10facher und Disketten mit 5- bis 6facher Geschwindigkeit in den C 64 geladen.

Bei »Tom« wird der Spieler in die Rolle eines Abenteurers versetzt, der geheimnisvolle Pyramiden nach Schatztruhen durchsuchen soll. Insgesamt sollen 54 Schlüssel zu diesen Truhen in sechs verschiedenen Labyrinthen eingesammelt werden. Dabei sieht der Spieler immer nur einen kleinen Ausschnitt aus einem riesigen Gesamtbild. Sobald sich der Spieler bewegt, wird das Bild in dieser Richtung weitergescrollt. Damit das Ganze nicht zu verwirrend und unübersichtlich wird, gibt es eine Hilfstaste, mit der man sich im Kleinformat das gesamte Labyrinth zeigen lassen kann und erkennt, wo die restlichen Schlüssel verborgen sind.

Natürlich verläuft die Suche nicht störungsfrei: Verschiedene Monster sowie Schlangen, Spinnen und andere feindselige Kreaturen versuchen Tom zu stoppen. Es handelt sich im Prinzip um ein Suchspiel ä la Manic Miner oder Jet Set Willy, allerdings mit wirklich riesigen Labyrinthen, die man so schnell nicht alle durchspielt hat.

Die Grafik ist ansprechend und die Musik ist auch nicht übel — wen sie nervt, der dreht einfach leiser.

Auch die Preise können sich sehen lassen: Das Spiel kostet auf Kassette nur 29 Mark, auf Diskette 39 Mark. Tom gibt es übrigens auch in einer leicht gekürzten Version für den VC 20 mit 16 KByte. Praktischerweise befinden sich auf der Kassette beide Versionen, so daß ein VC 20-Besitzer, der zum C 64 aufsteigt, seine Kassette nicht mehr wegzuwerfen braucht. Wie uns der Hersteller mitteilte, wird auch in Kürze eine Version für die neuen Commodore C 16 und C 116 lieferbar sein.

## Mit dem Hubschrauber ins Labyrinth

Nach dem Starten von Zaga werden nach dem ersten Bild unwillkürliche Erinnerungen an Zaxxon wach. Allerdings wurde hier der dreidimensionale Eindruck noch etwas verbessert, da die Objekte, die teilweise von Mauervorsprüngen und ähnlichem verdeckt werden, auch wirklich partiell ausgeblendet werden. Beim Spiel selber handelt es sich dann aber nicht um ein Ballerspiel, wie das vielbeachtete Zaxxon eines ist, sondern um ein reines Geschicklichkeitsspiel. Man muß einen Hubschrauber durch ein Labyrinth manövrieren und verschiedenen Hindernissen ausweichen (zum Beispiel beweglichen Mauern). Um den unerfahrenen »Piloten« bei den nicht einfachen Steuermanövern zu helfen, kann auf Wunsch eine Steuerhilfe eingeblendet werden, die anzeigt, in welche Richtung man möglichst fliegen sollte. Das Ganze wird noch durch einen brummigen Hubschrauber-Sound wirkungsvoll untermalt. Dieses Spiel erreicht zwar nicht ganz die Perfektion von Zaxxon, aber erfreulicherweise wird auch dieses Spiel für nur 29 Mark (Kassette) beziehungsweise 39 Mark (Diskette) angeboten, ein Bruchteil dessen, was vergleichbare Spiele aus den USA kosten.

(M. Kohlen/aa)

Bezugsquelle: Kingsoft, Schnackebusch 4, 5106 Roetgen, Tel. 0 24 08/8319

# HI-EDDI: ein fantastisches Zeichen- und Malprogramm

HI-EDDI ist ein High-Resolution-Grafik-Editor, der vieles bietet, was man bei teuren, kommerziellen Programmen vergeblich sucht. Sehen Sie sich die Bilder an und Sie bekommen einen Eindruck von seinen Fähigkeiten.

Hier eine Aufstellung der herausragenden Eigenschaften:

- Wahlweise als »Schwarzweiß«-Zeichenprogramm oder als farbiges Malprogramm verwendbar, in jedem Fall mit der vollen Auflösung von 320 x 200 Bildpunkten.
- 7 (in Worten: sieben) Schwarzweiß-Bildschirme oder 6 farbige stehen zur Verfügung.
- Integrierter, leistungsfähiger Sprite-Editor (mit Sprite spiegeln, drehen...) und die Fähigkeit, Sprites aus dem Grafikbild herauszukopieren oder einzupflanzen. Damit ist zum Beispiel Ausschnittvergrößerung (Zoom) ebenso wie das Erstellen von »Construction Sets« möglich.
- Mit einer Zeichentrickfilm-Funktion sind fast flimmerfreie Bewegungsabläufe mit bis zu 24 Bildern pro Sekunde möglich.
- Befehlseingabe wahlweise über Tastatur oder eine selbst zu gestaltende Menütafel (à la Koalapainter).
- Zusammenhängender Ausdruck mehrerer Bilder möglich, das ergibt Superbilder mit einer Breite von minimal 640 Punkten und unbegrenzter Länge (siehe Bild 2 im Listing-Teil).
- Ferner sind alle »Standardbefehle« wie Draw, Line, Rectangle, Circle, Paint, Move und Text vorhanden.

Natürlich ist klar, daß sowas nur in Maschinensprache geht, und die ist mit rund 4700 DATAs nicht gerade kurz. Gemessen an den Möglichkeiten des Programms ist es allerdings auch nicht viel. Die Bilder auf diesen Seiten lassen die Vielfältigkeit von HI-EDDI nur ahnen. Dabei lassen sich nicht nur mit HI-EDDI erzeugte Bilder laden und bearbeiten, sondern auch Grafikbilder anderer Programme, wie von Koala oder Paint Magic, zum Beispiel die der Dia-Show.

(Hans Haberl/gk)

<aside>

# Ein Chinese verhalf dem Gewinner zu 2000 Mark

> Das Programm HI-EDDI ist aus einem Textverarbeitungsprogramm geboren! Diese Aussage verwundert weniger, wenn man an das chinesische »Alphabet« denkt.

Angefangen hat’s ganz ohne Computerunterstützung anno 1960 in Steinhöring (also in Bayern). Schon bald begann ich mich für alles zu interessieren, was irgendwie nach Technik roch. Während andere Mumps oder Röteln hatten, litt ich an Radio-Zerlegeritis, Elektronik-Bastleritis und HiFi-Manie. »Dieser Saustall muß ein anderer werden«, hat sich das Christkind wohl gesagt und hat mir anno 79 einen TRS-80 unter den Christbaum gestellt — natürlich nicht ohne vorherige Absprache mit mir. Irgendwann sind mir dann die 16 KByte und die Grafikauflösung von 48 x 128 Punkten zu wenig geworden und es folgte ein C 64. Natürlich hat sich meine Neigung auch in beruflicher Hinsicht ausgewirkt: Seit 1980 studiere ich Elektrotechnik mit Schwerpunkt Datenverarbeitung an der Technischen Universität München. Neben der Computertei ist Musik, besonders klassische, mein Hobby: Brahms, Beethoven, Liszt und Dvorak sind meine Lieblingskomponisten.

Zu dem Programm HI-EDDI wurde ich angeregt, als sich mein chinesischer Freund einen C 64 kaufte: Eines seiner ersten Projekte war es, seine Adresse auf den Bildschirm zu bringen. Nur bewaffnet mit Simons Basic, brauchte er dazu meterlange DATA-Orgien, um die komplizierten chinesischen Zeichen zu definieren. Daraus wurde die Idee geboren, die Schriftzeichen in einem Sprite-Editor zu erstellen und in den Grafikbildschirm einzupflanzen. Die erste Version von HI-EDDI hatte deshalb im wesentlichen nur die Sprite-Befehle. Als chinesisches Textverarbeitungsprogramm eignet sich das schon hervorragend, aber da ich jetzt schon mal mit einem Grafikprogramm angefangen hatte, wollte ich’s auch perfektionieren. Nach rund dreimonatiger Arbeit fiel mir dann nichts mehr ein, was ich noch einbauen könnte; das Ergebnis ist die vorliegende Version von HI-EDDI.

(Hans Haberl)

</aside>

> Wie mächtig HI-EDDI ist, können Sie aus der umfangreichen Funktionsbeschreibung ersehen. Es kann sogar mit den »professionellen« Programmen verglichen werden, auf jeden Fall ist es das beste Grafikprogramm zum Abtippen.

Nach dem Start meldet sich HI-EDDI mit der Frage »Betriebsart«. Wird hier 0 eingegeben (oder einfach RETURN), wird HI-EDDI als »Schwarzweiß«-Programm betrieben, bei 128 dagegen als farbiges Malprogramm. Weitere mögliche Eingaben werden später behandelt, ebenso die Befehlseingabe mittels Menütafel. Zunächst werden alle Befehle, die im folgenden zusammengestellt sind, durch Tastendruck eingegeben.

### D Draw — »Freihändig« zeichnen

Im Draw-Modus kann mit dem kreuzförmigen Cursor (der wird mit einem Joystick in Port 2 gesteuert) »freihändig« gezeichnet werden. Bei gedrücktem Feuerknopf werden die überfahrenen Punkte gesetzt. Um Punkte zu löschen, muß zusätzlich die SHIFTTaste (oder SHIFT-LOCK zum Feststellen) gedrückt werden.

### L Line — Linien ziehen

Mit dem ersten Knopfdruck am Joystick wird der Anfangspunkt einer Linie festgelegt, mit dem zweiten der Endpunkt, mit dem dritten wieder ein Anfangspunkt etc.. Der jeweilige Anfangspunkt wird auf F7 gespeichert (siehe Funktionstasten), damit lassen sich Strahlen besonders einfach zeichnen. SHIFT wie bei D.

### R Rectangle — Rechtecke zeichnen

Wie L — auch bezüglich SHIFT und F7 —, jedoch wird zwischen den zwei markierten Punkten ein Rechteck gezeichnet.

### C Circle — Kreise zeichnen

Der erste Knopfdruck ergibt den Mittelpunkt (auf F7 gespeichert, damit ist einfaches Zeichnen konzentrischer Kreise möglich), derzweite einen beliebigen Randpunkt, von dem aus HI-EDDI im Uhrzeigersinn einen Kreis zieht. Wird beim Anstoßen an den Rand abgebrochen.

Möchte man einen Ausschnitt eines Kreises, der nicht ganz auf den Bildschirm paßt, zeichnen, so muß der zweite Knopfdruck einen Punkt am Bildschirmrand markieren, von dem aus der sichtbare Kreisausschnitt im Uhrzeigersinn gezeichnet werden kann. Allerdings darf der Radius maximal 256 Punkte betragen.

### P Paint — Ausmalen begrenzter Flächen

Cursor mitten auf die auszumalende Fläche setzen und Knopf drücken. Sollte durch ein Loch in der Umrandung der ganze Bildschirm vollzulaufen drohen, so kann der Vorgang durch nochmaligen Knopfdruck abgebrochen werden (dazu ist allerdings eine gute Reaktion nötig, denn HI-EDDI füllt Flächen um einiges schneller als Simons Basic). Zum Löschen von Flächen: Bildschirm mit »I« invertieren, entstandenes »Loch« vollaufen lassen, zurückinvertieren.

### M Move — Verschieben von Bildschirmbereichen

Mit den ersten beiden Knopfdrücken werden zwei diagonale Ecken des zu transportierenden Bereiches gesetzt (nach dem zweiten Knopfdruck erscheint eine farbliche Markierung dieses Bereiches), der dritte Knopfdruck gibt die linke, obere Ecke des Zielbereiches an. Der Zielbereich muß noch ganz auf den Bildschirm passen (sonst wird der Knopfdruck nicht akzeptiert), er darf jedoch den Quellbereich überlappen oder in einem anderen Bildschirm liegen. Die Auflösung des Move-Befehls entspricht der des normalen Textbildschirmes, es kann also nur im 40 x 25-Raster verschoben werden.

Soll ein Bereich mehrmals kopiert werden, so muß er nicht jedesmal neu markiert werden: Ein Druck auf die Pfeil-nach-oben-Taste holt die letzte Markierung wieder auf den Bildschirm, es kann danach sofort der Zielbereich bestimmt werden (funktioniert nur, solange zwischenzeitlich kein Moduswechsel erfolgte).

Hat man sich beim Markieren vertan, so löscht ein Druck auf die Pfeil-nach-links-Taste die Markierung wieder (gilt auch für L, R, C).

### T Text — Buchstaben und Grafiksymbole einfügen

Es erscheint ein 8 x 8-Pixel großer Rahmen, der sich fast so benimmt, wie der Blinkcursor im Textbildschirm: Drucken von Buchstaben und Grafikzeichen, Cursorsteuerung mittels Cursortasten, Löschen mittels DEL (rückwärts) und INST (vorwärts, um für Text Platz zu schaffen), Reverse on/off und Umschaltung der beiden Zeichensätze mit C = SHIFT (es können alle 512 Zeichen der beiden Zeichensätze gleichzeitig dargestellt werden!).

Daneben bleibt die Cursorsteuerung mittels Joystick erhalten, ebenso alle anderen Befehle, diejedoch nur durch gleichzeitiges Drücken der CTRL-Taste eingegeben werden können. Durch Anwahl eines anderen Modus, zum Beispiel CTRL D für Draw, wird der Textmodus verlassen und es ist wieder »Ein-Hand-Eingabe« der Befehle möglich.

### G Get Sprite — Sprite aus Bildschirm kopieren

In diesem und den folgenden drei Modi erscheint ein spritegroßer Rahmen als Cursor. Auf Knopfdruck wird der Bildschirmausschnitt, auf dem der Rahmen sitzt, in das Sprite hineinkopiert, anschließend geht HI-EDDI automatisch in den Append-Modus, das Sprite kann an anderer Stelle wieder eingepflanzt oder im Sprite-Editor bearbeitet werden.

### A Append — Sprite in Bildschirm einfügen

Auf Knopfdruck wird der Spriteinhalt in den Bildschirm eingefügt, ohne jedoch den Bildschirmausschnitt vorher zu löschen (Oder-Verknüpfung). Bei gleichzeitiger Bewegung wird das Sprite zum »programmierbaren Pinsel«.

### S Stamp — Sprite auf Bildschirm kleben

Wie A, jedoch wird vor dem Einfügen der Untergrund gelöscht, das Sprite wird wie eine Briefmarke auf den Bildschirm geklebt.

### E Erase — Löschen

Der Rahmen wird zum Radiergummi, der alles löscht, was er überfährt.

### F Foreground-Colourmode — Vordergrund einfärben<br>B Background-Colourmode — Hintergrund einfärben

Diese beiden Modus-Befehle sind nur wirksam, wenn HI-EDDI als farbiges Malprogramm betrieben wird. Doch dazu ist vorweg einiges zum Konzept zu sagen:

Im Gegensatz zu den meisten käuflichen Programmen, die im Multicolour-Modus arbeiten (mehrere Farben, aber nur halbe Auflösung), ist HI-EDDI konsequent als Zeichenprogramm mit maximaler Auflösung konzipiert. Die Farbfähigkeiten sind nur ein »Nebenprodukt« und deshalb nicht so ausgeprägt: Pro 8 x 8-Punkte-Feld (entsprechend einer Position im Textbildschirm) stehen nur zwei Farben — je eine für Vorder- und Hintergrund — zur Verfügung. Bei insgesamt 1 000 Feldern und 16 Farben kann das allerdings auch recht bunt werden. Außerdem ist es durch die Trennung von Zeichnen und Einfärben möglich, bestehende »Schwarzweiß-Bilder« leicht nachträglich zu colorieren.

Nun zu den Befehlen **F** und **B**: Sie schalten einerseits die Rahmenfarbe (und die Farbe des Sprite-Inhalts bei **A** und **S**) weiter, andererseits wählen sie den Fore- beziehungsweise Back-Mode an, in dem auf Knopfdruck die gesetzten Pixel (=Vordergrund) beziehungsweise gelöschten Pixel (= Hintergrund) des 8 x 8-Feldes, auf dem sich der Cursor befindet, mit der Rahmenfarbe eingefärbt werden. Beispiel: Um den Vordergrund gelb anzumalen, muß die Taste F so oft gedrückt werden, bis der Rahmen gelb ist. Dann kann mit dem Cursor gepinselt werden.

Hat man ein Feld zuviel angepinselt, so kann durch gleichzeitiges Drücken der SHIFTTaste (wie bei D, L, R, C) die gerade gemalte Farbe gelöscht werden. Genauer gesagt: Es erscheint wieder die Farbe, die beim letzten Bildschirmwechsel dort war. Als Bildschirmwechsel gelten:

1.	Bildschirmspeicherwechsel (1 bis 7)
2.	Ausschalten des High-Resolution-Bildschirmes (Sprite-Editor, Befehle H, V, SHIFT W, Disk- und Druckerbefehle).
3.	Move-Befehl, auch wenn nur innerhalb eines Bildes »gemovet« wurde.

Die Pfeil-nach-links-Taste (Korrekturtaste) hat die gleiche Wirkung wie SHIFT + Knopfdruck, jedoch für den ganzen Bildschirm: Es werden alle Farbveränderungen seit dem letzten Bildschirmwechsel rückgängig gemacht.

## Direkte Befehle

Alle bisher beschriebenen Befehle haben eins gemeinsam: Sie dienen zur Anwahl eines Modus, sie haben also eine »Nachwirkung«, vor allem, was die Funktion des Feuerknopfes anbelangt. Die nun folgenden Befehle ändern den gerade eingestellten Modus nicht, sie haben nur eine unmittelbare Wirkung.

### 1 bis 7 beziehungsweise 1 bis 6: Bildschirmspeicher-Anwahl

HI-EDDI hat im Schwarzweiß-Betrieb sieben und im Farbbetrieb sechs Bildschirmspeicher, die durch Eingabe ihrer Nummer auf den Bildschirm geholt werden.

Wozu so viele? Beispiele: Abspeichern von verschiedenen Zwischenstadien der bearbeiteten Werke, bei denen man wieder ansetzen kann, wenn man was vermurkst hat. Oder Erstellen von »Construction Sets«: Aus einer Anzahl zum Beispiel von Schaltsymbolen kann man mittels der Sprite-Befehle im Nu Schaltpläne aufbauen. Für die Befehle Print und Walk sind sieben Speicher eigentlich zuwenig, aber im C 64 haben eben nicht mehr Platz!

### I Invertieren

Die Pixel des Bildschirmes werden invertiert. In Zusammenhang mit den Befehlen Und, Or, Exor, Append, Stamp, Get, Erase, Paint und Print ergibt das eine Vielzahl von Möglichkeiten.

### Un Und-Verknüpfung

Der aktuelle (= sichtbare) Bildschirm und der Bildschirm Nummer n werden Und-verknüpft, das Ergebnis im aktuellen Bildschirm abgelegt.

### On Oder-Verknüpfung

Wie U, jedoch Oder-Verknüpfung. Eignet sich zum Beispiel zum Duplizieren von Bildern. Da die Befehle I, U, 0, X keinen Einfluß auf die Farbinformation eines Bildes haben, wird sie bei Farb-Betrieb nicht dupliziert. Soll dies geschehen, so muß mit dem Move-Befehl dupliziert werden.

### Xn Exor-(Exclusiv-Oder-)Verknüpfung

Zweimalige Exor-Verknüpfung mit demselben Bild bewirkt, daß dieses wieder aus dem sichtbaren Bild »herausgefieselt« wird.

### F, B (Fore, Back) — Rahmenfarbe weiterschalten<br>SHIFT F Total Foreground — Vordergrund-Farbe<br>SHIFT B Total Background — Hintergrund-Farbe

Die Befehle F und B wurden bereits bei den Modusbefehlen behandelt. Im Schwarzweiß-Betrieb schalten diese Befehle nur die Rahmenfarbe weiter, den aktuellen Modus verändern sie nicht.

SHIFT F und SHIFT B sind dagegen in beiden Betriebsarten (farbig und schwarzweiß) gleich: Sie färben den gesamten Vorder- oder Hintergrund mit der aktuellen Rahmenfarbe ein. Sollte man auf diese Art im Farb-Betrieb versehentlich eine mühsam erstellte Colorierung löschen: Pfeil-nach-links-Taste drücken, und sie ist wieder da.

### SHIFT CLR Bildschirm löschen

Die Farbinformation wird nicht gelöscht und kann somit isoliert werden.
+ Schnelle Cursorgeschwindigkeit (beschleunigend)
— Langsame Cursorgeschwindigkeit

HI-EDDI besitzt einen beschleunigenden Cursor: Er ist langsam genug, um durch Antippen des Joysticks pixelweise zu rangieren, bei größeren Entfernungen wird er jedoch — ohne lästiges Umschalten — schneller. Da jedoch die Beschleunigung manchmal unerwünscht ist, läßt sie sich durch Drücken der Minus-Taste abschalten.

### F1 bis F8: Tabulatoren

Die vier Funktionstasten dienen als Speicher für vier Cursorpositionen: Durch gleichzeitiges Drücken der SHIFTTaste und einer Funktionstaste wird die momentane Cursorposition gespeichert, durch Drücken einer Funktionstaste allein springt der Cursor wieder genau an die gespeicherte Stelle. F7 wird von den Befehlen L, R und C automatisch belegt.

### H — Horizontale Schrittweite<br>V — Vertikale Schrittweite<br>F1 bis F8: Schrittweiten speichern

Noch eine Speicherfunktion haben die Funktionstasten: Normalerweise bewegt sich der Cursor in 1-Pixel-Schritten bei der Joysticksteuerung, beziehungsweise in 8-Pixel-Schritten bei Steuerung mittels Cursortasten. Diese Schrittweiten sind jedoch — getrennt für horizontale und vertikale Bewegung — frei programmierbar, vier Schrittweitenpaare können auf den Funktionstasten gespeichert werden. Das Anwählen einer Schrittweite erfolgt durch gleichzeitiges Drücken der C = (Commodore-)Taste und einer Funktionstaste (gilt nur für die Cursortastensteuerung, der Joystick holt seine Schrittweite immer aus F1), das Programmieren durch die Befehle H und V, wonach die aktuelle (angewählte) Schrittweite angezeigt wird und geändert werden kann.

Im Einschaltzustand sind die Tasten folgendermaßen belegt:
**F1**:H = 1,V = 1,das ist die normale Joysticksteuerung. Durch Vergrößerung auf 2 oder 3 lassen sich im Draw-Modus punktierte Linien zeichnen.
**F3** (Diese Taste ist im Einschaltzustand angewählt): H = 8, V = 8, für Textmodus. Vergrößerung ergibt eine gedehnte Schrift oder einen größeren Zeilenabstand.
**F5**: H = 24, V = 21, = Spritemaße, zurflächendeckenden Bearbeitung mittels Sprite-Editor.
**F7**: H = 160, V = 96, zur Einteilung des Bildschirmes in Viertelbilder für Walk-Befehl.

Weitere Anwendungsmöglichkeiten sind: Maßstäbe, Gitterraster, exakt symmetrische Zeichnungen etc...

### Space: Sprite-Editor

Durch Drücken der Leertaste kommt man in den Sprite-Editor. Das Setzen und Löschen von Punkten geht dort genauso wie im Draw-Modus. Die Befehle des Grafik-Editors sind im Sprite-Editor nicht zugänglich, dafür stehen die folgenden zur Verfügung:

**M Mirror** — Das Sprite wird zur Senkrechten gespiegelt.
**T Turn** — Drehung um 180 Grad. M und T ergeben eine Spiegelung zur Waagrechten.
**R Rotate** — Das Sprite wird um 90 Grad im Uhrzeigersinn gedreht. Da esjedoch 24 Punkte breit, aber nur 21 hoch ist, gehen die rechten drei Spalten verloren. Außerdem ist zweimal R nicht dasselbe wie T.
**G Grid** — Zum besseren Abzählen von Punkten wird ein Gitter eingeblendet, bei nochmaliger Eingabe von G wird es wieder ausgeblendet.
**SHIFT CLR	Sprite löschen**
**Space	Sprite-Editor verlassen**
**W Walk	Bildfolge ablaufen lassen**
**SHIFT W	Bildsequenz programmieren**

Jetzt lernen die Bilder laufen! Mit W werden die Bildschirmspeicher in schneller, programmierbarer Folge zyklisch durchgeschaltet. Da jedoch sechs Bilder für einen Bewegungsablauf recht wenig sind (Speicher 7 wird als »Leinwand« benutzt, sein Inhalt geht verloren) und außerdem die Bildfolge-Geschwindigkeit bei der Verschiebung von jedesmal 8 KByte nicht gerade hoch ist (maximal 7 Bilder/s), können die sechs Bildschirme in 24 Viertelbilder (mitje 160 x 96 Punkten, die unterste Zeile bleibt frei) zerlegt werden, die bei Maximalgeschwindigkeit in einer Sekunde »durchgerasselt« werden.

Bei der Erstellung solcher Viertelbilder ist die programmierbare Schrittweite (160/96) sowie der Move-Befehl besonders nützlich. Die Programmierung der Bildfolge geschieht durch einen Sequenz-String, der aus den Zahlen 1 bis 6 zum Aufruf der großen Bilder oder aus den Buchstaben A bis X zum Aufruf der Viertelbilder bestehen kann. Der Bildschirmspeicher 1 enthält die Viertelbilder A (links oben), B (rechts oben), C (links unten) und D (rechts unten). Das geht so weiter bis zum Speicher 6, der die Viertelbilder U, V, W, X enthält. Beispiel: Zum sequentiellen Durchschalten aller Viertelbilder besteht der Sequenzstring aus den Buchstaben A bis X in alphabetischer Reihenfolge. Zahlen und Buchstaben dürfen mehrfach und sogar gemischt vorkommen.

Mit SHIFT W gelangt man in den Sequenzstring-Editor, mit W wird die Bewegung gestartet. Während des Laufes kann die Geschwindigkeit mit der Plus- und Minus-Taste geregelt werden, bei gedrückter SHIFT-Taste läuft der Film rückwärts. Durch Druck auf den Feuerknopf wird die Vorführung beendet.

Bei Farb-Betrieb wird Bildschirm 6 als Leinwand verwendet, es stehen nur noch 5 große oder 20 kleine Bilder zur Verfügung.

### Z Zeichensatz

HI-EDDI kann auch als Zeichensatz-Editor verwendet werden: Mittels Z wird der gerade angewählte Zeichensatz in die ersten sieben Zeilen des Grafikbildschirmes kopiert. Dort kann er mittels Get, Sprite-Editor und Stamp modifiziert, anschließend auf Diskette gespeichert und von anderen Programmen, zum Beispiel Textverarbeitungsprogramme, verwendet werden.
**C= L LOAD** (C = bedeutet Commodore-Taste)
**C= S SAVE**
**C= D Directory anzeigen**
**C= C Commando an Disk** oder (wenn nur RETURN) Fehlerkanal lesen

Bei LOAD und SAVE hat man die Wahl zwischen (schwarzweißem) Gräfikbild, Farbbild, Zeichensatz und Sprite. LOAD und SAVE beziehen sich immer auf den aktuellen (= sichtbaren) Bildschirmspeicher (beziehungsweise Sprite). Bei SAVE Zeichensatz muß dieser in den ersten sieben Zeilen des sichtbaren Bildschirmes stehen. Bei LOAD Sprite sollte man wirklich nur ein Sprite und nichts längeres laden, sonst gibt’s einen netten Absturz. Es können auch Diashow-Bilder und Files anderer Grafikprogramme gelesen werden.
**C= P Print** — Ausdrucken

Die Druckerroutine HI-PRINT wird bei Bedarf in Overlaytechnik nachgeladen, nach Beendigung des Druckvorganges wird wieder HI-EXE geladen.

Die vorliegende Druckerroutine bietet folgende Möglichkeiten:

1.	Ausdruck eines Bildes, groß oder klein.
2.	Zwei Bilder nahtlos nebeneinander, was natürlich nur in klein geht.

## Superhardcopy

Vor und nach dem Ausdruck werden keine zusätzlichen Zeilenvorschübe ausgegeben, aufeinanderfolgende Ausdrucke hängen somit nahtlos aneinander (Bild 1). So läßt sich zum Beispiel mit sechs Bildern eine Superhardcopy mit 640 x 600 Punkten erstellen (Bild 2), lädt man zwischendurch weitere Bilder von Diskette nach, kann man meterlange Bilder ausdrucken.

Leider ist Drucker nicht gleich Drucker! Die vorliegende Druckerroutine (Listing 1) läßt sich nur für Epson-Drucker und kompatible mit Interface verwenden. Deshalb möchte ich im folgenden Kapitel Hinweise zur Erstellung einer Druckerroutine für andere Konfigurationen geben.

Die Speicherbelegung von HI-EDDI
Die Speicherbelegung von HI-EDDI sieht folgendermaßen aus:

TODO

Die Druckerroutine wird in denselben Bereich wie HI-EXE geladen, also ab $D00, nach Beendigung des Druckvorganges wird wieder HI-EXE geladen (Listing 1 und 2).
Die vorliegende Druckerroutine enthält auch ein Software-Interface, das den User-Port zur Centronics-Schnittstelle umfunktioniert. Dazu muß ein Kabel mit folgender Pinbelegung verwendet werden:

TODO

Will man eine Routine für andere Drucker schreiben, so darf diese den gesamten Speicherbereich von $D00 bis $1F7F belegen, lediglich die residenten Speicherbereiche und der Basic-Speicher sind tabu. Die Information darüber, wo welcher Bildschirm im Speicher liegt, steht in den 7 Bytes von $1F96 bis $1F9C: In $1F96 steht die Nummer des Bildes, das ab $2000 in Speicher liegt (das ist das sichtbare Bild!), in Zelle $1F97 steht die Nummer des Bildes ab $4 000 und so weiter. Beispiel: Soll Bild Nummer 2 ausgedruckt werden, so sucht man in der Tabelle nach der 2. Steht sie zum Beispiel in Zelle $1F9A, so liegt Bild 2 im Bereich ab $A000 (unter dem Basic-ROM). Im Farb-Betrieb steht in Zelle $1F97 eine 0, weil im Bereich $4 000 bis $6 000 dann die Farbinformationen für die sechs Bilder liegen und dieser Bereich für Grafikbilder somit gesperrt sein muß.

Für den nicht Maschinenspracheerfahrenen Leser sind dies sicherlich alles spanische Dörfer, aber vielleicht sind einige »Maschinen-Profis« so nett und schicken Lösungen für andere Drucker ein.

## HI-EDDI als Menüprogramm

Wem die Eingabe der Befehle über die Tastatur nicht gefällt, der kann HI-EDDI zu einem Menüprogramm nach dem Vorbild des Koala Painter umfunktionieren, bei dem die Befehle über eine bunte, illustrierte Menütafel eingegeben werden. Ehrlich gesagt: Ich finde die Eingabe über Menütafel alles andere als benutzerfreundlich: Menü holen, Cursor auf das gewünschte Feld bugsieren und dann Knopf drücken ist eine wesentlich umständlichere Prozedur als ein einfacher Tastendruck. Dafür macht das Entwerfen und Realisieren einer Menütafel so viel Spaß, daß ich mich entschlossen habe, diese Möglichkeit vorzusehen.

Doch zunächst zurück zu dem Bytewert, der bei Programmstart auf die Frage »Betriebsart« eingegeben werden muß. Er setzt sich wie folgt zusammen:

Bit 7: =0 : Schwarzweiß-Betrieb
= 1 : Farb-Betrieb
Bit 6 : =0 : nur Tastatureingabe
= 1 : Menü-Eingabe
Bit 5-1 : keine Funktion
Bit 0 : =0 : Beim Start werden alle Bildschirmspeicher gelöscht
= 1 : Es wird nichts gelöscht, im Speicher befindliche Bilder bleiben erhalten
TODO

Für Farbe und Menü zum Beispiel muß 192 eingegeben werden. Ich finde die Menü-Eingabe nur in Farbe sinnvoll, ein Schwarzweiß-Menü sieht recht langweilig aus. Ist das Bit 6 gesetzt, also die Menü-Betriebsart angewählt, so muß sich auf der Diskette unter dem Namen »MENUE« die Menütafel befinden, die beim Start automatisch nachgeladen wird. Das Erstellen einer solchen Menütafel soll nun erklärt werden:

Die Menütafel wird in 20 x 12, also insgesamt 240 Felder von je 16 x 16 Punkten eingeteilt. 20 x 16 = 320, die Breite des Bildschirms, aber 12 x 16 = 192 gibt nicht ganz die Höhe des Bildschirmes: Die letzte Zeile (acht Punkte) bleibt, wie bei Walk, frei. In dieser Zeile werden die Steuerbytes untergebracht, für jedes der 240 Felder 2 Bytes. Wird im Menü-Modus der Cursor auf eines der Felder gefahren und der Feuerknopf gedrückt, dann holt sich HI-EDDI aus der letzten Zeile die diesem Feld zugeordneten Steuerbytes und entnimmt aus ihnen, welcher Befehl ausgeführt werden soll. Die Zuordnung von Feldern zu Steuerbytes geht zeilenweise, der Reihe nach: Die ersten beiden Steuerbytes (Adresse $3E00 und $3E01, wenn die Menütafel angewählt ist) gehören zum ersten Feld links oben, die nächsten beiden Bytes zu dem daneben und so weiter. Die Steuerbytes zum letzten Feld haben die Adressen $3FDE und $3FDF, das liegt bereits im unsichtbaren Teil des Bildschirmspeichers. Die nicht gerade ansehnlichen Steuerbytes im sichtbaren Teil können durch gleiche Farben für Vorder- und Hintergrund versteckt werden.

Somit ist klar, wie man vorgehen muß: Zunächst ist ein Menü-Bild zu zeichnen, bei dessen Einteilung nur die 20 x 12-Feld-Rasterung zu berücksichtigen ist. Wie man die Befehle anordnet, wieviele Fehler man für einen Befehl zusammenhängt und welche Befehle man überhaupt ins Menü aufnimmt, bleibtjedem selbst überlassen. Denn keineswegs alle Befehle sind »menüfähig«: Die Korrekturtaste (Pfeil nach rechts) wirkt nur bis zum letzten Bildschirmwechsel zurück. Da jedoch das Anwählen der Menütafel ein Bildschirmwechsel ist, verliert die Korrekturtaste dabei ihre Wirkung. Dasselbe gilt für die Pfeil-nach-oben-Taste: Die Anwahl der Menütafel gilt als Moduswechsel! Aus demselben Grund muß beim MOVEn über zwei Seiten die Seitennummer über die Tastatur eingegeben werden, da bei einem Moduswechsel die Markierung eines Quellbereiches gelöscht wird.

Aus dem Textmodus kommt man nicht direkt ins Menü (SPACE wird als zu druckendes Zeichen interpretiert). Es muß daher zuerst ein anderer Modus über die Tastatur angewählt werden (zum Beispiel CTRL D für Draw), bevor das Menü wieder zugänglich ist.

Dafür bietet die Menütafel auch einige Vorteile: Die Farbenwahl erfolgt nicht mehr durch umständliches Fortschalten, sondern durch Direktanwahl der Farben. Und die Befehle U, 0, X, die normalerweise zwei Eingaben erfordern, werden jetzt mit einer Eingabe »erschlagen«.

Hat man nun ein Menübild gemalt (und abgespeichert!), so folgt der zweite Teil, das Erstellen der Steuerbytes, am besten in Form eines DATA-Laders (siehe Listing 4). Von den zwei Steuerbytes pro Feld enthält das zweite den Tastaturcode des jeweiligen Befehls. Die Tastaturcodes sind im 64’er, Ausgabe 5/84, Seite 105 zusammengestellt, sie lassen sich auch mit dem folgenden »Programm« ermitteln:
10 PRINT PEEK(203):GOTO10

Beim ersten Steuerbyte muß man zwischen verschiedenen Befehlskategorien unterscheiden:

1.	»Normale« Befehle: Bit 0 : SHIFT-Bit, muß gesetzt sein, wenn für den entsprechenden Befehl die SHIFTTaste gedrückt werden muß. Bit 1 : C=-Bit, muß bei gedrückter Commodore-Taste gesetzt sein. Die Bits 2 bis 7 müssen 0 sein. Beispiel: Sprite-Editor einschalten ergibt die Bytes 1 (SHIFT, im Menü-Betrieb dient Space zur Anwahl der Menütafel, der Sprite-Editor ist nur mehr über SHIFT-Space erreichbar) und 60 (Tastaturcode Space).
2.	Befehle U, 0, X: Tastaturcode der entsprechenden Nummerntaste. Beispiel: X 5 ergibt die Steuerbytes 16 (Tastaturcode »5« und 23 (Tastaturcode »X«),
3.	Farbbefehle: Bit 0: SHIFT-Bit. Bits 2 bis 5: Nummer der Farbe, wie im Commodore-Handbuch angegeben. Die Bits 1 und 6 müssen 0 sein, das Bit 7 ist 1. Beispiel: Total Foreground, Blau ergibt: 128 (Bit 7) + 4 x 6 (blau) + 1 (SHIFT) = 153 und 21 (»F«),
4.	»Leerer« Befehl ohne Verlassen der Menütafel (zum Beispiel für Überschrift): 1. Byte = 64, 2. Byte = 0
5.	»Leerer« Befehl mit Verlassen des Menüs: 1. Byte = 0, 2. Byte = 64.

Die 5 Bytes im Anschluß an die 480 Steuerbytes müssen die Kennung »CBM80« enthalten. Das ist eigentlich die ROM-Kennung, ich habe sie hier als Menütafel-Kennung mißbraucht, um versehentliche Menü-Zugriffe auf ein normales Bild zu vermeiden. Vorsicht: Fehler in den Steuerbytes können zum Programmabsturz führen!

Nun braucht man nur noch Menübild und Steuerbytes zu verknubbeln: Dazu HI-EDDI laden, Starten (Betriebsart 128), Menübild laden und Programm mit STOP/RESTORE unterbrechen. Steuerbyte-DATA-Lader laden und starten. Der Lader muß, wie im Beispiel (Listing 4) zu sehen,mit den Befehlen POKE56, 32:CLR beginnen, um das im Speicher befindliche Menübild zu schützen! Dann HI-EDDI laden, starten (Betriebsart 129, damit die jetzt bereits fertige Menütafel im Speicher nicht gelöscht wird) und die nun sichtbare Menütafel unter dem Namen »MENUE« speichern.

Wie wird der »Menü-HI-EDDI« nun bedient? Beim Start muß auf die Frage Betriebsart 192 (oder 193) eingegeben werden. Auf der Menütafel fährt man den Cursor auf den gewünschten Befehl und drückt den Feuerknopf. Daraufhin wird das Menü verlassen, auf den aktuellen Bildschirm zurückgeschaltet (im Einschaltzustand ist dasjetzt 2, da in Speicher 1 die Menütafel steckt) und der Befehl ausgeführt. Das Menü wird durch Drücken der Space-Taste auf den Bildschirm geholt. Die Tastatureingabe bleibt neben dem Menü voll erhalten. Wie schon erwähnt, belegt das Menü den Speicher 1. Dieser Speicher kann natürlich auch direkt angewählt werden, allerdings befindet man sich dann nicht im Menü-Modus, sondern die Menütafel wird wie ein ganz normales Bild behandelt!

Zum Abschluß noch ein Tip: HI-EDDI läßt sich mit STOP/RE-STORE unterbrechen (nicht während einer Befehlsausführung!), ein Warmstart ist mit GOTO150 möglich, ein Kaltstart ohne Nachladen von HI-EXE, aber mit Betriebsart-Eingabe durch RUN100.

(Hans Haberl/gk)

# Der C64 als Handballtrainer

> Für eine erfolgreiche Trainingsarbeit ist es unabdingbar, bereits in der Jugendarbeit neben den praktischen Übungen mit und ohne Ball den Spielern taktische Kenntnisse zu vermitteln.

Das Standardgerät hierfür ist die berühmte Kreidetafel, auf der mit mehr oder weniger Geschick des Trainers die Bewegungen des Balles und der Spieler dargestellt werden. Da das Handballspiel nun einmal ein dynamisches und komplexes Spiel ist, sieht so eine Darstellung sehr oft wie ein Schnittmusterbogen aus. An diesem Punkt setzte die Überlegung ein, ob es nicht möglich wäre, hierfür die grafischen Fähigkeiten des C 64 zu nutzen. Zu diesem Zweck wurden einige grundlegende taktische Regeln des Handballspiels ausgewählt.

1. Darstellung der Angriffssysteme 5:1, 4:2, 3:3 und 2:4 2. Darstellung der Abwehrsysteme 5:1, 4:2, 6:0 und 3:2:1 3. Taktische Spielarten wie Passen, Stoßen, Laufspiel (Achterlauf) und Abwehren

Da die Anzahl der darzustellenden beweglichen Objekte beim C 64 auf acht begrenzt ist, aber im realistischen Fall 13 bewegte Objekte erforderlich sind (sechs Angriffsspieler, sechs Abwehrspieler und ein Ball) wurde ein Kompromiß geschlossen. Bei den taktischen Spielweisen Passen, Stoßen und Laufspiel wurden die Angriffsspieler als bewegliche Objekte dargestellt, beim Abwehren jedoch die Abwehrspieler.

Das Programm wurde erstmalig bei der Schulung von A-Jugendlichen eingesetzt. Darüber hinaus wird mit diesem Programm dem interessierten Laien das Handballspiel durchschaubarer und damit wesentlich interessanter gemacht.

(Manfred Luttkus/rg)

<aside>

## Lebenslauf

Ich bin schon sehr früh — und zwar beruflich — an die »Computerei« geraten. Aus der reinen Anwendung fertiger Programme entsprang sehr bald der Wunsch zu erkennen, was der Computer wirklich kann. Entsprechende Möglichkeiten, die sich mir boten, meine Arbeit mittels Computer zu rationalisieren, nahm ich wahr und kam schon 1969 beim Programmieren zu der Erkenntnis, daß der Computer nur so gut wie die verfügbare Software ist. 1975 brachen meine »hautnahen« Kontakte mit der EDV ab, die ich 1980 mit dem Kauf eines Sharp-PC 1211 wieder auffrischte und 1983 mit dem Kauf eines C 64 krönte. Den Sharp setze ich noch heute für berufliche Zwecke ein, während der C 64 — noch — den rein persönlichen Bereich abdeckt: Telespiele mit gekaufter Software, Führung von Plattendateien, Berechnung von Sportspieltabellen und Entwicklung von Spezialprogrammen, wie »Handballtrainer«, mit eigener Software. Mein kurzfristiges Ziel ist es, einen Personalcomputer für die Unterstützung meiner Planungsaufgaben bei der Montageabwicklung am Arbeitsplatz einzusetzen. Mein Lebenslauf in Kürze:
1943 Geboren in Ostpreußen
1960 Mittlere Reife
1963 Gesellenprüfung
1967 Maschinenbau-Ingenieur
1967 bis 1971 Berechnungs- und Entwicklungsingenieur im Dampfturbinenbau
1969 Programmieren in Basic (Programme für Wärmetechnik und Festigkeit)
1970 Programmieren in Fortran IV (Programme für Strömungstechnik)
1971 bis 1976 Planungs- und Projekt-Ingenieur im Chemie-Anlagenbau
1974 Programmieren in PL I (Anwendung von Montageplanungsprogrammen im Großanlagenbau)
1977 Montageingenieur im Chemie-Anlagenbau
1980 Kauf eines Sharp-PC 1211
1983 Kauf eines C 64

(Manfred Luttkus)

</aside>

Das Handball-Demonstrationsprogramm ist in Basic geschrieben, modular aufgebaut und nutzt vornehmlich die grafischen Fähigkeiten des C 64.

Das Programm ist im wesentlichen in drei Blöcke unterteilt. Im ersten Block sind die DATA-Zeilen abgelegt. Danach folgt der Programmabschnitt mit der Menüauswahl und der Sprite-Aktivierung. Abgeschlossen wird das Programm mit den Unterprogrammen für die einzelnen Programm-Module.

### Programmablauf

Nach dem Start des Programmes mit RUN erscheint das Titelbild während des Einlesens der DATA-Zeilen. Anschließend wird das halbe Spielfeld mit dem normalen Zeichensatz dargestellt und auf der rechten Seite des Bildschirmes das Menü angeboten. Aus den drei Hauptgruppen Angriffssystem (Auswahlelemente A—D), Abwehrsystem (Auswahlelemente E—H) und Taktik (Auswahlelemente l—M)

wird jeweils ein Element ausgewählt. Nach dieser Programmauswahl werden die beweglichen Spieler (beim Passen, Stoßen und Laufspiel sind es die Angriffsspieler), der Ball und die statischen Spieler (beim Abwehren sind es die Angriffsspieler) auf dem Bildschirm dargestellt. Entsprechend der gewählten Taktik wird dann die Spielart Passen, Stoßen, Achter oder Abwehren demonstriert. Das Programm wird durch das Drücken einer beliebigen Taste unterbrochen und zum Menü zurückgeführt. Anhand der Darstellungen können die Vorzüge der einzelnen Abwehr- und Angriffssysteme begreifbar gemacht, sowie die Aufgaben der einzelnen Spieler auf den verschiedensten Positionen klar beschrieben werden.

### Programmlisting

Aus speichertechnischen Gründen (die Sprites sind im Bereich 15872 — 16834 abgelegt) mußte im Programmlisting auf kommentierende Zeilen verzichtet werden. Entsprechende Erläuterungen sind im nachfolgenden Abschnitt angegeben. Zum besseren Verständnis:

Spielfeldplan für Programmzeile 4000-4120 in Bild 1, Grundaufstellungsplan für Programmzeile 36 000-36 084 in Bild 2.

(Manfred Luttkus/rg)

# Ohne gutes Werkzeug geht es nicht: SMON, Teil 3

> Der Maschinensprache-Monitor geht langsam seiner Vollendung entgegen. In diesem Teil kommen drei interessante Befehle hinzu, die vor allem bei der Fehlersuche sehr hilfreich sind.

Sicherlich haben Sie sich beim letzten Mal gewundert, wie es möglich ist, daß so viele neue Befehle in so wenig Programm stecken können. »Schuld« daran ist das SMON-Konzept. Wir haben im ersten Teil bereits alle Ein- und Ausgaberoutinen untergebracht. Alle Erweiterungen können nun darauf aufbauen und werden dementsprechend kürzer. Wir haben Ihnen sogar noch einen Befehl verschwiegen, der beim letzten Mal schon vorhanden war. Vielleicht haben Sie versehentlich einmal »B« eingegeben, und SMON hat mit einem Fragezeichen reagiert und damit gezeigt, daß er mit »B« etwas anzufangen weiß.

Im heutigen Teil 3 unserer SMON-Serie wollen wir Ihnen drei weitere Befehle vorstellen: BASIC-DATA, KONTROLLE und FIND. Es sind diesmal nur drei neue Befehle, nicht weil wir Sie für den nächsten Artikel über »SMON« auf die Folter spannen wollen, sondern weil wir der Meinung sind, daß ein so umfassender Befehl wie »FIND« schon eine Menge an Beispielen braucht, um verstanden zu werden.

## BASIC-DATA

**B (ANFADR ENDADR)** wandelt das Maschinenprogramm von ANFADR bis ENDADR-1 in Basic-DATA-Zeilen um.
B 4000 4020

Unser Testprogramm (Sie erinnern sich doch noch an unser kleines Programm aus 11/84?) wird in DATA-Werte umgerechnet und dann mit Zeilennummer 32000 beginnend im Basic-Speicher abgelegt. Ein im Speicher befindliches Basic-Programm (zum Beispiel ein Basic-Lader) mit kleineren Zeilennummern kann dann diese DATA-Zeilen benutzen.

Wenn Sie das Testprogramm wie oben beschrieben umgewandelt haben, verlassen Sie nun mit »X« den SMON und überzeugen sich mit »LIST« von der Ausführung. Dann können Sie folgendes eingeben:
10 FOR 1 = 16384 TO 16415 : READ D :POKE I,D : NEXT

In Verbindung mit den oben erzeugten DATA-Zeilen (und RUN!) hätten Sie wieder das ursprüngliche Maschinenprogramm im Speicher. Falls Sie dieses Beispiel durchführen wollen, denken Sie bitte daran, daß Sie nach Erstellung der DATAs, das Originalprogramm zum Beispiel mit OCCUPY (0 4000 4020 AA) überschreiben, damit Sie die richtige Ausführung überprüfen können. Der BRK-Befehl am Ende des Testprogramms bewirkt einen Sprung zum SMON zurück. Wollen Sie ein Maschinenprogramm von Basic aus starten und auch wieder dorthin zurückgelangen, muß der letzte Befehl ein RTS sein. Probieren Sie es aus, indem Sie das Basic-Programm um 20 SYS 16384 erweitern.

## KONTROLLE
**K (ANFADR ENDADR)** listet die ASCII-Zeichen im gewünschten Bereich. Es werden jeweils 32 Zeichen pro Zeile ausgegeben, so daß man sich einen schnellen Überblick über Texte oder Tabellen verschaffen kann.

Beispiel:
K 4000 listet die ersten 32 Zeichen unseres Programms. Die weitere Ausgabe ist genau wie beim Disassemblieren durch Druck auf SPACE oder RETURN möglich. Auch hier können Sie wie bei den anderen Bildschirm-Ausgabebefehlen Änderungen durch einfaches Überschreiben vornehmen (natürlich nicht im ROM und nur mit ASCII-Zeichen!).

Als Beispiel wollen wir einmal im Basic »herumpfuschen«: Das geht natürlich nicht so ohne weiteres, weil das Basic im ROM steht und damit nicht verändert werden kann. Tippen Sie bitte folgendes ein:
W A000 C000 A000

Auf den ersten Blick eine unsinnige Anweisung; der Speicher soll von A000 bis C000 nach A000 verschoben werden. Dieser Befehl entspricht exakt der Basic-Schleife
FOR I = 40960 TO 49152 : POKE I, PEEK (I) : NEXT

Nun ist es aber so, daß beim PEEK das ROM gelesen, beim POKE aber ins darunterliegende RAM geschrieben wird. Wir erreichen also, daß das Basic ins RAM kopiert wird. Jetzt müssen wir dafür sorgen, daß das Betriebssystem sein Basic aus dem RAM und nicht aus dem ROM holt. Zuständig dafür ist die Speicherstelle 0001. Geben Sie bitte »M 0001« ein, und überschreiben Sie die »37« mit »36«.

Es passiert gar nichts. Jetzt tritt unser K-Kommando in Aktion. Geben Sie ein: K A100 A360
Was Sie sehen, sind die Basic-Befehlswörter und -Meldungen. Schalten Sie mitSHIFT/CBM auf Kleinschrift, dann erkennen Sie, daß der jeweils letzte Buchstabe eines Befehlswortes groß geschrieben ist (Endekennung). Jetzt ändern Sie durch Überschreiben das »LIST« (A100) in »LUST« und »ER-ROR« (A360) in »FAELER«. (Bei »FAELER« müssen Sie ein Zeichen vor »ERROR« beginnen, sonst paßt es nicht.)
Verlassen Sie jetzt SMON mit »X« und geben Sie danach ein:
POKE 1,54
SMON schaltet nämlich beim »X«-Befehl immer auf das Basic-ROM zurück, daher müssen wir wieder auf unser geändertes Basic umschalten. Schreiben Sie nun einen Basic-Dreizeiler und versuchen Sie, diesen zu LISTen. Ergebnis? Versuchen Sie es jetzt einmal mit »LUST«. Ihrer weiteren Phantasie sind keine Grenzen mehr gesetzt...
Wie oben angesprochen stellt SMON eine Reihe verschiedener Suchroutinen zur Verfügung, die im Folgenden an vielen Beispielen beschrieben werden. Alle diese Befehle bestehen aus zwei Zeichen und beginnen mit dem Buchstaben »F«.

## FIND

**F (HEX-WERT(e), ANFADR ENDADR)** sucht nach einzelnen HEX-Werten innerhalb eines bestimmten Bereichs. Daszweite Zeichen (hinter F) ist hier ein Leerzeichen und darf nicht weggelassen werden! Die Bereichsangabe kann wie bei allen folgenden Befehlen entfallen, dann wird der gesamte Speicher durchsucht.
Beispiel: Wir suchen alle Befehle LDY # 01, also die Werte A0 01 im Bereich von $2000 bis $6000.

F A0 01, 2000 6000 (Die Leerzeichen zwischen den Hexbytes dürfen nicht weggelassen werden !). Es erscheinen alle Speicherstellen, die die gesuchten Bytes enthalten, also zum Beispiel 4000.

**FA (Adresse, ANFADR ENDADR)** sucht alle Befehle, die eine bestimmte Adresse als Operanden haben (absolut). Die Adresse braucht nicht vollständig angegeben zu werden, es kann das Jokerzeichen »\*« benutzt werden.

1.	Beispiel: Wir suchen alle JSR FFD2-Befehle im Bereich $2000 bis $6000.<br>FAFFD2,2000 6000<br>Es erscheinen alle Befehle disassembliert, die FFD2 im Operanden enthalten (also auch LDA FFD2 oder STA FFD2,Y...).
2.	Beispiel: Wir suchen alle Befehle, die auf den Grafikbereich ($D000 bis $DFFF) zugreifen.<br>FAD\*\*\*,2000 6000<br>Der Joker kann aber auch zum Beispiel zur Suche im Bereich $D000 bis $D0FF dienen: FAD\*\*\*,2000 6000

**FR (ADR, ANFADR ENDADR)** sucht nach relativen Sprungzielen. Anders als bei absoluten Sprüngen (JMP, JSR) benutzen die Branch-Befehle eine relative Adressierung, also zum Beispiel »Verzweige 10 vor« oder »37 zurück«. Solche Sprünge lassen sich mit dem FA-Kommando nicht finden. Hier wird »FR« eingesetzt.
Beispiel: Gesucht werden alle Branch-Befehle, die die Adresse $4002 anspringen.
FR4002,2000 6000
Natürlich können solche Befehle nur höchstens 128 Byte vom Sprungziel entfernt sein. Die Bereichsangabe ist hier also viel zu groß gewählt (SMON stört dies allerdings nicht). Der Einsatz des Jokers ist hier ebenfalls wie oben beschrieben möglich.

**FT (ANFADR ENDADR)** sucht Tabellen im angegebenen Bereich. SMON behandelt dabei alles, was sich nicht disassemblieren läßt, als Tabelle.
Beispiel: Wir suchen Tabellen oder Text im Bereich $2000 bis $6000.
FT 2000 6000
**FZ (Adr, ANFADR ENDADR)** sucht alle Befehle, die Zeropage-Adressen haben.

1.	Beispiel: FZC5,2000 6000 findet alle Befehle, die C5 adressieren, also zum Beispiel BIT $C5, LDA (05), Y etc.
2.	Beispiel: FZF\*,2000 6000findetalle Befehle, die den Bereich zwischen $F0 und $FF adressieren.
3.	Beispiel: FZ\*\*,2000 6000 findet sämtliche Befehle mit Zeropage-Adressierung.

**FI (Operand, ANFADR ENDADR)** sucht alle Befehle mit unmittelbarer Adressierung (immediate).
Beispiel: Gesucht werden Befehle, die zum Beispiel das Y-Register mit 01 laden. FI01,2000 6000 findet LDY #01 in Adresse $4000.

Sie sehen, SMON bietet eine Fülle von verschiedensten FIND-Routinen, mit denen alles gesucht und auch gefunden (!) werden kann. Zum Üben wollen wir ein großes Preisausschreiben veranstalten, bei dem Sie zumindest an Erfahrung gewinnen können! Hier sind die Aufgaben, die es zu lösen gilt:

1. Wie oft wird von SMON aus in das Betriebssystem gesprungen ($E000 — $FFFF)?
2. Welche Zeropage-Adressen benutzt SMON?
3. Wo wird die Hintergrundfarbe ($D021), wo die Schreibfarbe ($0286) gesetzt?
4. Wo sind im SMON die Tabellen untergebracht?
5. An einigen Stellen stehen Befehle, die die Register unmittelbar mit dem Highbyte des SMON-Speicherbereichs laden (dez. 49152 — 52208). Rechnen Sie die HEX-Werte aus und suchen Sie die Speicherstellen.
6. An zwei Stellen stehen aufeinanderfolgend fünf Nullen. Wo? Notieren Sie Ihre Lösung bitte auf einem Zettel und werfen Sie diesen fort. Der Rechtsweg ist ausgeschlossen... ,

## Der Lösung ein Stück näher...

Auch heute werden Sie nicht entlassen, ohne daß wir Ihnen einige Tips für eigene Assemblerprogramme mitgeben. Erinnern Sie sich noch an den in der letzten Ausgabe angesprochenen 16-Bit-Vergleich? Dieser wird im SMON zum Beispiel dazu benutzt, festzustellen, ob ein Programmteil weiter durchlaufen werden soll, oder ob das Ende erreicht ist. Das prüft SMON bei fast allen Befehlen, jüngstes Beispiel sind die FIND-Kommandos. Zur Erinnerung: Wir wollten zwei 16-Bit-Zahlen vergleichen, der Prozessor kann aber nur mit 8-Bit-Zahlen umgehen.

Wir brauchen dazu einen hochlaufenden Zähler (er heißt in unserem Beispiel »Programmzähler« PC und besteht aus Highbyte PCH und Lowbyte PCL) und einen End-Zeiger (ENDHI und ENDLO). Unser Programm dafür sah folgendermaßen aus:
LDA PCL
CMP ENDLO
LDA PCH
SBC ENDHI

Anschließend haben wir das Carry-Flag überprüft und festgestellt, daß schon bei Übereinstimmung beider Adressen dieses Flag gesetzt war. In unserem Falle würde also ein Beenden des Programmteils mit »BCS ENDE« zu einer »Unterschlagung« des letzten noch auszuführenden Befehls führen. Um hier einen Weg aus dem Dilemma zu finden, wollen wir uns das Verhalten der Zero- und Carry-Flagge im Status-Register einmal genauer ansehen. Und zwar in Abhängigkeit von PC und dem ENDE-Zeiger.

Sie sehen in Listing 1, daß wir den Programmzähler (PCL/PCH) nach $FB/$FC und den Endezeiger (END-LO/ENDHI) nach $FD/$FE schreiben. Dann springen wir die Routine an, die die Überprüfung auf erreichtes Ende im SMON vornimmt (CMPEND in $C466). Zum Abschluß sorgt der BRK-Befehl dafür, daß wir wieder im SMON landen. Schauen Sie sich die entsprechende Routine im SMON mit »D C466« an. Sie werden erkennen, daß sie den oben angesprochenen 16-Bit-Vergleich durchführt.

Speichern Sie jetzt dieses Programm mit »S ’’CMP-TEST” 4100 4112« ab und starten es mit »G4100«. Nachdem das Programm gelaufen ist, meldet es sich mit der Registeranzeige zurück. Achten Sie dabei vor allem auf die Statusregister-। Anzeige rechts, uns interessieren die Werte für Z und C (Zero- und Carry-Flagge).

TODO

Wir wollen herausfinden, was passiert, wenn der Programmzähler (PC) kleiner, gleich oder größer als ENDE ist. Wenn Sie jetzt in Speicherstelle $4106 für PCH den Wert C1 einsetzen, können Sie den Vorgang wiederholen und die Änderung der i Flaggen notieren. Anschließend setzen Sie C2 für PCH in $4106 ein. Tippen Sie »D4100 4112«, gehen mit dem Cursor in die Zeile 4106 und überschreiben den Wert #C0 mit dem neuen Wert #C1 beziehungsweise #C2.

TODO

So sollte Ihre Tabelle zum Schluß aussehen. Im ersten Fall (PC ist kleiner als END) ist das Carry-Flag gelöscht. Dann (PC ist gleich END) sind Z- und C-Flagge gesetzt, zum Schluß ist nur noch das C-Flag 1. Jetzt können wir unseren Vorstellungen entsprechend reagieren und mit den Branch-Befehlen verzweigen. Sehen Sie sich mit dem Disassembler auch einmal andere Routinen im SMON daraufhin an.

### Hinweise zum Abtippen

Aus vielen Telefonanrufen ist uns klar geworden, daß der bisherige DATA-Lader oft die Fehlerquellen nicht genau genug aufzeigte. Mit diesem Lader dürften Sie beim Abtippen keine Schwierigkeiten mehr haben. Danach sollten Sie das Ladeprogramm auf alleFälle auf Diskette oder Kassette abspeichern. Nach Eingabe von RUN muß der Lader bis zum READY durchlaufen. Um den neuen Teil an SMON anzukoppeln, müssen Sie jetzt den SMON vom letzten Mal mit »,8,1« laden und mit SYS 49152 starten. Jetzt können Sie mit
S ”SMON $C000” C000 CBF1
das bis hier komplette Programm abspeichern. Natürlich müssen Diskettenbesitzer eine andere Diskette einlegen oder das alte SMON-Programm nach dem Laden (!) löschen. Und bis zum nächsten Mal: Üben, üben, üben!

(N. Mann/D. Weineck/gk)

# Checksummer — keine Fehler mehr beim Abtippen von Listings

Das Programm Checksummer64 ist für all die Leute gedacht, die sich manchmal vor Verzweifelung »die Haare raufen« könnten. Da sitzt man mehrere Stunden, um ein gutes Programm aus dem 64’er-Magazin abzutippen, und dann: ein Fehler in der DATA-Zeile oder ein falscher Buchstabe... und schon geht die Fehlersuche los. Hier soll der Checksummer 64 weiterhelfen.

Der Checksummer 64 ist ein kleines Maschinenprogramm, das, wenn es aktiviert ist, Sie sofort davon unterrichtet, ob Sie diejeweilige Programmzeile korrekt eingegeben haben.

1.	Tippen Sie den Basic-Lader sorgfältig ein. Es gibt zwei Versionen: eine für den Commodore 64 und eine für den VC 20.
2.	Bevor Sie »RUN« eingeben, speichern Sie den Basic-Lader bitte erst ab, denn wenn Sie zum Beispiel einen Fehler bei den eingetippten POKE-Anweisungen gemacht haben, ist es möglich, daß der Rechner aussteigt. Heben Sie sich den abgespeicherten Checksummer 64 auf — Sie werden ihn immer wieder brauchen, wenn Sie ein Basic-Programm aus dem 64’er eintippen wollen.
3.	Der Checksummer 64 überprüft sich selbst. Wenn Sie einen Fehler in den DATAs gemacht haben, listen Sie die fehlerhafte Zeile einfach, korrigieren sie und starten dann das Programm neu.
4.	Nach Initialisierung des Maschinenprogramms ist der Checksummer 64 aktiviert. Er steht innerhalb des Betriebssystems und verbraucht kein einziges Byte Speicherplatz. Es sei hier für Interessierte gesagt, daß selbst alle Sprungvektoren unverändert bleiben, das Programm also mit einer Vielzahl von anderen Programmier-Spracherweiterungen wie etwa Exbasic Level II problemlos zusammenarbeitet. Achten Sie aber darauf, daß bestimmte Spracherweiterungen das hinter dem ROM liegende RAM für Hires-Grafiken benutzen. Wird zum Beispiel eine Hires-Grafik von Simons Basic aus angesprochen, so wird der Checksummer 64 zerstört.
5.	Wenn Sie den Checksummer 64 zwischenzeitlich nicht benutzen, können Sie ihn jederzeit mit »POKE 1, 55« desaktivieren. Auch durch Drücken der Run-Stop- und der Restore-Taste wird der Checksummer 64 desaktiviert. Wollen Sie, daß der Checksummer 64 auch noch nach Drücken dieser Tastenkombination erhalten bleibt, so geben Sie bei aktiviertem Checksummer64»POKE64982, 53«ein. Der Checksummer 64 ist dann nur durch »POKE 1, 55« abschaltbar.<br>Wollen Sie den Checksummer 64 wieder einschalten, so geben Sie bitte »POKE 1, 53« ein.<br>Das Maschinenprogramm bleibt solange erhalten, bis der Computer ausgeschaltet, oder wenn von anderen Programmen auf das hinter dem ROM liegende RAM zugegriffen wird.
6.	Eine Checksumme wird nur dann ausgegeben, wenn der Commodore 64 (VC 20) eindeutig erkennt, daß Sie eine Zeile bestehend aus der Zeilennummer und zumindestens einem alphanumerischen Zeichen eingegeben haben. Ansonsten reagiert der Commodore 64 normal.

**Hinweis**: Wenn Sie bei aktiviertem Checksummer 64 ein Programm mit »LOAD« in den Speicher holen, wird auch eine Checksumme ausgegeben. Dies liegtjedoch an rechnerinternen Routinen und hat keine weitere Bedeutung, stellt insbesondere keine Gefahr für das geladene Programm dar, da alle Pointer richtig gesetzt werden.

Nach Eingabe von RUN wird zunächst einmal das ROM in das RAM des Commodore 64 verschoben, wonach der Basic-Interpreter modifiziert wird. Dadurch hat man den Vorteil, trotz einer zusätzlichen Routine das gesamte RAM des Rechners zur Verfügung zu haben. Nach ordnungsgemässem Ablauf des Programms können Sie sofort mit Eingaben beginnen. Für Maschinensprache-Spezialisten weise ich darauf hin, daß ich ausnutze, daß die Einschaltmeldungen des Rechners nur nach einem Reset generiert wird. Der Textbereich, in dem die Meldung steht, wird von dem erzeugten Maschinenprogramm überschrieben.

Alle veröffentlichten Listings sind mit einer Checksumme versehen, die am Ende jeder Programmzeile steht. Diese Checksumme steht zwischen < und >. Sie wird beim Eintippen des Programms nicht mit eingegeben. Die Zahl zwischen den beiden Zeichen stellt lediglich eine Information für Sie dar. Wenn Sie diese Checksumme dennoch mit eintippen, werden Sie schnell bemerken, daß Sie etwas falsch gemacht haben. Bei aktiviertem Checksummer 64 wird nämlich nach Eingabe einer Basic-Zeile, die mit Return beendet wird, in die linke obere Bildschirmecke die Checksumme eingeblendet, die mit der Summe aus dem veröffentlichten Listing übereinstimmen muß. Ist das nicht der Fall, haben Sie die Zeile anders eingegeben, als sie im Listing dargestellt ist. Vergessen Sie also bitte nicht, daßdieam EndeeinerZeilein < und > stehendePrüfsumme nicht mit eingegeben werden darf.

Der Checksummer 64 ist so ausgelegt, daß er abhängig von der Zeilennummer und dem Text der Zeile eine Checksumme ausgibt. Beim Bilden dieser Checksumme werden Spaces (Leertaste) überlesen, was für Sie bedeutet, das es egal ist, wieviel Leerzeichen Sie zwischen den Worten lassen, da Sie für den Programmablauf ohnehin keine Bedeutung haben. Aber manchmal ist das richtige Setzen von Leerzeichen doch wichtig, besonders innerhalb von Strings (Zeichenketten), die gedruckt werden sollen. Seien Sie deshalb besonders genau bei Leerzeichen, die innerhalb von Anführungszeichen stehen, denn meistens ermöglichen nur die richtig gesetzten Spaces eine sinnvolle Textausgabe auf dem Bildschirm.

Beachten Sie auch, daß es durchaus erlaubt ist, Abkürzungen für die Commodore-Befehlswörter zu verwenden. So führt die Eingabe von » ? « als Kurzschreibweise für »PRINT« nicht etwa zu einem Checksummen-Fehler, sondern wird korrekt verarbeitet und dementsprechend die Checksumme generiert. Nachdem Sie ein Listing eingegeben haben, sollten Sie es aus Sicherheitsgründen vor dem Starten abspeichern. Sie brauchen hierfür jedoch nicht den Checksummer 64 zu desaktivieren.

### Hinweise zum Lesen von Listings

Die Listings haben sich ein wenig im Ausdruckformat verändert, um Ihnen das Eingeben von Programmen wesentlich zu erleichtern.

- Cursorsteuerzeichen und andere Steuerzeichen, die schwer zu lesen sind, werden von nun an in Klartext in speziellen Klammern gesetzt.<br>Tritt mehrmals hintereinander dasselbe Steuerzeichen auf, so wird diese Steuerzeichen-Sequenz zusammengefaßt, indem zuerst das Steuerzeichen und dann die Anzahl der Wiederholungen dieses Steuerzeichens in Klartext ausgegeben wird.
- alle Commodore-Grafikzeichen, die über Shift zu errei--% chen sind, werden nicht mehr als Grafikzeichen, sondern als Klartextzeichen dargestellt. Dabei wird aus dem Zeichen, das Sie auf dem Bildschirm sehen, wpnn Sie die Tastenkombination Shift und »A« ansprechen, wieder ein »A«. Um dieses »A« ' vom normalen »A« unterscheiden zu können, ist es etwas kleiner als das gewöhnliche »A« und ist außerdem mit einem Unterstreichungszeichen versehen. Diese Vereinbarung gilt auch für sämtliche andere Commodore-Grafikzeichen, die über Shift zu erreichen sind.
- entsprechendes gilt für sämtliche Commodore-Grafikzeichen, die über die Commodore-Taste zu erreichen sind. Hier wird jedoch das jeweilige Klartextzeichen nicht unterstrichen, sondern überstrichen.

### Erläuterungen zu den Cursorsteuerzeichen

Cursorsteuerzeichen werden, wie schon oben erwähnt, umdefiniert. Sie sehen hier eine Liste der möglichen Ausdrücke, die für ein Cursorsteuerzeichen im Listing auftauchen können. Gleichzeitig ersehen Sie aus der Tabelle, welche Taste beziehungsweise Tastenkombination zu drücken ist, damit dieses Steuerzeichen richtig in Ihr Programm übernommen wird. Beachten Sie, daß Sie die Steuercodes nur dann als reverses Zeichen sehen können, wenn der Rechner im »Quote-Modus« arbeitet, das heißt, daß er sich im Gänsefüßchenmodus befindet.

## Checksummer VC 20

Der Checksummer VC 20 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremäßig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.

In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC20:

- da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.
- angeschaltet wird der Checksummer VC 20 mit »SYS 955«
- Abschaltung des Checksummer VC 20 wird mit »SYS 58459« vollzogen

**ACHTUNG**: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Rechner bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).

Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Rechner »aussteigt«.

Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeit aufheben, wenn man den ChecksummerVC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht. Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop & Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.

- Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 20 feststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.
- bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.
- wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 63999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.

Viel Spaß beim Eintippen von Programmen mit dem neuen Checksummer!

(F. Lonczewski / gk)

# Vier Pseudo-VICs mit 32 Sprites

> Sie wollen mit 32 Sprites und vier Bildschirmbereichen gleichzeitig arbeiten? Nichts leichter als das. Mit Provic 64 können simultan Grafik, Text oder veränderte Zeichensätze dargestellt werden.

Die Autoren (Jürgen, 21, Physikstudent, und Stefan, 18, Schüler) haben sich Mitte 1983 einen Commodore 64 angeschafft. Schon nach kurzer Zeit stellte sich der bei den C 64-Fans übliche Frust über die schlechte Dokumentation und die schwierige Informationsbeschaffung ein, besonders wenn es um die speziellen Grafikfähigkeiten dieses Computers geht. So sitzen wir oft stundenlang vor dem Bildschirm, der nur undefinierbare Zeichen zeigt, weil wir bei dem Versuch, die Geheimnisse des C 64 zu enträtseln, in irgendeinen unbekannten Darstellungsmodus geraten sind.

Dabei entdeckten wir, daß der C 64 nicht nur acht, sondern auch 16, 24, 32 oder noch mehr Sprites gleichzeitig zeigen kann. Zusätzlich ergibt sich die Möglichkeit, mehrere Bildschirmmodi zu mischen.

Nun haben wir uns entschlossen, den Kunstgriff, der dies ermöglicht, anderen C 64-Fans nicht vorzuenthalten. Also entwickelten wir ein Programm in Maschinensprache und dazu ein kleines Demonstrationsprogramm in Basic.

### Zum Programm

Durch Aufruf der Initialisierungsroutine wird der Interruptmechanismus des C 64 verändert. Nicht mehr der Timer der CIA 1, sondern der VIC 6567 löstjetzt den Interrupt aus, und zwar synchron zum Takt des Bildschirmsignals. Außerdem werden vier sogenannte Pseudo-VICs eingerichtet. Alle PO-KEs, von Spritebewegung über Bildschirmfarbe bis zur Grafikkonfiguration, müssen abjetzt in diese Pseudo-VICs erfolgen. Jeder dieser Pseudo-VICs ist für einen der vier Bildschirmbereiche zuständig:

Der Bildschirm wird in vier waagerechte Bereiche aufgeteilt, deren Grenzlinien fast beliebig nach oben oder unten verschoben werden können. Jedereinzelne Bereich kann acht Sprites darstellen und eine eigene Farb- und Grafikkonfiguration aufweisen. So können zum Beispiel Normalschrift, HiRes-Grafik, Multicolor-Grafik und eventuell ein selbstdefinierter Zeichensatz gleichzeitig auf dem Bildschirm gezeigt werden.

Provic 64 kann selbstverständlich wieder abgeschaltet werden (bei Kassetten- oder Diskettenoperationen nötig).

Für Maschinensprachefreaks nun eine kurze Funktionsbeschreibung der Interruptroutine:

Bei Aufruf der Einschaltroutine (SYS 52544) wird der IRQ-Vektor auf die Hauptroutine des Provic 64 gestellt und der bisherige Interrupt durch den Timer A der CIA 1 verboten, während der Raster-IRQ des VIC 6567 erlaubt wird.

Sobald der Bildschirmstrahl die eingestellte Rasterzeile erreicht, wird ein Interrupt ausgelöst und der Prozessor bearbeitet die Hauptroutine des Provic 64. In dieser wird zunächst anhand eines Zählers ($ CFFF) festgestellt, welcher Bildschirmbereich an der Reihe ist. Dann wird die Rasterzeile, die das Ende dieses Bildschirms kennzeichnet, eingestellt.

Anschließend werden, falls ein entsprechendes Flag gesetzt ist, die Sprite- und andere Bildschirmparameter in den VIC 6567 übertragen. Nach dem Weiterzählen des IR-Zählers ($ CFFF) wird entweder der Interrupt beendet, oder zur IRQ-Routine des Betriebssystems gesprungen (nach jedem vierten Interrupt). So werden in der Sekunde 200 Interrupts (vier pro Fersehbild) ausgelöst und 50 mal in der Sekunde (einmal pro Bild) die normale IRQ-Routine abgearbeitet. Dadurch zählt die interne UhrTI in 50stel Sekunden und Tl$ wird unbrauchbar.

Beim Aufruf der Ausschaltroutine wird der Raster-IRQ des VIC 6567 unterbunden, der Interrupt des Timers A in CIA 1 erlaubt und der IRQ-Vektor auf die IRQ-Routine des Betriebssystems eingestellt.

## Handhabung der Pseudo-VICs

Im Grunde ist jeder der vier Pseudo-VICs wie der echte VIC zu behandeln. Ausnahmen sind hier nur die Register 30 (Sprite-Sprite-Kollision) und 31 (Sprite-Hintergrund-Kollision), die sich auf den jeweils vorausgegangenen Bildschirmbereich beziehen. Die Register 19 und 20 (Lightpenkoordinaten), sowie 25 und 26 (IRQ-Flags und -maske) werden nicht behandelt, da diese Funktionen nur direkt über den VIC 6567 sinnvoll gehandhabt werden können. Außerdem hatjeder Pseudo-VIC noch zusätzliche Register für zwei Flags (REG 47 und REG 57), acht Sprite-Pointer (REG 48 bis REG 55), Videomatrix-Anfangsadresse Highbyte (REG 56) und die CIA 2, REG 0, Bits 0 und 1 (REG 58) (Adreßbits 14 und 15 des VIC 6567).

### Übergang eines Sprites zwischen zwei Bildschirmbereichen:

Soll ein Sprite zwischen zwei Bildschirmbereichen wechseln, muß in beiden Bereichen derselbe Sprite (also zum Beispiel beidesmal Sprite 4) die gleiche Position besitzen, und zwar so lange, wie der Sprite die Trennlinie zwischen den Bereichen überdeckt. Wird dies nicht beachtet, werden die entsprechenden Sprites zerschnitten und verschoben.

Aktivieren von Provic 64: Von Basic aus mit SYS 52544 und von Maschinensprache aus mit JSR $CD40.

Ausschalten von Provic 64: Von Basic aus mit SYS 52970 und von Maschinensprache aus mit JSR $CEEA.

### Der Basic-Lader:

Der Lader erzeugt Provic 64 aus den DATA-Zeilen und falls kein Prüfsummenfehler vorliegt, wird Provic 64 sofort als Maschinenprogramm auf Floppy oder Datasette (Zeile 400 entsprechend ändern!) abgespeichert. Dieses Maschinenprogramm enthält auch gleich die Standardwerte der Pseudo-VICs.

Laden von Provic 64: lm Programm am besten mit der Zeile IF PEEK(52544)><120 THEN LOAD ”PROVIC64”,Gerätenummer, 1 die am Anfang des Basic-Programms stehen sollte.

Das Demonstrationsprogramm zeigt einige der Vorzüge von Provic 64. Es ist nur als Anregung gedacht, deshalb verzichten wir hier auf eine nähere Beschreibung.

Provic 64 ist nicht nur für Basic-Programmierer, sondern vor allem auch für Maschinensprache-Freaks gedacht, da erst durch schnelle Maschinenprogramme die Möglichkeiten von Provic 64 voll ausgeschöpft werden können.

(Jürgen und Stefan Haas/rg)

Die vier Basisadressen der PVICs sind:
PVIC 1	52992 ($ CF00)	= REG 0
PVIC 2	53056 ($ CF40)	= REG 0
PVIC 3	53120 ($ CF80)	= REG 0
PVIC 4	53184 ($ CFC0)	= REG 0
TODO

Da die Pseudo-VICs praktisch gleichberechtigt sind, hier die Registerbeschreibung eines Pseudo-VICs:

TODO

# Hypra-Load mal vier

> Selten hat ein Programm so viele Leserreaktionen hervorgerufen wie Hypra-Load. Deswegen führen wir Ihnen heute vor, was man mit Hypra-Load noch so alles machen kann.

Hätten wir doch bloß nicht unsere Telefonnummern angegeben. Das war unser beherrschender Gedanke in den ersten Tagen nach Erscheinen der Ausgabe 10/84 des 64’er-Magazins. Doch nach und nach begannen wir am Telefonieren Gefallen zu finden, wohl auch deswegen, weil fast alle Anrufer so nett und höflich waren, und uns einige gute Tips und konstruktive Kritik gaben. Uns erreichten sogar Telefonate aus der Schweiz, Österreich, Holland und Dänemark.

Viele Anrufer hatten ein gemeinsames Problem: Nach RUN meldete sich der Basic-Lader immer mit FEHLER IN DATENBLOCK 100-109, obwohl dort garantiert kein Fehler vorlag. Manche Leser haben diesen DATA-Block mehrere Male eingetippt, und sogar von Hand aufaddiert und verglichen, konnten aber keinen Fehler finden. Hatte vielleicht unser Druckfehlerteufelchen zugeschlagen? Nein, das hatte genug Respektvor der DATA-Wüste, um sie zu verschonen. Des Rätsels Lösung: Uns unterlief ein Denkfehler im Prüfsummenprogramm. Denn das arbeitet nur dann korrekt, wenn alle Zeilen und alle Kommata eingegeben werden, sonst meldet die total verwirrte Prüfsummenroutine einen Fehler, wo gar keiner ist. Entgegen unserer Aussage, daß Hypra-Load mit dem SX 64 nicht funktioniert, hatten einige SX 64-Besitzer keine Probleme. Es scheint drei oder vier verschiedene SX 64-Versionen zu geben, von denen sich mindestens eine nicht mit Hypra-Load verträgt. Wir wollen die genauen Gründe noch erforschen, und bitten alle SX 64-Besitzer um ihre Hilfe. Schreiben sie uns ihre Erfahrungen mit ihrem SX 64. Welche Programme laufen, welche nicht? Insbesondere würde uns dann die Seriennummer ihres SX 64 interessieren.

Unsere Bemühungen, Hypra-Load für den VC 20 umzuschreiben, scheiterten bisher an dessen Busstruktur.

Ein Fehler schlich sich in der Beschreibung zu Hypra-Load ein. Um es nach einem RESET mit einem Taster wieder einzuschalten, muß als erstes POKE 40960, PEEK (40960) eingegeben werden. Dann darf mit POKE 1,53 eingeschaltet werden.

So, nach dieser langen Vorrede aber endlich zu den versprochenen Änderungen an Hypra-Load.

## Hypra-Boot

Manche Leser ärgerten sich darüber, daß, wolle man ein bestimmtes, langes Programm schnell laden, zwei LOAD- und zwei RUN-Befehle notwendig sind. Deswegen haben wir Hypra-Load zu Hypra-Boot umgeschrieben. Wie funktioniert Hypra-Boot? Nach dem Laden und Starten von Hypra-Boot wird automatisch ein weiteres Programm von Diskette nachgeladen und gestartet. Dieses Programm muß, wenn es kein Basic, sondern ein Maschinenprogramm ist, allerdings am Basic-Start mit zumindest einem SYS-Befehl vertreten sein, da Hypra-Boot den RUN-Befehl simuliert.

Und so geben sie Hypro-Boot ein: Laden Sie den Basic-Lader, das heißt, das in Ausgabe 10/84 abgedruckte Programm. Geben Sie nun die in Listing 1 abgedruckten Änderungen ein.

Damit Sie beliebige Programme nachladen können, müssen Sie natürlich noch den Filenamen des nachzuladenden Programms angeben. Dies geschieht wie folgt in der Zeile 276. Geben Sie als DATA-Werte die ASCII-Codes der ersten sieben Buchstaben des Filenamens und als achten Wert 042 (ASCII-Code für \*) ein. Kürzere Filenamen sind erlaubt, dann muß der Stern aber auch früher stehen, soll kein FILE NOT FOUND ERROR gemeldet werden.

Da die DATA-Zeilen schon mit Prüfsummen für unseren Checksummer versehen sind, nimmt das Programm selbst keinen Prüfsummencheck vor!

Es wird auch nicht mit RUN, sondern mit GOTO 520 gestartet. Danach speichern Sie Hypra-Boot unter dem gewünschten Namen.

Hypra-Boot kann nicht nur Einzelprogramme,.sondern zum Beispiel auch ein Menü-Programm oder ähnliches laden.

Ganz Verwegene können Hypra-Boot noch mit einem Autostart versehen. Allerdings ist Vorsicht geboten, sollen Autostart-Programme nachgeladen werden. Wenn diese den Stack überschreiben, kann es Konflikte mit Hypra-Boot geben. Am besten, Sie probieren es einfach aus. Hypra-Boot lädt immer wie LOAD”name”,8,1!

Es kann ab und zu passieren, das Hypra-Boot beim Nachladen »VERIFYlNG« anzeigt. Dies hat nichts zu bedeuten und tritt nur auf, wenn Hypra-Boot selber ein Autostart-Programm ist. Es empfiehlt sich, Hypra-Boot so zu nennen, wie das nachzuladende Programm. Dieses erhält dann einen Namen wie ”101” oder ähnliches. Dann können mehrere Hypra-Boot-Programme auf einer Diskette stehen.

Sollten Sie den Basic-Lader nicht besitzen, so wird es etwas kompliziert. Sie müssen, nach dem Laden von Hypra-Load, die entsprechenden DATA-Werte von Hand an die Speicherstellen von 3385 bis 3464 POKEn. Sie tippen also ein:
POKE 3385, 245
POKE 3386, 169
...
POKE 3464, 000

Vergessen Sie dabei nicht, sich vorher die DATA-Werte für den Filenamen zu notieren!

## Hypra-Track 18

Wer sich weder ein Modul brennen, noch das Betriebssystem austauschen möchte, wäre froh, wenn er Hypra-Load auf jeder Diskette abspeichern könnte, um sich Diskettenwechsel zu ersparen. Aber da gibt es doch immer einige Disketten, die sich strikt weigern, Hypra-Load noch aufzunehmen, da weniger als 6 Blöcke frei sind. Was soll man tun? Weiterhin Disketten wechseln, den Inhalt auf zwei Disketten verteilen, oder auf Hypra-Load verzichten?

Es gibt noch eine letzte Rettung: Hypra-Load wird ins Directory-Track geschrieben. Normalerweise passen in ein Directory 144 Einträge. Wenn Hypra-Load am Ende des Directory-Tracks steht, ist dieses auf 88 Einträge begrenzt. Die normale Funktion des Directory wird dadurch nicht beeinträchtigt! Das Programm überprüft natürlich, ob weniger als 88 Einträge vorhanden sind, damit nichts aus Versehen gelöscht wird.

Das als Listing 2 abgedruckte Programm schreibt Hypra-Load in folgende Sektoren der Spur 18: 3,6,9,12,15,18.

Der Filename, den Hypra-Load tatsächlich erhalten soll, ist frei wählbar. An diesen wird »”,8:« angehängt Somit ist es möglich, bei gelistetem Directory nur mit dem Cursor auf diesen Fileeintrag zu fahren, LOAD zu schreiben und RETURN zu drücken. Nach dem Laden startet man es, wie gewöhnlich, mit RUN.

Und so geben sie Listing 2 ein:

1. Laden Sie den Basic-Lader von Hypra-Load, abgedruckt in Ausgabe 10/84
2. Löschen Sie alle Zeilen außer die Zeilen von 100 bis 279
3. Geben Sie nun Listing 2 zusätzlich ein.
4. Speichern Sie das Ganze auf Diskette.

Wir empfehlen, unbedingt einen Testlauf mit einer leeren formatierten Diskette zu machen, da sich Tippfehler eingeschlichen haben könnten. Es wird kein Prüfsummenvergleich vorgenommen! Nach erfolgreichem Testlauf kann Hypra-Load auf praktisch alle Disketten überspielt werden.

## Hypra-ROM

Manchmal ärgerten sogar wir uns darüber, daß Hypra-Load dann und wann neu geladen werden muß, sei es, weil der Computer eingeschaltet wurde, sei es, weil irgendein Programm mal wieder Hypra-Load oder das Basic-RAM überschrieben hatte. Hypra-Load resident machen, hieß also die Devise. Und wenn man nicht gerade das Betriebssystem auswechseln möchte, bietet es sich geradezu an, Hypra-Load in ein Modul zu brennen.

Hierzu sind weit weniger Änderungen nötig, als erwartet. Ganze vier DATA-Werte müssen modifiziert werden, soll Hypra-Load nicht ab $0800 sondern ab $8000 im Speicher stehen.

Es sind dies folgende Werte:

TODO

In den entsprechenden Bereich schreiben Sie Hypra-Load wie folgt:
FOR I = 32 769 TO 34207 : READ A : POKE I,A : NEXT I

Bitte führen sie keinen RUN aus, daja nun die Checksummen nicht mehr stimmen. Gestartet wird das Ganze nun mit SYS 33958. Hypra-Load meldet sich wie gewohnt. Dieses Programm kann auch in ein Modul gebrannt werden. Auf einen Autostart im Modul wurde verzichtet, da es ja einige Programme gibt, die sich mit Hypra-Load nicht vertragen (zum Beispiel Simons Basic).

Hier noch die POKEs für alle, die nur das Maschinenprogramm haben:
POKE 3301, 130: POKE 3332, 128
POKE 3356, 133: POKE 3343, 132

Danach muß der Speicherbereich von $0800 bis $0E00 nach $8000 verschoben werden, am besten mit einem Monitor oder einer FOR-NEXT-Schleife.

Dieser Bereich kann nun auch in ein EPROM gebrannt werden.

Wer Hypra-Load in andere Bereiche verschieben möchte, der sollte sich mit einem Disassembler das Umfeld der vier angegeben Adressen ansehen, und die Angleichungen selber vornehmen. Zu beachten ist nur, daß all diese Versionen immer noch das Betriebssystem ins RAM kopieren und dort verändern. Auf diese Art und Weise ist es nicht möglich, das Betriebssystem im ROM zu ändern!

## Schnelles Laden ohne Laden

Das Arbeiten mit Hypra-Load und dem Diskettenlaufwerk 1541 ist für viele Commodore-Besitzer schon zur unverzichtbaren Gewohnheit geworden. Leider muß das Programm zuvor immer noch von Diskette geladen werden. Fest im Betriebssystem einprogrammiert entfällt dieser Nachteil.

Jedes Programm, daß die Datenübertragungsgeschwindigkeit vom Diskettenlaufwerk zum Computer beschleunigt, büßt einen Teil seines Geschwindigkeitsvorteils ein, weil es erst geladen und gestartet werden muß. Wesentlich angenehmer ist es, wenn der Computer schon nach dem Einschalten die gewünschte Laderoutine verwenden kann. Um zu diesem Ziel zu gelangen, sind zwei Wege denkbar. Zum einen kann man sich, ähnlich einem Spielmodul, eine Steckplatine mit EPROMs bauen und diese am Expansion-Port anschließen. Zum anderen besteht aber die Möglichkeit, den Computer intern zu verändern, indem ein neues Betriebssystem eingebaut wird. Die Vorteile der zweiten Methode sind beachtlich.

Dadurch, daß die Änderung des Betriebssystems nicht mehr im RAM-Bereich von $EOOO-$FFFF liegt, sondern im gleichen, darüberliegenden ROM-Bereich, steigt die Kompatibilität mit jeder Art von Programmen enorm. Die Erklärung dafür ist einfach. Viele Programme verwenden den $E000-Bereich, indem sie ihn kopieren und für ihre eigenen Zwecke modifizieren. Jedes dort befindliche Programm wird damit selbstverständlich überschrieben. Dazu gehören aber leider immer Betriebssystemänderungen wie beispielsweise das Hypra-Load. Steht die Veränderung aber im darüberliegenden ROM, so entstehen diese Probleme kaum noch, denn der beschriebene RAM-Bereich steht, wie bei jedem Original-Betriebssystem, frei zur Verfügung.

Natürlich ist zum Einbau des neuen Betriebssystems ein Eingriff in den Computer notwendig. Das alte Kernal-ROM muß gegen das neue ausgetauscht werden. Wie das gemacht wird, haben wir in der letzten Ausgabe ausführlich beschrieben. Die wichtigsten Arbeitsschritte werden aber trotzdem nocheinmal erklärt. Zunächst ist es notwendig, das abgebildete Basic-Programm einzugeben und zu starten. Wenn es fehlerfrei funktioniert, kann esabgespeichertwerden. Als nächstes wird ein EPROM-Programmiergerät benötigt, das in der Lage ist, EPROMs vom Typ 2764 zu brennen. Dieses Programmiergerät wird nun angeschlossen. Der nächste Arbeitsgang besteht aus der eigentlichen Veränderung des Betriebssystems. Alle notwendigen Programmierungen werden vom abgedruckten Programm selbständig durchgeführt. Dazu wird zunächst der Bereich $EOOO-$FFFF nach $6000-$7FFF kopiert. In Overlaytechnik werden anschließend sowohl das Hypra-Load als auch eine Funktionstastenbelegung programmiert. Wer auf die Funktionstastenbelegung verzichten möchte, braucht im Listing übrigens nur die Zeilen 8000 bis 9000 wegzulassen. Nachdem das Programm durchgelaufen ist, befindet sich im Bereich $6000 bis $7FFF ein komplettes, neues Betriebssystem, das lediglich noch in ein EPROM gebrannt werden muß. Selbstverständlich darf die Treibersoftware für das EPROM-Programmiergerät nicht in diesem Bereich liegen.

Das fertig gebrannte EPROM wird einfach im Steckplatz U4 auf der Computerplatine mit einem Adapter eingesteckt. Der Adapter ist leider wegen der unterschiedlichen Pinbelegung der Commodore-ROMs und des EPROMs unabdingbar. Auch wenn die Herstellung eines solchen Zwischenstücks etwas Geschick erfordert, stellt sie doch kein unüberbrückbares Problem dar.

Wenn der Computer nun nach dem Einschalten seine Bereitschaftsmeldung zeigt, steht dem schnellen Laden nichts mehr im Weg. Andernfalls sollten Sie das EPROM löschen und den Vorgang wiederholen. Die Belegung der Funktionstasten entspricht der in der letzten Ausgabe veröffentlichten, hinzugekommen istaber die Belegung der RUN-Taste. Durch einmaliges Betätigen sind wieder die langsamen Laderoutinen aktiviert. Ein zweiter Druck auf die gleichen Tasten schaltet wieder auf Hypra-Load. Leider muß gelegentlich, besonders bei Autostartprogrammen, von dieser Funktion Gebrauch gemacht werden. Auch sollte zum Laden von Programmen nur ein Peripheriegerät eingeschaltet sein, da sonst eine Fehlermeldung ausgegeben wird. Die Belegung der Funktionstasten kann bei Bedarf mit Poke 2,1 ausgeschaltet und mit Poke 2,0 wieder angeschaltet werden.

Abgesehen von diesen Nachteilen und den nicht mehr möglichen Betrieb eines Datenrecorders, läßt sich mit dem neuen Betriebssystem sehr gut arbeiten. In einer der nächsten Ausgaben werden wir dem Commodore 64 und dem MPS 802 zusätzlich noch einen deutschen Zeichensatz verleihen. Schnelles Laden und eine Funktionstastenbelegung — der Commodore macht sich.

(Günther Reimuth/Uwe Schönewolf/Boris Schneider/Erich Schöberl/Arnd Wängler/gk)

# Der C 64 als PET

> Wenn Sie CBM 2000, 3000 oder 4000 geschriebene Programme auf Ihrem C 64 laufen lassen wollen, müssen Sie umständlich PEEKs und POKEs ändern. Der »Pet-Simulator« nimmt Ihnen diese Arbeit ab.

Ist das Programm eingegeben und gestartet, werden als erstes die DATAs für das Maschinenprogramm in den Bereich ab Adresse 49152 gePOKEt (SU = Prüfsumme für die Daten). Danach fragt das Programm nach der Zeichenfarbe. Sie wer-^ den aufgefordert, eine Zahl zwischen 0 und 15 einzugeben. (0 = schwarz, 1 = weiß, ..., 15 = grau 3).

Bei anschließendem Starten des Maschinenprogrammes wird das Basic-ROM in das darunterliegende RAM gePOKEt (Basic-Interpreter kopieren). Anschließend wird das Bildschirm-RAM von Adresse 1024 nach Adresse 32768 verlegt. Basic-Speicheranfang und -ende, werden dem des PET angepaßt. Weiterhin wird in der POKE-Routine des Basic-Interpreters ein Eingriff vorgenommen, nach der der Computer aus dem Interpreter in eine Routine des Maschinenprogramms springt. Hier wird überprüft, ob das Bildschirm-RAM angesprochen wurde. Trifft dies zu, wird die dazugehörige Farb-RAM-Adresse berechnet und der vorher festgelegte Farbwert (Zeichenfarbe) hineingePOKEt. Um das Zurücksetzen des Bildschirmes auf das C 64-Format zu vermeiden (durch Drücken der RUN/STOP- und RESTORE-Tasten) wird die RESTORE-Taste durch Verändern des NMI-Vektors ausgeschaltet. Programme können aber noch mit der RUN/STOP-Taste unterbrochen werden.

Nach Ablauf des Maschinenprogrammes meldet sich der Computer mit »PET-SIMULATOR AKTIV«. Sie können jetzt immer noch die Zeichenfarbe mit POKE 49239, ZF (ZF = Zeichenfarbe — siehe oben) ändern. Wenn Sie jetzt zum Beispiel POKE 32768,1 eingeben, erscheint ein »A« am linken oberen Bildschirmrand in der gewählten Zeichenfarbe. Schlußbemerkung: Bevor Sie das Programm starten, empfiehlt es sich, es vorher abzuspeichern, da sich das Programm selbständig löscht.

(Wolfgang Hopf/rg)

# Parameterübergabe an Programme in Maschinensprache

> Der SYS-Befehl läßt es zu, daß neben der Startadresse des Maschinenprogrammes auch Parameter übergeben werden.

Das kann zum Beispiel so aussehen: SYS adresse,p1,p2,p3,... . Wobei »adresse« Startadresse bedeutet und p1 bis p3 die Parameter sind. Für die Verarbeitung der Parameter ist es wichtig zwischen 1-Byte- und 2-Byte-Parametern zu unterscheiden, da unterschiedliche Interpreterroutinen nötig sind.
Hier sind die benötigten Interpreterroutinen:
Komma = $AEFD
1byte = $B79E
2byte = $B7EB
Dabei ist die Routine »Komma« nötig, um die Kommas vor den Parametern zu erkennnen und die Parameter zu trennen. Anschließend können dann die Parameter mit »1byte« oder »2byte« eingelesen werden.

### Übergabe von 1-Byte-Werten
Die Befehle
JSR $AEFD ; Komma
JSR $B79E ; 1byte
laden den Parameter bei SYS...,p1 ins X-Register des Prozessors, wo er für die weitere Verarbeitung bereitsteht. Jetzt ist es zum Beispiel möglich p1 zu verarbeiten und mit JSR Komma : JSR 1byte den nächsten Parameter (p2) zu holen. Angewandt wird dies im Beispielprogramm Cursorsetzen.

Folgendes passiert: Nacheinander werden »zeile« (120,130) und »spalte« (160,170) eingelesen und schließlich verarbeitet. Die Routine $FFFO setzt bei gelöschtem Carry-Flag den Cursor nach den Werten im X- und Y-Register an die gewünschte Position, wie schon in Ausgabe 7/84 beschrieben.

Aufruf des Hilfsprogrammes das im Kassettenpuffer liegt: SYS 828,zeile,spalte
(siehe Listing 1)
SYS 828,10,5:PRINT CHR$(42) setzt den Stern \* auf Zeile 10, Spalte 5.

### Übergabe von 2-Byte-Werten

Die Befehle
JSR $AEFD ; Komma
JSR $B7EB ; 2byte
bringen den ersten Parameter bei SYS...,p1,p2 auf die Zeropage Adresse $14/$15, und den zweiten ins X-Register, da die Routine $B79E : 1byte (siehe oben) mit aufgerufen wird. Hierbei wird p1 nach Low- und High-Byte getrennt abgespeichert. Sein Wert kann alsozwischen 0 und 65535 (= 2t15) liegen. Der Interpreter benutzt diese Routine, um zum Beispiel bei POKE Speicherzellen mit bestimmten Werten zu laden.

Das nächste kleine Programm soll nun den Gebrauch der Routine 2byte = $B7EB demonstrieren. Es erspart das doppelte POKEn von Bildschirm- und Farb-RAM. Der Aufruf hat die Form:
SYS 828,position, zeichen,farbe

Da »position« hier ein 2-Byte-Wert ist, muß die Routine $B7EB benutzt werden, gleichzeitig wird dadurch »zeichen« ins X-Register geladen. »Farbe« wird dann später in Zeile 210 über $B79E geladen (siehe Listing 2).
SYS828,1063,1,1 setzt ein weißes A in die rechte obere Ecke des Bildschirms.

Zum Schlußnoch die Basic-Lader der Demoprogramme, für diejenigen, die keinen Assembler oder Monitor besitzen, aber die Routinen gebrauchen können. Sie liegen jeweils im Kassettenpuffer(ab828). DurchVerändern der Werte in Zeile 110 lassen sie sich jedoch nach Bedarf verschieben.

(Markus Kuhn/rg)

# Große Buchstaben

> Wer hat in Titelbildern eigener Spiele nicht schon über die »normalen« Buchstaben geklagt? Mit diesem Programm wird das anders.

Auf die Idee, dieses Programm zu verfassen, kam ich, als mir die immer gleich großen Buchstaben in den Titelbildern vieler Spiele so auf den Wecker gingen, daß ich selbst zum Programmierwerkzeug griff.

Das Programm stellt auf dem Bildschirm maximal 86, in der Höhe doppelt so große, Buchstaben dar. Diese könne jeweils aus 1 bis 2 Farben bestehen.

Nun zum Programm selbst. In Zeile 5 bis 6 stehen die DATAs für das Maschinenprogramm, das den Bereich ab 12288 auf 0 setzt. Dadurch wird ein fließender Aufbau der Buchstaben garantiert. Die Zeilen 7 bis 10 lesen und starten das Maschinenprogramm. In Zeile 20 werden die Grundadresse des VIC sowie die neue Zeichensatz-Startadresse Variablen zugewiesen. Zeile 22 schaltet auf den neuen Zeichensatz um. Zeile 25 dient zum Setzen der Screen-Farben.

Die Variable »D« in Zeile 30 legt fest, ab welchem Zeichen umdefiniertwerdenkann. DerWertist82, dabis hier alle wichtigen und oft benötigten Zeichen, noch zum Auslesen nötig sind. Ab Zeile 60 beginnt dann das Setzen der umzudefinierenden Zeichen. Von Zeile 120 bis 180 werden dann die gesetzten Zeichen umdefiniert und damit die neue Schrift auf dem Screen dargestellt. Das Ganze funktioniert wie folgt. Zuerst werden die alten Zeichen je viermal Byte für Byte ausgelesen. Jedes einzelne Byte wird dann zweimal dargestellt. Jetzt ist ein Zeichen umdefiniert. Nun wird der zweite Teil des Zeichens ausgelesen, verdoppelt und dem darunterliegenden Zeichen zugeordnet. In dem Unterprogramm ab Zeile 300 wird die Anfangsposition einer Druckzeile festgelegt.

Die DATAs für den Text können dann ab 500 stehen. Wenn dieses Programm aber später nur als Unterprogramm verwendet werden soll, empfiehlt es sich die DATA-Zeile ans Ende dieses Programms zu verlegen.

Eine DATA-Zeile ist folgendermaßen aufgebaut:

1.	Spalte in der der Text später beginnen soll
2.	Zeile
3.	Anzahl der Zeichen die in eine Reihe sollen
4.	Farbe obere Zeichenhälfte
5.	Farbe untere Hälfte
6.	-XX. Hier stehen die Bildschirmcodes der darzustellenden Zeichen.

Wichtig — als letztes Datum muß unbedingt fünfmal die -1 stehen. Da das Programm sehr kurz ist, ist es hervorragend zur Titelbildgestaltung von Spielen, Anwenderprogrammen oder ähnlichem geeignet.

(Matthias Baldauf/rg)

# Restore für Unterprogramme

Wenn beide Programmteile, Hauptprogramm und Unterprogramme, DATAs enthalten, muß sichergestellt werden, daß auch wirklich die richtigen Werte gelesen werden. Wenn man nichtaufpaßt, kann es passieren, daß das Unterprogramm DATAs aus dem Hauptprogramm liest. Wie kann man das verhindern? Es gibt eine umständliche Methode: Man kann eine kleine Basic-Erweiterung einbauen, den RESTORE X-Befehl. Es geht aber auch einfacher. Die Zeropage, das sind die ersten 256 Byte des Speichers, hilft uns bei der Lösung des Problems. Genauer gesagt, die Adressen 65/66 und 122/123. Schlagen wir im C 64-Handbuch auf Seite 162 nach, dann steht dort:
65 - 66 Adresse des aktuellen DATA-Elements
122 - 123 Basic-ZeigerinnerhalbderSubroutine

Mit diesen Informationen läßt sich schon etwas anfangen. Wenn das Unterprogramm angesprungen wird, dann sollte der Zeiger in Speicherstelle 122/123 auf die Adresse des Unterprogramms im Speicher stehen. POKEt man diese Werte in die Zeilen 65/55 mit
POKE65,PEEK(122)
POKE 66,PEEK(123),
so wird beim nächsten READ der Wert gelesen, der hinter dieser Basic-Zeile mit den POKEs steht, also das erste DATA-Element innerhalb des Unterprogramms. Nach dem Rücksprung aus dem Unterprogramm muß der Zeiger eventuell auch im Hauptprogramm wieder gestellt werden.

In dem kurzen Demo-Listing werden drei Unterprogramme in zufälliger Reihenfolge aufgerufen.

(Stephan Pätzold/gk)

# Lösungen von Abenteuerspielen: Dallas Quest

Nachdem wir die Lösung von The Blade of Blackpool veröffentlicht hatten, bekamen wir Hunderte von Zuschriften mit der Bitte, dem einen oder anderen bei dem Abenteuerspiel xyz an der Stelle abc weiter zu helfen. Dies ist natürlich aus den verschiedensten Gründen nicht möglich. Dazu müßte bei den meisten Abenteuerspielen die Vorgeschichte bekannt sein, um genau zu wissen, welche Gegenstände man bei sich trägt, welchen Weg man vorher zu dieser Stelle beschritten hat, etc. Ein extrem zeitaufwendiges Unterfangen also. Zudem versteht sich das 64’er Magazin nicht als Spiele-Zeitschrift, obgleich dieser Aspekt des Computereinsatzes nicht außer Acht gelassen wird.

Für 15 bekannte Abenteuerspiele gibt es jetzt übrigens bei Markt & Technik ein Buch mit ausführlicher Beschreibung des Lösungsweges. Da aber ein Buch nicht so aktuell wie eine Zeitschrift sein kann, wollen wir in loser Folge für die neuesten Abenteuerspiele Lösungen anbieten. Unsere Leser sind daher zur regen Mitarbeit aufgerufen. Haben Sie ein Adventure gelöst, so lassen Sie doch Ihre verzweifelten Mitabenteurer daran teilhaben. Den Anfang macht Wolfgang Habich mit der Lösung von Dallas Quest.

<aside>
east, north, take sunglases, north, give sunglases, go barn, drop owl, take shovel, south, south, south, take envelope, west, take bugle, west, wait, wait, blow bugle, dig, look tombstone, read epitaph, east, drop money, north, open desk, take pouch, north, north, west, west, north, look plane, give envelope, open knapsack, look knapsack, take parachute, drop ring, close knapsack, take knapsack, jump, open pouch, give pouch, close pouch, south, south, look, look parrot, tickle anaconda, south, south, go dinghy, open pouch, give pouch, close pouch, row boat, blow bugle, read sign, go post, open pouch, give pouch, close pouch, look ladder, drop all, open knapsack, (mit take und drop alles einpacken bis auf parachute und bugle),close knapsack, pull curtain, take flashlight, light flashlight, climb ladder, read sign, drop flashlight, east, go post, take knapsack, climb ladder, drop knapsack, east, go post, take shovel, climb ladder, take all, west, unlit flashlight, open knapsack, take photograph, show photograph, read sign, drop photograph, take coconuts, west, look monkey, take pouch, open pouch, give pouch, give eggs, take mirror, give mirror, take ring, wave ring, warm eggs, light flashlight, drop ring, look floor, take map, no, unlit flaslight, give map.
<aside>

Auf Anweisung des Computers return drücken!

Viel Spaß beim Nachvollziehen.

(Wolfgang Habich)

# Müllabfuhr im Computer: Die Garbage Collection

> Wer viel mit Strings arbeitet, wurde wohl schon öfter mit einem Problem konfrontiert, der Garbage Collection. Um was es dabei geht, und warum es sich lohnt, sich etwas mehr mit Strings zu beschäftigen, erfahren Sie in folgendem Artikel. Dies soll zugleich der Auftakt zu einer Serie sein, in der wir uns mit speziellen Problemen und Programmiertechniken beschäftigen werden.

Kennen Sie das? Sie haben ein Basic-Programm geschrieben, starten es, und eine Zeit lang läuft es perfekt. Und plötzlich, wenn Sie nur mal zwei Strings vertauschen oder die FRE-Funktion aufrufen, spielt Ihr Computer nicht mehr mit, ja, er reagiert nicht einmal mehr auf die STOP-Taste. Warten Sie dann einige Sekunden oder Minuten, ist der Spuk vorbei. Ihr Computer tut so, als sei nichts geschehen. In solchen Augenblicken hat der Basic-Interpreter mal wieder Müllabfuhr gespielt, er hat die »Garbage Collection« durchgeführt. Dieses Wort ist der Alptraum mancher Programmierer, die schnelle Programme schreiben möchten, welche Strings in großen Mengen benutzen.

Hier sind schon einige Stichworte gefallen: Bei der Garbage Collection handelt es sich wohl um etwas, das mit Strings zu tun hat und wohl auch mit Speicherplatz.

Um allerdings genau zu verstehen, was es mit dieser Routine auf sich hat, und welche programmtechnischen Wege man gehen muß, um sie zu meiden, müssen wir uns erst einmal mit dem computerinternen Aufbau von Strings und Stringarrays beschäftigen.

## Was ist ein String?

Ein String ist eine Zeichenkette, also eine Aneinanderreihung von Zeichen aus dem Zeichensatz eines Computers. Unserem Computer zeigen wir an, daß er die nächste Eingabe als String betrachten soll, indem wir selbigem ein Gänsefüßchen voranstellen. Mit einem solchen geben wir ihm auch das Ende eines Strings bekannt.

Ein String hat immer eine bestimmte Länge, sie entspricht der Anzahl der in ihm enthaltenen Zeichen. Die Länge darf zwischen 0 und 255 betragen, weil der Computer nur über Umwege mehr als 255 Zeichen auf einmal überblicken könnte. Bei einer Länge von Null spricht man übrigens auch von einem Leerstring, weil keine Zeichen in ihm enthalten sind, nicht zu verwechseln mit einem String, der Leerzeichen (Spaces, Blanks) enthält.

Da es unpraktisch wäre, jedesmal, wenn ich einen bestimmten String bearbeiten will, diesen vollständig einzugeben, gibt es die Stringvariablen. Eine Stringvariable ist nichts anderes als ein Platzhalter für einen String. Wenn ich beispielsweise der Stringvariablen A$ den String »BORIS SCHNEIDER« zuteilen möchte, so schreibe ich:
A$="BORIS SCHNEIDER"

Das Dollarzeichen hinter dem Variablennamen zeigt dem Computer an, daß es sich hier um eine Stringvariable handelt. Nun kann ich im weiteren Verlauf jedesmal, wenn ich »BORIS SCHNEIDER« eingeben müßte, A$ dafür schreiben. Allerdings können Basic-Befehle so nicht abgekürzt werden. Wenn ich eingebe:
A$ = "PRINT":A$ 3\*5
so erhalte ich nicht das gewünschte Ergebnis, 15, sondern schlicht und einfach SYNTAX ERROR. Das liegt daran, daß Basic-Befehle intern anders codiert sind als Strings.

### Aufbau einer Stringvariablen

Wie sieht nun eine Stringvariable aus? Dazu betrachten wir ein Speichermodell des Computers. Die folgenden Erläuterungen beziehen sich auf Bild 1.

Beim Ablauf eines Programms läßt sich der Speicher in folgende fünf Bereiche aufteilen, deren Grenzen allerdings flexibel sind und sich laufend ändern:
— Basic-Programm
Das gerade im Speicher befindliche Programm liegt ganz unten, angefangen bei den kleinsten erreichbaren Adressen.
— Variable
In diesem Bereich befinden sich alle Variablen, Zahlvariablen wie auch Stringvariablen. In den Stringvariablen ist allerdings nicht der String selbst enthalten, sondern nur ein Zeiger auf die Adresse, wo sich der eigentliche String befindet.
— Arrays
Hier befinden sich die Arrays, auch Felder genannt. Wenn Sie mehr als elf Elemente enthalten sollen, müssen Sie vor ihrer Benutzung erst durch den DIM-Befehl definiert werden, damit der Basic-Interpreter genügend Speicherplatz in diesem Bereich bereitstellt.
— Freier Speicher
Freier Speicher existiert interessanterweise nicht am oberen oder unteren Ende des Speichers, sondern in der Mitte, zwischen Arrays und Strings. Das hat aber enorme Vorteile, wie wir noch sehen werden.
— Strings
Hier sind sie endlich, am oberen Ende des Speichers, die von uns gesuchten Strings. In diesem Bereich befinden sich, dicht aneinander gepackt, die Inhalte der Stringvariablen (mit einer Ausnahme, aber davon später).

Nun kommen wir aber wieder auf die Stringvariablen selbst zurück.

Wie schon erwähnt, steht, speichertechnisch gesehen, in einer Stringvariablen gar kein String, sondern nur die Adresse, wo wir den Inhalt der Stringvariablen finden können. Das bemerken wir allerdings normalerweise nicht, da der Basic-Interpreter für uns automatisch den String an der entsprechenden Adresse abholt.

Der genaue Aufbau einer StrinQvariablen steht in Tabelle 1. Hier einige Erläuterungen dazu:

Jede Variable ist durch eine Zweizeichen-Kombination gekennzeichnet. Das erste Zeichen muß ein Buchstabe, das zweite Zeichen darf auch eine Ziffer sein. Durch das Anhängen eines »$« definieren Sie die vorstehende Variable als Stringvariable. Intern speichert der Computer nun das Dollarzeichen nicht mit, sondern kennzeichnet eine Stringvariable, indem er zum Code des zweiten Buchstabens 128 addiert. So werden nur zwei Speicherstellen benötigt, um den Variablennamen zu speichern. Bei Zahlvariablen wird nichts addiert, bei Integervariablen (Ganzzahl) zu beiden Codes jeweils 128.

Das dritte Byte gibt die Länge des Strings an. Dies ist notwendig, da die eigentlichen Strings in ihrem Speicherbereich ohne Trennzeichen einfach aneinandergehängt sind. Wüßte der Computer nicht, wie lang der gefragte String ist, so könnte er auch nicht sein Ende feststellen. Da kein Trennzeichen verwendet wird, darf in einem String auch jedes Zeichen, das der Computer kennt, vorkommen. Außerdem wird so der Speicherplatz am besten ausgenutzt.

Die Bytes 4 und 5 enthalten die Adresse des Strings im Low/High-Byte-Format. Um diese beiden Bytes in die entsprechende Zahl umzuwandeln, müßte folgende Rechnung durchgeführt werden:
Byte 4 + (256 x Byte 5)

Die Bytes 6 und 7 enthalten beide den Wert Null. Wenn Sie nach dem Sinn und Zweck fragen, so ist die Antwort, daß es für den Computer einfacher ist, wenn alle Variablentypen, Zahlen wie Strings, die gleiche Länge haben. Eine Zahlvariable belegt nun genau 7 Bytes, deswegen werden Stringvariable auf diese Länge aufgefüllt.

Der Teil der Stringvariablen, der Länge und Adresse angibt, wird als Descriptor bezeichnet.

## Stringarrays

Nun gibt es aber neben den normalen Stringvariablen auch Stringarrays. Dies sind ein- oder mehrdimensionale Platzhalter. Am besten läßt sich das mit einem Beispiel erklären. Mit dem Befehl DIM A$(100,5) wird ein zweidimensionales Stringarray definiert. In diesem Array lassen sich bestimmte Strings mit Hilfe von zwei Koordinaten ablegen, zurückholen oder bearbeiten. Das soeben definierte Array läßt sich mit genau 606 Strings auffüllen. Man darf die erste Koordinate, oder besser gesagt den ersten Index, von 0 bis 100 und den zweiten Index von 0 bis 5 angeben. Dies sind 101 x 6 = 606 Platzhalter für Strings. Der Vorteil von Stringarrays ist, daß mit ihnen berechnete Zugriffe auf Strings möglich werden. So lassen sich zum Beispiel Strings in eine Reihenfolge bringen, diese Reihenfolge aber auch beliebig ändern, indem zwei Strings miteinander vertauscht werden. Anders gesagt sind zum Beispiel Sortierprogramme erst mit Stringarrays möglich geworden. Denn es gibt wohl keinen Weg, ohne große Tricks und viel Speicheraufwand die Inhalte der Stringvariablen A$, B$ .... Z$ zu sortieren. Mit einem Array ist dies sehr einfach möglich. Doch nun zu den Stringarrays selber.

Auch hierzu habe ich wieder eine Tabelle zusammengestellt (Tabelle 2).

Wie Sie schon auf einen Blick sehen, ist der Aufbau von Stringarrays ungleich komplizierter als der von normalen Stringvariablen.

Hier bezeichnet man den gesamten Block der einzelnen Stringdescriptoren als Arraydescriptor (description = Beschreibung, Darstellung).

In den ersten beiden Bytes steht, wie bei normalen Stringvariablen, der Name im Interpretercode. Auch hier wird zum zweiten Byte 128 addiert. Als nächstes wird, wieder im Low/High-Format, die Gesamtlänge des Arrays angegeben (Byte 3 und 4). Diese Gesamtlänge umfaßt sowohl den Arraydescriptor, wie alle nachfolgenden Stringdescriptoren.

Im Byte 5 wird die Anzahl der Dimensionen angegeben. Im Beispiel A$(100,5) wäre dies 2, da ja zwei voneinander abhängige Indizes vorhanden sind. Man spricht auch von einem zweidimensionalen Array oder Feld. Jeder Index definiert also eine Dimension. Da ein Byte maximal den Wert 255 aufnehmen kann, wäre dies auch die höchstmögliche Dimensionierung.

Nun steht hintereinander die Anzahl der Elemente jeder einzelnen Dimension in absteigender Reihenfolge. Diese Angaben sind wieder im Low/High-Format. Um auf unser Beispiel zurückzukommen: Zuerst würde hier eine 5 stehen und dann eine 100. (Beide im Low/High-Format!)

Damit wäre dann der Arraydescriptor abgeschlossen; an ihn schließen sich die Descriptoren der einzelnen Strings an. Jeder Stringdescriptor belegt 3 Bytes: Das erste gibt die Stringlänge, die beiden anderen die Speicheradresse des Stringinhalts an. Diese Stringdescriptoren stehen in folgender Reihenfolge hinter dem Arraydescriptor: Zuerst wird der Index der höchsten Dimension hochgezählt, dann der der zweithöchsten und so weiter, bis zur Dimension 1. Auch hier greife ich kurz auf unser Beispiel zurück: Der erste angegebene Stringdescriptor bezieht sich auf den String A$(0,0), der zweite auf A$(0,l), der sechste auf A$(0,5) der siebte auf A$(l,0), ... der 606te auf A$(100,5). Damit wäre dann auch die Liste der Stringdescriptoren zu Ende.

Diesen kleinen Ausflug in die Speichertechnik möchte ich mit einer Formel beenden, mit der Sie die Größe eines Arraydescriptors und seiner Stringdescriptoren berechnen können. Sie lautet: 5 + (Anzahl der Dimensionen) x 2 + (Anzahl der Elemente Dimension 1) x (Anzahl Elemente Dimension 2) x ... (Anzahl Elemente Dimension n) x 3.

Wichtig wäre hierbei, daß Sie bei der Angabe der Anzahl der Elemente beachten, daß die Zählung immer bei Null beginnt. A$(100,5) belegt also 5 + 2 x 2 + 101 x 6 x 3 = 1 827 Bytes, die Inhalte der einzelnen Variablen natürlich ausgeschlossen.

### Ein Blick in den Speicher

Nun wissen wir also, wie Stringvariablen und -arrays aussehen. Was passiert nun aber, wenn ich einen String anlege oder ihn bearbeite?

Um uns die Stringverarbeitung des Computers genauer anzusehen, bedienen wir uns ein paar speichertechnischer Tricks.

Wie schon erwähnt, stimmen die Adressenangaben, die ich bei unserer Beispielspeicherbelegung gemacht habe, nicht. Der Beginn eines Basic-Programms liegt normalerweise an der Adresse 2048, das Ende des Speichers bei 40959.

Die Grenzen zwischen den einzelnen Bereichen sind, wie gesagt, nicht exakt festlegbar, da sie sich laufend ändern. Sollten Sie sich für die gerade bestehenden Grenzen interessieren, so können Sie sie mittels PEEK erfragen. In den in Tabelle 3 angegebenen Speicherstellen stehen die jeweiligen Grenzen im schon erwähnten Low/High-Format. Um also beipielsweise den Beginn der Strings auszudrucken, müssen Sie folgendes eingeben:
PRINT PEEK(51) + 256xPEEK(52)

Wir beschreiten nun einen sehr ungewöhnlichen, aber wirkungsvollen Weg. Wir verkleinern unseren Speicher so, daß er auf den Bildschirm paßt, und legen den Bildschirmspeicher an diese Stelle. Wir können dann zwar nicht mehr sehen, was wir eintippen, haben aber einen vollen Überblick über den Speicher.

Geben Sie bitte folgendes ein: FORI = 2060T03072:POKEI,32: NEXTI, POKE 56,11:POKE 53272, 37:CLR.

Sie haben im Augenblick zirka 750 Bytes freien Speicherplatz, der Rest wurde vorhin für Basic gesperrt.

Tippen Sie nun mal (blind) A$ = "ihr name”. Sie sehen an zwei Stellen auf dem Schirm ein paar Grafikzeichen. Drücken Sie gleichzeitig die SHIFT- und die COMMODORE-Taste, um auf Kleinschrift umzuschalten. Nun erkennen Sie Ihren Namen, der im String A$ gespeichert wurde und an der obersten Speichergrenze steht.

Die Stringvariable selbst am oberen Bildschirmrand können Sie auch jetzt nicht entziffern, da sie im Interpretercode gespeichert wird. Zumindest können Sie aber die Stringinhalte lesen.

Jetzt wird es interessant: Tippen Sie mal A$ = ”BORIS SCHNEIDER".

Sie werden bemerken, daß ihr Name stehengeblieben ist, während mein Name einfach vorne angehängt wurde.

Dies ist der Haken der Stringverarbeitung, denn Ihr Name ist jetzt, bitte nehmen Sie es nicht persönlich, zu Stringmüll geworden. Er steht immer noch im Speicher herum, obwohl kein Stringdescriptor mehr auf ihn zeigt.

Dies macht einen großen Teil der gegenüber anderen Computern hohen Geschwindigkeit der Stringverarbeitung aus, denn neue Strings werden einfach vor die anderen gesetzt, ohne daß diese überprüft werden, ob sie noch gültig sind. Hier findet sich dann auch die Erklärung, warum freier Speicher gerade in der Mitte anzutreffen ist, zwischen Arrays und Strings. Denn während die Arrays und anderen Variablen mit zunehmender Zahl nach oben wachsen, wachsen die Strings nach unten. Der dazwischenliegende Speicher wird immer kleiner.

Und was passiert nun, wenn Strings und Arrays »zusammenstoßen«?

Hier gibt es zwei Möglichkeiten: Da ja kein Speicherplatz mehr frei ist, wird OUT OF MEMORY angezeigt, oder ...

Wie Sie sich vielleicht schon gedacht haben, können sich unter den Strings eine Vielzahl von Müllstrings befinden, die einfach nicht mehr gebraucht werden, sondern nur Speicherplatz schlucken. Könnte man diese entfernen, und nur noch die tatsächlich verwendeten Strings übriglassen, so wäre wieder eine Menge Speicher für weitere Anwendungen frei.

Nun sind wir also endlich beim Stichwort: Garbage Collection. Dies ist die vorhin angesprochene Möglichkeit der Müllbeseitigung.

### Problemkind: Das Vertauschen

Bei der Garbage Collection wird sämtlicher vorhandener Stringmüll entfernt; so wird der größtmögliche Speicherplatz frei.

Wie arbeitet nun die Garbage Collection? Auch dies zeigt man am besten an einem Beispiel. Am praktischsten finde ich das Stringvertauschen. Sie wissen ja wahrscheinlich, wie man normalerweise zwei Strings vertauscht: H$ = A$ : A$ = B$ : B$ = H$

Diese Sequenz vertauscht die Inhalte der zwei Stringvariablen A$ und B$. So zu tauschen ist der einfachste Weg, er hat aber auch zwei große Nachteile:

— Es wird eine zusätzliche Hilfsvariable, hier H$ benötigt.
— Es entsteht eine Menge Stringmüll, nämlich 150 Prozent!

Schauen wir uns mal genau an, was bei der oben genannten Sequenz im Speicher passiert.

Wenn Sie es selbst am Bildschirm verfolgen wollen, geben Sie bitte nochmals die oben genannten POKE-Befehle ein. Ansonsten betrachten Sie bitte Bild 2 bis 6.

Zuerst definieren wir die zwei Strings A$ und B$:
A$ = "BORIS" : B$ = "SCHNEIDER” (Sie können selbstverständlich jeden anderen Stringinhalt wählen.) Sie sehen, daß das Betriebssystem zwei Strings im Speicher abgelegt hat; die Descriptoren der entsprechenden Variablen zeigen auf diese (Bild 2).

Nun folgt der erste Vertauschungsschritt: H$ = A$. Sie sehen, daß nun zweimal der String "BORIS" im Speicher steht, einmal als Inhalt von A$, einmal von H$ (Bild 3).

Der nächste Schritt wäre: A$ = B$.

Schon wieder wird ein schon vorhandener Inhalt nochmals angehängt, in diesem Falle das »SCHNEIDER«. Das erste »BORIS« ist jetzt schon Stringmüll, da kein Descriptor auf ihn zeigt (Bild 4).

Als letztes käme noch: B$ = H$. Nochmals wird der String »BORIS« in den Speicher geschrieben. Damit ist auch der vorherige Inhalt von B$, der erste »SCHNEIDER«, zu Stringmüll geworden (Bild 5).

Zum Schluß wäre zu beachten, daß wir ja nun die Variable H$ nicht mehr benötigen, da sie nur Zwischenspeicher bei der Vertauschung war. Wenn wir also schreiben: H$ = ””, wird auch das zweite "BORIS" zu Stringmüll (Bild 6).

Nun rechnen wir mal: Fünf Strings stehen im Stringspeicher, aber nur zwei werden benötigt. Eine traurige Bilanz, wenn man bedenkt, daß wir ja nur zwei Stringvariablen vertauscht haben. Denn bei jeder Stringfunktion entsteht Stringmüll. Probieren Sie doch mal A$ = A$, und Sie werden sehen, wie schnell sich Stringmüll entwickeln kann.

Allerdings gibt es eine löbliche Ausnahme, die man immer ausnutzen sollte. Wenn Sie Stringvariablen in einem Programm definieren, zum Beispiel: 10 A$ = "HALLIHALLO", so werden Sie am oberen Speicherende vergeblich nach "HALLI-HALLO" suchen! Denn im Programmtext ist dieser String ja schon enthalten, wieso sollte der entsprechende Descriptor nicht einfach auf die entsprechende Stelle im Programmtext zeigen? Das tut er auch; zu beachten wäre aber, daß bei jeder weiteren Manipulation an dieser Stringvariable ein String im Stringspeicher abgelegt wird; es können also beim Vertauschen mehrerer im Programm definierter Stringvariablen ohne weiteres wieder Müllstrings entstehen.

Ich würde Ihnen empfehlen, einige andere Stringoperationen selbst auszuführen und sich die Effekte mit Hilfe des oben genannten Tricks selbst anzusehen.

Doch nun endlich zurück zur Garbage Collection und unserem Beispiel. Wir können den entstandenen Stringmüll durch Aufrufen der FRE-Funktion beseitigen, zum Beispiel: PRINT FRE(0).

## Garbage Collection

Wenn Sie dies bei unserem Beispiel machen, dann sehen Sie, wie blitzschnell der Speicher umorganisiert wird; leider zu schnell, denn wir bekommen gar nicht mit, was passiert. Deswegen gehen wir also die Verfahrensweise der Garbage Collection an unserem Beispiel durch (Bild 7 und 8).

Die Garbage Collection durchsucht den gesamten Variablenspeicher nach dem String, der den am höchsten liegenden Pointer hat. Dabei werden alle Strings, die die Länge Null haben, übergangen, da sie ja keinen Inhalt haben können.

In unserem Fall ist das ziemlich einfach, da wir ja nur zwei richtige Strings haben, A$ und B$. H$ hat ja die Länge 0, wird also nicht beachtet.

Der String, der den höchsten Descriptor hat, ist bei uns A$, denn der Inhalt von A$ steht an einer höheren Stelle als B$. Daraus folgt aber auch sofort, daß alles, was über dem Inhalt von A$ steht, Stringmüll sein muß, da ja kein Descriptor mehr darauf weist. Also kann der Inhalt von A$ an die obere Speichergrenze geschoben, und der Descriptor von A$ entsprechend geändert werden (Bild 7).

Die Garbage Collection merkt sich nun noch die Adresse, bei der der Inhalt der zuletzt bearbeiteten Stringvariablen (hier A$) endet, denn alle Stringvariablen, deren Inhalte über dieser Adresse stehen, müssen ja schon von der Garbage Collection behandelt worden sein.

Nun haben wir also A$ schon aufgeräumt, es fehlt uns noch B$. Er wird an die vorhin gemerkte Adresse (Ende von A$) geschoben, und sein Ende wird wieder gemerkt (Bild 8).

Da jetzt alle vorhandenen Stringdescriptoren über diese Grenze hinaus weisen, sind alle Stringvariablen aufgeräumt worden, und die Garbage Collection ist beendet.

Sie werden jetzt vielleicht fragen, wo denn der Haken bei der Garbage Collection liegt, denn sie war ja unwahrscheinlich schnell.

Nun, wir hatten aber auch nur zwei Strings im Speicher, die aufgeräumt werden mußten. Wenn Sie Ihren Computer mal beschäftigen wollen, so probieren Sie folgendes:
DIM A$(9000)
FOR I = 0 TO 9000:A$(I)="A": NEXTI
TI$="000000":?FRE(0):?TI$

Bitte tippen Sie das nur, wenn die normale Speicherbelegung eingeschaltet ist, sonst erhalten Sie sofort einen OUT OF MEMORY ERROR.

Undjetzt können Sie erst mal in Ruhe diesen Artikel weiterlesen, denn Ihr Computer kann über eine Stunde lang mit der Garbage Collection beschäftigt sein! Wenn er fertig ist, sagt er Ihnen auch, wie lange er gebraucht hat.

Die Zeit, die die Garbage Collection benötigt, ist proportional zum Quadrat der vorhandenen Stringvariablen. Für die Nicht-Mathematiker unter uns: Die Garbage Collection muß so viele Durchgänge machen, wie Stringvariablen vorhanden sind, da in jedem Durchgang nur eine aufgeräumt wird. In jedem Durchgang muß aber auch jede Stringvariable angeschaut werden, ob sie:

— schon aufgeräumt ist; dann liegt ihr Descriptor über der gemerkten Grenze.
— jetzt aufgeräumt werden soll; dann hat sie den höchsten Descriptor unter der Grenze.
— erst später aufgeräumt wird, dann trifft keiner der beiden ohigen Fälle zu.

Also werden soviele Vergleiche benötigt, wie die Anzahl der vorhandenen Stingvariablen im Quadrat, von der Anzahl der Speicherverschiebungen mal abgesehen, denn sie entspricht der Anzahl der Stringvariablen.

Auf einen Nenner gebracht bedeutet das, daß die FRE(0) Routine aus dem DIMA$(9000) Beispiel 9001x9001 = 81 Millionen Vergleiche benötigt!

Diese Zahl stimmt nicht ganz mit der Wirklichkeit überein, da auch andere Faktoren eine Rolle spielen, die Größenordnungen sind aber ziemlich richtig.

Die Zeit der Garbage Collection hängt aber nicht von der Anzahl der Müllstrings ab, da diese ja gar nicht überprüft werden, sondern nur alle Descriptoren.

Es gibt mehrere Möglichkeiten, die Garbage Collection kurz zu halten:

— Benutzen Sie so wenig Strings wie möglich, dann braucht die Garbage Collection weniger Zeit, außerdem muß sie nicht so oft aufgerufen werden, da ja mehr Platz für Müllstrings ist.
— Strings wenn möglich im Programm definieren, und dann nie mehr verändern, dann entsteht weniger Stringmüll
— Weitere Stringmüll verursachende Befehlssequenzen meiden, wie zum Beispiel A$ = A$ und ähnliches.
— Sollen Strings vertauscht werden, SWAP-Routine verwenden.

Halt, werden Sie jetzt sagen, was ist denn eine SWAP-Routine?

Um einen der größten Stringmüll-Verursacher, das Vertauschen von Strings, zu entschärfen, habe ich diese Routine geschrieben. Sie vertauscht zwei Strings, ohne daß Stringmüll entsteht.

Sie werden sich wahrscheinlich schon gefragt haben, warum eigentlich beim Vertauschen von Strings nicht einfach die Descriptoren der beiden Stringvariablen ausgetauscht werden. Dann könnte kein Stringmüll entstehen.

Genau das tut die SWAP-Routine. Eine ähnliche ist vielleicht schon in einer Basic-Erweiterung enthalten, die Sie benützen. Wenn nicht, so tippen Sie einfach Listing 1 ab. SWAP ist im Speicher frei verschiebbar, Sie können es also an jede beliebige Adresse legen. Sinnvoll wäre wohl der Kassettenpuffer (Adresse 828) oder der Bereich ab $C000. Das hängt ganz von weiteren Programmen oder Erweiterungen ab, die sich gleichzeitig im Speicher befinden.

Wie Sie die SWAP-Routine anwenden, steht in den REM-Zeilen des Listings, die Arbeitsweise verdeutlichen die Bilder 9 und 10.

Wenn Sie das Thema Stringverarbeitung und neue Stringfunktionen in Maschinensprache mehr interessiert: Darauf werde ich in der nächsten Ausgabe genauer eingehen, ebenso wie auf die genaue Funktionsweise der SWAP-Routine.

(Boris Schneider/gk)

# Memory Map mit Wandervorschlägen – Teil 3

> Die Landkarte, der wir auf unserer Reise durch den Speicher fo^en, weist diesmal — neben vielen interessanten Plätzen — auch zwei 0rte auf, die nützlich sind.

Zum einen ist es die Adresse 19, zum anderen gelangen wir in den Bereich ab Speicherzelle 43, der für Speicher-Manipulationen so eminent und wichtig ist.

### Adresse 18 ($12)<br>1. Flagge für Vorzeichen bei SIN, COS und TAN<br>2. Flagge bei Vergleich

Zuerst kommt das Vorzeichen der trigonometrischen Funktionen an die Reihe.

Die Routinen des Basic-Übersetzers (Interpreter), welche die drei trigonometrischen Funktionen SIN, COS und TAN berechnen, verwenden die Speicherzelle 18 zur Bestimmung des Vorzeichens.

Zur Erinnerung: Die trigonometrischen Funktionen haben in den vier »Quadranten« des Kreises(0-90, 90-180, 180-270, 270-360 Grad) nicht unbedingt dieselben Vorzeichen. Die Vorzeichen ändern sich allerdings nur an den Grenzen der Quadranten, wie in Bild 1 zu sehen ist. Die Flagge in Zelle 18 gibt das Vorzeichen nicht direkt an, sondern auf Umwegen. Die Darstellung ist in der folgenden Tabelle 1 zusammengefaßt.

TODO

Dabei bedeutet »gleich«: 0-0-0-0 oder 255-255-255
»Wechsel«: 0-255-0-255

Da die Erklärung mit »gleich« beziehungsweise »Wechsel« nicht gerade einleuchtend ist, schlage ich vor, daß Sie sich das Ganze mit dem folgenden kleinen Programm selbst anschauen, welches für viele Werte des Winkels im Bogenmaß — und in kleinen Schritten — den Wert der Flagge, daneben den Winkel I und den Wert der Funktion mit Vorzeichen ausdruckt.
10 FOR I = 0TO 10 STEP 0.01
20 PRINT PEEK(18);INT(I\*100)/100;SIN(I):NEXT

Diese etwas umständliche Art, den Wert von I auszudrucken, vermeidet Rundungsfehler und begrenzt den Ausdruck auf zwei Dezimalstellen. Wenn Sie die Winkelwerte von I in Graden ausgedruckt haben wollen, können Sie eine andere Zeile 20 verwenden, welche die Umrechnungsformel vom Bogenmaß in Grade verwendet:
Winkel in Grad = Winkel im Bogenmaß \* 180/π
20 Print PEEK(18);INT(I\*180/π) ;SIN(I):NEXT

Statt SIN können Sie genauso gut COS und TAN einsetzen.

In Bild 1 sind nicht nur die Kurven und die Bereiche der Vorzeichen, sondern auch die Winkelbereiche sowohl im Bogenmaß, als auch in Graden dargestellt.

Die Speicherzelle 18 wird auch noch von anderen Routinen des Basic-Interpreters beansprucht und zwar von allen, die einen Vergleich wie < - >, >= und so weiter durchführen. Entsprechend der Art des Vergleichs steht dann in der Zelle 18 eine Ziffer von 0 bis 6.

Das folgende Programm macht das deutlich.
10 A = 2
20 FORI = 1 TO 3
30 IF I = A THEN PRINTI;PEEK(18);” = ”
40 IF I <> A THEN PRINT I;PEEK(18);"><”
50 IF I > A THEN PRINT I;PEEK(18);”>”
60 IF I < A THEN PRINTI;PEEK(18);”<”
70 IF I >= A THEN PRINT I;PEEK(18);”>=”
80 IF I <= A THEN PRINTI;PEEK(18);”<=”
90 IF I < A OR I = A THEN PRINTI;PEEK(18);"< OR =”
100 NEXT I

Kurz zur Erklärung dieser Zeilen: In der FOR..NEXT-Schleife wird die Variable I mit der Konstanten A = 2 verglichen. In den Zeilen 30 bis 90 werden alle möglichen Vergleichsoperatoren durchgeprüft. Jeder der zutrifft, druckt den Wert von I, den Wert der dann in Zelle 18 stehenden Flagge und schließlich den Vergleichsoperator aus. Aus dem Resultat dieses Programms läßt sich folgende Tabelle zusammenstellen:

TODO

Sie sehen, die Flagge für die kombinierten Vergleichsoperatoren entspricht der Summe ihrer Einzelwerte. Nur die Verknüpfung über OR nicht, denn die ergibt 0.

### Adresse 19 ($13)<br>Flagge zur Kennzeichnung des laufenden Ein-/Ausgabegerätes

Immer dann, wenn von Basic Daten ein- oder ausgegeben werden, schaut die entsprechende Routine des Übersetzers in Zelle 19nach, umwelches Peripheriegerät es sich handelt. Zur Debatte stehen Tastatur, Datasette, RS232/User-Port, Bildschirm, Drucker und Floppy-Laufwerk.

Die Flagge ihrerseits ist ausschlaggebend für die feinen Unterschiede, wie zum Beispiel das Fragezeichen, bei Eingabe von der Tastatur (INPUT) oder die Anweisung »Press Play on Tape« bei Eingabe von der Datasette.

Beim Einschalten des Rechners setzt die Initialisierungsroutine des Betriebssystems, die beim VC 20 ab Adresse 58276 ($E3A4), beim C 64 ab 58303 ($E3BF) beginnt, die Flagge in Zelle 19 auf 0. Die Null bedeutet Eingabe über Tastatur und Ausgabe über Bildschirm.

Wenn Sie einen Dissassembler haben, drucken Sie doch einmal das Assemblerlisting aus. Sie werden in Adresse 58324/58325 ($E3D4/E3D5), beim C 64 in 58354/58355 ($E3F2/E3F3) den Befehl finden, der eine Null nach Zelle 19 ($13) bringt.

Immer dann, wenn ein Programm nicht Tastatur und Bildschirm, sondern eines der oben genannten anderen Peripheriegeräte anspricht (indem mit OPEN.... eine Datei = Logical File eröffnet wird), wird in Zelle 19 die Nummer der gerade bearbeiteten Datei eingetragen, mit den bereits beschriebenen Konsequenzen.

Ich will hier nicht weiter darauf eingehen, da wir den Inhalt von Zelle 19 selbst nicht auslesen können. Er wird nämlich immer gleich wieder auf Null gesetzt.

Wir können ihn aber durch POKE verändern. Durch POKE 19,1 gaukeln wir dem Rechner vor, daß Ein- und Ausgabe über »externe« Geräte läuft, selbst wenn nur die Tastatur und der Bildschirm betrieben werden.

Wenn zum Beispiel der Rechner der Meinung ist, daß ein INPUT von der Datasette kommt, druckt er kein Fragezeichen aus, auch kein EXTRA IGNORED als Fehlermeldung bei zu zahlreicher Eingabe und das alleinige Drücken der RETURN-Taste ignoriert er auch, im Gegensatz zum »normalen« INPUT. Probieren Sie es aus:
10 INPUT ”TEST”;A$
20 PRINT A$

In diesem Normalfall erscheint nach RUN darunter die Aufforderung TEST?

Eine Eingabe, zum Beispiel XX, erscheint mit einem Abstand daneben, und nach RETURN wird XX an den Anfang der nächsten Zeile gedruckt. Alle falschen Eingaben werden mit den üblichen Fehlermeldungen quittiert.

Jetzt fügen wir ein:
5 POKE 19,1

Nach RUN erscheint wieder die Aufforderung TEST, aber ohne Fragezeichen. Die Eingabe XX wird ohne Abstand daneben gesetzt und nach RETURN mit einem Abstand in derselben Zeile weitergeschrieben.

Das Drücken der RETURN-Taste setzt den Cursor nicht wie üblich in die nächste Zeile, sondern schiebt ihn in derselben Zeile weiter.

Diesen zusätzlichen Effekt muß man beachten, da er sehr störend für den Verlauf eines Programms sein kann.

Man kann ihn natürlich auch nutzbringend einsetzen, hat er doch die Eigenschaft eines automatischen »Cursor UP«. Eine pfiffige Anwendung dieser Art wurde von Brad Templeton für den PET erfunden und ist von Jim Butterfield für eine MERGE-Routine mit dem Namen »Magic Merge« veröffentlicht worden.

Da diese Routine aber primär auf der Eigenschaft der Speicherzelle 153 basiert, werde ich sie dann erläutern, sobald wir bei der Zelle 153 angelangt sind.

Zurück zur Flagge in Zelle 19.

Umgekehrt können wir POKE 19,0 leider nicht nutzen, da die betroffenen Befehle GET, GET#, INPUT, INPUT# und PRINT# die Flagge sofort auf den richtigen Wert setzen. Nur PRINT und LIST tun das nicht, wie wir bei dem PRINT-Befehl oben ja gesehen haben.

Adresse 20-21 ($14-$15) ZeilennummerfürLIST, GOTO, GOSUB und 0N, Zeiger der Adresse bei PEEK, POKE, SYS und WAIT

In diesen Speicherzellen wird die Zeilennummer der Sprungbefehle GOTO, ON..GOTO und GOSUB sowie die Zeilenangabe beim LIST-Befehl gespeichert. Da die Werte bis maximal 65535 gehen können, braucht der Computer 2 Bytes zur High/Low-Byte-Darstellung.

Die GOTO-Routine (im VC 20 ab 51360 = $C8A0, im C 64 ab 43168 = $A8A0) vergleicht die Zahl in 20/21 mit der laufenden Zeilenzahl. Wenn sie kleiner ist, wird ab der ersten Zeile des Programms gesucht. Ist sie aber größer, dann beginnt die Suche ab der laufenden Zeilenzahl. Die Suche geht so lange, bis die in 20/21 angegebene Zeilenzahl gefunden ist. Dann fährt das Programm mit dieser Zeile fort.

LIST speichert in 20/21 die höchste auszulistende Zeilennummer ab, falls keine Angabe beim LISTen gegeben worden ist, den Wert 65535 ($FFFF).

Die Befehle PEEK, POKE, SYS und WAIT verwenden diese Speicherzellen zur Angabe der Adressen, die dem Befehl immer folgen müssen.

Leider können wir die Speicherzellen 20/21 mit Basic-Programmen nicht bearbeiten; ihr Inhalt wird immer gleich auf 20 zurückgesetzt.

### Adresse 22 ($16)<br>Zeiger auf den nächsten freien Speicherplatz im »Temporary String Descriptor Stack«

Dieser Zeiger bezieht sich in seiner Wirkung auf die übernächsten Speicherzellen 25 bis 33 ($19-$21).

Diese werden als Stapelspeicher (Stack) für Angaben über vorläufige Zeichenketten — auf englisch »Temporary String Descriptor« — verwendet (siehe unten).

Die Speicherzelle 22 ($16) ihrerseits enthält einen Zeiger auf den jeweils nächsten verfügbaren Platz in diesem Speicher ab Zelle 25. Da er eine Kapazität von 3 mal 3 Byte hat, zeigt der Zeiger auf die Zelle 25 ($19), wenn er leer ist. Bei einem Eintrag zeigt er auf 28 ($lC), bei zwei Einträgen auf 31 ($lF) und schließlich auf 34 ($22), wenn der Speicher voll ist.

Eine Zeichenkette ist dann »vorläufig«, wenn sie noch nicht einer Stringvariablen zugeordnet worden ist, zum Beispiel »Mahlzeit« in dem Basic-Befehl PRINT "MAHLZEIT.

Beim Einschalten setzt das Betriebssystem mit der Einschalt-Routine ab Adresse 58303 ($E3BF) im C 64, beim VC 20 ab 58276 ($E3A4) den Zeiger auf 25. Die Stringverwaltungsroutine ab 46215 ($B487) im C 64 beziehungsweise ab 54407 ($D487) im VC 20 fragt bei String-Eingaben die Flagge ab. Nach jeder Eintragung in den Speicher ab Zelle 25 wird der Zeiger um 3 weitergesetzt.

Sie können die LeerfIagge 25 mit PRINT PEEK (22) leicht nachprüfen.

Die anderen Eintragungen können nicht nachgeprüft werden, weil sie sofort auf 25 zurückgesetzt werden.

Wir können sie aber durch POKE beeinflussen; ob das sinnvoll ist, ist eine andere Frage.
10 POKE 22,34
20 PRINT "MAHLZEIT"

Die Zahl 34 in Zelle 22 sagt dem Programm, daß der Speicher ab Zelle 25 voll ist und wir bekommen statt der MAHLZEIT eine Fehlermeldung serviert.

Mit einem POKE-Befehl, der als Argument die für den vorgesehenen Zweck ungültige Zahl 35 verwendet:
POKE 22,35
erreichen wir allerdings zwei interessante »Dreckeffekte«. Zum einen unterdrückt der Befehl die Ausgabe des READY, zum anderen aber bewirkt er, daß bei LIST ein Listing ohne Zeilennummern ausgedruckt wird, sowohl auf dem Bildschirm als auch mit dem Drucker.

## Das billigste editierfähige Textverarbeitungssystem

Die Idee dazu habe ich von Mike Apsey’s Hinweis in »Commodore User« Juli 1984. Mit Zeilennummern versehen, läßt sich jeder beliebige Text schreiben, verbessern, verschieben, abspeichern, aber nicht RUNen!

Der POKE-Befehl von oben (POKE 22,35) gefolgt von einem CMD und LIST, druckt dann alles brav als reinen Text aus. Die maximale Zeilenlänge entspricht der Zeilenlänge des jeweiligen Computers.

Probieren Sie es aus:
10 DER COMPUTER BIETET IN DER
20 DATENFERNÜBERTRAGUNG
30 UNGEAHNTE MÖGLICHKEITEN.
40 ABER DIE GEFAHR
50 USW. USW.
60:

Jede Zeile wird mit der RE-TURN-Taste abgeschlossen. Damit auch alles gedruckt wird, muß — zumindest bei meinem Drucker (1526) — eine »Leerzeile« folgen (Zeile 60). Mit POKE 22,35:OPEN l,4:CMD l:LIST

wird der Text ohne Zeilennummern ausgedruckt. Sie können ihn vorher nach Belieben verändern.

Wie gesagt, nur nicht mit RUN starten, denn das bringt unweigerlich eine Fehlermeldung.

### Adresse 23-24 ($17-$18)<br>Zeiger auf die Adresse der letzten Zeichenkette im »Temporary String Stack«

Der Inhalt dieser zwei Bytes zeigt auf den zuletzt benützten Speicherplatz innerhalb der Adresse 22 bis 33. Das heißt, daß der Wert in 23 ($17) immer um 3 kleiner ist als der in 22 ($16), während der Wert in 24 ($18) eine Null ist.

Adresse 25-33 ($19-$21) Stapelspeicherfür Angaben über vorläufige Zeichenketten

Das ist also der Speicherbereich, von dem in den beiden vorigen Abschnitten dauernd die Rede war. Ich gebe zu, »Descriptor Stack for Temporary Strings« drückt die Sache präziser aus als der deutsche Text.

Die Bedeutung eines »vorläufigen« Strings habe ich oben in der Beschreibung der Speicherzelle 22 erklärt.

Was ein Stapelspeicher (Stack) ist, entnehmen Sie bitte dem Texteinschub. Jeder der drei Byte langen Angaben im Stack von 22 bis 33 enthält die Länge sowie die Anfangs- und Endadressen eines vorläufigen Strings, ausgedruckt als Verschiebung im Basic-Speicherbereich.

### Adresse 34-37 ($22-$25)<br>Verschiedene Zwischenspeicher

Diese vier Speicherzellen werden vom Basic-Übersetzer (Interpreter) für verschiedene Zwischenergebnisse und Flaggen benützt, die aber dem Programmierer nichts nützen.

### Adresse 38-42 ($26-$2A)<br>Arbeitsspeicher für arithmetische Operationen

Diese Speicherzellen werden von den Basic-Routinen bei der Multiplikation und Division als »Notizblatt« verwendet. Auch die Routinen, welche die erforderliche Speichergröße beim Definieren eines Zahlenfeldes (Array) ausrechnen, benutzen diesen Bereich.

### Adresse 43-44 ($2B-$2C)<br>Zeiger auf den Anfang der Basic-Programme im Speicher

Dieser Zeiger, in der Low/ High-Byte-Darstellung, gibt dem Basic-Übersetzer an, ab welcher Speicherzelle das Basic-Programm beginnt. Normalerweise ist diese Adresse fest vorgegeben. Beim C 64 zum Beispiel zeigt der Zeiger auf 2049 ($801). Beim VC 20 ist die Lage schon schwieriger, denn der Speicherbeginn hängt davon ab, welche Speichererweiterung eingesetzt ist. Die folgende Tabelle gibt darüber Auskunft.

  Beginn des Programmspeichers
  C 64	2049 ($801)
  VC 20 (GV)	4097 ($1001)
  VC20( + 3K) 1025($401)
  VC 20 (+ 8 K) 4609 ($1201)

TODO

Mit dem Befehl PRINT PEEK (43) + PEEK (44)\*256 läßt sich der jeweilige Beginn des Programmspeichers leicht feststellen. Mit einem POKE-Befehl kann der Programmierer diese Anfangsadresse verändern. Wozu das gut ist, fragen Sie?

#### Anwendung #1:

Nun, wenn Sie zum Beispiel ein Maschinenprogramm mit einem Basic-Programm gemeinsam betreiben wollen, brauchen Sie einen Speicherbereich für das Maschinenprogramm, der vom Basic-Programm nicht belegt wird. Wir sprechen vom »Schützen des Maschinenprogramms vor dem Überschreiben durch das Basic«. Der Speicherbereich eines Maschinenprogramms ist immer bekannt. Nach seinem letzten Speicherplatz kann das Basic-Programm beginnen.

Die Verschiebung der Anfangsadresse erfolgt in vier Schritten:

1.	Schritt: In den Speicherplatz vor dem neuen Basic-Bereich muß eine Null gePOKEt werden. Die Null dient zum Abgrenzen.
2.	Schritt: Die Adresse der ersten Speicherzelle wird in die Low-High-Byte-Darstellung umgerechnet. Ich verweise dazu auf die Erklärung dieses Vorgangs in der ersten Folge dieses Kurses in Ausgabe 11/84.
3.	Schritt: Das Low-Byte wird in die Speicherzelle 43, das High-Byte in die Zelle 44 gePOKEt.
4.	Schritt: Die Operation muß unbedingt mit dem Befehl NEW abgeschlossen werden, um sicherzustellen, daß der neue Basic-Bereich auch »sauber« ist.

Im folgenden kleinen Programm wird angenommen, daß der Speicher bis zur Adresse 5000 ($1388) durch ein Maschinenprogramm belegt ist. Das Basic-Programm kann daher ab 5002 ($138A) anfangen, denn in 5001 muß ja eine Null stehen. Die Adresse 5002 teilt sich auf in ein High-Byte von INT (5002/256) = 19 und ein Low-Byte von 5002 — (19\*256) = 138.
10 POKE 5001,0 20 POKE 43,138 30 POKE 44,19 40 NEW

Der Effekt einer solchen »Verbiegung« des Zeigers in 43/44 wird im Texteinschub 2 »Der sichtbare Basic-Speicher« demonstriert.

Neben der oben erwähnten Anwendung der Zeigerverbiegung gibt es noch andere Möglichkeiten:

#### Anwendung #2:

Christoph Sauer hat in seinem Kurs »Der gläserne VC 20« in Ausgabe 10/84 auf Seite 158 gezeigt, wie man mehrere Programme gleichzeitig im Speicher unterbringen und zwischen ihnen umschalten kann.

#### Anwendung #3:

Man kann zwei oder mehrere unabhängige Programme genau hintereinander in den Speicher bringen, um sie aneinanderzuhängen , was dem im Commodore-Basic fehlenden Befehl MERGE entspricht. Dabei dürfen die Zeilennummern sich allerdings nicht überschneiden.

#### Anwendung #4:

Durch Hinaufschieben des Basic-Bereichs kann Platz geschaffen werden für selbstdefinierte Zeichen oder hochauflösende Grafik (siehe dazu auch den Grafik-Kurs).

### Adresse 45-46 ($2D-$2E)<br>Zeiger auf die Anfangsadresse des Speicherbereichs für Variable

Mit dieser Adresse werden wir das nächste Mal fortfahren.

(Dr. Helmuth Hauck/aa)

<aside>

## Was ist ein Stapelspeicher (Stack)?

Der normale Arbeitsspeicher des Computers, auf englisch »Random Access Memory« oder kurz RAM genannt, hat für jede Speicherzelle eine eigene Adresse, die beim Schreiben in den Speicher oder beim Lesen aus dem Speicher angegeben werden muß.

Als Analogie möge eine Aktenablage dienen, bei der jeder Akt (Brief, Papier, Zeichnung) in einen Ordner kommt, mit Nummer versehen.

Um einen Akt herauszuholen, muß man die Nummer (Adresse) kennen, unter der er abgelegt ist.

Ein Stapelspeicher, auf englisch »Stack« genannt, funktioniert wie eine Aktenablage, bei der jeder Akt einfach oben auf einen Stapel gelegt wird, daher der Name. Diese Ablage erfolgt ohne Kennzeichnung oder Nummer, einfach immer der Reihe nach.

Einen Akt kann man aus einem Stapelspeicher nicht beliebig herausholen, da immer nur der oberste Akt zugänglich ist.

Die Methode der Stapelspeicher bietet sich überall dort an, wo es auf die Reihenfolge der gespeicherten Daten ankommt. Basic merkt sich zum Beispiel der Reihe nach die Adressen, von denen aus mit GOSUB ein Unterprogramm angesprungen wird. Wenn mehrere GOSUBs hintereinander eingesetzt werden, liegt auf dem Stapel immer die letzte Absprungadresse bereit zum Rücksprung.

Ein Stapelspeicher hat demnach nur eine einzige Adresse, die sowohl zum Abspeichern als auch zum Auslesen dieselbe ist.

Voraussetzung eines Stapelspeichers ist natürlich eine Routine, welche alle gespeicherten Daten im Stapelspeicher um einen Platz weiterschiebt, wenn eine neue Information »oben auf den Stapel gelegt wird«.

Das Basic der Commodore-Rechner verwendet mehrere dieser Stapelspeicher.

Die Programmiersprache Forth ist völlig auf dem Prinzip des Stapelspeichers aufgebaut.

</aside>

<aside>

## Der sichtbare Basic-Speicher

Wenn wir den Variablen A die Adresse des Speicherbeginns der Basic-Programme zuordnen und dann mit einer FOR..NEXT-Schleife den Inhalt dieser und der nächsten 100 Speicherplätze ausdrucken, sehen wir in dezimaler Darstellung die ersten 101 Zahlenwerte, mit denen der Computer ein Basic-Programm abspeichert.

Ein Verbiegen des Zeigers in Speicherzelle 43/44 kann auf diese Weise in seiner Wirkung sichtbar gemacht werden.

Als Demo-Programm wähle ich zwei Zeilen, welche die Zahlen 1 bis 9 und die Buchstaben A bis I ausdrucken.
10 PRINT "123456789"
20 PRINT "ABCDEFGHI"
100 A = 2049:REM*C 64
4097 : REM*VC 20 ohne Erweiterung
1025 : REM*VC 20 mit 3 KByte
4609 : REM*VC 20 mit 8 KByte oder mehr
110 PRINT CHR$(147)

Zeile 100 definiert den Speicheranfang. Zeile 110 löscht den Bildschirm.
120 FOR J= TO A + 100
130 PRINT PEEK (J);
140 NEXTJ

Die Befehle in den Zeilen 120 bis 140 drucken den Inhalt der ersten 101 Zellen dieses Basic-Programms aus. SAVEn Sie bitte dieses kleine Programm, denn wir brauchen es noch einmal. Dann geht es los mit RUN. In Bild 2 ist der Bildschirm-Ausdruck des VC 20 mit 8 KByte dargestellt, der des C 64 zeigt praktisch dieselbe Information.

Überspringen Sie bitte zunächst die ersten beiden Zahlen. Die dritte und vierte Zahl ist 10 und 0. Das ist (als Low- und High-Byte) die Nummer der ersten Zeile des Basic-Programms. Dann folgt 153, das ist der interne Codewert für PRINT Diese Codes für alle Basic-Befehlswörter heißen »TOKEN« und sind zusammen mit den ASCII-Codes aller Zahlen, Zeichen und Funktionen in den Commodore-Handbüchern angegeben.

Die nächste Zahl im Bildschirm ist die 34, sie ist der ASCII-Code für den Gänsefuß. Danach folgen in aufsteigender Reihenfolge die ASCII-Codes der Ziffern 1 (48) bis 9 (57). Danach sehen Sie wieder den Gänsefuß (34). Schließlich kommt eine Null als Abstandszeichen zur nächsten Basic-Zeile.

Machen Sie bitte folgendes Experiment: Ausgehend von der Adresse der ersten auf dem Bildschirm ausgedruckten Speicherzellen — zum Beispiel 4609 beim VC 20 mit 8 KByte — zählen Sie die Zellen weiter bis zur Abgrenzungs-Null. In meinem Beispiel steht die 0 in Zeile 4625. Das heißt, daß die nächste Basic-Zeile in 4626 anfängt. Und das ist genau die Zahl, die in den ersten beiden Zellen steht, die wir vorhin übersprungen haben; in meinem Beispiel steht da 18 18. Machen wir die Probe: 18 + 256 x 18 = 4626.

Jede Basic-Zeile im Speicher beginnt also mit der Adresse der nächsten Zeile (sie heißt Koppeladresse) und endet mit einer Null. Ab 4626 folgt dann die nächste Koppeladresse, danach mit 20 0 die Zeilennummer, und Sie erkennen jetzt sicher die Codes der Angaben von Zeile 20 wieder.

So, jetzt wollen wir den Zeiger in 43/44 verbiegen. Ich schlage vor, daß wir den Basic-Beginn um zehn Adressen höher schieben wollen. Sie müssenjetzt die in Zeile 100 oben verwendete Zahl für A in die High/Low-Byte-Darstellung umrechnen und das Low-Byte um 10 erhöhen. Dieses Zahlenpaar POKEn wir in die Zellen 43/44. Vorher müssen wir aber noch in die Zelle (A + 10) - 1 eine Abstands-Null POKEn.

Wir geben diese Befehlsseguenz im Direktmodus ein: □ für den C 64:

POKE 2058,0;POKE 43,ll:POKE 44,8:NEW
- für den VC 20 (GV):<br>POKE 5006,0:POKE 43,143:POKE 44,19:NEW
- für den VC 20 (= 3 KByte):<br>POKE 1034,0:POKE 43,ll:POKE 44,4:NEW
- für den VC 20 (> 8 KByte)<br>POKE 4618,0:POKE 43,ll:POKE 44,18; NEW

Jetzt ist der Anfang des Basic-Speichers versetzt. Um das zu prüfen, geben wir das kleine Programm von oben nochmal ein und lassen es mit RUN laufen. Der resultierende Bidlschirmausdruck ist in Bild 3 dargestellt.

Die ersten Zahlen sind genauso wie vorher. Es sind auch die Reste von vorher, da wir den Speicher nicht auf Null gesetzt haben. Aber zählen Sie bitte die ersten zehn Adressen hoch. Da finden Sie unser Programm von vorhin genau wieder, beginnend mit der Abstandsnull. Aber Vorsicht, lassen Sie sich nicht verwirren, denn die Koppeladressen sind natürlich jetzt auch jeweils um 10 höher. Aber hinter den Koppeladressen finden wir wieder unser Programm, in gleicher Weise dargestellt wie beim ersten Mal. Da der Zeiger in 43/44 von allen entsprechenden Routinen des Übersetzers und des Betriebssystems abgefragt wird, läuft ein verschobenes Programm fehlerfrei, solange natürlich der Zeiger nicht wieder verändert wird.

# Der gläserne VC 20: Teil 4

> Nachdem wir in der letzten Folge Funktion und Sinn verschiedener Vektoren erläutert haben, wenden wir uns heute einem nicht minder interessanten Kapitel, nämlich den verschiedenen hochauflösenden Grafikmodi zu.

Dieser Teil unserer Serie soll schrittweise zur Gestaltung des Bildschirmes in hochauflösender beziehungsweise vielfarbiger Grafik hinführen. Dazu ist eine genaue Kenntnis der VIC-Register und des Speicheraufbaus notwendig. Wer sich nochmals eine Übersicht über die Aufteilung des Speichers verschaffen will, der kann jetzt in Teil 1 und 3 dieser Serie nachschlagen.

## Der VC 20-Zeichensatz

Wenn man den Computer einschaltet, so stehen »serienmäßig« zwei Zeichensätze zur Verfügung (Großschreibung mit Grafikzeichen oder Groß- und Kleinschreibung). Die Umschaltung zwischen beiden erfolgt, wie bekannt, unter anderem über die Tastenkombination CBM + SHIFT.

Was geschieht bei dieser Umschaltung, und warum lassen sich beide Zeichensätze (normalerweise) nicht gleichzeitig darstellen? Um diese Fragen zu klären, betrachten wir im folgenden das Innenleben des VIC (Video Interface Chip).

Dieser Baustein kümmert sich um alles, was mit der Informationsweitergabe an das angeschlossene Fernsehgerät zu tun hat, also Bild, Farbe und Ton. Da er — wie bereits das letzte Mal kurz angedeutet — eigenständig, das heißt unabhängig von der CPU arbeitet, muß der VIC selbständig auf Informationen zurückgreifen können. Diese sind zum einen in den internen Registern, zum anderen in den normalen Speicherstellen enthalten. Die Register speichern Parameter für die Bildschirmgröße, die Tongeneratoren, die Lage des Bildschirm-, Farb- und Zeichenspeichers. Ferner können aus ihnen die Zustandswerte des Paddels und des Lichtgriffels ausgelesen werden (Tabelle 1).

Nun wollen wir sehen, wie man die Startadressen der einzelnen VIC-externen Speicherstellen ermitteln kann. Beginnen wir mit dem Videospeicher.

Wenn man Bild 1 betrachtet merkt man schon, wie haarig die Berechnung mit Hilfe der einzelnen Bits ist. Aus den beiden hier beteiligten Registern Nummer (#) 2, Adresse 36865, und Nummer 5 (Adresse 36869) müssen jeweils bestimmte Bits für die Erstellung der Adresse herangezogen werden. Bild 1 zeigt nun, wie die jeweiligen Bits (die vier höchstwertigen aus Register # 5 und Bit 7 aus Register # 2) in das High-Byte-Schema »eingebaut« werden. Ferner muß Bit 7 aus Register #2invertiert werden, das heißt aus der Null wird eine Eins und umgekehrt.

Fassen wir noch einmal zusammen: Aus bestimmten Bits der Register 2 und 5 entsteht das High-Byte der Bildschirmspeicheranfangsadresse (ein Low-Byte gibt’s hier nicht). Außerdem sind bestimmte Bits aus diesem Adreßschema immer auf Null. Die Konsequenz daraus ist, daß der Videobereich nur in bestimmten Speicherbereichen angesiedelt werden kann. Tabelle 2 zeigt die möglichen Adressen, die sich aus Bild 1 ergeben. Zu beachten ist, daß das untere Nibble (1 Nibble = 4 Bits) im Register #5 dem Zeichenspeicher zugeordnet ist, dieses darf vorläufig noch nicht angetastet werden.

## Kompliziertes — Die Adreßermittlung

In gleicher Weise wie für den Bildschirm wird auch die Adresse des Farbspeichers ermittelt. Auch hier gibt es ein Adreßschema (Bild 1), in das Bit 7 aus Register #2 eingesetzt wird. Daher erklärt sich auch, warum sich bei einer Erweiterung von mehr als 8 KByte der Farbspeicher verschiebt. Liegt der Bildschirmspeicher bei Adresse 4096, dann hat Bit 7 aus Register # 2 den Wert Null, wodurch sich eine Coloradresse von 37888 ergibt. Im anderen Fall (Bildschirmstartadresse 7680) ist genau dieses Bit auf eins, wodurch es eine Verschiebung nach 38400 gibt.

Kommen wir nun zum Zeichenspeicher. Er erhält Informationen über jedes Zeichen, das auf dem Bildschirm darstellbar ist. Auch hier kann über das untere Nibble von Register #5 die Startadresse ermitteln. (Bild 2). Wenn die Bits 0-3 auf Null gesetzt sind, liegt sie bei 32768, also im Zeichengenerator-ROM (Normalstellung). Dort sind alle beim VC 20 verfügbaren Zeichen abgelegt (in welcher Form dies geschieht, werden wir später noch sehen).

Wie sie bestimmt schon bemerkt haben, spielt bei der Verwaltung des Bildschirms die Adresse 36869 (Register # 5) eine bedeutende Rolle. Fragt man sie mit PEEK ab, so erhalten wir in der Grundversion oder bei einer 3-KByte-Erweiterung den Wert 240, bei einem um 8 KByte erweiterten Speicher 192. Zerlegt man diese Zahlen wie in Bild 2, so erhält man jedes Mal die gleiche Adresse für den Zeichenspeicher. Setzen wir nun Bit 1 auf 1 (= 242 in GV beziehungsweise 194 bei 8 KByte), liegt die Anfangsadresse des Zeichenspeichers bei Adresse 34816 (Tabelle 3), wodurch wir auf einmal Groß- und Kleinschrift auf dem Bildschirm haben. Die eine der zwei zu Anfang gestellten Fragen haben wir damit beantwortet.

Wie sind die im Zeichengenerator abrufbaren Zeichen eigentlich aufgebaut? Spätestens hier müssen wir ein Zeichen (im wahrsten Sinne des Wortes) unter die Lupe nehmen (Bild 3). Die vergrößerte Darstellung läßt erkennen, daß jedes Zeichen aus acht Zeilen mit je acht Spalten (8 x 8 Matrix) zusammengesetzt ist. Innerhalb dieses Gitters sind einzelne Punkte gesetzt beziehungsweise gelöscht. Jede Zeile innerhalb dieser Matrix ist als Byte (mit verschieden gesetzten Bits) im Zeichengenerator-ROM abgelegt (ROM natürlich deshalb, damit die Zeichen nach dem Abschalten erhalten bleiben).

## Punkt für Punkt — der Zeichenaufbau

Im unteren Teil von Bild 3 sieht man sehr gut, daß ein gesetzter Punkt der 1, ein nicht gesetzter (gelöschter) Punkt der 0 entspricht. Die Zeile wird dann in einen normalen Zahlenwert zwischen 0 und 255 umgerechnet. In dieser Form und in der Zeilenreihenfolge von oben nach unten sind sie nun im ROM abgelegt. Der »Klammeraffe« @ (Bildschirmcode 0) ist als erstes Zeichen dort zu finden. Folglich enthält die Startadresse des Zeichengenerators (Adresse 32768) die 0-te Zeile des Zeichens — also 28, Adresse 32769 enthält 34 und so weiter. Damit machen wir folgende Rechnung auf:
Ein Zeichen: 8 Byte
Anzahl: 128 Zeichen
Invers: 128 Zeichen

Also 256 Charakter pro Zeichensatz mal 8 Bytes = 2048 Bytes Platzbedarf für Großbuchstaben und Grafikzeichen mit deren inversen Gegenstücken. Dazu kommen nocheinmal so viele Bytes für den zweiten Zeichensatz, womit sich ein Speicherbedarf von 4 KByte für den gesamten Zeichenvorrat des VC ergibt.

## Die Platznummern

Jedes Zeichen hat nun eine (eben durch die Reihenfolge im ROM) bestimmte Platznummer zugewiesen bekommen. Der Klammeraffe (@) hat die 0, der Buchstabe A die 1, B die 2 und so weiter.

Diese Platznummern stehen als Bildschirmcodes im Handbuch auf Seite 141. POKEt man nämlich ein Zeichen ins Bildschirm-RAM, so multipliziert der VIC den Bildschirmcode mit 8 und addiert die Startadresse des Zeichengenerators hinzu.

Beispiel: Das Zeichen $ (Bildschirmcode 36) ist ab folgender Adresse abgespeichert (Formel 1).
AD = BC \* 8 + ZG
36 \* 8 + 32768 33056
TODO

Diese Formel müssen wir im Hinterkopf behalten, denn wir benötigen sie später noch.

Weiterhin ist anzumerken, daß jeweils nur 256 Zeichen gleichzeitig dargestellt werden können (eine Ausnahme davon lernen wir nächstes Mal kennen).

## Characterstyling: Eigene Sonderzeichen

Schön wäre es nun, wenn man jedes Zeichen nach eigenen Wünschen abändern könnte. Dies gehi (wie sich inzwischen wohl herumgesprochen hat), indem man den Zeichengenerator (also die Zeicheninformationen) ins RAM verlegt und das Register #5 ändert.

Dazu müssen wir uns anhand einer Grafik des Speicheraufbaus (Bild 4) überlegen, wo wir diese Zeichen abspeichern, denn wie in Tabelle 2 zu sehen ist, lassen sie sich nicht überall, sondern nur an bestimmten Stellen unterbringen. Auch hier muß man zwischen den beiden Ausbaustufen Grundversion /+3 KByte und ab 8 KByte unterscheiden.

## Nachhilfe — Die logischen Funktionen

Aufgrund der Zweiteilung des Registers # 5 sollte man alle Änderungen nur mit Hilfe logischer Funktionen durchführen, dazu ein kleiner Exkurs.

Gerade bei unserem Fall, aber auch bei anderen Gelegenheiten, will man nur bestimmte Bits einer Speicherstelle ändern. Mit den boolschen Operationen OR und AND lassen sich jeweils die gewünschten Bits Ein- beziehungsweise Ausschalten.

Die erste wichtige Verknüpfungsoperation ist die ODER- (in Basic OR) Operation, die zwei Bits nach der in Tabelle 4a abgebildeten Wahrheitstabelle verknüpft. Haben wir nun eine Kette von 8 Bit (also ein Byte), so kann man mit Hilfe dieser Operation bestimmte Bits »einschalten«. Dazu ein Beispiel: Von einer Speicherstelle sollen die Bits 1 und 6 eingeschaltet werden. Da Basic die Binärzahlen nicht direkt, sondern nur als Dezimalzahlen verarbeiten kann, müssen wir zunächst alle Werte in dieses Zahlensystem umwandeln.

TODO

Durch Addition der Wertigkeiten der zu setzenden Bits ergibt sich der Wert 66 (= 64 + 2). Durch die OR-Verknüpfung der Speicherstelle mit 66 ergibt sich folgende Bitstruktur (für den ursprünglichen Inhalt der Speicherstelle nehmen wir einmal 229 an):

TODO

Der gewünschte Effekt ist eingetreten, das heißt die Bits 1 und 6 wurden gesetzt (da Bit 6 bereits eingeschaltet war, ergab sich hier keine Änderung).

Analog verfährt man beim Löschen bestimmter Bits. Dazu wird dann allerdings die UND-Operation (Basic-Befehl AND) verwendet. Wie Tabelle 4b zeigt, bleiben nur die Bits unverändert, die mit 1 »verANDet« werden. Auch hierzu ein Rechenbeispiel, bei dem die Bits 1 und 6 gelöscht werden sollen:

TODO

Auch hierbei muß man sich vor der Verknüpfung ein Bitmuster berechnen, in dem die zu löschenden Bits auf Null, die nicht zu verändernden auf 1 gesetzt werden müssen. Wem dies noch nicht restlos klar ist, der sollte anhand von einigen Rechenbeispielen diese Operationen üben, denn wir benötigen diese in der nächsten Folge, wenn es darum geht, jeden Grafikpunkt einzeln anzusteuern (beispielsweise über Koordinaten).

Aber auch das Register #5 kann damit wesentlich eleganter geändert werden. So schaltet POKE 36869,PEEK (36869) OR 1 auf Groß-/Kleinschreibung um (überlegen Sie mal, warum dies so ist), wobei man keine Unterscheidung zwischen verschiedenen Speicherausbaustufen treffen muß.

Fassen wir das bis jetzt behandelte noch einmal kurz zusammen: Wir haben also die Möglichkeit, den gesamten Zeichensatz ins RAM zu verlegen. Dort kann er dann nach eigenen Wünschen verändert werden. Bevor man jedoch irgendeine Änderung vornehmen kann, müssen die Zeichen in das bisher ja »leere« RAM kopiert werden.

Das in Listing 1 abgedruckte Basic-Programm erfüllt diese Aufgabe. Die Routine ist so aufgebaut, daß lediglich die Variable RG eingesetzt werden muß. Sie wurde mit Absicht so allgemein gehalten, damit sie für alle Speichererweiterungen einsetzbar ist.

Hier nun eine Auflistung der einsetzbaren Werte (sie entsprechen im übrigen denen in Tabelle 2):

RG = 12: Aus diesem Registerwert errechnete sich das Programm die Zeichenspeicheradresse 4096. Die Zeichen füllen bei dieser Einstellung also den gesamten Grundversionsspeicher aus (aber wer benötigt schon 512 verschiedene Zeichen?). Man nutzt diese Zeichenfülle also nur bei einem um mindestens 3 KByte erweiterten Speicher aus. In diesem Fall (und auch bei einer 8-KByte-Erweiterung) darf man den Bildschirmspeicher nicht außer acht lassen, denn dieser befindet sich ja auch im Bereich zwischen 4096 und 8192 (je nach Erweiterung). In beiden Fällen ergeben sich also Überschneidungen zwischen den beiden Speichern. So können bei einem 8-KByte-Speicher die unteren 512 Byte nicht für Zeicheninformationen verwendet werden (da dort ja der Bildschirmspeicher liegt). Also reduziert sich die Anzahl der verfügbaren Zeichen um 64.

Bei einer 3-KByte-Erweiterung wird man mit dem gleichen Problem konfrontiert.In diesem Fall werden die obersten 512 Bytes vom Videospeicher in Beschlag genommen.

**ZG = 13** (Startadresse 5120): Mit diesen 384 Zeichen kommt man in der Regel gut aus (wie man alle auf den Bildschirm bringt, sehen wir in der nächsten Folge). Bezüglich der Nutzbarkeit der Zeichen ergibt sich nur bei der Grundversion beziehungsweise 3-KByte-Erweiterung das Problem, daß der obere Bereich (also Adresse 7680 bis 8192) vom Bildschirmspeicher belegt werden. Das betrifft die Bildschirmcodes 64 bis 128 im Klein-/Großschriftmodus.

**ZG = 14** (Startadresse 6144): Hier haben wir Platz für 256 Zeichen, die bei 8 KByte voll nutzbar sind. Im anderen Fall sind wiederum 64 Zeichen für den Videospeicher zu subtrahieren.

**ZG = 15** (Startadresse 7168): Diese Zeichenmenge wird üblicherweise in der Grundversion verwendet. Hierbei reduziert sich der Programmspeicher nämlich nur um 512 Byte (also 64 Zeichen). Die anderen 64 Zeichen fallen ja wiederum dem Bildschirmspeicher zum Opfer. .

Da das Zeichenkopieren fast immer notwendig ist, verwendet man anstelle des Basicprogramms aus Geschwindigkeitsgründen besser eine Maschinenroutine (Listing 2 und 3). Das Programm kann mit Hilfe des Laders in ihre eigene Grafikroutine eingebaut werden. Auch speicherplatzmäßig ergeben sich, da das Maschinenprogramm recht kurz ist, keine Probleme, denn es liegt im Bandpuffer (Adresse 828).

### Das Ändern der Sonderzeichen

Nun sind wir an einer Stelle angelangt, von der aus wir die Zeichen nach eigenen Wünschen abändern können, seien es mathematische Sonderzeichen, deutsche Umlaute oder Grafikzeichen für eigene Spielprogramme.

Am Anfang steht der Entwurf eines Zeichens mit Hilfe einer 8 x 8 Matrix (Bild 5). Hier in unserem Beispiel soll das Pfundzeichen £ (Bildschirmcode 28) durch das Copyrightzeichen ersetzt werden.

Dazu wird unser Beispielprogramm aus Listing 1 um folgende 5 Zeilen ergänzt:
60 CH = 28: AD = CH \* 8 + ZG: REM Formel #1
70 FOR Z = 0 TO 7
80 READ D
90 POKE AD\*Z,D: NEXT
100 DATA 60, 66, 153, 161, 153, 66, 60

Der Bildschirmcode des Zeichens wird durch die Variable CH übergeben. Daraus errechnet sich das Programm die Startadresse des Zeichens, indem es den Bildschirmcode mit 8 multipliziert und die Anfangsadresse des Zeichenspeichers dazuaddiert (in unserem Fall 6144).

### Das Abspeichern der Zeichen

Im allgemeinen erstellt man solche Zeichen nicht aus Spaß an der Freude, sondern man möchte sie in Spielen oder anderen Programmen verwenden. Dazu müssen sie in irgendeiner Form abgespeichert werden. Hierfür gibt es wieder zweierlei Möglichkeiten. Entweder man schreibt die Zeicheninformationen in Form von DATA-Zeilen ins Programm oder man SAVEt sie direkt auf Band oder Diskette ab.

Beide Verfahrensweisen eignen sich für bestimmte Anwendungsgebiete besonders gut, für andere weniger gut.

Die DATA-Zeilen-Methode eignet sich dann, wenn es darum geht, lediglich 3 oder 4 Zeichen abzuändern (beispielsweise für ein Textverarbeitungsprogramm mit deutschen Umlauten). Diese werden dann — wie in dem Beispiel oben — als DATA-Zeilen ins Programm geschrieben.

Für größere Änderungen am Zeichenvorrat ist diese Methode aber aus Geschwindigkeits- und Platzgründen (sie benötigt etwa viermal so viel Platz) denkbar ungeeignet.

Bei der anderen Methode werden die Zeicheninformationen wie ein Programm einfach auf Band abgespeichert. Dazu besinnen wir uns wieder auf Folge 1 in Ausgabe 9, wo von den Basic-Zeigern die Rede war. Ferner ist dort beschrieben, wie man Platz für Maschinenprogramme und Sonderzeichen schafft, und sie vor dem Zugriff des Basicinterpreters schützt. Auch hier muß man — wie so oft, wenn es um Grafik oder Bildschirm geht — zwischen den zwei grundsätzlichen Ausbauversionen unterscheiden.

All diese Vorgänge möchte ich anhand von Bild 6 erklären (6a für die Grundversion, 6b für die 8-KByte-Erweiterung):

Grundversion (Bild 6a): Der dunkelgelb unterlegte Teil der Speichergrafik stellt den Adreßbereich dar, auf den der Interpreter zurückgreift. Dieser geht normalerweise bis Adresse 7680 (zu erkennen an der hellgelben Farbe).

Durch die Umstellung mit PO-KE 55,0: POKE 56, 28:CLR hat man Platz für 64 Zeichen (= 512 Byte) geschaffen, die vom Interpreter nicht angetastet werden (dies haben wir ja in Folge 1 schon besprochen).

Nun aber zu dem Abspeichern des Zeichensatzes. Auch beim SAVEn richtet sich der VC nach diesen Zeropagezeigern, denn er speichert alles ab, was er zwischen den beiden Adreßpaaren 43, 44 (Basic-Anfang) und 45,45 (Programmende) findet. Folglich gibt das erste Paar die Anfangs-, das andere die Endadresse der zu speichernden Daten an. Normalerweise sind diese Daten das Basic-Programm, welches sich zwischen diesen Zeigern befindet. Durch eine Änderung der beiden Zeropagespeicherstellen 45 und 46 auf das Ende des Zeichensatzs (Adresse 7680) bewirkt man, daß das gesamte Programm mit Variablenbereich und Zeichensatz abgespeichert wird (Bild 6a — rote Markierung).

## Schritt für Schritt auf Band

Hier noch einmal die nötigen Programmschritte:

1. Programm um Zeile 5 ergänzen.<br>5 POKE 45, XXX: POKE 46, XX: POKE 55, 0: POKE 56, 28: CLR<br>Warum muß das Programm um eine Zeile ergänzt werden? Nun, da sich der Computer bei der Variablenverwaltung nach diesen Zeigern richtet, müssen diese nach dem Ladevorgang wieder auf den alten Wert — der auf das wirkliche Programmende zeigt — gesetzt werden, damit der Computer nicht mit der Verwaltung durcheinander kommt. Auch die Zeichen selbst müssen nach dem Laden wieder vor dem Interpreterzugriff geschützt werden, welches durch die Veränderung der Zeiger 55, 56 geschieht.
2. Nun stellen wir quasi »zu Fuß« den Inhalt von Adresse 45 und 46 fest:<br>PRINT PEEK(45), PEEK(46)
3. Diese Werte werden nun nachträglich (statt »xxx«) in Zeile 5 geschrieben, wobei zu beachten ist, daß der Wert von Adresse 45 ein-, zwei- oder dreistellig sein kann (oben wurden drei Stellen angenommen). Sollten es nun nicht drei Ziffern sein, so ist der Rest mit Nullen zu ergänzen (zum Beispiel 2= 002 oder 34 = 034). Wichtig ist, daß sich die Zeilenlänge nicht ändert, da sich damit auch das Programmende verschieben würde.
4. Die Zeiger werden nun zum Abspeichern vorbereitet: POKE 45, 0: POKE 46, 30: CLR: SAVE»...«.

Wie man sieht, befindet sich das Programm vor den Sonderzeichen im Speicher. Die Zeiger müssen zum Abspeichern also nach oben gesetzt werden. Bei einer 8-KByte-Erweiterung liegt der Fall genau anders herum. Dort liegt der Zeichensatz nämlich vor dem Programm. Folglich muß hier der Basic-Anfang beim Abspeichern nach unten gelegt werden, aber dies besprechen wir jetzt im Folgenden noch genauer:

8-KByte-Erweiterung (Bild 6b): Auch hier ist die erste Handlung das Verstellen eines Basic-Zeigers. Auffällig ist, daß die Sonderzeichen — wie oben bereits angesprochen — nicht mehr oberhalb des Basic-Programms (also wie in Bild 6a zu sehen an dessen Ende), sondern unterhalb liegen. Daher muß die Basic-Anfangsadresse so geändert werden, daß auch hier kein zerstörendes Eingreifen mehr möglich ist. Durch das Hochsetzen der Startadresse von 4608 auf 8129 wird dies erreicht: POKE 44, 32: POKE 8192,0: NEW

Diese Anweisung ist vor dem Laden oder der Eingabe des Programms notwendig, denn wie man sieht, muß nach der erstmaligen Umschaltung der Programmspeicher mit NEW gelöscht werden.

Nachdem sich nun das Programm und die Sonderzeichen im Speicher befinden, können beide zusammen wieder abge-SAVEt werden; auch dazu ein »Rezept«:

1. Den Inhalt von Zeigerpaar 45,46 feststellen und notieren.
2. Basic-Anfang auf 4608 (Ursprungswert) zurückstellen: POKE 44,18: NEW
3. Zeile eingeben:<br>10 POKE 44,32: RUN
4. Den notierten Zeigerinhalt in die beiden Zeropagespeicherstellen zurückschreiben:<br>POKE 45,Low-Byte: POKE 46, High-Byte: CLR
5. Die Zeichen mit dem Programm abspeichern (SAVE).

Lädt man das Programm wieder in den Speicher, so muß das High-Byte des Basic-Anfangszeigers (44) auf 32 gestellt werden, denn dort befindet sich ja das eigentliche Programm. Zeile 10 in Schritt 3 hat diese Aufgabe. Die Zeile befindet sich am zurückgestellten Programmbeginn (4608), also noch vor dem Zeichensatz, der erst bei Adresse 5120 beginnt. Das hat den Vorteil, daß man das Programm direkt mit RUN starten kann.

Soweit der wichtige Abschnitt über das Abspeichern der Sonderzeichen, der mit Absicht etwas umfangreich ausgefallen ist, denn auch derjenige, der nicht so viele Kenntnisse über den VC 20 hat, soll in der Lage sein, seine grafischen Werke auf Band zu bringen.

Mit dieser Erkenntnis beschließen wir die Einführung in die ’Grafikfähigkeit des VC 20. Das nächste Mal benutzen wir die bisher gewonnenen Grundlagen, um voll in die Materie einzusteigen.

(Christoph Sauer/ev)

Dem Klang auf der Spur: Teil 2

> Bevor wir in der nächsten Folge genauer auf die Musik- und Klangerzeugung auf dem SID eingehen, soll in dieser Folge die Musik im allgemeinen behandelt werden.

Der Komplex Mathematik/Informatik und die Musik haben sich lange genug als zwei getrennte Welten gegenübergestanden. In den letzten Jahren hat man erkannt, daß Computerprogramme, die von anderen Leuten benutzt werden als von denen, die sie geschrieben haben, möglichst viele Sinne und Bereiche des Gehirns ansprechen müssen, um Erfolg zu haben. Schlagwörterwie Benutzerfreundlichkeit, Softwareergonomie und gehirngerechte Programme sind in diesem Zusammenhang aufgetaucht. Ästhetische Gesichtspunkte setzen sich in der Computertechnik mehr und mehr durch.

Die Musik bedient sich seit der Erfindung des Phonographen mehr und mehr der Technik, besonders der Elektronik, die auch die technische Grundlage für Computer darstellt. Und obwohl die Welten noch getrennt sind, gibt es eine Menge Analogien zwischen Informatik und Musik: Musiker und Informatiker wirken beide gestaltend. Beide schreiben ihre Werke in einer abstrakten Sprache nieder. Die Werke erwachen erst durch eine Interpretation zum Leben und vermögen uns dann zu faszinieren. Was dem Musiker sein Instrument ist, ist für den Informatiker der Computer. Sowohl in der Informatik als auch in der Musik gab und gibt es Tendenzen, universelle Instrumente, die möglichst alles können sollen, zu schaffen. In der Musik zeugen die gewaltigen Kirchenorgeln und die Orchestrions des vorigen Jahrhunderts von diesen Bemühungen. Programmgesteuerte Rechner waren schon bald nach ihrer Erfindung mehr als nur Rechenmaschinen. Die technische Annäherung der beiden Bereiche ist heute schon so weit fortgeschritten, daß, zumindest was elektronische Musik anbelangt, es keinen wesentlichen Unterschied mehr zwischen Computern und Musikinstrumenten gibt. Mit Computern kann man heute nicht nur Noten editieren und Partituren plotten lassen, sondern Musik direkt auf vielfältige Weise wiedergeben. Ein moderner Synthesizer kann heufe nicht nur typisch »elektronische« Klänge erzeugen, sondern auch lebendige Naturklänge bis hin zur menschlichen Stimme. Und bei genauerer Betrachtung erweist er sich als ein Computer, der mit einigen Sonderbauteilen und einem besonderen Betriebssystem auf seine Aufgabe spezialisiert wurde.

Der Musiker (zumindest der Studiomusiker) kommt also heute nicht darum herum, sich auch mit der Computertechnik zu befassen, während der Computerspezialist eher spielerisch mit der Musik, die sein Computer so nebenbei bietet, konfrontiert wird.

Man kann wagen zu hoffen, daß der künstlerische und der wissenschaftliche Typ im Universalinstrument Computer einen Ort der Begegnung finden werden. Dieser könnte ihnen die Welt des jeweiligen anderen Charakters, der in vielleicht vernachlässigter Form auch in einer eigenen Gehirnhälfte schlummert, auf vertrautem Boden eröffnen.

Diese Serie soll hauptsächlich dem Computeranwender, der schon einige Programmiererfahrung hat, zeigen wie man die Musikfähigkeiten des C64 gezielt einsetzen kann, doch sollen auch die Musiker, die genügend Aufgeschlossenheit gegenüber der neuen Technik mitbringen, nicht zu kurz kommen.

## Die Grundlagen

Um die Wirkungsweise elektronischer Musikinstrumente zu verstehen und um Musik einer Bearbeitung mit dem Computer zugänglich zu machen, müssen wir akustische Ereignisse mit Mitteln der Physik und der Mathematik beschreiben. Wenn auch unsere Sprache eine sehr technische ist, werden wir doch so oft wie möglich den Bezug zur traditionellen Sprache der Musik herstellen. Da wir stilistisch zunächst keine experimentelle Musik machen wollen, sondern Musik im traditionellen Stil mit dem Computer realisieren wollen, ist dies sogar unumgänglich.

### Musik nicht mehr als Schwankungen des Schalldrucks?

Auslösend für eine Wahrnehmung des Gehörs ist ein sich schnell verändernder Schalldruck. Treten diese Veränderungen periodisch, das heißt zeitlich regelmäßig auf, so nimmt das Gehör einen Ton oder einen Klang wahr, andernfalls ein Geräusch. Trägt man den sich verändernden Schalldruck nach oben gegen eine rechtsgerichtete Zeitachse auf, erhält man einen für das akustische Geschehen charakteristischen Kurvenzug (Bild 1). Bei Tönen und Klängen, die einen periodischen Kurvenverlauf haben, genügt zur vollständigen Beschreibung die Angabe einer einzelnen Periode. Diese Beschreibungsart nennt man »Darstellung im Zeitbereich«, da sich aus ihr zu jedem Zeitpunkt die zugehörige Amplitude ablesen läßt. Diese Beschreibungsart erscheint, technisch gesehen, zunächst als die natürlichste, zumal bereits seit langem existierende Geräte wie Plattenspieler und Tonbandgerät getreue Abbilder solcher Kurvenzüge in Form von Rillen beziehungsweise einer magnetisierten Schicht verwenden. Die Beschreibung im Zeitbereich entspricht aber nicht der Arbeitsweise des Gehörs. Das Ohr ist kein Mikrofon, das nur Kurvenzüge an das Gehirn weitergibt. Dem Gehör und auch den meisten elektronischen Musikinstrumenten entspricht besser die »Beschreibung im Frequenzbereich«.

### Beschreibung im Frequenzbereich — Fourier-Reihen

Wir betrachten zunächst periodische Kurvenzüge, weil diese als Töne und Klänge die Hauptrolle in der Musik spielen. Um einen periodischen Kurvenzug zu beschreiben, genügt es eigentlich, seine Frequenz, das heißt die Anzahl der Perioden, die pro Sekunde wiederkehren, seine Amplitude, also den Wert des maximalen Ausschlags des Kurvenzuges nach oben und nach unten und die Kurvenform zu kennen (Bild 2). Frequenz und Amplitude lassen sich leicht durch Zahlen ausdrücken. Da Frequenz und Amplitude für Tonhöhen- und Lautstärkeempfinden verantwortlich sind, hat man hier schon zwei musikalisch wichtige Parameter erfaßt. Die Kurvenform, die für den Klangcharakter verantwortlich ist, kann man allerdings nicht so einfach beschreiben. Es gibt aber einige einfache spezielle Kurvenformen, die sowohl theoretisch als auch musikalisch eine besondere Rolle spielen:

### Die Sinus-, Rechteck-, Sägezahn- und Dreieck-Kurve

Diese Kurvenformen lassen sich mathematisch und grafisch einfach darstellen und auch technisch mit vertretbarem Aufwand mit einer Schaltung erzeugen. Der Sinus-Funktion kommt aber noch eine besondere Bedeutung zu. Akustisch wird der Sinuston, den kein natürliches Instrument erzeugen kann, als dumpf, undifferenziert und ohne ausgeprägten Charakter empfunden. Den Sinuston kann man sich als das einfachste mögliche akustische Ereignis vorstellen, aus dem man sich alle anderen Klänge mit periodischem Kurvenzug zusammengesetzt denken kann. Diese Betrachtungsweise läßt sich mathematisch durch die sogenannte »Entwicklung in Fourier-Reihen« rechtfertigen: Gehen wir von einer periodischen und stetigen Funktion aus. Stetig bedeutet anschaulich, daß der Kurvenzug keine Sprünge macht beziehungsweise, daß er sich in einem Zug zeichnen läßt ohne daß man absetzen muß. Die ideale Rechteck- und Sägezahnfunktion ist nicht stetig. Die Sprungstellen sind aber bei den realen elektro-akustischen Kurven nur mehr oder wenig steile Flanken. Eine solche Funktion kann man nun als Summe von geeigneten Sinus- und Cosinus-Funktionen schreiben (Bild 3).

Diese Summen bestehen im allgemeinen aus unendlich vielen Summanden. Eine solche Summe nennt man in der Mathematik eine Reihe. Die Fourier-Reihen bestehen aus Sinus- und Cosinus-Funktionen mit Frequenzen, die immer nur ganzzahlige Vielfache der Grundfrequenz betragen. Andere Frequenzen treten nicht auf. Die erste Komponente der Reihe nennt man auch Grundton, die weiteren Obertöne. An der unendlichen Anzahl der Summanden darf man sich nicht stoßen; eine solche Summe ist nämlich so zu verstehen: Betrachtet man nur eine Teilsumme, zum Beispiel mit allen Summanden bis zur fünffachen Grundfrequenz, so erhält man eine Funktion, die zwar nicht exakt die darzustellende Funktion ist, die sie aber bestmöglich annähert, so gut das mit fünf Sinus- und Cosinus-Funktionen eben möglich ist. Nimmt man weitere Obertöne hinzu, zum Beispiel noch den sechsten und den siebten Oberton, dann wird die Annäherung besser. Es ist durch Hinzunahme von immer mehr Obertönen in die endliche Summe möglich, die Originalkurvenform beliebig genau anzunähern, wobei Obertöne mit wachsender Frequenz anteilmäßig beliebig klein werden. Nur unter diesen Umständen darf man in der Mathematik von einer unendlichen Summe (= Reihe) sprechen. Diese Umstände sind aber bei den Fourier-Reihen durch die Theorie gesichert.

### Beschreibung im Frequenzbereich — das Spektrum

Eine Fourier-Reihe wird bereits allein durch die Angabe ihrer Koeffizienten vollständig beschrieben. Die Koeffizienten sind die Zahlen, die angeben, wie stark die einzelnen Grund- und Obertonanteile vertreten sind. Die Folge dieser Koeffizienten nennt man das Spektrum der dargestellten Kurvenform. Diese Koeffizienten beschreiben einen Klang genauso vollständig wie die der Kurve zugrundeliegende Funktion. Eine anschauliche Darstellung des Spektrums erhält man, wenn man auf einer waagrechten Achse in gleichmäßigen Abständen die Frequenzen des Grundtones und der Obertöne kennzeichnet und darauf Balken errichtet, deren Höhe den Koeffizientenwerten entspricht.

Die Fourier-Reihe beziehungsweise das Spektrum eines Klanges nennt man auch »Beschreibung im Frequenzbereich«. Die beiden vorgestellten Darstellungsarten von Klängen sind gleichwertige Beschreibungen ein und derselben Sache und lassen sich ineinander umrechnen (Bild 4).

### Wie das Gehör arbeitet

Unter Gehör wollen wir das Ohr zusammen mit dem Teil des Gehirns verstehen, der für die Verarbeitung von akustischen Reizen zuständig ist. Dem Gehör wird nun die spektrale Sichtweise von Klängen weitaus besser gerecht als die Sichtweise als Kurvenformen. Der schallverarbeitende Teil des Innenohres (Schnecke mit Basilarmembran und dem Cortischen Organ) zerlegt in der Tat die eintreffenden Schwingungen in ihre spektralen Bestandteile und leitet diese einzeln über zirka 30000 Nervenfasern an das Gehirn weiter. Das Gehirn verarbeitet also Spektren und nicht Kurvenformen. Es macht einem geschulten Gehör keine Mühe, aus einem Orchester einzelne Instrumente herauszuhören. Musiker können sogar aus dem Klang eines einzelnen Instruments die Obertöne einzeln für sich hören. Sieht man sich die Kurvenform eines Orchesterklanges mit Mikrofon und Oszilloskop an, so sieht man nur Chaos, betrachtet man aber das Spektrum, so kann man durchaus einzelne Instrumente oder Instrumentengruppen wiedererkennen. Die Leistungsfähigkeit der spektralen Betrachtungsweise wird hier deutlich. Das menschliche Gehör kann im Idealfall Frequenzen im Bereich von 16 Hz bis 20000 Hz wahrnehmen. Man kann daher bei Spektren Obertöne über 20000 Hz unberücksichtigt lassen. Ein Beispiel: Ein Sinuston und ein Sägezahnklang, beide von 400 Hz, klingen sehr unterschiedlich. Während der Sägezahn ein reichhaltiges Obertonspektrum besitzt, besteht der Sinus nur aus einem Grundton. Der Sägezahn klingt daher auch hell und scharf, während der Sinuston als weich und dumpf empfunden wird. Beträgt die Grundfrequenz der beiden Kurven aber zum Beispiel 16000 Hz, so kann man keinen Unterschied mehr hören, weil bereits der erste Oberton des Sägezahn mit 32000 Hz weit jenseits der Hörgrenze liegt.

### Der Ton macht die Musik — über hohe und tiefe Töne

Wenn wir mit elektronischen Mitteln Musik machen wollen, müssen wir über Frequenzen genau Bescheid wissen. Das Gehör leitet die empfundene Tonhöhe grundsätzlich vom Grundton ab, unabhängig vom restlichen Spektrum, das für die Klangfarbe verantwortlich ist. Wir müssen uns zunächst also nur mit dem Grundton befassen. Eine interessante Eigenschaft des Gehörs ist, daß es absolute Tonhöhen schlecht, relative aber sehr gut bestimmen kann. Spielt man einen beliebigen Ton aus der Stille heraus ohne jede Vergleichsmöglichkeit, so wird sich selbst ein Musiker in der Beurteilung der Tonhöhe um bis zu mehreren Halbtönen verschätzen (außer den wenigen, die mit einem »absoluten Gehör« gesegnet sind). Spielt man aber innerhalb eines Musikstücks nur einen Viertel- oder gar einen Ächtelton falsch, so hört das sogar ein unmusikalischer Laie.

Das Gehör kann also Frequenzabstände gut beurteilen, arbeitet dabei aber logarithmisch. Das bedeutet, daß der empfundene Tonabstand, den man in der Musik als Intervall bezeichnet, nicht von der Differenz der Frequenzen abhängt, sondern von ihrem Verhältnis zueinander.

Ein Beispiel: Drei Töne mit 500 Hz, 1000 Hz und 1500 Hz sind jeweils 500 Hz voneinander entfernt. Das Verhältnis von Ton 2 zu Ton 1 ist 1000:500 = 2:1, das von Ton 3 zu Ton 2 aber 1500:1000 = 3:2. Ton 3 und Ton 2 liegen dem Hörempfinden nach näher beieinander als Ton 2 und Ton 1. Das Verhältnis 2:1 ist musikalisch die Oktave, das Verhältnis 3:2 die Quinte. Alle anderen musikalischen sinnvollen Intervalle lassen sich durch ähnlich einfache Zahlenverhältnisse charakterisieren (Tabelle 1).

### Tonsysteme — reine und temperierte Stimmung

Aus einer Auswahl von theoretisch unendlich vielen Frequenzen zwischen 16 Hz und 20 000 Hz beschränkt man sich in der Musik immer auf eine Auswahl von Frequenzen, eine Skala. In dieser Auswahl kann man eine weitere Eigenschaft des Gehörs erkennen: Je einfacher das zahlenmäßige Frequenzverhältnis zweier Töne ist, desto mehr scheinen Töne zueinander zu passen, desto mehr verschmelzen sie zu einem Klangbild. Aus diesem Grund spielen in der Musik die Intervalle mit den einfachsten Frequenzverhältnissen, die Oktave (2:1), die Quinte (3:2) und die Quarte (4:3) die zentrale Rolle. Töne im Oktavabstand werden musiktheoretisch nicht einmal als etwas wesentlich Verschiedenes angesehen. Die abendländischen Tonskalen werden alle dadurch gewonnen, daß man von einem festen Ton ausgehend in Quint-, Quart- und Oktavabständen mehr oder weniger neue Töne in die Skala einbezieht. Wenn man sich mit dieser Methode um 12 Quinten nach oben vom Grundton entfernt hat, erhält man einen Ton, der annähernd 7 Oktaven vom Grundton entfernt ist. Man erhält also mit mehr als 11 Quintenschritten nichts wesentlich Neues mehr. Bringt man die durch Quintenschritte erhaltenen 11 Töne durch Oktavverschiebungen in den Bereich einer einzigen Oktave, so teilen sie dieses Intervall in 12 annähernd gleiche kleine Teilintervalle, die sogenannten Halbtöne auf. Aus diesem Grund wird in der Musik, die wir betrachten, fast ausschließlich diese 12stufige Skala oder eine Teilmenge von ihr verwendet. Die 12 Halbtöne dieser sogenannten »rein gestimmten« Skala haben, wie schon erwähnt, nicht exakt den gleichen Abstand voneinander. Wenn man eine Melodie transponiert, das heißt jeden Ton um das gleiche Intervall verschiebt, und dabei nur die 12 schon vorhandenen Halbtöne verwendet, erhält man eine Melodie, die, abgesehen davon, daß sie jetzt höher oder tiefer erklingt, auch einen etwas anderen harmonischen Charakter hat. Dieses Problem hat bereits J.S. Bach erkannt und die sogenannte temperierte Stimmung erfunden, welche die Oktave in 12 mathematisch exakt gleiche Intervalle einteilt.

Die temperierte Stimmung wird heute fast ausschließlich verwendet. Die Berechnung der Frequenzen für ein elektronisches Musikinstrument ist einfach: Ausgehend vom eingestrichenen a, dessen Frequenz international auf 440 Hz festgelegt ist, erhält man die anderen Frequenzen der anderen Töne der Oktave durch wiederholte Multiplikation mit dem Halbtonabstand <sup>12</sup>√2. Die Frequenzen der Töne anderer Oktaven erhält man durch Multiplikation und Division mit Zweierpotenzen (Tabelle 2).

Bevor wir detailliert auf die Klangerzeugung im C 64 eingehen, wollen wir uns erst einen Überblick über die wichtigsten Synthesetechniken in elektronischen Instrumenten verschaffen.

### Additive und subtraktive Synthese in Orgeln

Der Unterschied zwischen Orgel und Synthesizer verwischt sich durch den zunehmenden Einzug der Digitaltechnik mehr und mehr. Hier soll aber noch einmal der Unterschied zwischen einer typischen Orgel und einem typischen Synthesizer, wie er noch vor einigen Jahren bestanden hat, dargestellt werden.

## Synthesetechniken

In einer Orgel werden fürjede einzelne Taste ein oder mehrere Töne zur Verfügung gestellt. Man braucht dazu so viele einzelne Tongeneratoren, wie das Instrument Tasten hat. Diese Tongeneratoren, die Sinus-, Rechteck- oder Sägezahnschwingungen erzeugen können, müssen alle einzeln gestimmt werden. Den Aufwand an Generatoren kann man reduzieren, wenn man nur die 12 Töne der obersten Oktave erzeugt und die Töne der weiteren Oktaven durch Frequenzteilung realisiert. Die hier erforderliche Teilung durch Zweierpotenzen ist schaltungstechnisch einfach zu lösen. Man kann sogar die 12 Töne der obersten Oktave durch Teilung aus einer noch viel höheren Master-Frequenz (im MHz-Bereich) gewinnen. Dadurch wird die Orgel stimmstabil und kann als Gesamtheit, nur durch Verändern der Masterfrequenz anderen Instrumenten angepaßt werden. Ein Nachteil dieses Teilerkonzepts ist, daß die Oktaven zu genau sind. Da Töne im Oktavabstand phasenstarr miteinander gekoppelt sind, klingen zwei solche Töne wie nur ein Ton, nur mit einem etwas volleren Oberton-Spektrum.

Charakteristisch für eine Orgel ist, daß alle Töne gleichzeitig und durchgehend bereitstehen und durch Tastendruck auf einen Verstärker durchgeschaltet werden, der sie hörbar macht. Dieses Konzept hat den Vorteil, daß beliebig viele Töne polyphon, das heißt gleichzeitig gespielt werden können. Gehen wir einmal davon aus, daß eine Generatorgruppe für alle Tasten Sinustöne zur Verfügung stellt. Dann findet man zumindest für die tieferen Töne der Klaviatur neben dem Grundton eine ganze Reihe von geeigneten Obertönen aus der Generatorgruppe. Diese kann man durch geeignete Verschaltung den Grundtönen zumischen, wobei der Anteil der Obertöne einzeln und stufenlos durch sogenannte Zugriegel eingestellt werden kann. Benötigt man auch für die hohen Töne der Klaviatur noch Obertöne, so muß die Generatorgruppe mehr Töne erzeugen können, als die Orgel Tasten hat. Einen solchen Klangaufbau aus einzelnen Obertönen nennt man »Additive Synthese«.

### Filter

Nun kann die Generatorgruppe einer Orgel oft auch Rechteck- oder Sägezahnschwingungen erzeugen, die von sich aus schon sehr obertonreich sind. Leitet man diese Schwingungen durch Filter, wird der Obertongehalt abgewandelt: es entstehen weitere Klangfarben. Ein Filter ist eine Baugruppe, die Signale abhängig von ihrer Frequenz verstärkt oder abschwächt (Bild 5). Ein Filter macht aus einem Sinuston immer wieder einen Sinuston, nur mit veränderter Amplitude. Andere Signale werden durch ein Filter auch in ihrer Kurvenform geändert. Man kann sich in Gedanken vorstellen, daß ein Filter ein Signal in seine Spektralanteile zerlegt, jeden einzelnen sinusförmigen Anteil frequenzabhängig verstärkt oder abschwächt und schließlich diese Anteile wieder zu einer neuen Kurvenform zusammenbaut. Da Filter keine neuen Obertöne produzieren, sondern nur das Verhältnis von vorhandenen Obertönen zueinander verändern, spricht man von »subtraktiver Synthese«.

## Perkussion, Tremolo, Vibrato

Eine Orgel, wie sie bis hierher beschrieben wurde, klingt noch sehr starr und unlebendig. Wenn auch additive Synthese und Filterung eine gewisse Variation der Klangfarbe zulassen, so ist der Klang trotzdem so unlebendig wie der einer Autohupe, die einfach ein- und ausgeschaltet wird. Da der zeitliche Lautstärkeverlauf viel vom Charakter eines Klanges ausmacht, kommt man nicht umhin, die Amplitude eines Klanges vom Anschlag der Taste bis zum Loslassen dynamisch zu beeinflussen. Ein Verstärker, dessen Verstärkung im Moment des Anschlags am größten ist und die dann exponentiell abklingt, sorgt für einen natürlichen, perkussiven Amplitudenverlauf. Den zeitlichen Verlauf der Amplitude eines Klanges nennt man seine Hüllkurve.

Man kann bei Orgeln auch nur einzelne Obertöne abklingen und andere unverändert stehen lassen. Man erhält damit einen Klang, dessen Färbung sich im zeitlichen Ablauf ändert. Man spricht dann von **Klangfarbendynamik**.

Mit **Tremolo** beziehungsweise **Vibrato** bezeichnet man langsame periodische Änderungen in der Lautstärke beziehungsweise in der Tonhöhe eines Klanges. Beide Effekte lassen den Klang voller, natürlicher und wärmer wirken. Ein gutes Vibrato erhält man mit rotierenden Lautsprechern. Dieser Effekt läßt sich aber auch mit rein elektronischen Mitteln realisieren.

### Das klassische Synthesizer-Konzept von Moog

Eine Orgel, wie sie hier vorgestellt wurde, erzeugt trotz aller Feinheiten nur Klänge, die durch den Umfang der Generatorgruppe, durch fest eingestellte Filter und durch die verfügbaren Effektschaltungen für Perkussion, Vibrato und Tremolo festgelegt sind.

Der (klassische) Synthesizer dagegen ist ein Instrument, das keine festen Klangregister wie die Orgel besitzt. Er setzt sich aus Baugruppen zusammen, die unabhängig voneinander die verschiedenen Qualitäten eines Klanges bestimmen, wie Tonhöhe, Amplitude und Klangfarbe. Diese Baugruppen lassen sich dabei noch dynamisch beeinflussen. Bild 6 zeigt ein Schema eines einfachen klassischen Synthesizers. Die Funktionsblöcke waren früher physikalisch als Einzelmodule gebaut, die sich erst der Anwender zu seinem persönlichen Synthesizer zusammengestellt hat. Auch die Verbindungen der Blöcke untereinander lagen vollkommen in der Hand des Musikers. Das Schema in Bild 6 stellt nur eine Minimalkonfiguration mit Standardverkabelung dar.

Das Manual (Keyboard) schaltet nicht fertige Klänge durch wie bei der Orgel, sondern erzeugt lediglich eine Steuerspannung (Control Voltage CV), die der Tonhöhe entspricht, sowie ein digitales Signal (Gate), das anzeigt, ob eine Taste gedrückt ist oder nicht. Standard bei der Steuerspannung ist 1 V pro Oktave beziehungsweise ^ V pro Halbton.

Die Steuerspannung steuert das »Herzstück« des Synthesizers, den spannungsgesteuerten Oszillator (Voltage Controlled Oscillator VCO), der die gängigen Kurvenformen wie Sinus, Dreieck, Sägezahn, Rechteck erzeugen kann. Er hat im allgemeinen eine exponentielle Steuercharakteristik von 1 V pro Oktave, damit er zum Keyboard paßt. Der VCO hat, wie auch die anderen spannungsgesteuerten Baugruppen, einen Steuerspannungs-Addierer. Damit kann man seine Frequenz über mehrere Eingänge gleichzeitig manipulieren.

Die Schwingungen des VCO gelangen an ein spannungsgesteuertes Filter (Voltage Controlled Filter VCF). Man kann einstellen, ob sich das Filter wie ein Hochpaß, ein Tiefpaß, ein Bandpaß oder wie eine Bandsperre verhalten soll. Die Filterresonanz ist ebenfalls einstellbar. Der wichtigste Filterparameter, die Eckfrequenz, ist darüber hinaus auch durch eine Spannung steuerbar. Schließt man wie im Bild 6 die CV des Keyboards an das Filter mit an, so folgt es mit seiner Eckfrequenz exakt der Frequenz des zu filternden Klanges, was ein Festfilter in einer Orgel nicht kann.

Ein spannungsgesteuerter Verstärker (Voltage Controlled Amplifier VGA) sorgt schließlich für eine Amplituden-Hüllkurve. Die Steuerspannung stammt von einem Hüllkurvengenerator (Envelope Generator EG), im Bild 6 EG 2. Dieser erzeugt, ausgelöst durch den Gate-Impuls der Tastatur, einen der gewünschten Hüllkurve entsprechenden Spannungsverlauf. Es ist Standard geworden, Hüllkurven nach dem ADSR-Schema mit nur vier Parametern zu charakterisieren:

Attack — Anstiegszeit von Null auf Maximalpegel
Decay — Abklingzeit bei gedrückter Taste auf den Sustain-Pegel
Sustain — Pegel, der sich nach der Attack- und Decay-Phase einstellt
Release — Ausklingzeit nach Loslassen der Taste

Die Zeiten (A,D und R) sind im allgemeinen im Bereich von Millisekunden bis zu mehreren Sekunden einstellbar. Der Sustainpegel kann von Null bis zum Maximalpegel variiert werden.

Bei manchen Synthesizern ermöglicht ein weiterer EG (im Bild 6 EG 1) eine getrennte Beeinflussung des Filters. Damit ist eine Gestaltung der Klangfarbendynamik in weiten Grenzen möglich.

Auch Vibrato und Tremolo werden über eine weitere Steuerspannung bewirkt. Ein eigener Oszillator für niedrige Frequenzen von zirka 0,1—20 Hz (Low Frequency Oszillator LFO) ist dafür vorgesehen. Schaltet man den LFO auf den VCO so erhält man ein Vibrato, schaltet man ihn auf den VCA, so erhält man ein Tremolo. Die Tiefe der LFO-Modulation ist an jeder Baugruppe stufenlos einstellbar. Eine bei natürlichen Instrumenten nicht mögliche Modulation erhält man durch Beeinflussung des Filters durch den LFO.

Der Rausch-Generator (Noise-Generator) ist ein wichtiges Effekt-Element jedes Synthesizers. Rauschen wird durch modulierbare Filterung erstaunlich vielseitig und lebendig. Im Spektrum des theoretisch idealen Rauschens sind alle Frequenzen gleichermaßen vertreten. Einzelne Grund- und Obertöne treten nicht auf. Da Rauschen kein periodisches Signal ist, kann man keine FOURIER-Reihe dafür angeben. Daß man dennoch von einem Spektrum reden darf, sichert eine erweiterte Theorie, auf die hier nicht eingegangen werden soll. Durch Rauschen mit dynamischer Filterung und Amplitudenhüllkurve lassen sich fast alle geräuschhaften Ereignisse nachbilden. Dies kommt noch mehr den Videospielen als der Musik zugute.

Unser Synthesizer-Schema kann man durch weitere Baugruppen ergänzen. So ergeben mehrere parallelgeschaltete VCOs einen volleren Klang, wenn man sie parallel stimmt, oder ermöglichen das Spielen von Akkorden, wenn man sie im Abstand musikalischer Intervalle stimmt. Mehrere LFOs gestatten reichhaltigere Möglichkeiten zu Modulationen.

Ein Nachteil soll aber nicht verschwiegen werden: Es kann immer nur ein Ton oder Klang gespielt werden. Möchte man polyphon spielen, so benötigt man einen Synthesizer, der aus so vielen Einzelschaltungen nach Bild 6 besteht, wie man maximal Töne gleichzeitig spielen möchte. Weiterhin benötigt man ein Keyboard, das mehrere unabhängige CV-Gate-Signal-Paare erzeugen kann. Der Schaltungsaufwand dafür ist sehr hoch. Man hat ihn aber heute dank fortschreitender Integration im Griff. So enthält der Sound-Chip des C 64 immerhin einen Synthesizer, der fast dem dreifachen des Standardschemas entspricht.

## Digitaltechnik bei Analog-Synthesizern

Die Stärke des (Moog-) Synthesizers ist gerade, daß alle wesentlichen Eigenschaften der Module in weiten Grenzen einstellbar sind. Um aber eine einmal gefundene Einstellung reproduzierbar zu machen, muß man alle wichtigen Einstellparameter speichern und bei Bedarf diese gespeicherten Werte an den Modulen neu einstellen. Bei den ersten Synthesizern mußte man sich alle Werte aufschreiben und zur Reproduktion mühsam oft über hundert Potentiometern einstellen. Heute übernimmt diese Aufgabe weitgehend die Digitaltechnik. Es gibt kaum mehr professionelle Analog-Synthesizer, die nicht auch einen Mikrocomputer enthalten. Analog bedeutet hier, daß die Klangerzeugung weiter nach dem Schema von Bild 6 abläuft, das heißt, daß insbesondere die dynamische Steuerung der Module weiter über Steuerspannung erfolgt, daß aber die Einstellung von festen Parametern ein Mikrocomputer übernimmt. Dieser speichert ganze Parametersätze für verschiedene Sounds in nichtflüchtigen Speichern und belegt die Module auf Knopdruck mit einem gewünschten Parametersatz. Der Mikrocomputer kann auch ein polyphones Keyboard verwalten.

Bei weiterem Fortschreiten der Digitalisierung gibt es in einem Synthesizer keine Steuerspannungen mehr. VCO, VCF und VGA werden dynamisch mit Digitalwerten gesteuert. Sinngemäß spricht man dann auch von DCO, DCF und DCA. Die Funktion von LFOs und von Hüllkurvengeneratoren kann direkt von einem Mikrocomputer wahrgenommen werden. Dieser muß Folgen von digitalen Werten zur Verfügung stellen, die in ihrem zeitlichen Verlauf einer Modulationskurve oder einer Hüllkurve entsprechen. Theoretisch sind so zum Beispiel beliebige Hüllkurven denkbar, man hält aber meistens an dem bewährten ADSR-Schema fest.

Der Sound-Chip im C 64 entspricht diesem Konzept. Funktionell entspricht er ungefähr dreimal dem Schema nach Bild 6. Die Funktionsblöcke werden nicht mit Spannungen oder über Drehknöpfe gesteuert, sondern über Digitaldaten, die in eigenen Speicherplätzen des Synthesizers, den SID-Registern abgelegt werden müssen. Durch Adreß-Decodierungs-Hardware werden diese Register auf den CPU-Speicherbereich $D400 - $D41C abgebildet. Der Computer kann allein durch Belegung dieser Register mit sinnvollen Werten den Synthesizer-Chip steuern. Was dem C 64 zu einem vollständigen Sythesizer fehlt, ist ein Keyboard als musikergerechte Schnittstelle sowie festeingebaute Software zur Steuerung des Sound-Chips, denn mit dem Sound-Chip allein kann man noch keine Musik machen.

Das fehlende Keyboard ist nur dann ein Mangel, wenn man live auf dem C 64 spielen will. Wir werden in dieser Reihe sehen, wie man über das alphanumerische Tastenfeld spielen kann. Das soll aber nur experimentellen Charakter haben, zumal bereits ein brauchbares Musiker-Keyboard samt Software auf dem Markt ist. Die Stärke der Wiedergabe vorprogrammierter Musikstücke und in der Erzeugung von Sound-Effekten für Spiele. Daß es sich bei den Programmiertechniken, die dazu noch vorgestellt werden, nicht nur um reine Spielerei handelt zeigt die Tatsache, daß mit denselben Techniken auch zeitexaktes Steuern von mehreren professionellen Synthesizern über eine MIDI-Schnittstelle möglich ist.

Weitere interessante neuere Synthesetechniken sollen nur erwähnt, aber nicht näher beschrieben werden, da sie mit dem C 64 allein nicht zu verwirklichen sind.

Sound-Sampling bedeutet die vollständige Digitalisierung eines ganzen Kurvenverlaufs. Der Kurvenverlauf wird durch Abtastung natürlicher Schallereignisse gewonnen, oder ist das Ergebnis eines Rechenprozesses oder eine Kombination von beiden. Er befindet sich digitalisiert in einem Speicher, der periodisch ausgelesen wird, vergleichbar dem Auslesen des 

TODO Fortsetzung auf Seite 163

---

Bild 5. Das Prinzip der Filter, die verschiedenen Filtertypen und die Filterresonanz

Ein Filter verändert das Verhältnis der Obertöne eines Klanges zueinander. Filter werden durch ihren Frequenzgang beschrieben. Der Frequenzgang ist die Funktion, die das Verhältnis von Ausgangs- zu Eingangsamplitude bei Sinustönen, abhängig von der Frequenz, beschreibt.

Frequenzgang eines Hochpaßfilters mit einer Eckfrequenz (das ist die Frequenz, bei der die Filterwirkung von Sperren nach Durchlassen übergeht) von zirka 550 Hz.

Geht man davon aus, daß das Rechtecksignal eine Grundfrequenz von 100 Hz besitzt, dann sieht das Spektrum nach Durchlaufen des Filters etwa so aus:

### Gebräuchliche Filtertypen sind:

Beschrieben werden Filter durch:
Eckfrequenz f<sub>e</sub> (Hoch- und Tiefpaß)
Mittelfrequenz f<sub>m<sub> (Bandpaß und Bandsperre)
Steilheit: Das ist der Grad der Steigung des Frequenzgangs beim Übergang zwischen sperrendem und durchlässigem Zustand.
Resonanz siehe Zeichnung

### Filterresonanz

Unter Resonanz versteht man die Verstärkung der Frequenzen um die Eck- beziehungsweise Mittenfrequenz. Alle bisher dargestellten Filter haben sehr niedrige Resonanz, da sie bei fe beziehungsweise fm nicht verstärken sondern nur mehr oder weniger abschwächen.

---

Assembler ist keine Alchimie: Teil 5

> In dieser Folge des Assembler-Kurses wird die relative Adressierung erklärt. Damit verbunden sind auch die wichtigen Vergleichsoperationen. Anhand einer sehr häufig verwendeten Betriebssystem-Routine können Sie Ihr neu erworbenes Wissen testen.

In der letzten Ausgabe haben wir die Branch-Befehle kennengelernt. Heute wollen wir uns mit der relativen Adressierung dieser Befehle und noch einer anderen Art der Adressierung befassen. Weiterhin werden Sie einige neue Assembler-Worte lernen, nämlich die Vergleichsbefehle. Wie ganze Zahlen im Computer gespeichert sind, wissen wir bereits. Heute untersuchen wir die Speicherung von Zeichen. Schließlich werden wir unsere Nase noch ein wenig in die eingebaute Software des C 64 stecken.

### Die relative Adressierung

Als wir den BNE-Befehl das erstemal verwendet haben, stellten wir fest, daß zum Beispiel BNE 1200 nicht — wie eigentlich zu erwarten war — ein 3-Byte-Befehl, sondern ein 2-Byte-Befehl ist. Damals mußten wir uns mit der Bemerkung zufrieden geben, es läge an der besonderen Art der Adressierung, nämlich der relativen Adressierung. Relativ bedeutet ja »bezogen auf etwas«. Wenn wir also beispielsweise BNE 1200 schreiben, liegt es nur an der Benutzerfreundlichkeit des SMON und vieler anderer Assembler, daß dieser die so geschriebene absolute Adresse 1200 in die richtige Form, nämlich die relative umrechnet. In Wahrheit verlangt der 6502 (und natürlich ebenso der 6510) eine Angabe darüber, wieviele Bytes nach vorne oder hinten im Programm er zur weiteren Programmverarbeitung springen (verzweigen) soll. Es gilt nun also, zwei Fragen zu klären:

1.	Relativ wozu wird gesprungen und
2.	Wie berechnet sich die Angabe, um wieviele Bytes nach vorne oder hinten im Programm der Sprung vollzogen werden soll.

Zur Klärung verwenden wir ein hypothetisches Programmsegment mit einem Sprungbefehl und sehen uns das Disassembler-Listing an:

TODO

Dieses Programm-Teilchen lädt den Inhalt der Speicherstelle 3000 in den Akku, überprüft dann, ob dieser Inhalt null ist und verzweigt beim Vorliegen der Null zum Rücksprung (RTS). Ist der Inhalt von 3000 nicht Null, dann wird 3000 auf Null gesetzt. 3000 könnte zum Beispiel eine Flagge sein.

Der Pfad, dem der Computer bei der Abarbeitung des Programmes folgt, wird durch den Programmzähler vorbereitet. Dieser ist dann, wenn der BEQ-Befehl an der Reihe ist, schon einen Schritt weiter, nämlich im Programmzähler steht dann die Adresse 2005.

Relativ zu dieser Adresse hat dann der Sprung zu erfolgen. Zum Inhalt des Programmzählers muß also die Sprungweite (auch häufig Offset genannt) addiert werden. Soweit zur Frage 1.

Zur Klärung von Frage 2 listen wir uns mal Byte für Byte unser Programm auf:

TODO
TODO

Neben der Byte-Nummer ist noch die Entfernung zu 2005 geschrieben. Daraus ist deutlich zu erkennen, daß die Sprungweite, die zum Programmzähler addiert wird, 05 sein muß, wenn der Sprung zum RTS erfolgen soll. Für Vorwärts-Verzweigungen gilt also: Von der Adresse des Befehls an, der auf den Branch-Befehl folgt, zählt man die Byte-Anzahl bis zum Sprungziel. Das Ergebnis ist der Offset.

Nun gibt es genauso häufig Rückwärts-Sprünge. In den bisher gezeigten Programmen sind sie mehrmals aufgetreten. Wie berechnet man den Offset in diesen Fällen? Sehen wir uns wieder das Disassembler-Listing eines solchen Programmsegmentes an:

TODO

Dieses Progrämmchen tut nichts anderes, als das vorher auf Null gesetzte X-Register hochzuzählen, bis es über 255 läuft (dann tritt ja wieder 0 auf!). Solange der Inhalt des X-Registers ungleich Null ist, erfolgt ein Sprung zurück bis zur INX-Anweisung in Zeile 1002. Erst wenn die Null durch den Überlauf aufgetreten ist, endet das Programm mit einem BRK in Zeile 1005.

Wir wissen schon, daß der Programmzähler beim Verarbeiten des BNE-Befehls auf 1005 steht. Sehen wir uns auch dieses Programm Byte für Byte an:

TODO

Wieder ist neben der Bytenummer die Entfernung vom aktuellen Programmzählerstand angegeben. Wir müssen also vom Inhalt des Programmzählers 3 abziehen, um zum INX-Befehl in Byte 1002 zu gelangen. Das kennen wir aber schon aus den vergangenen Ausgaben: Wenn der Computer eine Zahl abzieht, dann addiert er das Zweierkomplement dieser Zahl. Hier soll nun 3 subtrahiert werden. Wir berechnen das Zweierkomplement:
3 = 0000 0011 (binär)
Das Einerkomplement davon ist:
1111 1100
Dann wird eine 1 addiert
1111 1101

Dies ist das Zweierkomplement. In hexadezimal ausgedrückt heißt diese Zahl $FD und ist unser Offset. Für Rückwärts-Verzweigungen gilt also: Von der auf die Branch-Anweisung folgenden Speicherstelle an zählt man die Bytes zurück bis zum Sprungziel. Das Zweierkomplement der sich dadurch ergebenden Byte-Anzahl ist der Offset.

Das sieht reichlich kompliziert aus, aber zum einen haben Sie ja einen ganz freundlichen Assembler und nur in seltenen Notfällen müssen Sie den Offset berechnen. Zum anderen gibt es noch eine Faustregel, mit der man sich das ganze vereinfachen kann. Die soll durch folgendes Schema erläutert werden:

TODO

Bei Vorwärtssprüngen ist ohnehin alles klar: Bei einem Sprung nach Adresse 2005 müßte man in vorliegendem Fall einen Offset von 03 eingeben. Bei Rückwärts-Verzweigungen zählt man einfach von $FF an rückwärts bis zur Zieladresse. Eine Verzweigung nach 1996 würde im vorliegenden Fall also einen Offset von $FA erfordern.

Eine Einschränkung der relativen Adressierung können Sie nun auch sofort verstehen, wenn Sie an Zweierkomplementzahlen denken: Der Offset belegt ein Byte. Die größte positive Zahl in einem Byte ist
0111 1111 = +127 = $7F
und die kleinste negative Zahl ist
1000 0000 = -128 = ($80)

Es sind keine größeren Vorwärts-Verzweigungen als um 127 Bytes möglich, weil in diesem Fall ein Offset größer als $7F, also mit einem Bit 7 gleich 1 nötig wäre, was aber wieder als negative Zweierkomplementzahl verstanden und einen Rückwärtssprung verursachen würde. Ähnliches gilt anders herum: Es ist kein weiterer Rücksprung als um 128 Bytes möglich, weil das im Offset zum gelöschten Bit 7 führen würde, also zu einem Offset kleiner als $80, was wiederum anstelle des Rücksprunges eine Vorwärts-Verzweigung herbeiführen würde.

Darauf sollte man achten beim Erstellen eines Assembler-Programmes, daß man nie weitere Rückwärtssprünge als um 128, beziehungsweise Vorwärtssprünge um 127 Bytes verlangt. Auch wenn man im Assembler gar nicht auf relative Adressierung Rücksicht nehmen muß, weil der Assembler sich mit den Absolutadressen begnügt, sollte man wissen, daß zum Beispiel folgende Zeile aufgrund dieser Einschränkung nicht möglich ist:
3000 BNE 1000

Die meisten Assembler reagieren auf solch eine Zeile mit einer Fehlermeldung oder so wie der SMON, der klammheimlich die Programmstartadresse statt 1000 einsetzt. Aber es ist doch ärgerlich, wenn man auf dem Papier ein Programm fertig hat und erst beim Eintippen feststellt, daß der Computer das so nicht haben will.

### Zeropage-Adressierung

Weil wir nun gerade mit der Adressierung so schön in Schwung sind, stelle ich Ihnen noch eine andere vor: Die Adressierung der Zeropage. Was ist die Zeropage? Auf deutsch heißt das Nullseite. Am besten versteht man das, wenn man sich in Erinnerung ruft, wie Adressen in unserem Computer verwaltet werden. Da haben wir doch ein LSB (Least Significant Byte) und ein MSB (Most Significant Byte), zum Beispiel $lF 04 (mit lF als MSB und 04 als LSB). Nun hat unser C 64 65535 Adressen von $0000 bis $FFFF. Bei den ersten 256 Adressen von $0000 bis $00FF ist das MSB $00. Man nennt so einen 256-Byte-Block eine Seite (engl. page). Weil hier für alle Adressen dieser ersten Seite des MSB Null ist heißt sie Nullseite = Zeropage. Messerscharf werden Sie schließen, daß man die Seite mit den MSBs $01 als erste Seite bezeichnet, die mit den MSBs $02 als 2. Seite und so weiter.

Wenn wir nun zum Beispiel den Akku mit dem Inhalt der Zeropage-Adresse $00FA laden wollen, dann könnten wir schreiben:
3000 LDA 00FA

Unser Mikroprozessor versteht uns aber auch, wenn wir nur schreiben:
3000 LDA FA

Das ist sie, die Zeropage-Adressierung. Anstelle eines 3-Byte-Befehls ist das jetzt ein 2-Byte-Befehl, was Speicherplatz und vor allem Rechenzeit einspart. Auf diese Weise kann man von den bisher kennengelernten Befehlen folgende adressieren:
LDA, LDX, LDY, STA, STX, STY, INC, DEC, ADC und SBC

Sie können sich merken, daß man (bis auf zwei Ausnahmen, die wir noch kennenlernen werden) alle absolut adressierbaren Befehle auch Zeropage-absolut anwenden kann. Genauere Angaben über die Codes, die Ausführungszeiten und die Beeinflussung der Flaggen (letztere ist identisch mit der absoluten Adressierung) entnehmen Sie bitte der angefügten Tabelle 1.

Zum Thema Geschwindigkeit: Wenn Sie die benötigten Taktzyklen von absolut und von 0-absolut adressierten Befehlen in den Tabellen miteinander vergleichen, werden Sie jeweils einen Unterschied von einem Zyklus feststellen. Das mag Ihnen läppisch vorkommen. Bedenken Sie aber, daß Sie sehr häufig Schleifen programmieren müssen, die mehrere 100 Mal durchlaufen werden, die vielleicht als oft zu verwendende Unterprogramme dienen... Sie werden bald feststellen, daß da schnell beachtliche Zeitunterschiede auftreten können: Für zeitkritische Programme ist die Verwendung der Zeropage-Adressierung dringend geboten.

Dieser Tatsache waren sich leider auch die Schöpfer unseres Betriebssystems und des Basic-Interpreters voll bewußt. Die Zeropage ist nahezu randvoll mit Speicherstellen, in denen sich beide Programmkomplexe tummeln. Fast jede Kernal- und Interpreter-Routine notiert sich irgendwelche Werte auf der Seite Null. Das macht es uns als Assembler-Programmierer nicht gerade leicht, die Zeropage-Adressierung zu verwenden, wenn wir außerdem den Interpreter oder das Betriebssystem benutzen wollen. Es kann geradezu katastrophale Folgen haben, einige Zeropage-Adressen zu überschreiben. Andere werden ständig neu beschrieben durch das Betriebssystem oder den Interpreter, was unseren eigenen — vielleicht gerade in so einer Speicherzelle gelagerten — Zwischenwerten den Garaus machen würde. Man sollte sich also die ersten 256 Speicherstellen ganz genau ansehen, bevor man sie adressiert oder aber auf das Betriebssystem und den Basic-Interpreter verzichten. Ersteres erleichtern uns Tabellen der Speicherbelegung (zum Beispiel Babel, Krause, Dripke »Das Interface Age Systemhandbuch zum Commodore 64«, Interface Age Verlag, oder »Das Commodore 64 Buch, Band 4, Ein Leitfaden für Systemprogrammierer«, Markt und Technik Verlag) und auch die Serie von Dr. Helmut Hauck »Memory Map mit Wandervorschlägen«, die seit Ausgabe 11/84 erscheint.

Ohne Hemmungen nutzen dürfen wir nur die Speicherstellen (jedenfalls beim C 64) $02 und $FB bis $FE. Weil das doch recht mikrig ist, hat jeder Assembler-Programmierer spezielle Tips, welche Zellen er noch mit welchen Vorsichtsmaßnahmen benutzt. Wenn man bestimmte Routinen aus dem Betriebssystem oder dem Interpreter nicht aufruft, bleiben dazugehörige Zeropage-Adressen unbeeinflußt und sind dann für eigene Zwecke nutzbar. Manchmal ist es notwendig, den alten Zustand einer Adresse nach Beendigung eigener Programme wieder herzustellen, manchmal nicht. Interessant und viel beschrieben in allen möglichen Zeitschriften, Büchern etc. ist die Möglichkeit, die Notizen, die sich das Betriebssystem oder der Interpreter auf der Zeropage macht, zu verändern. Im Prinzip schreibt man damit kleine Teile dieser Großprogramme um oder variiert Tabellenteile davon. Wie schon Dr. Hauck in seiner Serie sagt, geschieht das im Rahmen der »Tricks« mit irgendwelchen POKEs mehr oder weniger blind, weshalb auch bevorzugt Abstürze des Computers dabei festzustellen sind. Warum Abstürze? Na, stellen Sie sich mal ein von Ihnen geschriebenes Programm vor — zum Beispiel das aus der letzten Ausgabe, zur Berechnung der Summe einer arithmetischen Reihe — und POKEn Sie dann anstelle irgendeines Befehlscodes, der dorthin gehört, jetzt eine 0 (also ein BRK) hinein. Die Wirkung dürfte ähnlich sein. Wenn man allerdings die Funktion der betreffenden Speicherstelle genau kennt, lassen sich recht nützliche Änderungen hervorrufen, wie zum Beispiel die SchutzPO-KEs für den Basic-Speicher durch Verändern der Adressen $33, $34, $37 und $38.

Wir werden im folgenden immer dann, wenn wir mit Zeropage-Ädressierung arbeiten oder Routinen des Betriebssystems oder Interpreters untersuchen, spezielle Stellen der Nullseite kennenlernen.

Vorhin hatte ich noch angedeutet, daß man dann die Zeropage fast vollständig nutzen könne, wenn man auf den Basic-Interpreter und das Betriebssystem verzichtet. Das ist tatsächlich möglich. Nur wird man dann erstaunt feststellen, wieviel Arbeit uns die computerinterne Software abnimmt oder anders herum: Viele bislang selbstverständliche Dinge werden wir dann plötzlich selbst programmieren müssen, und das kann ein hartes Brot sein!

Als Beispiel für ein Programm, das nicht nur die Zeropageadressierung verwendet, sondern sogar selbst komplett in der Zeropage steht, werden wir uns die CHRGET-Routine ansehen. Eine Klasse von Befehlen, die dort angewendet wird, die Vergleichsbefehle, soll zuvor noch gezeigt werden.

### Die Vergleichsbefehle: CMP, CPX, CPY

Vergleichen heißt in englischer Sprache »to compare«, woraus Sie unschwer erkennen können, woher die Bezeichnung CMP und die CPs in CPX beziehungsweise CPY kommen. Verglichen wird jeweils der Akku-Inhalt (bei CMP), der Inhalt des X- (bei CPX) oder des Y-Registers (bei CPY) mit Daten, die der Compare-Befehl adressiert. Einige Beispiele werden Ihnen das klarer machen:
CMP #FF
vergleicht den Akku-Inhalt mit der Zahl $FF. Hier liegt die unmittelbare Adressierung vor, die ebenso für CPX und CPY verwendbar ist. Außerdem ist das dann ein 2-Byte-Befehl.
CPX 3000
vergleicht den Inhalt des X-Registers mit dem Inhalt der Speicherstelle $3000. Die absolute Adressierung ist also auch anwendbar (natürlich auch für CMP und CPY). Der Compare-Befehl besteht so aus 3 Bytes.
CPY A8
vergleicht den Inhalt des Y-Registers mit dem Inhalt der Zeropage-Stelle $A8. Diese soeben frisch gelernte Zeropage-Adressierung ist bei allen drei Vergleichsbefehlen möglich und macht aus ihnen 2-Byte-Befehle.

Für CPX und CPY sind das alle Möglichkeiten der Adressierung. CMP erlaubt weitere, die wir noch kennenlernen werden. Nun interessiert uns natürlich noch, wie das Vergleichsergebnis zu erhalten ist! Bei diesen Befehlen geschieht merkwürdiges: Die Vergleichsdaten werden vom Inhalt des Akkus (beziehungsweise X- oder Y-Registers) abgezogen, aber: Weder wird dieser Inhalt noch werden die adressierten Daten verändert! Der Trick ist, daß drei Flaggen das Ergebnis anzeigen: Die Negativ-Flagge N, die Null-Flage Z und das Carry-Bit C. Diese Anzeige geschieht so:

1) Der Registerinhalt (Akku, X-, Y-Register) ist größer als die Vergleichsdaten:<br>Dann ist das Carry-Bit = 1, die N- und die Z-Flagge = 0.
2) Der Registerinhalt ist gleich den Vergleichsdaten:<br>Dann sind Carry- und Z-Flagge = 1, die N-Flagge = 0.
3) Der Registerinhalt ist kleiner als die Vergleichsdaten:<br>Die N-Flagge ist dann = 1, Carry- und Zero-Flagge sind 0.

Damit Sie die Übersicht behalten können, ist in Bild 1 das ganze als Schema gezeigt.

Sie werden sich vermutlich schon denken können, wie der Hase weiterläuft: Mit den Verzweigungsbefehlen prüfen wir die Flaggen und springen die gewünschten weiteren Programm-Routinen an.

Die Kombination der Compare-Befehle mit den Verzweigungsoperationen wird Ihnen im weiteren Verlauf dieses Kurses noch ganz geläufig werden. Ein Beispiel sehen Sie nachher ebenfalls in der CHRGET-Routine. Leider muß ich Sie immer noch etwas vertrösten, denn mit Verstand begreifen läßt sich diese Routine nur dann, wenn man etwas mehr über die Codierung von Zeichen weiß. Deswegen werden wir uns nun noch mit dem ASCII-Code und dem Commodore-ASCII herumschlagen.

### Zeichencodierung mit dem ASCII- und dem Commodore-ASCII-Code

ASCII ist die Abkürzung von »American Standard Code for Information Interchange« und das heißt auf deutsch »amerikanischer Standard-Code zum Informations-Austausch«. Diese Zeichenverschlüsselungsart ist international als ISO-7-Bit-Code genormt, und es wäre wirklich nett, wenn alle sich daran halten würden. Tatsächlich aber finden wir zum Beispiel bei unserem C 64 eine Abart des Normcodes, den Commodore-ASCII-Code. Über die damit erzwungenen Umrechnungen können alle diejenigen Dramen erzählen, die zum erstenmal einen (Nicht-Commodore-)Drucker an ihr Gerät anschließen oder aber blauäugig in den Online-Betrieb mit anderen Computern eintreten wollten.

Sehen wir uns zunächst einmal den ASCII-Code an. Es handelt sich um einen 7-Bit-Code, das heißt 128 Zeichen können in nur 7 Bits untergebracht werden (0000 0000 bis 01111111). Das achte Bit dient bei manchen Operationen mit Computer-Peripherie als Paritäts-Bit. Bei dieser Gelegenheit soll auch gleich erklärt werden, was Parität in diesem Zusammenhang bedeutet. Werden Daten übertragen, muß immer mit Übermittlungsfehlern gerechnet werden. Das Paritätsbit dient dazu festzustellen, ob ein Byte korrekt angekommen ist. Bei der sogenannten geraden Parität zählt man die Einser im Byte zusammen und setzt Bit 7 auf 1 wenn sich eine ungerade Zahl ergibt. Mit dem Paritätsbit haben wir dann eine gerade Zahl. Ist die Quersumme des Byte schon gerade, bleibt Bit 7 eine Null. Ebensogut kann man die ungerade Parität verwenden, indem dann Bit 7 so gewählt wird, daß sich immer eine ungerade Zahl ergibt. Welche Art der Parität zur Anwendung kommt, ist Vereinbarungssache. Nehmen wir mal an, es sei gerade Parität gefordert und ein Byte mit der Information 00010110 soll übermittelt werden. Die Quersumme ist 3, also ungerade. Das Paritätsbit muß auf 1 gesetzt werden. Wir senden das Byte 10010110. Der Empfänger überprüft zunächst auf gerade Parität und verwendet dann nur die Bits 0 bis 6. Doppelfehler, die mittels des Paritätsverfahrens nicht festgestellt werden können, sind sehr selten. Leider kann auf diese Weise nur bemerkt werden, daß ein Übertragungsfehler aufgetreten sein muß, aber nicht welcher. Die Information muß dann neu angefordert werden.
Sehen wir uns nun den Commodore-ASCII-Code an. Durch die Einbindung der Grafikzeichen brauchen wir mehr als die 128 Kombinationen. Commodore benutzt deswegen einen 8-Bit-Code. Mit dem Basic-Befehl CHR$(x) können Sie sich alle 256 Möglichkeiten ansehen. Erschwerend kommt aber noch hinzu, daß wir nicht nur einen Zeichensatz, sondern deren vier zur Verfügung haben, die durch den jeweiligen Schreibmodus ansprechbar sind (Klein-/Großschriftmodus, Großschriftmodus, beide Modi mit Reverse-ON oder OFF). Im Zeichen-ROM liegen insgesamt 512 Muster abrufbereit. Zu diesen kommen beim CHR$-Befehl noch eine ganze Reihe von Steuerzeichen hinzu... die Verwirrung ist perfekt! Wir wollen an dieser Stelle keine Entwirrung vornehmen, sondern wir durchschlagen den Gordischen Knoten, indem wir nur die ersten 128 Zeichen mit den ASCII-Zeichen vergleichen. In Bild 2 und 3 finden Sie unsere Gegenüberstellung.
Einige Kombinationen dienen als Steuer-Codes. (Die Bedeutung der dabei verwendeten Abkürzungen sehen Sie unten.
Nur ein Teil dieser Codes wird tatsächlich genutzt. Andere haben — je nach Gerät an das sie gesandt werden — unterschiedliche Bedeutungen. Denken Sie dabei nur mal an die verschiedenen Betriebssysteme des Commodore-Druckers 1526, wo man bei dem einen mit CHR$(1), bei dem anderen mit CHR$(14) den Breitschrift-Modus anschaltet. Innerhalb unseres Computers werden offensichtlich bestimmte Codes anders genutzt. Das sind:

Anstelle von | geschieht folgendes
ENQ | Zeichen weiß
BS | Blockieren der Umschaltung Klein-/Großschrift
HT |Zulassen der obigen Umschalt.
DC1 | Cursor abwärts
DC2 | Reverse-Modus an
DC3 | Cursor in HOME-Position
DC4 | INST/DEL
FS | Zeichen rot
GS | Cursor rechts
RS | Zeichen grün
US | Zeichen blau
TODO

Der auffälligste Unterschied ist der, daß beim CommodoreASCII anstelle der Kleinbuchstaben Grafikzeichen liegen. Sollte anstelle des Normalmodus der Klein-/Großschriftmodus eingeschaltet sein, findet man anstelle der Großbuchstaben die kleinen.

Jetzt haben wir alle nötigen Kenntnisse, um die CHRGET-Routine in unserem Computer zu verstehen.

### Die CHRGET-Routine

Das Kürzel CHRGET kommt von »Get a character«, was bei uns heißt: »Hole ein Zeichen«. Es handelt sich um eine sehr häufig benutzte Routine unseres Basic-Interpreters, die — wie schon vorhin erwähnt — komplett in der Zeropage steht. Wenn Sie mit dem SMON mal nachsehen wollen, dann geben Sie den Befehl
D 0073 008B
ein. Sie haben dann die komplette Routine vor sich:

TODO

Eventuell sieht die Zeile 0079 bei Ihnen anders aus. Das liegt dann an den Speicherstellen 7A und 7B, welche einen Zeiger darstellen (LSB = 7A und MSB = 7B), der bei Ihnen gerade auf einen anderen Platz zeigt als auf $0225.

Diese CHRGET-Routine besteht aus drei Teilen:
Zeilen 0073 bis 0079

Weiterstellen des CHRGET-Zeigers und Einladen des dadurch angezeigten Speicherzelleninhaltes in den Akku.
Zeilen 007G bis 0082 Prüfroutinen
Zeilen 0084 bis 008A Flaggen-Routinen

Im ersten Teil haben wir schon gleich etwas neues vor uns: Ein sich selbst veränderndes Programm. Die Speicherstelle (aus dem Basic-Eingabepuffer), aus der der Akku ein Zeichen holt, wird um 1 weitergezählt mit INC 7A.

Dabei handelt es sich um das LSB der Adresse und die nächste Zeile prüft, ob ein Überlauf (255 + 1) stattgefunden hat: BNE 0079.

Diese Technik kennen wir schon aus den letzten Folgen: Bei Überlauf wird die Z-Flagge auf 1 gesetzt und der BNE-Befehl führt keinen Sprung herbei, Den Offset von 02 können wir leicht nachrechnen: Der Programmzähler steht schon auf 0077. Die Zieladresse 0079 ist also noch 2 Bytes entfernt. Hat eine Überschreitung des Höchstwertes 255 stattgefunden, dann muß das dazugehörige MSB um 1 erhöht werden. Dies tut die nächste Zeile: INC 7B

In beiden Fällen ist nun der Zeiger 7A/7B um eine Stelle weitergerückt und der Inhalt der dadurch angezeigten Speicherstelle wird in den Akku geladen. Zwei Dinge können wir uns aus diesem kurzen Programmteil merken:

1) Wie man eine 16-Bit-Zahl hoch-(oder auch herunter-) zählt und
2) eine Möglichkeit, Zeiger einzusetzen. Wir werden noch eine Reihe anderer Zeigertypen kennenlernen und sehen, daß es nicht immer so direkt zugeht wie hier.

Im zweiten Teil finden wir die Prüfroutinen. Die Vergleichsbefehle beschränken sich auf den Akkuinhalt, also CMP.
CMP # 3A testet, in welcher Beziehung das im Akku befindliche Zeichen zum Wert $3A = dezimal 58 steht. Erinnern wir uns an das Schema in Bild 1:

1)	Commodore-ASCII-Code im Akku größer als 58, also Zeichen hinter dem Doppelpunkt (Buchstaben, Grafikzeichen, einige Sonderzeichen). Dann ist die Carry-Flagge = 1, N- und Z-Flagge sind 0.
2)	Im Akku steht genau der Code 58, also der Doppelpunkt. Dann sind Carry-Bit und Z-Flagge = 1, nur die N-Flagge = 0.
3)	Der Code des Zeichens im Akku ist kleiner als 58 (das wären alle Zahlen, einige Sonderzeichen und Steuerzeichen). In diesem Fall ist die N-Flagge = 1. Die beiden anderen Flaggen zeigen Null.

Der nun folgende Befehl BCS 008A überprüft die Carry-Flagge. Wenn sie gesetzt ist, wenn also der Code im Akku größer oder gleich dem eines Doppelpunktes (58) ist, springt der Programmzähler zum RTS. Der Code (und auch die Flaggen) wird unverändert zum aufrufenden Hauptprogramm weitergegeben. Zur Übung können Sie ja nochmal den Offset nachrechnen. Der Rest des Programms wird nur noch durchlaufen, wenn Codes kleiner als 58 im Akku stehen.

Die nächste Zeile CMP #20 dient zum Vergleich des Space-Codes $20 = dezimal 32 (Leertaste). Die Flaggen treten dann, wie schon oben beim ersten Vergleich gezeigt, je nach Akku-Inhalt auf. Durch die Verzweigung BEQ 0073 erfolgt ein Rücksprung zum Beginn der CHRGET-Routine dann, wenn die Z-Flagge gesetzt ist, also ein Space-Code im Akku liegt. Somit werden die Leerzeichen einfach übersprungen und das nächste Zeichen geholt. Alle anderen Zeichen, die bis hierher durchgehalten haben, werden nun im letzten Teil der CHRGET-Routine einer Prozedur unterworfen, die ich Flaggen-Routine genannt habe.

Durch zwei aufeinanderfolgende Subtraktionen, die insgesamt den Wert im Akku unverändert lassen (es wird 256 abgezogen), wird die Carry-Flagge beeinflußt. Verfolgen wir, was da passiert:

SEC dient als Vorbereitung für die folgende Subtraktion.
SBC # 30 zieht vom Akku-Inhalt $30 = dezimal 48 ab. Wir wissen inzwischen, daß das der Addition des Zweierkomplementes entspricht. Dieses ist (rechnen Sie mal nach!) 1101 0000.
Nehmen wir mal an, wir hätten den Code der Zahl 4 (also dezimal 52 oder $34) im Akku stehen. Die Rechnung sieht dann so aus:

TODO

Das Ergebnis ist also 4, der Übertrag wird vernachlässigt.

Als anderes Beispiel sei nun der Code für das Ausrufungszeichen im Akku (dezimal 33 = $21 = binär 0010 0001). Die Rechnung ist dann:

TODO

Das Ergebnis ist —15.

Alle Codes, die nicht für Zahlen stehen, haben nach dieser Subtraktion ein negatives Ergebnis im Akku hinterlassen und durch das »Borgen« das Carry-Bit gelöscht.

Nun machen wir weiter ab Zeile 0087:
SEC
SBC #D0

Wir ziehen $D0 = dezimal 208 ab. Das Zweierkomplement ist: ...Doch da kommen wir ins Stocken! Denn dieses Zweierkomplement ist nicht mehr mit 8-Bit-Zahlen darzustellen. Schon die Zahl 208 im Binärformat (1101 0000) würde als negative Zahl angesehen werden, weil Bit 7 gleich 1 ist. Wir machen es uns einfach und sagen, daß sich das Zweierkomplement wie bisher bilden läßt, aber dabei das Carry-Bit mit einbezogen wird. Unser Zweierkomplement ist dann also: 0011 0000 und das Carry-Bit ist gelöscht. Nun nehmen wir unser erstes Beispiel. Dort war nach der Subtraktion im Akku eine 4 verblieben:

TODO

Das ist wieder unser ursprünglicher Wert dezimal 52 = $34 = Code für die Zahl 4. Das Carry-Bit bleibt gelöscht.

Im zweiten Beispiel mit dem Ausrufungszeichen stand noch im Akku eine —15:

TODO

Da haben wir wieder den Code für das Ausrufungszeichen ($21 = dezimal 33) im Akku und ein gesetztes Carry-Bit. Was kommt also bei der CHRGET-Routine heraus?

1)	Alle Zeichen außer dem Space werden unverändert an das aufrufende Programm über den Akku weitergegeben. Space wird unterdrückt.
2)	Bei allen Zeichen außer bei den Zahlen ist das Carry-Bit gesetzt.
3)	Manche der aufrufenden Routinen überprüfen außer dem Zustand der Carry-Flagge auch den der Z- oder N-Flagge, die ja beim ersten CMP-Befehl ebenfalls gesetzt werden. So liefert die CHRGET-Routine noch weitere Informationen.

In der einschlägigen Literatur stoßen Sie auch auf eine Routine, die CHRGOT genannt wird. Es handelt sich dabei ebenfalls um die hier beschriebene CHRGET-Routine, nur erfolgt der Einsprung nicht bei $0073, sondern bei $0079.

Der Zeiger $007A/7B wird in diesem Fall nicht weitergestellt. Das vorher schon einmal in den Akku geladene Zeichen wird damit noch einmal angesprochen (got ist die Vergangenheitsform von get).

Mit dem CHRGET-Programm haben wir eines der wichtigsten Unterprogramme unserer computerinternen Software kennengelernt. Will man sich Interpreter-Routinen zunutze machen, stolpert man ständig darüber. Außerdem aber liegt die CHRGET-Routine im RAM. Das bedeutet, daß wir sie ohne weiteres für unsere Zwecke verändern können.

Ein Beispiel für so eine Änderung hat Christoph Sauer in seiner Serie über den »gläsernen VC 20« in der Ausgabe 9 (Seite 158) gezeigt. Dort wird die CHRGET-Routine nach dem LDA angezapft und auf das Pi-Zeichen geprüft, das neuen Befehlen vorangestellt wurde. Sehen Sie sich das Programm dort (auf Seite 160f.) mal genau an, viel kann man durch Nachvollziehen fremder Programme für die eigene Programmiertechnik lernen. Wir werden im Verlauf dieser Serie noch andere Möglichkeiten behandeln, die CHRGET-Routine zu verändern.

Damit sei es für diesmal genug. Als Assembler-Alchimisten gehören Sie jetzt zu den fortgeschrittenen Eleven, denn Sie können immerhin schon so trickreiche Programme wie die CHRGET-Routine nachvollziehen.

(Heimo Ponnath/gk)

# In die Geheimnissee der Floppy eingetaucht (Teil 4)

> In dieser Folge beschäftigen wir uns das erste Mal mit dem DOS der Floppystation. Wir wollen uns die Technik der Diskettenaufzeichnung ansehen und die Funktionsweise des DOS genauer unter die Lupe nehmen.

Zuerst wollen wir uns mit dem Aufzeichnungsformat der Diskette beschäftigen: Für einen einwandfreien Betrieb der Floppystation ist es unumgänglich, daß sich Markierungen auf der Diskette befinden. Diese Markierung braucht das Laufwerk, um bestimmte Daten schnell finden zu können. Hierfür gibt es prinzipiell zwei Möglichkeiten: die Hardsektorierung und die Softsektorierung.

Hardsektorierte Disketten erkennt man daran, daß diese eine ganze Anzahl von Indexlöchern besitzen. Damit sind die kleinen Löcher nahe am Innenrand der Magnetscheibe gemeint. Mit einer Fotozelle können nun diese Löcher abgetastet werden, um die jeweilige Position der Diskette festzustellen. Dieses Verfahren hat den Vorteil, daß die Diskettenkapazität voll ausgenutzt werden kann. Es können so bis zu 5 MBytes Daten auf eine 5¼-Zoll-Diskette geschrieben werden. Allerdings erfordert diese Methode einen enormen Hardwareaufwand, der den Preis in die Höhe schnellen läßt. Für preiswerte Laufwerke (wie die 1541) geht man daher einen anderen Weg: die Softsektorierung. Hier besitzt die Diskette nur ein Indexloch zur Drehzahlüberwachung. Bei der 1541 ist sogar noch nicht einmal dieses erforderlich. Die notwendigen Markierungen werden beim Formatierungsvorgang softwaremäßig auf die Diskette aufgebracht, wobei natürlich wertvoller Speicherplatz verloren geht. Softsektorierte Disketten im 5¼-Zoll-Format verfügen daher über zur Zeit maximal 1 MByte Speicherkapazität.

Uns soll also im weiteren die Softsektorierung beschäftigen, wobei in Bild 1 eine Diskette schematisch dagestellt ist, nachdem sie auf der 1541 formatiert wurde. Sie ist in 35 konzentrische Spuren, nachfolgend Tracks genannt, aufgeteilt. Jeder dieser Tracks enthält wiederum eine bestimmte Anzahl von Sektoren, die von außen nach innen abnimmt. Diese Tatsachen sind Ihnen aber schon aus der ersten Folge bekannt. Nun wollen wir genauer auf den Aufbau der Sektoren einer Diskette eingehen.

Jeder Sektor besteht aus einem Blockheader und dem dazugehörigen Datenblock; eine schematische Darstellung zeigt Bild 2. Angeführt werden die Sektoren einer Diskette von den schon erwähnten Markierungen, die der Orientierung dienen. Diese Marken bezeichnet man als Synchron (SYNC)-Markierungen, sie bestehen aus mehreren $FF auf der Diskette. Erkennt der Schreib-/Lesekopf der Floppy also eine solche Marke, dann »weiß« die Foppystation, daß entweder ein Blockheader oder ein Datenblock nachfolgt. Nun müssen wir nur noch diese beiden voneinander unterscheiden können.

Hierzu dient das nächste Kennzeichen auf Diskette. Es folgt direkt nach der SYNC-Markierung und meldet dem Diskcontroller (DC) ob ein Blockheader oder ein Datenblock vorliegt. Hat das Kennzeichen den Wert $08, so handelt es sich um einen Blockheader; findet der Kopf hingegen den Wert $07, so handelt es sich um den Beginn eines Datenblocks.

Wir nehmen jetzt einmal an, der DC hätte das Kennzeichen $08 entdeckt; es handelt sich also um den Header eines Datenblocks. Dann folgt als nächstes Byte die Prüfsumme über den Header, die zur Kontrolle auf Lesefehler dient. Die Reihenfolge der Headerbytes, wie sie im Commodore-Handbuch angegeben ist, stimmt nicht mit der Aufzeichnung auf Diskette überein.

Die nächsten 2 Bytes stellen Sektor- und Tracknummer dieses Sektors dar. Anhand dieser Werte kann der DC bei Trackwechsel sehr schnell die Position des Schreib-/Lesekopfes ausfindig machen.

Das 5. und 6. Byte des Blockheaders geben jeweils einen Teil der ID der Diskette an, und zwar folgen zuerst das zweite und dann das erste Zeichen der ID, die beim Formatieren festgelegt wurden. Mit diesen Angaben ist die Behandlung des Headers bereits abgeschlossen. Es folgen jetzt noch ein paar Bytes, die eine Lücke darstellen.

Mit der nächsten SYNC-Markierung wird der Beginn des eigentlichen Datenblocks eingeleitet. Nach der SYNC-Marke folgt das Datenblockkennzeichen $07. Die nächsten zwei Bytes sind uns bestens bekannt. Sie können mit jedem Diskmonitor angesehen werden und geben Track- und Sektornummer des nächsten Blocks im File an. Man bezeichnet sie deshalb als Linker oder Linkadressen (engl.: to link = verbinden).

Nun erst folgen die eigentlichen Daten auf Diskette, die in jedem Block 254 Byte ausmachen.

Hinter diesen Datenbytes steht die Prüfsumme des Datenblocks, die wiederum zum Erkennen von eventuellen Lesefehlern dient. Werden solche Fehler festgestellt, so versucht die Floppystation noch mehrere Male, den Block doch zu lesen. Erst wenn viele Versuche kein befriedigendes Ergebnis bringen, steigt sie mit einer Fehlermeldung aus.

Nach der Prüfsumme des Datenblocks folgt wieder eine Lücke auf der Diskette, bevor die SYNC-Markierung des nächsten Blockheaders kommt. Wenn wir uns diesen Aufbau eines Sektors betrachten, wird klar, warum die Speicherkapazität bei softsektorierten Disketten gegenüber hardsektorierteri Disketten deutlich abnimmt.

Jetzt werden sie vielleicht auch die Beschreibung der Fehlermeldungen im Floppyhandbuch verstehen, die wir hier nicht mehr aufführen, da sie dort sehr genau und richtig erläutert werden.

Das Verständnis des Diskettenaufbaus ist für die weitere Behandlung des Floppy-DOS unerläßlich, da wir nur so die Funktionsweise begreifen lernen.

Jetzt wollen wir uns aber einmal mit der grundlegenden Arbeitsweise des Floppybetriebssystems (DOS) befassen, die um einiges komplizierter ist, als die im Computer.

Wenn wir die Floppy einschalten, passiert zunächst das gleiche, wie im Computer. Die RE-SET-Leitung geht auf Low und der Mikroprozessor, hier ein 6502, holt sich seine Systemstartadresse. Danach läuft das RESET-Programm an, wobei die Floppy einen Selbsttest durchführt. Erkennen können Sie dies daran, daß für kurze Zeit der Motor anläuft und die rote LED leuchtet. Wurde kein Defekt registriert, so erlischt die Leuchtdiode wieder, und der Motor geht aus. Jetzt wird der RAM-Bereich der Floppy initialisiert und alle wichtigen Zeiger werden hergestellt. Danach ist die 1541 betriebsbereit.

Von jetzt an laufen quasi drei Programme gleichzeitig ab: — das Hauptprogramm läuft in emer Schleife, die nur bei der Ausführung von Befehlen verlassen wird;

— das Diskcontrollerprogramm wird über den IRQ gesteuert und durch den Timer des DC alle 10 ms aufgerufen;
— die Routinen des Buscontrollers (BC) schließlich, werden nur im Bedarfsfall aufgerufen, nämlich, wenn die ATN-Leitung des seriellen Bus auf Low geht.

Wir wollen uns die Funktion dieser Routinen nun einmal etwas genauer betrachten.

### Das Hauptprogramm

Das Hauptprogramm hängt, wie schon gesagt, in einer Warteschleife, bis ein Befehl vom Computer kommt. Dieser aktiviert zuerst die Busroutinen, die die gesendeten Bytes dann entgegennehmen und abspeichern. Jetzt bekommt das Hauptprogramm, das übrigens den Zustand der beiden IRQ-Routinen (DC und BC) ständig überwacht, die Meldung, daß ein Befehl anliegt. Es verzweigt nun zur Befehlsauswertung, ähnlich dem Basic-Interpreter, und führt gegebenenfalls einen Befehl aus, sofern ein Syntaxfehler entdeckt wurde. In diesem Fall würde sonst eine Fehlermeldung generiert, die dann vom Computer ausgelesen werden kann.

Ist ein Befehl korrekt ausgeführt worden, so werden die Befehlsparameter wieder gelöscht, und das Hauptprogramm kehrt in die Warteschleife zurück.

### Das Diskcontrollerprogramm

Der Diskcontroller enthält den Baustein VIA 6522, durch den er mit dem Mikroprozessor in Kontakt steht. Dieser Baustein enthält auch Timer, die in einem eingestellten Rhythmus einen IRQ auslösen können. Einer dieser Timer ist in der 1541 so eingestellt, daß er ungefähr alle 10 ms einen IRQ auslöst, der dann seinerseits das Diskcontrollerprogramm aufruft.

Es soll an dieser Stelle der Unterschied zwischen Diskcontroller und Diskcontrollerprogramm erläutert werden: Als Diskcontroller (DC) bezeichnet man die Hardware in der Floppy, die für den Laufwerksbetrieb zuständig ist.

Unter dem Diskcontrollerprogramm versteht man den Programmteil im DOS, der, durch IRQ geregelt, die Ansteuerung des DC übernimmt.

Eine vollständige Trennung dieser beiden Begriffe ist jedoch weder notwendig noch zweckmäßig, so daß wir mit dem Ausdruck »DC« immer die Gesamtheit von Hard- und Software beschreiben wollen. Nun aber wieder zu den Aufgaben des DC.

Auch dieses Programm hat eine Art Wartezustand, solange kein Befehl vom Computer anliegt. Wird nämlich das Hauptprogramm über den Bus aktiviert, so wertet dieses die Befehle aus und gibt sie an den DC weiter, der dann seinerseits dafür sorgt, daß das Laufwerk aktiviert wird. Er steuert den Laufwerk- und den Stepper (Schreib-/ Lesekopf)-Motor und bedient die Daten, die vom und zum Tonkopf gehen. Die gesamten Vorgänge am Laufwerk werden also interruptgesteuert vorgenommen.

### Die Busroutinen

Die Routinen des Buscontrollers (BC) werden ebenfalls über die IRQ-Leitung gesteuert. Auch der BC enthält einen VIA 6522-Baustein. Hier wird der Aufruf der Routinen allerdings nicht über den Timer organisiert, sondern, wie schon erwähnt, über die ATN-Leitung des seriellen Busses. Zieht der Computer also diese Leitung auf Low, so wird in der Floppy (und in allen anderen Peripheriegeräten ebenso) ein IRQ ausgelöst. Dann erfolgt die Abfrage, ob dieser IRQ vom Timer des DC kam. Ist dies nicht der Fall, so wird die BC-Routine aufgerufen, die dann den weiteren Busbetrieb übernimmt. Sollte die Floppy gerade einen Befehl bearbeiten, während schon ein neuer vom Computer gesendet wird, so wartet der BC solang mit der Annahme, bis die Floppy wieder in den Bereitschaftszustand zurückgekehrt ist.

Wie Sie sehen, stellt das DOS eine ziemlich komplizierte Einheit dar, deren Schema in Bild 3 zu sehen ist.

<aside>
Wie Sie vielleicht bemerkt haben, ist uns in Folge 2 ein Fehler unterlaufen. Das abgedruckte Listing 6 wäre eigentlich Listing 5 gewesen. Als tatsächliches Listing 6 liefern wir Ihnen heute das Directory-Sortierprogramm nach, das Sie in Listing 1 abgedruckt finden.
</aside>

Wollen wir also in dieses System einsteigen, um dort eigene Programme ausführen zu lassen, so ist es natürlich unerläßlich, daß wir die »Spielregeln« dieses Prozessorsystems genau kennen, da es sonst leicht zu kleinen Katastrophen kommen kann.

Zu Ihrer weiteren Arbeit mit der 1541 noch ein paar Tips: Wenn Sie vorhaben, Programme in der Floppy ablaufen zu lassen, sollten Sie Ihre Floppy öffnen und ohne Deckel betreiben. So können Sie genau beobachten, wie der Kopf positioniert wird und was bei Lesefehlern geschieht. Sie werden unter anderem auch entdecken, daß Disketten nicht etwa auf der Seite beschrieben werden, auf der sich das Etikett befindet, sondern auf der Rückseite. Dies ist um so bemerkenswerter, als man eine Diskette immer nur auf der Vorderseite schonend behandelt, die ja eigentlich nicht benutzt wird. Auch wir mußten die Erfahrung machen, daß wir Disketten lange Zeit mit der wertvollen Seite auf Tische gelegt haben, stets darauf achtend, daß ja kein Staubkorn auf die von uns so gehütete Vorderseite kam.

## Disketten werden auf ihrer Rückseite beschrieben!

Das Betreiben des Laufwerks ohne Deckel hat auch den Vorteil besserer Wärmeableitung. Die ICs werden es Ihnen danken.

Nachdem Sie Ihre 1541 also auf »Arbeitsbetrieb« getrimmt haben, wollen wir gleich einmal mit kleinen Programmen beginnen. In Tabelle 1 sehen Sie eine Aufstellung einiger wichtiger Zeropageadressen, die uns im weiteren Verlauf noch beschäftigen werden. Für einDOS-Listing ist in unserer Serie natürlich kein Platz vorhanden; auch können wir nur mit kleinen Beispielen versuchen, Ihnen die Programmierung der Floppy nahezubringen. Für diejenigen unter Ihnen, die jedoch vorhaben, tiefer in die Floppyprogrammierung einzusteigen, sei an dieser Stelle ein Buch angesprochen, das voraussichtlich im Februar 1985 von Markt & Technik herausgegeben wird. Es behandelt die 1541 bis ins kleinste Detail, ist unter anderem mit einem ausführlichst kommentierten DOS-Listing ausgestattet und geht weit über das in dieser Reihe besprochene hinaus.

### Programmieren der Floppy

So, jetzt soll es aber endlich losgehen. Wir wollen unser erstes Programm schreiben und in der Floppy ablaufen lassen.

Es handelt sich um Listing 2. Dieses »Miniprogramm« schreiben wir in den Puffer 0 der Floppy, das heißt ab Adresse $0300. Das Basic-Programm haben wir der Kürze halber gleich an den Assemblercode angehängt. Wenn Sie das Programm starten, wird das Bit abgefragt, das beim DC für den Zustand der Schreibschutzplakette verantwortlich ist. Sie werden vielleicht wissen, daß die Floppy die Schreibschutzkerbe bei den Disketten mit Hilfe einer Lichtschranke abfragt. Ist die Lichtschranke unterbrochen, das heißt es liegt eine Diskette mit Schreibschutzaufkleber im Laufwerk, dann steht das entsprechende Bit auf 0.

Unser Programm schiebt nun einfach das Bit der Lichtschranke an die Stelle des Bits für die rote LED und speichert diesen Wert wieder ab. Starten Sie einmal unser kleines Programm, dann werden Sie feststellen, daß die Leuchtdiode am Laufwerk erlischt, wenn die Lichtschranke unterbrochen wird. Holen Sie die Diskette dagegen aus dem Laufwerk oder legen Sie eine Diskette ohne Schreibschutzplakette ein, so beginnt die rote LED zu leuchten.

Mit diesem Programm können Sie also testen, ob von Ihnen selbst angefertigte Schreibschutzkerben in der Diskettenhülle an der richtigen Stelle liegen, um eine Diskette eventuell doppelseitig benutzen zu können.

Da unser Programm aus einer Endlosschleife besteht, können Sie die Floppy nur durch einen RESET wieder in einen ansprechbaren Zustand versetzen.

Das Programm hat aber einen Schönheitsfehler; es beeinflußt nämlich nicht nur die beiden LED-Bits in Speicherstelle $lC00, sondern löscht beijedem Durchgang auch alle anderen Bits dieses Registers, deren Belegung Sie Tabelle 2 entnehmen können. Für unsere Testzwecke ist diese »Pfuscherei« jedoch unwesentlich.

### Der »&«-Befehl

Nach diesem aufregenden Beispiel wollen wir Sie nun mit einem Befehl bekanntmachen, den Sie sehr wahrscheinlich noch nicht kennen. Er nennt sich »&« und wird unverständlicherweise in noch keinem uns bekannten Buch beschrieben. Der &-Befehl entspricht in gewisser Weise einem BLOCK-EXECUTE-Befehl; auch hier wird ein Programm von Diskette geladen und sofort ausgeführt.

Der Unterschied besteht nur darin, daß mit dem &-Befehl nicht nur ein Block, sondern ein ganzes File, das im Directory verzeichnet ist, geladen und im Puffer als Programm ausgeführt wird.

Außerdem müssen die Files, die mit dem Befehl »&« gestartet werden sollen, speziell gekennzeichnet sein. Sie enthalten als erstes Zeichen im Filenamen das Zeichen »&«. Soll also zum Beispiel ein File mit dem Namen »Test« als Autostartprogramm in der Floppy ausgeführt werden, so geben Sie diesem File den Namen »&Test« und starten Sie es danach mit: OPEN1,8,15,”&TEST”

Haben Sie nur ein einziges Autostartfile auf Diskette, so können Sie es auch nur mit »&« abspeichern und ebenso mit OPENl,8,15,”&” starten.

Leider erwartet die Floppy von Autostartfiles eine spezielle Syntax, die in Tabelle 3 zu sehen ist.

Als Listing 3 haben wir noch einmal unser LED-Testprogramm; nur wird diese Routine durch das Basic-Programm als &-File auf Diskette geschrieben und kann danach durch den schon erwähnten Befehl direkt von Diskette in den Pufferspeicher geschrieben und dort gestartet werden.

Zu Tabelle 3 noch einige Anmerkungen:

Zuerst muß die Startadresse des Programms im Pufferspeicher der Floppy in das File geschrieben werden. Danach folgt die Anzahl der Bytes im Programm. Jetzt werden die Programmbytes abgespeichert, und schließlich folgt noch eine Prüfsumme, die sich wie folgt errechnet:

Es werden alle Bytes des Programms addiert und zum Ergebnis noch die zwei Bytes der Startadresse und die Anzahl der Bytes im Programm hinzugezählt. Dieses Ergebnis ist als Integerzahl zu verstehen und besteht also aus einem niederwertigen (LO) und einem höherwertigen (HI) Byte. Das niederwertige Byte ist die Prüfsumme, zu der noch der Übertrag im höherwertigen Byte addiert werden muß. Diese Berechnung klingt kompliziert; ist es aber nicht. In Listing 4 wird Ihnen diese Rechnerei abgenommen. Die allgemeine Formel hier noch einmal:
HB = INT(SUMME/256)
LB = SUMME-HB\*256

dabei bedeuten:
HB — das höherwertige Byte
LB — das niederwertige Byte
SUMME — die Gesamtsumme der Programmbytes

Achtung: Die Übertragsberechnung muß nach jedem neu dazugezählten Wert erfolgen, da das Endergebnis kleiner als 256 sein muß! Wie Sie sehen, ist das Anlegen eines &-Files nicht ganz einfach. Bisher wurde diese Fileart fast nur von Profis zum Programmschutz angewandt, da sie, wie schon erwähnt, nahezu unbekannt war.

Zu erwähnen wären noch zwei seltsame Fehlermeldungen der Floppy:

»OVERFLOW IN RECORD« erscheint, wenn die Anzahl der tatsächlichen Bytes mit der Angabe nicht übereinstimmt.

»RECORD NOT PRESENT« erscheint, wenn die Prüfsumme nicht stimmt.

Da wir stets darum bemüht sind, Ihnen die Arbeit mit der Floppy so angenehm wie möglich zu machen, haben wir unserem Artikel noch Listing 4 beigefügt. Es handelt sich hier um ein Programm, das es Ihnen gestattet, auf einfachste Weise &-Files zu erstellen. Diese können sogar länger als 256 Byte sein, da das Programm dann automatisch eine Prüfsumme und die Anschlußadresse einfügt. Ununterbrochene &-Files, die länger als 256 Zeichen sind, kann es ja nicht geben, da die Anzahl der Programmbytes im File nur in einem Byte abgespeichert wird.

Mit dieser neuen Fileart wollen wir Sie für dieses Mal entlassen. Ruhen Sie sich für die nächste Folge aus. Wir werden dann auf die Technik der Jobschleifenprogrammierung eingehen, die Ihnen eine Fülle von Anwendungen eröffnen wird.

(K. Schramm/B. Schneider/gk)

# 500 Mark für formatierte Eingabe

> Schreiben Sie ein Programm, dann besteht es in der Regel aus drei Teilen: Eingabe, Verarbeitung und Ausgabe von Daten. Es sind also diese Teile, die immer wieder programmiert werden müssen. Und deshalb hat dieses Mal ein Unterprogramm den Wettbewerb gewonnen, das eine wichtige und universelle Eingabe-Routine zur Verfügung stellt.

Jeder Programmierer steht bei einem neuen Programm vor der gleichen Frage: Wie soll meine Eingabe aussehen? Begnügt man sich mit dem vorhandenen Wortschatz des Commodore-Basic, ist es schwierig, eine sichere Eingabe zu erhalten. Andere Basic-Versionen haben entsprechende Befehle. Was also liegt näher, als sich eine Eingabe-Routine selbst zu programmieren, und zwar eine, die man immer wieder verwenden kann? Doch da beginnt auch schon das Problem. Es ist gar nicht so einfach, Standard-Unterprogramme zu entwickeln. So ein Programm muß folgende Forderungen erfüllen:

1.	Es muß fehlerfrei sein. Das heißt, ganz gleich, welche Taste bei einer Eingabe gedrückt wird, das Programm darf niemals mit einer Fehlermeldung (oder noch schlimmer: ohne Meldung) abstürzen.
2.	Es muß flexibel sein. Man muß das Unterprogramm in jedem möglichen Programm einsetzen können, unabhängig von der sonstigen Aufgabe. Die wichtigsten Eingaben sind: nur numerische, also alle Ziffern von 0 bis 9; für kaufmännische und ähnliche Probleme muß wahlweise zusätzlich noch die Eingabe eines Dezimalpunktes möglich sein; und Text, also alle Buchstaben, Sonderzeichen und Ziffern. Oft wird eine bestimmte Eingabelänge gefordert und darf nicht überschritten werden, auch das ist wichtig. Und damit die einzugebenden Werte auch an der richtigen Stelle stehen, muß der Cursor positioniert werden können.

Das folgende Unterprogramm erfüllt diese Forderungen und läßt sich in jedem Basic-Programm einsetzen. Die Bedienung des Programms können Sie den REM-Zeilen des Listings entnehmen.

(Rolf Hilchner/gk)

# Einzeiler-Wettbewerb: Die nächsten 14

Wieder haben wir die interessantesten Einzeiler für Sie herausgesucht. Darunter sind sowohl nützliche als auch witzige oder lehrreiche. Sogar ein Adventure ist darunter. Alle Veröffentlichungen werden mit 50 Mark und einer Diskette mit allen Programmen dieser Ausgabe belohnt.

Wenn man einigen Einsendern Glauben schenken will — und es besteht kein Grund, das nicht zu tun — , so sind ihre Einzeiler keineswegs schnell dahingeschriebene Programme, sondern oft das Ergebnis von tage-, ja wochenlangen Experimenten und Versuchen. Bei manchen anderen allerdings ist die programmiertechnische Umsetzung einer Idee nicht das Entscheidungskriterium gewesen, sondern vielmehr die Idee selbst. Sie werden auch sehen, daß bei einem Einzeiler weder das Programm noch die Idee besonders originell ist. Aber seine Programmbeschreibung ist so überzeugend, daß sie Ihnen nicht vorenthalten sein soll. Doch nun viel Spaß und hoffentlich einige »Aha«-Erlebnisse.

## Umwandlung beliebiger Zahlensysteme (VC 20/C 64)

Die beiden Einzeiler dienen zum Umrechnen zwischen Dezimalzahlen und Zahlen beliebiger Basis. Kombiniert bilden beide eine Umwandlung zwischen verschiedensten Zahlensystemen. Beide Zeilen können sowohl als Unterroutine (mit RETURN) wie auch als Teil eines größeren Programms stehen.

a) **Umwandlung dezimal/beliebig**

Die Routine wandelt eine Dezimalzahl beliebiger Größe in der Variablen D in eine Zahl der Basis um, die in der Variablen B angegeben ist. Das Ergebnis steht in Z$. Zuerst wird Z$ gelöscht. Dann wird eine Dummy-Schleife eröffnet, die nur einen einzigen Durchlauf zu haben scheint (0 bis 0). Der Befehl wird dazu genutzt, später wieder mitten in die Zeile einspringen zu können. Bei jeder Stelle wird D durch die Basis B geteilt und dadurch die unterste Ziffer abgeschnitten. Die jeweils niederwertigste Stelle ist der ganzzahlige Rest dieser Division und steht in S. S wird nun in den ASCII-Code umgerechnet, indem zur Zahl S 45 addiert wird. Ist S eine Ziffer von 0 bis 9, so nimmt der Term (S < 10) den Wert —1 an und es wird 7 subtrahiert (siehe ASCII-Tabellen). Der Code wird durch den CHR$-Befehl in einen String gewandelt und vorne an Z$ angehängt. Die letzte (höchstwertige) Ziffer ist erreicht, wenn D < 1 ist (nächste Stelle = 0). Die Schleifenvariable P wird auf —D gesetzt. Beim darauffolgenden NEXT-Kommando wird P um den STEP (hier 1) erhöht und mit dem Endwert des FOR-Befehls (hier 0) verglichen. Wenn D noch > = 1 ist, ist P + I < = 0, die Endbedingung ist noch nicht erreicht und es wird zu dem Statement nach dem FOR-Befehl gesprungen.

b) **Umwandlung beliebig/dezimal**

Diese Routine wandelt eine beliebige große Zahl der von der Variablen B angegebenen Basis in eine Dezimalzahl. Die zu wandelnde Zahl muß in Z$ stehen; die Variable D enthält das Ergebnis. Am Anfang wird die Variable D auf Null gesetzt. Die Schleifenvariable S des darauffolgenden FOR-Befehls dient als Zeiger auf die einzelnen Stellen von Z$. Diese werden nun in den ASCII-Code gewandelt, der Code für Null (48) wird subtrahiert und das Ergebnis in H zwischengespeichert. Die schon umgewandelten Stellen (in D) werden zunächst durch Multiplikation mit B um eine Potenz dieser Basis erhöht, um dann die aktuelle Stelle (H) zu addieren. Ist H>9 (Darstellung durch einen Buchstaben) müssen aufgrund des ASCII-Codes noch sieben abgezogen werden (Term (H>9) wird —1). Nach der niederwertigsten Stelle ist die Schleife beendet.

(Martin + Hartmut Sprave)

TODO

## Scrollen in x-Richtung (C 64)

FORG=0TO3:NEXT ist eine Verzögerungsschleife; hier kann die Geschwindigkeit des Scrollers eingestellt werden. Zu beachten ist, daß alle Befehle in abgekürzter Schreibweise eingegeben werden müssen.
(Hans-Peter Harmann)

TODO

## Das abwechslungsreiche Programm (C 64)

Liebe Redaktionäre, endlich ein Wettbewerb, an dem auch ich als Novize mich beteiligen kann. Meine Computer- und Programmierkenntnisse sind mittlerweile schon weit fortgeschritten (die l-Prozent-Hürde werde ich demnächst überspringen), so daß ich mich berufen glaube, auch etwas zum Besten zu geben.

Ich stellte mir selbst hohe Anforderungen:

1.	Das Programm sollte abwechslungsreich sein
2.	Es sollte Bewegung im Spiel sein
3.	Die Farbe durfte nicht fehlen.

Bitte das Programm sorgfältig abschreiben, um eine langwierige Fehlersuche zu vermeiden.
Variablenliste:
A$ = Stunden von TI$
B$ = Minuten von TI$
C$ - Sekunden von TI$

Vor Eingabe des Programms muß selbstverständlich TI$ auf die aktuelle Uhrzeit eingestellt werden. Die Zeilennummer 11 fristet für gewöhnlich ein Schattendasein hinter der 10. Deshalb habe ich aus Mitleid die 11 gewählt. Nachdem Sie den Bildschirm durch CLR/Home gereinigt haben, starten Sie das Programm. Sie sehen, daß meine Anforderungen erfüllt wurden.

1.	Das Programm ist abwechslungsreich (Wiederholungen treten höchstens nach 24 Stunden auf)
2.	Es bewegt sich was
3.	Es ist Farbe im Spiel

Zu 3. Das Programm wurde so gestaltet, daß der Anwender leicht die Farbe ändern kann.
PS: Das Ausschalten des Computers bringt das Programm zum Abstürzen!!
PPS: Freundlich zugedachte Geldspenden werden nur auf Antrag angenommen.

(Gerd Pickard)

TODO

# Ein RENEW, das funktioniert (C 64/VC 20)

Routinen, die nach einem Reset oder NEW das Basic-Programm zurückholen, sind zwar schon oft veröffentlicht worden, doch waren die meisten entweder nicht lauffähig oder das Abtippen wurde durch die Länge zu einer umständlichen und unsicheren Prozedur. Dieser Einzeiler ist natürlich im Direktmodus, also ohne Zeilennummer, einzugeben. Vorher dürfen jedoch keine Variablen definiert oder Basic-Zeilen eingetippt werden, da sonst das gelöschte aber noch im Speicher befindliche Programm zerstört werden würde. Das Prinzip des UNNEW-Programms beruht auf dem Aufruf einer System-Routine, die die Basic-Zeilen neu bindet und das Ende des gelöschten Programms herausfindet. Der erste POKE dient nur dazu, der Routine vorzutäuschen, daß sich noch ein ungelöschtes Basic-Programm im Speicher befindet, da sie sonst nicht arbeitet. Die Endadresse des Basic-Programms wird um zwei erhöht und in den Zeiger auf den Start der Variablen (45/46) übertragen. Der CLR-Befehl gleicht alle weiteren Basic-Zeiger diesem Wert an.

SYS-Adresse für VC 20: 50483. Da beim VC 20 die Startadresse des Basic-Programms je nach Speicherausbau verschieden ist, muß man die Zahl »2050« durch das Ergebnis des folgenden Terms ersetzen« PRINT/PEEK(43) + 256 \* PEEK(44) + 1.

(Hartmut + Martin Sprave)

TODO

## Eine Zeile - kompletter Datenschutz (C 64)

Dieses Programm verhindert das Auflisten des Inhaltsverzeichnisses jeder beliebigen Diskette. Nebenbei stellen sich noch einige sehr brauchbare Effekte ein. Das Löschen und Überschreiben der auf der Diskette befindlichen Programme ist nicht mehr möglich. Außerdem kann nichts mehr auf die Disk geschrieben werden. Ebenso werden Diskettenbefehle wie VALIDATE oder INITIALIZE ignoriert. Sogar ein Headern der Diskette ohne neue ID ist nicht möglich. Das einzige, was den Inhalt der Diskette noch manipulieren kann, ist das Headern (Diskettenbefehl »NEW«) mit einer neuen ID-Nummer.

Das Laden der bereits auf der Disk befindlichen Programme funktioniert hingegen ganz normal. Allerdings sollte man sich die Namen der gespeicherten Files merken, denn das Suchen mit Jokerzeichen ist bestenfalls ein netter Zeitvertreib, aber nicht unbedingt immer erfolgreich. Hat man beispielsweise zwei Programme, die mit A anfangen, auf der Diskette, so muß man von dem zweiten Programm ja mindestens die ersten beiden Buchstaben angeben, um es laden zu können.

Daß das Directory nicht mehr gelistet werden kann liegt daran, daß es als Basic-Programm geladen wird und in dem veränderten Directory drei Nullen am Anfang erscheinen. Dies ist für den Interpreter jedoch das Zeichen für das Programmende. Das »Directory-Programm« endet also bereits nach zehn Bytes. Die ersten fünf Bytes stellen den Zeilenanfang und die Zeilennummer dar. Darauf folgen ein Leerzeichen und ein Anführungszeichen, die ja immer am Anfang eines Inhaltsverzeichnisses stehen. Um diese drei Zeichen beim Auslisten verschwinden zu lassen, folgen nun drei chr$(20), die jeweils ein Delete darstellen. Dies bewirkt, daß das Directory beim Auslisten nun völlig verschwindet. Das Listen wird hier abgebrochen, da nun unmittelbar die drei Nullen folgen, die das Programmende markieren. So erfolgt auf den List-Befehl nur die Meldung »READY«.

Die reversen »t« werden am einfachsten eingegeben, wenn man zuerst zwei Anführungszeichen hintereinander schreibt, dann den Cursor zurück auf das zweite Anführungszeichen bewegt, dreimal die Taste »INST«( = Insert) und danach dreimal die Tasten »SHIFT« und »INST« (= Delete) betätigt. Die Zeile kann natürlich genauso im Direktmodus abgeschickt werden.

(Volker Ritzhaupt)

TODO

## Geänderter Zeichensatz (C 64)

Das Programm enthält eine Variable, sechs POKE-Befehle, einen PEEK-Befehl und eine FOR-NEXT-Schleife. In der Variablen R wird die Adresse des Interrupt-Registers definiert (# 56334/$DC0E). Nun wird die Position des Zeichengenerators geändert, indem Bit 3 der Adresse 53272 ($D018) gesetzt und Bit 1 gelöscht wird. So wird der Bereich ab # 8192 beziehungsweise $2000 ausgewählt. Um den alten Zeichensatz lesen zu können, muß der Interrupt ausgeschaltet werden (Bit 0 in Adresse 56334 gelöscht), ebenso der Video-Chip (Bit 2 in Adresse 1 gelöscht). Die folgende Schleife würde in einem übersichtlichen Programm so aussehen
FOR I = 0 TO 4095
POKE 8192 + 1,
PEEK(I + 53248) AND 60
NEXT

Es wird also der Zeichensatz von Adresse # 53248 beziehungsweise $D000 an nach #8192 übertragen, wobeijedes Byte durch die AND-Funktion geändert wird. Diese bewirkt, daß die Bits 0, 1, 6 und 7 in jedem Byte gelöscht werden, also ganz einfach jedem Zeichen der rechte und der linke Rand abgeschnitten wird. In meinem Programm überdeckt die Schleife einen etwas größeren Bereich als eigentlich nötig wäre, nämlich von 6hoch5 = 7776 bis R/5 = 11267, was dem Resultat jedoch keinen Abbruch tut.

Schließlich werden Video-Chip und Interrupt wieder eingeschaltet (Bit 2 in Adresse 1 und Bit 1 in Adresse 56334 gesetzt).

Bemerkenswert ist vielleicht, daß ich nach der Realisierung meiner Idee ein einziges Zeichen zuviel im Programm hatte. Nach drei Stunden angestrengten Tüftelns kam mir die erlösende Idee. Ursprünglich hatte ich den Video-Chip durch POKEl,55 wieder eingeschaltet. Es genügt aber auch POKEl,7, da die übrigen Bits vom Prozessor automatisch gesetzt werden.

(Klaus Vorwalter)


## Trick 17 mit ON..JGOTO (C 64/VC 20)

Eine sehr interessante Version einer ON...GOTO-Anweisung. Zur Erklärung braucht eigentlich nur gesagt werden, daß der Ausdruck (A$ = ”A”) den Wert —1 hat, wenn ein »A« eingegeben wurde, sonst den Wert 0. Rechnen Sie nach oder probieren Sie es aus: Es funktioniert einwandfrei.

(Peter Zankl)

TODO

## Das kürzeste Abenteuerspiel der Welt (C 64/VC 20)

Das Spiel heißt »Nosferatu«. Im Spiel selbst stehen Sie einem Vampir gegenüber und müssen herausfinden, wie Sie ihn besiegen. Erlaubt sind deutsche Zweiwortkommandos. Eine Alternative für die Lösung besteht, indem Sie anstatt »WIRF KNOBLAUCH« »ZEIGE KREUZ« eintippen. Sie können sich auch andere Situationen überlegen, was das Programm noch zum kürzesten Adventure-Generator macht Cursorsteuerzeichen: Reverses Q = Cursor hoch, Reverses q = Cursor runter. Bitte achten Sie auf mein Copyright (für einen Vermerk war leider kein Platz) DARUM HIER: (C)Copyright 1984, by me. Und noch etwas: Mogeln Sie beim Abtippen bitte nicht! Es wäre schade, wenn Sie schon beim Eintippen die Lösung kennen würden.

Vampirische Grüße

(Thomas Werner)

## Dividieren mit beliebig vielen Stellen hinter dem Komma (V 64)

Das Programm muß mit den bekannten Abkürzungen eingegeben werden, damit es in das 80-Zeichenformat paßt.

### Variablenliste

Z = Zahl (mathematisch korrekt : DIVISOR)
D = Dividend
N = Anzahl der gewünschten Stellen hinter dem Komma
E% = Ergebnis ohne Rest (wird ausgegeben)
R = Rest
Q% = Quotient beschränkt auf Vorkommazahl

### Beschreibung:

Um die Vorkommazahl zu erhalten, benötigt man Q = INT(Z/D), was ich durch Q% = Z/D vereinfacht habe. Q% wird als Vorkommazahl ausgegeben. Es wird der Rest, nämlich die Differenz aus Z und Q% \* D gebildet. Der Rest dient als Ausgangspunkt für die folgende Berechnung. Die Schleife wird Nmal durchlaufen, um exakt N Stellen hinter dem Komma zu ermitteln.

Analog zum Vorschleifenteil wird E% = R \* 10/D gebildet. E% wird ausgegeben als I.te Stelle.

Der neue Rest wird durch R(neu) = 10 \* R(alt) — D \* E% (vergleiche Vorkommateil) gebildet.

Und wiederum kann die Schleife durchlaufen werden, bis alle Stellen ausgegeben sind.

### Beispiel:

Wie lautet die 85. Stelle hinter dem Komma von 116/i3? (also: Z = 116, D = 13, N = 85) Programmlauf....
Ergebnis:

Die 85. Stelle hinter dem Komma ist 9. (Selbstverständlich werden auch alle übrigen Stellen ausgegeben).

(Heinz Bauschke)


TODO

## Simulation - GOTO X (C 64)

Das Programm simuliert den im Commodore-Basic nicht vorhandenen Befehl GOTO X.

Zu dem etwas seltsamen Aussehen der Zeile läßt sich folgendes sagen: In den Anführungszeichen steht ein Maschinenprogramm, dessen Opcodes im Listing des Basic-Interpreters diese merkwürdigen Zeichen erzeugen. Das disassemblierte Maschinenprogramm finden Sie in Listing 2, wobei die absoluten Adressen keine Bedeutung haben, das Programm adressiert nur relativ. Der mit der Materie etwas vertrautere Leser wird feststellen können, daß das Programm etwas umständlich geschrieben ist. Das liegt daran, daß nicht alle Character, die ein Opcode darstellen, eindeutig einer Zahl zugeordnet sind. So gäbe zum Beispiel die Zahl 255 im Maschinenprogramm das Zeichen (Commodore & K), wenn die Zeile aber dann editiert würde, interpretiert das Basic dieses Zeichen aber mit 161. So ließe sich die Zeile nicht editieren, wäre also keine Basic-Zeile. Aus diesem Grund wurden alle solchen »doppeldeutigen« Codes umgangen, was die Umständlichkeit des Maschinenprogramms zur Folge hatte. Die SYS-Anweisung stellt die Lage des Maschinenprogramms mit Hilfe zweier Zeiger des Interpreters fest und startet das Programm.

Nun zur Benutzung der GOTO X-Zeile und wie man sie eingibt: Es ist zwar möglich, die Zeile mit der in Ausgabe 7/84 beschriebenen »Finkel«-Methode einzugeben, was jedoch umständlich, zeitaufwendig und fehleranfällig wäre. Deshalb ist in Listing 3 ein Generierungsprogramm abgebildet. Dieses wird eingegeben und gestartet.

Wenn der Checksum-Test positiv ausgefallen ist und man sich vergewissert hat, daß das Programm genauso eingegeben wurde, wie es ausgelistet ist, gibt man LIST ein, gefolgt von NEW. Dann fährt man mit dem Cursor auf Zeile 10 und drückt RETURN. GOTO X steht nun im Speicher und kann gelistet, editiert und abgeSAVEt werden.

Selbstverständlich kann die Zeilennummer zwecks der Einbindung in eigene Programme geändert werden. Dazu weist man der Variablen LL% den Wert der anzuspringenden Zeile zu und springt mit GOTO zur Zeile, in der GOTO X steht.

(Reinhard Jurk)

TODO

## Irrgarten (VC 20/C 64)

Das Programm belegt nur 40 Bytes Speicherplatz. Es erzeugt einen zufallsbedingten Irrgarten und läuft auf einem C 64 oder VC 20:

Zum Programm: X ist eine durch die RND-Funktion ermittelte Zufallszahl. Sie ist nicht gerundet und liegt zwischen 0 und 2. Der Computer druckt hierauf den CHR$-Code von 164 plus der Zufallszahl x aus, wobei er von sich aus X auf 0 oder 1 rundet. Es erscheint also auf dem Bildschirm je nach X das CHR$-Zeichen von 164 oder 165.

Der nach dem PRINT-Befehl folgende Strichpunkt bewirkt, daß das nächste Zeichen nicht erst in der nächsten Reihe, sondern gleich neben dem Zeichen davor erscheint.

Die Variable Q, welche durch den RUN-Befehl automatisch gleich Null gesetzt wurde, wird nun um 1 erhöht. Ist sie noch kleiner als 880, so wird die Schleife erneut durchlaufen. Das entstehende horizontale und vertikale Muster ist ein Labyrinth — aufgebaut aus nur diesen beiden Zeichen.

Durch Verwendung anderer CHR$-Zeichen (zum Beispiel 176 bis 179) läßt sich das Programm gut variieren.

Jedenfalls: Es ist nicht immer einfach den richtigen Weg zu finden!

(Marco Gleiter)

TODO

## Clevere Idee: Grafikhildschirm löschen mit dem DIM-Befehl (C 64)

Programmbeschreibung:
1. a = 0:b = 0<br>Im weiteren Verlauf wird das Variablenfeld beeinflußt. Die Variablen a und b müssen deshalb vor der DIM-Anweisung angelegt sein.
2. a = peek(49):b = peek(50)<br>Die Werte für das Variablenende werden gesichert.
3. dim f((16191-a-b\*256) /5)<br>Durch das Dimensionieren einer Variablen wird ein entsprechend großer Platz hinter dem Variablenende freigemacht beziehungsweise mit dem Wert 0 gefüllt. Nun muß der Platz nur noch mit der Adresse des Bildschirms übereinstimmen.<br>Zur Formel (16191-a-b\*256) / 5 :<br>Der Bildschirmspeicher liegt von 8192 bis 16191. Die Variable f wird hinter dem bisherigen Variablenende angelegt. Adresse des Variablenendes: a + b\*256 also: 16191-a-b\*256<br>Pro indizierte Variable werden 5 Byte freigemacht, also: (16191-a-b\*256) / 5<br>Die mit 0 indizierte Variable ist nicht berücksichtigt, ebenso die ersten 7 Byte für Variablenname und Dimension.
4. poke 49,a : poke 50,b<br>Die alten Werte werden wieder hergestellt. Die Variable f ist jetzt nicht mehr dimensioniert.

Zum ordnungsgemäßen Verlauf müssen zwei Punkte beachtet werden.

1.	Das Variablenende muß kleiner als 8186 sein, das heißt das Programm darf einschließlich Variablenfeld nicht größer als 6 KByte sein. Mit 6 KByte stehtjedoch ein ausreichend großer Platz zur Verfügung.<br>Ist dies nicht der Fall, wird lediglich der Bildschirm nicht ganz gelöscht. Das Programm kann in keinem Fall Schaden nehmen.
2.	Soll das Grafikprogramm zum Abspeichern von Bildern benutzt werden, darf man nicht vergessen, den Zeiger für Speichergrenze (peek(55) + peek(56)\*256) auf eine Adresse kurz hinter den Bildschirmspeicher zu setzen.<br>In meinem Grafikprogramm rufe ich die Zeile 10 immer dann auf, wenn über die Tastatur »shift + clr home« eingegeben wird (entsprechend »freier Bildschirm im Textmodus«).

(Manfred Hedtke)

TODO

## Zweifarbiger Rahmen (C 64)

Wie jeder weiß, ist der Bildaußenrahmen des C 64 immer einfarbig. Ich habe nun einen kleinen Einzeiler geschrieben, der einen zweifarbigen Außenrahmen simuliert. Die beiden Farben sind: 0 = schwarz und 1 = weiß. Es ist darauf zu achten, daß die Basic-Zeile genauso eingetippt wird, wie sie abgebildet ist. Ich meine damit die Anzahl der Spaces und Doppelpunkte. Erklärung: Ich wollte die Grenze zwischen den beiden Farben möglichst ruhig auf dem Bildschirm haben und mußte dazu die genaue Farbwechselperiode finden. Der Interpreter arbeitet Doppelpunkte und Spaces unterschiedlich schnell ab; so konnte ich mit den Spaces eine Feineinstellung vornehmen. Aber vorsichtig: Sobald während des Programmlaufs eine Taste gedrückt wird, tritt die Raster-Interrupt Tastaturabfrage in Kraft und das Bild fängt an zu »laufen«.

Hilfe zum Abtippen:
Zwischen den beiden POKEs, und den Doppelpunkten befinden sich je fünf Spaces. Es folgen dann 17 beziehungsweise 15 Doppelpunkte.

So einfach es auch immer ist: Es verblüfft einen doch!


(Markus Hillebrand)

TODO

## Fakultät (C 64)

Das Programm berechnet Fakultäten, ist also sehr nützlich für einige mathematische Funktionen, da der C 64 keinen derartigen Befehl besitzt.
Variablen:
A = Eingabevariable,
B = Zählvariable,
C = Rechen- und Ausgabevariable.

Das Programm berechnet sogar Fakultäten, die größer als »69« sind. Es ist also besser als ein Taschenrechner.

(Detlef Marks)

# Vorschau

## Compiler

Im Mikrocomputerbereich setzen sich Compiler für die verschiedensten Sprachen immer mehr durch. Für die meisten Anwender bleibt der Compiler aber ein undurchschaubares Ding, das auf geheimnisvolle Weise in der Lage ist, höhere Programmiersprachen in Maschinencode zu übersetzen. Wir zeigen, wie sie funktionieren, wie sie konstruiert werden und wo ihre Stärken und Schwächen gegenüber einem Interpreter liegen.

## Plus/4 im Test

Seit kurzem kann man den Plus/4 in Computerläden entdecken. Was dieser neue Computer kann und für welchen Anwenderkreis er geeignet ist, zeigt unser Test.

## Mathematik-Lernprogramme

Zwölf verschiedene Mathematik-Lernprogramme wurden von uns getestet. Auch bei diesen Programmen war festzustellen: Nicht alles was als Lernsoftware verkauft wird, hat diesen Namen verdient. Welches der Programme eignet sich als »Nachhilfelehrer«?

## MSE - eine enorme Erleichterung

Ähnlich wie der »Checksummer« ist der MSE ein weiteres Hilfsmittel bei der Eingabe von Programmlistings, diesmal jedoch von reinen Maschinensprache-Programmen, das heißt beim Abtippen von DATAs. Der MSE verringert die Tipparbeit um ein Drittel und schließt Fehleingaben vollkommen aus. Durch akustische Meldungen können Sie DATAs sogar »blind« eingeben.

## Endlich: Die Lösung von Hobbit

Lange wurde auf die Lösung des Abenteuerspiels »Hobbit« gewartet. Einen der möglichen Lösungswege und den Lageplan finden Sie in der nächsten Ausgabe.

## Richtig verbunden

Wenn Sie einen Fernseher mit Videoeingang besitzen und den C 64 noch immer an der Antenne »hängen« haben, dann sollten Sie schon mal Ihren Lötkolben anheizen. Wir zeigen in einer Bauanleitung, wie der C 64, mit geringem Aufwand, an Fernsehgeräte und Monitore mit Videoeingängen angeschlossen werden kann.

## Assembler Vergleichstest (2)

Im zweiten Teil unseres Vergleichstests nehmen wir die Assembler bis 100 Mark unter die Lupe. Sie besitzen vielleicht nicht die Leistungsfähigkeit der »großen«, aber reicht nicht auch ein preiswertes Programm?

## Grafikkurs - noch mehr Informationen

Es hat sich gezeigt, daß viele Leser noch mehr zur Grafikprogrammierung wissen wollen. Deshalb wird der Grafik-Kurs in lockerer Reihenfolge fortgesetzt. Wir gehen auf spezielle Wünsche der Leser ein und stellen Ihnen ein Grafik-Hilfsprogramm vor, das viel mehr ist, als nur eine einfache Hilfe. Um leichter Grafik programmieren zu können, stehen auch nützliche Befehle wie OLD, MERGE, RENUMBER, AUTONUMBER, etc. zur Verfügung.

## Basic-Compiler im Test

Basic-Compiler stellen ein Bindeglied zwischen reinen Basic-Programmen und Maschinensprache her. Sie beschleunigen den Ablauf der Basic-Programme, erreichen jedoch nie die Schnelligkeit von Assembler. Compiler bringen aber nicht nur eitel Freude, sondern einen auch manchmal zum Verzweifeln. Anders gesagt, sie haben ihre Macken, die man kennen muß. Wir stellen Ihnen die wichtigsten Compiler vor.

## Außerdem...

— Sieben lehrreiche Kurse für Anfänger und Profis
— Tests verschiedener Sprachausgabesysteme
— interessante Listings zum Abtippen
— und wieder viele Tips und Tricks für VC 20 und C 64

