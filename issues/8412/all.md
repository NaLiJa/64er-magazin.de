## Mehr 64'er

Obwohl wir Ihnen in jeder Ausgabe des 64’er um die 120 Seiten redaktionellen Teil bieten, reicht der Platz nicht aus, um all das unterzubringen, was an interessantem und nützlichem Material vorhanden ist. Das hat natürlich auch seine positive Seite: Zeigt es doch, wieviel im »Volkscomputer« und in seinem größeren Bruder steckt — und daß der Benutzer nicht so schnell an die Grenzen des Systems stößt.

Da bei den Lesern eine starke Nachfrage nach Kursen besteht und die einzelnen Kurse ja auch in einer vernünftigen Zeit zu Ende gebracht werden sollen, haben wir versucht, zunächst hier Platz zu sparen: Der Kursteil hat eine »kompaktere« Form bekommen. Auf diese Art läßt sich pro Heft mehr Information unterbringen — ohne daß das (so glauben wir zumindest) auf Kosten der Übersichtlichkeit oder der Lesbarkeit geht.

Nach der Neugestaltung des Listingteils ist das ein zweiter Schritt, um die Wünsche unserer Leser noch besser zu erfüllen — ohne daß das ohnehin knapp kalkulierte Magazin dicker und damit teurer werden muß. Wahrscheinlich werden immer noch Wünsche offen bleiben — aber dafür gibt es ja die Karte »Lesermeinung«, auf der Sie (unter anderem) mitteilen können, was Ihnen an Informationen fehlt. Sie können sicher sein, daß wir die Karten fortlaufend sorgfältig auswerten — und schnell reagieren, wenn wir feststellen, daß bestimmte Themen besonders gefragt sind.

Michael Pauly, Chefredakteur

# Aktuell

## Interpod für C 64 und VC 20

Das in England entwickelte Interpod-Interface ist jetzt auch auf dem deutschen Markt erhältlich. Dieses Interface verfügt über einen IEEE-Bus zum Anschluß der Commodore-Peripherie mit dieser Schnittstelle, einen getrennten seriellen Ein- und Ausgang sowie eine RS232C-Schnittstelle.

Damit sind bis auf die Centronics-Schnittstelle alle wichtigen Verbindungen in einem Gehäuse vereinigt.

Das Interpod-Interface verfügt über einen eigenen 6502-Prozessor. Angeschlossen wird es an die serielle Schnittstelle vom C 64 oder VC 20. Angeboten wird das Interface bei Boston Computer zu einem empfohlenen Endverbraucherpreis von 398 Mark.

Info: Boston Computer, Rosenheimer Straße 145a, 8000 München 80, Tel. 0 89/ 491073/74

## CP/M-CBM 64: Multi-Micro-Entwicklungssystem

Das Multi-Micro-Entwicklungssystem vereinigt die beiden Betriebssysteme Commodore-CBM und Digital Research CP/M 2.2 in einem Gerät. Es gestattet die Entwicklung verschiedener 8-Bit Mikroprozessor-Systeme mit Hilfe eines leicht modifizierten C 64. Die integrierte Programmiereinheit arbeitet mit interaktiver Bildschirmführung auf beiden Betriebssystemen und erlaubt Filetransfer, Duplizieren, Schnellprogrammierung, Anzeigen von Speicherinhalten, Vergleich zwischen Memory und EPROM, Erased-Test, mit frei definierbarem Memory- und EPROM-Bereich. Programmierbar sind zur Zeit die EPROM-Typen Intel 2758 bis 27256, Texas 2516 bis 2564, 2732, 2764. Außerdem die Single-Chip-Mikroprozessoren Intel 8741 bis 8749 beziehungsweise 8041 bis 8050 inklusive der H- und C-Typen.

Das System besteht aus CBM-CP/M-Zentraleinheit mit 64 KByte Speicher, 12 Zoll S/W-Monitor, 5¼-Zoll-Diskettenlaufwerk, EPROM-Programmiereinheit, EPROM-Löschgerät, Drucker, 40/80 Zeichen Bildschirmumschaltung und Tastatur.

Info: Ingenieurbüro für elektronische Systeme, Dipl.-Ing. K.E. Wnuk, Nansenstr. 3, 6100 Darmstadt, Tel. 0 6151/8 44 39

## Computer-Seminare

Cossem bietet in Nürnberg Kursprogramme für das Erlernen der Programmiersprachen Pascal, Basic, Fortran und Assembler 6502/6510 als auch einen »Anfängerkurs« (Wie funktioniert ein Computer?) und einen speziell auf den Commodore 64 ausgelegten Kurs an.

Info: Cossem, Computer-Software-Seminare, Gerlestraße 13, 8500 Nürnberg 40, Tel. 09131/26228.

## Neue 128-KByte-R0M-Platine für den Commodore 64

Eine Platine für insgesamt 128 KByte ROM wurde von Frank Computertechnik, München vorgestellt. Die Platine ist für die Aufnahme von 8- bis 32-KByte-EPROMs vorgesehen. So können Speicherstufungen in 8-, 16-, 32-KByte-Schritten vorgenommen werden. Die Steuerung der einzelnen Speicherbereiche übernehmen zwei Register. Die Bedienung dieser Register wird in der Form eines Auswahlmenüs programmiert. Ein Directory mit dem Inhalt der Platine wird so angezeigt und das gewünschte Programm mit Knopfdruck gestartet. Da die Platine vollständig abzuschalten ist, sollte einer dieser Wahlpunkte auch aus dem Sprung in das normale Basic bestehen. Die Platine beeinflußt dann das Laden von Basic- und Maschinenprogrammen in keiner Weise. Ein Verlust an Speicherplatz tritt in diesem Fall nicht auf. Die Beschreibung zur Platine ist sehr ausführlich und geht auch auf verschiedene Programmierschritte (Autostartkennung, Betriebssystem- und Basic-Initialisierung) ein. Die Platine ist sehr solide aufgebaut und wird mit einem stabilen Gehäuse geliefert. Der Preis soll bei zirka 100 Mark liegen.

(Arnd Wängler)

Info: Frank Computertechnik, Metzstraße 8, 8000 München

## Portables Meßdatenerfassungsystem mit SX 64

Der SX 64 kann, mit einem digitalem Speicheroszilloskop ausgesrüstet, zur Dastellung und Berechnung periodischer als auch transienter Signale in Industrie und Forschung eingesetzt werden.

Die Abtastrate beträgt 20 MHz bei 8 Bit, die Speichertiefe reicht von 4 bis 16 KByte und es sind sowohl Realtime- als auch Speicherbetrieb möglich. Es lassen sich beispielweise Impulssignale bis zu 6 MHz darstellen. Die Darstellung auf dem Oszilloskop ist flackerfrei und kann durch eine Lupenfunktion unterstützt werden.

Info: GTE, Brunnengräber Str. 6, 6362 Wöllstadt 2, Tel. 0 60 34/30 24/30 25

## Minimodem billiger

CTK hat die Preise für die Akustikkoppler der Serie Minimodem aus dem Hause Modular Technology um 25 Prozent gesenkt. Das CTK Minimodem 3005 (mit FTZ-Nummer) 300 Baud vollduplex kostet nun 585 Mark. Das neue Schwestermodell CTK Minimodem 3005 S (Originate/Answer umschaltbar) kostet jetzt 655 Mark.

Info: CTK Computer-Text- und Kommunikations-Systeme, Dolmanstraße 82, 5060 Bergisch Gladbach

## Kurze Reparaturzeiten

Schnelle Reparaturen kündigt der offizielle Systemhändler für CBM-Geräte, die Firma HDS in München, an. Die Fachwerkstätte übernimmt Servicearbeiten an allen CBM- und VC-Geräten und will diese innerhalb kürzester Zeit fachmännisch ausführen. Wir haben die Probe gemacht und bekamen unser Gerät innerhalb eines Tages repariert zurück. Für Bastler bietet HDS zusätzlich den Verkauf von Commodore-spezifischen ICs (in kleinen Mengen).

Info: HDS Prüftechnik, Maria-Eich-Str. 1, 8000 München 60, Tel. (0 89) 83 70 21-22

## Matrixdrucker von Olympia

Von Olympia gibt es jetzt aus der compact-Serie mit dem Olympia electronic compact NP auch einen Matrixdrucker. Dieser Drucker soll Epson FX-kompatibel sein und hat dazu noch weitere Eigenschaften. So kann per Tastendruck in Schönschrift gedruckt werden. Durch eine Gummiwalze wird ein sehr leiser Druck erzielt. Mit Bedientasten kann der linke und rechte Rand gesetzt werden. Der Traktor ist auf schmales Papier (einbahnige Etiketten) einstellbar. Der Preis beträgt für die Ausführung mit Centronics-Interface 1698 Mark, mit zusätzlicher V.24-Schnittstelle 1948 Mark. Die Ausführung für den C 64 mit Grafikfähigkeit kostet ebenfalls 1948 Mark.

Info: iti-Datentechnik, Telemannstraße 18, 7250 Leonberg, Tel. 0 7152/63 05/710 74

## Kopfreinigungs-Diskette

Das Kopfreinigungs-Kit von Dysan besteht aus zwei Reinigungs-Disketten und einer Dosierflasche mit genügend Reinigungszyklen für 40 Reinigungsvorgänge (50% mehr als bisher). Mit dem Kit sollen Datenverlust, Systemausfall sowie Disketten- und Kopf-Verschleiß als Folge von Verschmutzungen vermieden werden. Als Besonderheit haben die Reinigungs-Disketten einen dünnen Film-Aufkleber über der Schreib-/ Leseöffnung mit der bei einseitigen Laufwerken eine bessere Druckverteilung erzielt wird. Der Preis liegt bei 75 Mark ohne Mehrwertsteuer.

Info: Dysan, Frankfurter Allee 27-29, 6236 Eschborn, Tel. 06196/481641

# Interessant bis brisant – die elektronischen Briefkästen

> Würde die Tagesschau über Mailboxen berichten, Herr Köpke könnte jeden Abend neben einem Haufen neuer Telefonnummern Erstaunenswertes dem Publikum mitteilen. In der bundesdeutschen Mailbox-Szene tut sich allerhand; Grund genug, sich einmal genauer umzuschauen.

Was eine Mailbox ist, dürfte mittlerweile sicher hinreichend bekannt sein. Wie eine solche funktioniert und zu betreiben ist, hat sich wohl auch schon rumgesprochen, denn wie sonst würden diese elektronischen Briefkästen jeden Tag wie Kraut und Rüben aus dem Boden wachsen, der, nebenbei bemerkt, ausgerechnet im Industriegebiet rund um den Ruhrpott hierfür auch noch am fruchtbarsten erscheint.

Mailboxen gibt es seit der Erfindung der telefonischen Datenfernübertragung, doch erst preiswerte Geräte, wie zum Beispiel Akustikkoppler, lassen es zu, daß jetzt auch jeder seine eigene Box aufmachen kann. Voraussetzungen hierfür sind lediglich die FTZ-Nummer am Koppler und, falls galvanisch angeschlossen, also per Postmodem, auch noch eine spezielle für den Computer. Das benötigte Programm gibt es für Programmiergegner bereits im Handel.

Auf der anrufenden Seite bedarf es nur der Terminalsoftware, und schon steht einem die Welt offen. Was sich aber in dieser nun wirklich abspielt, reicht von banal über kurios bis hin zu Dingen, für die sich auch Verwaltungsdetektive der Post zu interessieren beginnen.

Doch vornweg: Die meisten Mailboxen dienen dem harmlosen Austausch von Informationen zwischen Computerfreaks aller Couleur: Da werden Adventure-Lösungen gesucht oder weitergegeben, Tips und Tricks für Hard- oder Software verraten, Termine für Clubtreffen vereinbart oder auch mal mitgeteilt, daß Herbert Bit und Renate Byte »ONLINE«, lies freundschaftlich und frisch verliebt zusammen sind.

Im Grunde genommen also eigentlich nichts anderes als ein Schwarzes Brett, elektronisch auf dem Bildschirm dargestellt und einer breiteren Hacker-Öffentlichkeit zugänglich gemacht. Zudem bieten einige Mailboxen, meist die, die von kommerziellen Anbietern oder Verlagen betrieben werden, noch die Möglichkeit, Programme in Form von Listings kostenlos abzurufen. Oft genug sind dies jedoch solche, die ohnehin schon hinreichend bekannt sind; man spart sich aber immerhin das mühselige Eintippen der Zeilen.

Doch es gibt auch andere, mehr verborgene Seiten in den Mailbox-Dateien. Bei einigen kann man sich direkt oder via Post als Benutzer eintragen lassen und so Nachrichten empfangen, die nur für sie oder ihn persönlich bestimmt sind. So ist ein relativer Schutz der Daten, die man weitergeben oder bekommen will, einigermaßen gewährleistet. Wer also in die höheren »Hackerweihen« im Mailbox-Verkehr einsteigen will, braucht demnach unbedingt einen Hacker-Namen und ein »geheimes« Password.

Wem hierzu nichts einfällt, kann sich ja fürs erste mal als GAST, GUEST, VISITOR oder sonstwas einloggen, das heißt melden; die meisten Mailboxen öffnen dann zumindest für den »öffentlichen« Teil der Nachrichten, Mailbox-Lesen und Mailbox-Eingeben, ihre Pforten. Und spätestens beim Lesen dieser »MSGs«, Messages, kommen jedem bestimmt die Ideen für einen eigenen »LO-GON« oder Codenamen. Hier einige Beispiele: Albatros, Hacman, Prof. Falken, Donald Duck, Blackbird, Sister CPU, Hacintosh, Dr. Binaer, Mr. Bit & Dr. Byte, Codo, Interram oder Hein-Soft. Namen gibt es noch und nöcher.

Einige findet man in geradzu jeder Box wieder, andere, wohl wegen der hohen Telefonkosten, nur in regionalen. Wiederum andere Teilnehmer verwenden einfach ihren »Vornamen aus Dingsbums«. Und manche haben anscheinend ihre Namen und Erfahrungen im Bereich des CB-Funks gesammelt.

Doch schauen wir uns die Mailboxen und deren Inhalt doch einmal etwas genauer an. Zwei Gruppen lassen sich auf Anhieb ausmachen: Die, die jede Nachricht erst nach Zensur »reinlassen«, das heißt veröffentlichen, und die, die (fast) ohne Zensur arbeiten. In beiden Gruppen geht’s quer durch den Garten. Doch nur in letzteren findet der »PHREAK«, gleich Kunstwort aus »PHone« und »Computer fREAK«, die Informationen, die sein Herz höherschlagen lassen werden. Allerdings diese dann oft in einer, für den Telekommunikations-Anfänger und -Laien gänzlich unverständlichen Abkürzungssprache.

Wie gesagt, befinden sich die meisten Mailboxen im Telefonbereich »02xxx«, und dort beginnt auch unser Überblick. Die Telefonnummern der Mailbox, deren genauer Namen und ihre Betriebszeiten sind im Kasten ausführlich aufgeführt. Falls dieser nicht vollständig ist, freut sich die Redaktion über jeden eingesandten Nachtrag.

Und noch eine Bitte: Benutzt die Mailboxen nur zu den angegebenen Öffnungszeiten. Entweder wird sonst der normale, kommerzielle Betrieb tagsüber gestört oder, bei »Handvermittlung«, wo der SYSOP (SYStem OPerator) sich erst mit VIOCE meldet, um dann den Hörer auf den Koppler zu quetschen, ist es gut möglich, daß Ihr arme, nicht hackende Menschen aus ihrem wohlverdienten Schlaf klingelt.

Wenn eine große, öffentlich-rechtliche Institution wie der Westdeutsche Rundfunk, WDR, sich dem Thema Computer annimmt, ist man ja schon froh, daß in den »alten Medien« überhaupt etwas mit den »neuen« geschieht. Und Dank dieses »WDR-Computer-Clubs« gibt es auch eine gleichnamige Mailbox. Leider dachte man zu wenig an die Anrufer, die nur mit 40 Zeichen auf dem Bildschirm arbeiten können, und so ist die nicht umschaltbare 60-Zeichen-Anzeige manchmel etwas mühselig zu lesen. Inhaltsmäßig muß eine solche »offizielle« Mailbox wohl sehr aufpassen. Hauptsächlich beschränkt sich dieser meist auf liebe Grüße und harmlose Tips.

So ziemlich das gleiche Bild liefern auch die beiden Ortskonkurrenten »Epson« und »Software-Express«. Erstere erzählen viel von ihren eigenen Modellen und letztere, trotz ihres »guten« Rufes in der Hacker- und Cracker-Scene nun doch wieder wenig.

Wer’s etwas intimer haben will, ruft doch mal um die Ecke an. Dort freuen sich die »C 64-Box«, die »Saturn-Box« und die der Firma »Symic« höchster Aktualität und Aktivität auf betreibender wie I auf anrufender Seite. Dies kommt den Tips & Tricks genauso zugute wie den News, ohne die kein Hacker leben kann.

Immer noch im selben Vorwahlraum 02xxx tummeln sich seit neuestem die Boxen »Mythos« (heißer Atari-Tip), »Radio Schossau«, »Esprit«, »Computer Center CC EVD« und »Kobra«. Wer nicht gerade in der Nähe wohnt und Geld für teure Ferngespräche hat, wird dort die eine oder andere nützliche Info j sicher finden. Ansonsten I herrscht meist nur Lokalkolorit vor.

Das gleiche gilt übrigens auch für die Inselstadt Berlin. Trotz schöner Anlagen, auf denen die TIC. und die »MB-Berlin« betrieben werden, gibt es in anderen Mailboxen, pardon Berlin, einfach »heißere« Informationen und News.

Nächste Station: Hamburg. Doch das Tor zur Welt verhält sich, was seine Mailboxen angeht, wie das eigene Wappen — zu. Entweder ist wirklich dauernd besetzt oder stundenlang nur Quatsch auf dem Bildschirm. Denn die beiden Boxen, »Uni-Hamburg« und »M.C.S« gelten bekanntlich als die Haus-Boxen des Chaos--Computer-Clubs. Jenen Jungs also, die sich selbst zu den Oberhackern der Nation gekürt haben. Und dementsprechend sind auch die meisten Anfragen aus der ganzen BRD in diesen Boxen. Antwort gibt’s leider nur selten.

Weiter nördlich wird’s dann wieder lustig bis heiß. In Pinneberg eröffnete vor kurzem die »Wang-Info« (versuchsweise) im 24 Stundenbetrieb ihre elektronischen Pforten. Zwar ist die Teilnehmerzahl verständlicherweise noch gering, doch immerhin! Zudem läßt ein Helpmenü von 40 KByte auf vielfältige Entwicklungsmöglichkeiten schließen.

Ganz heiß wird’s dann in Kiel. Dort ist die »N.C.S.-Box« zu Hause und tourjour zu erreichen. Wer sich da als User eintragen läßt, hat auch wirklich was davon.

Höchst informativ wird es dann erst wieder rund um die Main-Metropole. Bei »Decates« lohnt sich das Reinschauen allein schon wegen der witzigen Kommentare des »Sysop«. Ganz zu schweigen von der internationalen Mailbox-Nummernliste und den vielen informativen Einträgen der User. Als eine der wenigen bietet »Decates« auch ein »Download« von Programmlistings an.

Gleich nebenan ist »Tecos« mit einer ebenfalls sehr guten Box beheimatet. Die »Taunus-Box«mag wohl keiner, denn sie ist leider leer. Ganz anders dagegen die »Otis-Box«. Sehr interessant und sehr aktuell. Eine private Box, die auch Werbung und Angebote führt.

Im Süden ist dann wieder krasse Ebbe. Hier scheint’s, kriegen die Jungs, trotz mannigfaltigen Ankündigungen, einfach kein Bein aufs Mailbox-Land. Einzige und nicht gerade aufregende Ausnahme ist die vom Franzis-Verlag betriebene Box »Tedas«. Ebenfalls mit Programm-Service und viel Eigenwerbung für das Verlagsprogramm. Nachrichten erscheinen im Bulletin erst nach vorheriger Zensur durch die Redaktion und sehen dann entsprechend brav aus.

Würde es Noten geben, nur einige wenige würden das Prädikat »sehr gut« bei allen Kriterien verdienen. Manche sind einfach beim besten Willen nicht benutzerfreundlich, andere zu lahm oder zu bieder. Doch wir stehen hier in diesem unseren Lande ja erst am Anfang einer Mailbox-Karriere.

(Klaus Koch/aa)

# Leserforum

## Die Zwangspausen des C 64

Bei längerem Suchen in einer Indexsequentiellen Dateimacht der C 64 Pausen bis zu zirka fünf Minuten (bei Datamat bis zu 20 Minuten!). Woher kommen die Pausen, und wie sind sie zu beseitigen?

Henry König

Wenn der C 64 sehr viele Strings zu verarbeiten hat, muß er ab und zu seinen dafür benötigten Speicherplatz aufräumen. Das heißt, er überprüft, welche Variablen noch aktuell sind und benötigt werden. Den Rest schmeißt er weg. Die dadurch entstandenen Lücken werden durch die verbleibenden Werte geschlossen. Diese Vergleiche und Verschiebearbeiten sind der Grund für diese langen Wartezeiten. Den Vorgang selber nennt man auch Garbage Collection. Man kann die Wartezeit verringern, indem man ab und zu ein FRE(0) ausführt. Dann wird automatisch eine Garbage Collection ausgeführt. Leider geht das nicht mit Programmen, die nicht unterbrochen werden können und die ein Garbage Collection nicht automatisch verhindern.

## Ungewünschte Programme von Diskette?

Wenn ich ein Programm von Floppy lade, kommt manchmal ein Programm, das garnicht gewünscht wurde.

Thomas Stepputat

Abgesehen davon, daß Ihre Floppy vielleicht defekt ist, kann es andere Gründe für dieses Verhalten geben. Setzen Sie zum Beispiel Wildcards ein, das sind die Zeichen »*« und »?« zum Abkürzen von Namen oder Ersetzen von Zeichen, so kann es natürlich vorkommen, daß ein File geladen wird, das mit den gleichen Zeichen anfängt wie das gewünschte, jedoch vor diesem im Directory steht. Eine andere, jedoch ziemlich unwahrscheinliche Ursache könnte in der Verbindung VC 1541 und den von Ihnen angegebenen Drucker VC 1526 liegen, der ja bekanntlich den seriellen Bus stören kann. Allerdings ist uns diese von Ihnen beschriebene Wirkung noch nicht vorgekommen.

## C-Compiler für C 64?

Ich suche dringend einen »CH-Compiler für den C 64. Wer kann helfen?

Hermann Eisele

## LCD-Display für C 64?

Läßt sich an den Commodore 64 ein LCD-Display anschließen? Wer hat eine Bauanleitung oder kann Hinweise geben? Wo bekomme ich ein für diese Zwecke brauchbares LCD-Display?

Thomas Müller

## MPS 802 baugleich mit VC 1526?

Ich habe eine C 1541 mit der ROM-Version 5 (neueste Version). Kann ich den Drucker 1526 ohne Probleme betreiben? Ist der MPS 802 absolut baugleich mit dem 1526?

Andreas Linnebach

Betrachtet man die Hardware des MPS 802, stellt man eine weitgehende Baugleichheit zum 1526 fest. Das bezieht sich auch auf das identische Betriebshandbuch. Wenn Sie beim 1526 die ROM-Version 7C besitzen (die neueste Version), gibt es keine Probleme. Der MPS 802 besitzt das gleiche ROM. Ihre Version können Sie mit dem Drucker-Selbsttest feststellen.

## Mailbox mit C 64?

Wer kann mir Telefonnummern nennen, unter der ein C64 eine Mailbox bedient?

Stephan Prinz

## Spektral-Analyse mit C 64?

Ich möchte meinen C 64 als Spektral-Analyser einsetzen. Bisher konnte ich keine entsprechende Erweiterung finden. Wer hilft?

Emil Kubeck

## Deutsche Anleitung für MPS 802?

Ich brauche unbedingt eine deutsche Anleitung für den MPS 802.

Peter Sintke, Akazienweg 4, 8343 Triftern

Eigentlich sollte es Sache Ihres Commodore-Händlers sein, Ihnen eine deutsche Anleitung zu besorgen. Aber vielleicht hilft Ihnen ein(e) Leser(in).

## Textverarbeitung mit DIN-Tastatur und deutschen Umlauten?

Gibt es für den C 64 Textverarbeitungsprogramme, die eine deutsche DIN-Tastatur auf dem Commodore ermöglichen mit Ausdruck der deutschen Umlaute?

Joachim Ludwig

Es gibt sogar mehrere Programme, die das (fast) können. SM-Text hat einen kompletten deutschen Zeichensatz und auch y und z sitzen an der richtigen Stelle. Das gilt auch für den Textomat. Vizawrite setzt y und z so, wie sie auf der C 64 - Tastatur zu sehen sind. Blind schreiben ist also bei allen Programmen ohne Probleme möglich.

## RENEW mit einem POKE?

Mit dem POKE 2050,10 bekommt man Programme, die mit SYS 64738, mit Reset oder mit NEW gelöscht wurden, wieder! Nach der Eingabe einer nicht belegten Programmzeile und (RETURN) ist das Programm wieder da.

Oliver Becker

Schön wär’s ja, aber leider nicht ganz richtig. Zwar kann man das Programm mit diesem POKE wieder sichtbar machen, doch lauffähig ist es nicht mehr. Sobald in dem Programm eine Variable definiert wird, hat man nur noch Schrott vor sich. Auch Speichern nach dem »RENEW« hilft nichts mehr. Der POKE 2050,10 setzt nämlich die Pointer nicht mehr neu.

## Eingaben von der Tastatur verhindern?

Wie verhindere ich Eingaben von der Tastatur (insbesondere die STOP- Taste)?Kann man das mit einem POKE-Befehl verhindern?

Klemens Högenauer

Eingaben von der Tastatur verhindert man mit POKE 649,0 (in Speicherstelle 649 ist die Größe des Tastatur-Puffers gespeichert). Die RUN/STOP und RESTORE-Taste sperrt man durch POKE 808,227. Die Sperre wird gelöst durch POKE 649,10:POKE 808,237.

## VC 20 zum C 64 umrüsten?

Ich möchte meinen VC 20 zum C 64 umrüsten. Geht das? Kann man die 3584 Byte für die Grafik beim VC 20 vergrößern?

Stefan Junghänel

Der VC 20 kann nicht in dem Sinne zum C 64 umgerüstet werden, daß anschließend die C 64-Software darauf läuft (es sei denn, man baut eine komplette C 64-Platine in das VC 20-Gehäuse ein.

Roßmöller Datentechnik, Finkenweg 1, 5309 Meckenheim bietet jedoch eine 64 KByte-Karte mit einer Speicherorganisation wie beim C 64 an. Das bedeutet, die 64 KBytes RAM liegen »parallel« zu ROM- und I/O-Bereich, so daß man wie beim C 64 das Betriebssystem ins RAM kopieren und verändern kann.

Die zweite Frage beruht offenbar auf einem Mißverständnis. Die 3583 Bytes sind nicht der Grafikspeicher, sondern der gesamte RAM-Bereich des VC 20 (lacht da jemand?), und der läßt sich natürlich durch Speichererweiterungen vergrößern.

## Zeichensalat?

Es kommt sehr oft vor, daß ich nach dem Auflisten eines Programms nur noch merkwürdige Zeichen und Zeilen voller unsinniger Basic-Befehle sehe, wie zum Beispiel »10 PRINTPRINT-SAVELISTGET...« etc. Das Ganze wird zudem noch in vielen verschiedenen Farben angezeigt, teilweise auch in reverser Darstellung. Ich kann diese Zeilen dann auch nicht überschreiben. Woran liegt das, wie bekomme ich das weg ?

Dirk Schepanek

Der beschriebene Effekt kann drei verschiedene Ursachen haben:

1. Sie haben ein Maschinenprogramm ohne Basic-Vorspann geladen und dabei die Sekundäradresse 1 vergessen.
2. Sie haben ein Basic-Programm, das den unteren Basic-Bereich Speicherplatz für Grafik benötigt, einfach geladen, ohne mit bestimmten POKE-Befehlen den Basic-Start hochzusetzen.
3. Sie haben durch mehr oder weniger wildes POKEn in von Basic oder Betriebssystem benutzten Speicherstellen den Computer völlig irritiert.

Es gibt nun Gott sei Dank einen bemerkenswert einfachen Weg, diesen »Zeichensalat« wieder zu beseitigen: Durch Aus- und Wiedereinschalten des Computers.

## Nochmals Rechengenauigkeit

In Ausgabe 10/84 antwortete Rolf Voigt auf die Frage, warum der C 64 bei »PRINT INT(3/0.03)« nicht 100, sondern 99 ausgibt. Leider war seine Antwort nicht ganz richtig.

Die selbstgestrickte Erklärung von Rolf Voigt für die Integer-Funktion (INT) ist zwar ganz pfiffig, aber falsch. Mathematisch gesehen ist die INT-Funktion eine Abbildung der Menge der reellen Zahlen auf die Menge der ganzen Zahlen, mit der Eigenschaft: INT(x) ist diejenige ganze Zahl, die kleiner oder gleich (!) x ist. Anders ausgedrückt schneidet INT einfach alle Nachkommastellen einer Zahl ab. Und genau das macht auch der C 64.

Warum erhält man dann aber die falsche Antwort »INT(3/0.03) = 99«? Dazu muß ich etwas ausholen. Testen Sie mal das folgende Programm:

<pre>
10 K = 0 : FOR I = 0 TO 2 STEP 0.1
20 IF I = 1 THEN PRINT"I = 1 GE-FUNDEN !” : K = 1
30 NEXT
140 IF K = 0 THEN PRINT "I = 1 NICHT GEFUNDEN !”
50 END
</pre>

Wenn Sie keinen Tippfehler gemacht haben und keine Sonderversion des C 64 besitzen, erhalten Sie als Ausgabe »I = 1 NICHT GEFUNDEN!«. Erstaunlich! Wie kann so etwas sein? Wenn man von Null bis Zwei in Zehnteln zählt, erreicht man doch ganz sicher auch die Eins. Nun, der C 64 scheinbar nicht. Er stellt nämlich intern alle Zahlen binär dar, also auch solche kleiner als Eins. Fatalerweise ist es nun so, daß dezimal endliche Brüche in Binärschreibweise häufig nur als nicht abbrechende, periodische Zahlen geschrieben werden können. Das ist speziell bei 0.1 und auch bei 0.03 der Fall. Also wird die interne Binärdarstellung dieser Zahlen im Computer nach einer gewissen Stellenzahl abgebrochen (gerundet). Darum gibt der Ausdruck »3/0.03« beim Computer nicht ganz exakt 100, sondern etwas weniger.

Die Differenz können Sie sich mit »PRINT 100 - 3/0.03« selbst anschauen.

Wendet man nun die INT-Funktion auf eine Zahl an, die etwas kleiner ist als 100, dann kann nur 99 dabei herauskommen.

Das auf den ersten Blick merkwürdige Ergebnis »INT(3/0.01) = 99« ist also nicht, wie Herr Voigt meint, auf die INT-Funktion zurückzuführen (diese arbeitet völlig einwandfrei), sondern ist eine Folge der internen Binärdarstellung von Dezimalzahlen im C 64.

Aus diesem Grunde ist bei »IF...THEN« Abfragen auch Vorsicht geboten. So manches selbstgeschriebene Programm arbeit in manchen Situationen scheinbar nicht korrekt, weil einfach nicht an die nur begrenzte Rechengenauigkeit eines Computers gedacht wurde.

Jürgen Busch

## Fragen Sie doch!

Selbst bei sorgfältiger Lektüre von Handbüchern und Programmbeschreibungen bleiben beim Anwender immer wieder Fragen offen. Viel mehr Fragen ergeben sich bei Computer-Interessenten, die noch keine festen Kontakte zu Händlern, Herstellern oder Computerclubs haben. Sie können der Redaktion Ihre Fragen schreiben oder Probleme schildern (am einfachsten auf der beigehefteten Karte). Wir veranlassen, daß die Fragen von einem Fachmann beantwortet werden. Allgemein interessierende Fragen und Antworten werden veröffentlicht.

## Monitor-Anschluß

Frage: Wie schließe ich diverse Monitore an den C 64 oder VC 20 an?
Ausgabe: 8/84

(verschiedene Fragesteller)

Einen Schwarz-Grün Monitor schließt man an, indem man aus dem Video-Port des C 64 die Drähte »GND» und »VIDEO HIGH» mit den entsprechenden Monitoreingängen verbindet. Dabei muß »GND» am Monitor-Stecker außen hegen.

Einen RGB-Monitor anzuschließen ist nicht oder nur mit erheblichem Aufwand möglich. Mir ist kein Konverter bekannt; ein solcher würde im Selbstbau aber mindestens 400 Mark kosten.

Andreas Roeschies

## Geldfrage

Welche Disketten haben das günstigste Preis-/Leistungsverhältnis? Kann man Sprites drehen? Wo gibt es die billigste Hard-/Software? Kann man mit dem Heimcomputer Geld verdienen?
Ausgabe: 10/84

Hendrik Richter

1. Der Preis eines Zehnerpacks Disketten mittlerer Preislage liegt zwischen 55 bis 68 Mark. Dazu wäre noch zu erwähnen, daß ein Diskettenpack für 48,50 Mark genauso gut sein kann wie einer zu 69,80 Mark. Achten Sie unbedingt auf eine Lochverstärkung, die eine Abnutzung der Innenseite fast völlig ausschließt. Auch auf solche Kleinigkeiten wie eine ausreichende Anzahl beschriftbarer Etiketten sollte man achten. Es ist sehr unangenehm, wenn man seine Disketten einmal neu beschriften will, dazuaber keine Möglichkeit, sprich Etiketten, mehr hat. Normalerweise gehören in einen Zehnerpack mindestens 15 bis 20 Etiketten.

Kommen wir nun zur Qualität. Es gibt mehrere, für den Laien unerklärliche Abkürzungen auf der Diskettenverpackung. Da findet man SD/SS, DD/SS oder auch DS/DD. Die Standarddisk ist wohl SS/DD, also »Single Sided, Double Density«, was soviel heißt wie »einseitig geprüft, doppelte Aufzeichnungsdichte«.

2. Die Sprites des C 64 kann man nicht drehen. Man kann allerdings mehrere Sprites entwerfen, die jeweils im Muster etwas gedreht sind, und diese dann in einer geeigneten Reihenfolge hintereinander auf den Bildschirm bringen.

3. Hier kann man Herrn Richter nur empfehlen, einmal einen Blick in den Anzeigenteil des 64’er-Magazins zu werfen.

4. Natürlich kann man mit dem Heimcomputer Geld verdienen. Zum Beispiel kann man sein Wissen in Worte kleiden und als Manuskript an Zeitschriften senden, die das dann gerne abdrucken.

Oder wie wär’s mit einem kleinen Programm? So mancher Top-Programmierer hat bestimmt mit einem Heimcomputer angefangen, seine ersten Ideen zu verwirklichen.

Marco Kelting

## Horizontales Scrolling

Wie kann man beim C 64 ein horizon tales Soft-Scrolling realisieren?
Ausgabe: 10/84

Christoph Bergmann

Sowohl horizontales als auch vertikales Scrolling ist punktweise möglich. Hier eine Übersetzung aus dem »Commodore 64 reference guide«:

»Der VIC-II-Chip unterstützt weiches Scrolling sowohl in horizontaler als auch in vertikaler Richtung. Weiches Scrolling ist eine punktweise Bewegung des gesamten Bildschirms. Es kann aufwärts, abwärts, nach links oder nach rechts gehen. Es wird verwendet, um neue Daten weich auf den Bildschirm zu bringen, während auf der anderen Seite Zeichen weich das Bild verlassen.

Während der VIC-II-Chip den größten Teil der Arbeit macht, müssen Sie das eigentliche Scrolling mit Hilfe eines Maschinenprogramms erzeugen. Der VIC-II-Chip hat die Fähigkeit, das Videobild in acht verschiedene horizontale und acht verschiedene vertikale Richtungen zu bringen. Diese Positionierung wird von den VIC-II-Scrolling-Registern überwacht. Der VIC-II-Chip hat auch einen 38-Zeichen- und einen 24-Zeilen-Modus. Der kleinere Bildschirm wird dazu verwendet, um Ihnen Platz zur Verfügung zu stellen, die neuen Zeilen zum Hereinrollen außerhalb des sichtbaren Bildschirms zu speichern. Die Vorgehensweise im einzelnen:

1. Bildschirm verkleinern (der Rand wird breiter).
2. Das Scrolling-Register auf Maximum oder Minimum einstellen, je nach Richtung.
3. Die neuen Zeichen in den nicht sichtbaren Bildschirmbereich schreiben.
4. Das Scrolling-Register vergrößern oder verkleinern, bis zum anderen extremen Wert.
5. Verwenden Sie an diesem Punkt eine Maschinenroutine, um den gesamten Bildschirminhalt, um ein Zeichen in die Scrollrichtung zu verschieben.
6. Weiter mit Schritt 2.

Für nähere Einzelheiten sollten Sie sich Literatur über den VIC-II-Chip beschaffen. Wenn Sie kein versierter Programmierer mit Maschinensprache-Kenntnissen sind, sollten Sie allerdings die Finger vom Scrolling lassen.

Holger Jakobs

## Schwierigkeiten mit Softwareschutz?

Wieso ist das Programm auf einer geschützten Diskette nach einem »Backup» nicht lauffähig ?

Caronni Germano

Weil der Software-Hersteller durch den Kopierschutz gerade den »Backup« verhindern will. Zu diesem Zweck sind meist gleich mehrere Sicherungen eingebaut. Um es mit den Software-Herstellern nicht zu verderben, wollen wir Ihnen aber lieber nicht verraten, wie das im einzelnen funktioniert.

## Simons Basic und Turbotape

Kann man Turbotape und Simons Basic zusammen benutzen?
Ausgabe: 8/84

Rolf Lehr

Leider kann Turbotape nicht mit Simons Basic laufen. Diese Funktion wird durch zwei Dinge verhindert: Erstens liegt Turbotape im Speicherbereich $C000-$CFFF, welcher auch von Simons Basic verwendet wird, und zweitens verbiegen beide Utilities die CHRGET-Routine im RAM, um die von beiden Erweiterungen zur Verfügung gestellten neuen Befehle decodieren zu können.

Marc Haber

## Wo gibt's den »Super Expander«?

Ich habe mir das Buch »Grafik mit dem VC 20« aus dem Markt & Technik Verlag gekauft. Dazu benötigt man aber eine Befehlserweiterung (Super Expander). Woher kann ich die bekommen?

Michael Schmitt

Die Grafikerweiterung VC 1211 A (auch als »Super Expander« bekannt) sollte bei jedem Commodore-Händler erhältlich, sein.

## Probleme mit Datasette

Ich habe andauernd »LOAD ERROR« bei meiner Datasette.
Ausgabe: 9/84

Peter Ritter

Bei Problemen mit Datasette hilft es oft, den Tonkopf mit Spiritus zu putzen (Wattestäbchen verwenden). Außerdem sollte man keine Chromdioxid-Kassetten verwenden. Auch die Justierung des Tonkopfes mittels der dafür gedachten Schraube bringt manchmal Erfolg.

Klaus Kohler

## Drucker zu langsam?

Die an meinen C 64 angeschlossene Typenrad-Schreibmaschine »Privileg 3000«, betrieben mit Textomat von Data Becker ist mir viel zu langsam. Wer kann helfen? Und wie?

Jürgen Heesch

Typenraddrucker sind leider nun einmal um einiges langsamer als Matrix- oder Tintenstrahl-Drucker. Dieser Mangel ist Konstruktionsbedingt und läßt sich softwaremäßig nicht beheben. Es ist ähnlich wie mit den Autos der 18-PS-Klasse — sie sind einfach von Natur aus langsam. Die einzige Abhilfe besteht in der Anschaffung eines schnelleren Modells.

## Testprogram für C 64

Gibt es ein Testprogramm für den C 64?
Ausgabe: 10/84

Peter Strempel

Die amerikanische Firma M-W Dist. Inc., 1342B Route 23 Butler NJ07405 vertreibt das Programm »Mr Tester«.

Überprüft werden: Joystick, Speicher, SID, Bildschirmposition und -Farbe, Tastatur, Kassette (lesen/schreiben), Disk (Spur und Sektor lesen/schreiben), Diskettenformat und Drucker. Der Preis beträgt 29,95 Dollar.

David Twigg-Flesner

## Beset-Schaiter zerstört Computer?

Ich wollte einen Reset-Schalter in meinen C 64 einbauen lassen. Mein Händler sagt aber nein dazu. Frage: Stimmt es, daß nach einem Reset durch Kurzschluß einige Bausteine im Computer zerstört werden können?

Lothar Birkenstock

Sie sind einem Ammenmärchen aufgesessen. Ein ordnungsgemäß eingebauter Reset-Schalter kann nichts zerstören. Der Netzschalter Ihres Computers ist beispielsweise ebenfalls mit der RESET-Leitung des Prozessors verbunden, und niemand würde auf die Idee kommen zu behaupten, das Einschalten eines Computers könnte diesen zerstören.

## Geht TI$ falsch?

Die eingebaute Uhr (TI$) verliert die richtige Zeit, wenn Daten oder Programme auf Kassette gespeichert werden. Nach Beendigung eines Abspeichervorganges hat die Uhr einen Sprung nach vorne getan, der jedoch leider keinerlei Beziehung zur tatsächlich vergangenen Zeit hat. Das ist bei meinem Programm-Thermometer mit stündlichem Abspeichern der Temperatur auf Kassette sehr störend.

Rolf Tulewski

Sowohl die interne Uhr (TI$) als auch die Kassettenoperationen werden bei VC 20 und C 64 über Interrupt gesteuert. Da es beim Laden und Speichern von Programmen und Daten auf hohe zeitliche Genauigkeit ankommt, wird die interne Uhr für die Dauer dieser Operationen einfach abgeschaltet. Nach Beendigung der Kassettenoperation kann TI$ daher einen nicht definierten Wert besitzen. Leider gibt es keine Möglichkeit, dies zu umgehen, es sei denn, man verwendet einen externen Zeitgeber.

## Piraten, Piraten

Bezugnehmend auf die Kolumne »Piraten, Piraten« in der Ausgabe 8/84 kann ich Ihnen bestätigen, daß die Firma »R & S Computerorganisation« eine Schwindelfirma ist. Unter dem Aktenzeichen — 52 Js 1025/84 — hat die Staatsanwaltschaft beim Landgericht Berlin dies noch einmal ausdrücklich bestätigt. Man sollte aber auf jeden Fall die Leser darauf hinweisen, daß der Handel mit Raubkopien strafrechtlich relevant ist und zu hohen zivilrechtlichen Schadenersatzansprüchen führen kann. Keinesfalls sollte man aber ohne weiteres Unterlassungserklärungen unterschreiben, bevor man hinsichtlich des rechtlichen Sachverhaltens Klarheit hat. Einige Firmen scheinen tatsächlich darauf spezialisiert zu sein, mit überhöhten Schadensersatzansprüchen die Leute so einzuschüchtern, daß diese nachher freiwillig einen zwar geringeren, aber eigentlich nicht notwendigen Betrag zahlen.

Dr. H. G. Baare-Schmidt, Rechtsanwalt

## Testprogram« für C 64

Gibt es ein Testprogramm für den C 64?
Ausgabe: 10/84

Peter Strempel

Die amerikanische Firma M-W Dist. Inc., 1342B Route 23 Butler NJ07405 vertreibt das Programm »Mr Tester«.

Überprüft werden: Joystick, Speicher, SID, Bildschirmposition und -Farbe, Tastatur, Kassette (lesen/schreiben), Disk (Spur und Sektor lesen/schreiben), Diskettenformat und Drucker. Der Preis beträgt 29,95 Dollar.

David Twigg-Flesner

## Raubkopien testen?

Testen Sie doch mal Spiele, die noch nicht bei 8O% aller Besitzer seit Wochen als Raubkopie vorliegen.

Willi Brechtel

Sie werden lachen, aber es ist oft so, daß Raubkopierer viele Spiele Wochen vor dem offiziellen Vertriebsbeginn bekommen. Sie werden verstehen, daß wir nicht gerne Spieletests von Raubkopien veröffentlichen. Es kommt nämlich manchmal vor, daß diese Kopien besser sind als die Originale und das könnte peinlich werden — nicht nur für uns.

## Der PET-Emulator der Demodiskette

Was hat es mit dem Programm »PET-Emulator« auf der Demo-Diskette auf sich?
Ausgabe 10/84

Wolfgang Joachim

Ohne Frage ist die Dokumentation von Commodore auch hier wieder sehr mies, das Programm »Emulator« läßt sich jedoch trotzdem sehr gut verwenden. Es gibt inzwischen zwar schon eine große Auswahl an Programmen für den C 64, aber einige Probleme (zum Beispiel mathematischer Natur) sind noch nicht umgesetzt worden. Da bietet sich doch eine Übernahme der alten CBM 3032-Programme an.

Konstruktionsbedingt unterscheiden sich der 3032 und der C 64 aber stark in der Speicherbelegung, dem Speicherplatz und der Zeropage. Zum Beispiel liegt das Video-RAM des 3032 im Bereich von 32768 bis 33792. Der C 64 dagegen hat sein Video-RAM ab Adresse 1024 bis 2023 und benötigt zusätzlich noch die Information über die Zeichenfarbe. Der 3032 verfügt über 31 KByte freies RAM, der C 64 dagegen über 38 KByte.

Um nun 3032-Programme direkt und ohne Umschreiben auf dem C 64 laufen zu lassen, braucht man nur den Emulator von der Demo-Diskette laden und starten. Danach wird das betreffende 3032-Programm von Kassette oder Diskette geladen und ist ohne weiters sofort lauffähig. Das gilt sowohl für Basic- als auch für reine Maschinenprogramme.

Bei einer geringen Anzahl von Maschinenprogrammen kann der Emulator aussteigen, beispielsweise wenn auf ROM-Routinen zugegriffen wird, die der Emulator nicht unterstützt. Da hilft nur eines: ausprobieren.

Der Emulator enthält übrigens einen DOS-Manager, der dem DOS 5.1 der Demo-Diskette entspricht.

Alles in allem ist der Emulator eine nützliche Sache. Er vergrößert die ohnehin schon bemerkenswerte Programmvielfalt für den C 64 noch um einiges.

Stefan Ullmann

## Wer kennt »Quicktext«?

Im 64’er-Magazin, Ausgabe 6/84, wurde das Listing zum Textverarbeitungsprogramm »Quicktext« abgedruckt. Seit Erscheinen dieses Heftes sitze ich nun daran. Selbst nach der Berichtigung im »Druckfehlerteufelchen« und nach wiederholtem Checken des Listings läuft das Programm einfach nicht. Wer kann helfen?

Margie Bastow

## Simons Basic und DOS 5.1

Wie kann man gleichzeitig mit Simons Basic und DOS 5.1 arbeiten?
Ausgabe: 64/10/84

Detlev Preisler

Beide Programme arbeiten wie folgt zusammen:

- Simons Basic laden und starten.
- DOS 5.1 mit ”LOAD” ”DOS 5.1",8.1 laden und mit SYS 52224 starten.

Es geht natürlich auch umgekehrt, kann aber dann in einigen Fällen zu Problemen führen.

Hier nun die Abhilfen:

- Sind beide Programme im Speicher, dann wird das DOS mit SYS 52224 eingeschaltet.
- Werden DOS-Befehle nur mit einem müden READY beantwortet (oder überhaupt nicht), dann gibt man ” # 8” ein. Die »8« steht dabei für die Geräteadresse der Floppy.

Es gibt aber auch eine Simons Basic-Version II die von anfang an problemlos mit dem DOS 5.1 läuft.

## C 64-Platine und Tastatur kaufen

Wo kann man eine C 64-Platine kaufen?
Ausgabe: 10/84

Eric Kratzin

Wo kann man eine C 64-Tastatur kaufen?
Ausgabe: 10/84

Oliver Varoß

Der TKD (Technische Kundendienst) von Quelle müßte in der Lage sein, die gewünschten Teile zu einem vertretbaren Preis zu beschaffen. In Ihrem Fall schlage ich aber vor, Sie tun sich zusammen und teilen sich ein komplettes Neugerät.

Holger Jacobs

## Wo gibt’s Comal?

Ich habe mit großem Interesse den ersten Teil Ihres ausgezeichneten Comal-Kurses gelesen. Leider haben Sie nirgendwo geschrieben, wo man Comal 0.14 erhalten kann und was es kostet.

Jürgen Kruse

Hier sind zwei Bezugsadressen:
Comal User Group
Otkerstr. 34
8000 München 90
<br>Comal Gruppe A. Knapp
Giersdorfer Str. 10
2800 Bremen 44

Bei beiden Adressen erhalten Sie Comal 0.14 auf Diskette einschließlich Kurzanleitung/Befehlsübersicht für 25 Mark Vorkasse (Schein oder Scheck). Für 30 Mark Vorkasse erhalten Sie zusätzlich noch das Handbuch. Wenn Sie zunächst nur das Handbuch haben wollen, kostet es 6 Mark. Bitte sehen Sie von Anfragen bei den beiden Comal-Gruppen ab, da alle anfallenden Arbeiten von den Mitgliedern in ihrer Freizeit ausgeführt werden müssen.

## Programmunterhrechung bei Druckerausgabe

Bei der Druckerausgabe erhalte ich oft einen »DEVICE NOT PRESENT ERROR«, obwohl der Drucker eingeschaltet ist.
Ausgabe: 8/84

Rudolf Ott

Dieser Fehler tritt sehr häufig bei Druckern auf, die über den seriellen Bus des C 64 angeschlossen werden. Die Ursache dafür liegt in der Konzeption des seriellen Busses. Abhilfe: Statt PRINT # mit CMD arbeiten, dann tritt der Fehler nur noch äußerst selten oder gar nicht mehr auf.

Marc Haber

# Wo gibt's EPROM-Brenner?

Wo kann ich den im Hardware-Test beschriebenen EPROM-Brenner von Roßmöller beziehen?

Jürg Kauer

Die Bezugsadresse ist Roßmöller Datentechnik, Finkenweg 1, 5309 Meckenheim. Es wäre noch darauf hinzuweisen, daß Roßmöller die Preise erhöht hat und außerdem der »Bausatz« nur aus einer Platine besteht.

# Die Scharfmacher

> Um den Streit um den häuslichen Farbfernseher zu beenden, gibt es eigentlich nur zwei Lösungen. Entweder wird ein zweiter Fernseher gekauft oder gleich ein Datenmonitor. Wir stellen vier dieser Sichtgeräte vor.

Uber technische Daten von Monitoren wird viel diskutiert, letztlich entscheidend über den Gebrauchswert eines Monitors ist aber immer die Qalität des Bildes. Diese ist aber von mehr als nur einigen Maßzahlen abhängig. Die meisten der in bunten Farbprospekten abgedruckten Daten verunsichern eher den Käufer, als ihm bei einer Entscheidung zu helfen. Oft wird von 40 oder 80 darstellbaren Zeichen pro Zeile gesprochen, oder mit Meßwerten nur so um sich geworfen. Dem Interessenten nutzt das sehr wenig.

Als wesentlichstes Beurteilungskriterium hat sich inzwischen die sogenannte Bandbreite (gemessen in Megahertz) eingebürgert. Die für eine deutliche Darstellung notwendige Bandbreite ist im wesentlichen davon abhängig, wieviele Einzelpunkte in einer Bildschirmzeile abgebildet werden. Beim Commodore 64 sind das 730 Punkte in der Horizontalen. Die minimale Bandbreite für diese Punktdichte beträgt etwa 5 bis 6 Megahertz bezogen auf die erste Oberwelle. Das schafft sogar ein einfacher SW-Fernseher. Deutlicher wird die Darstellung allerdings erst, wenn eine höhere Bandbreite zur Verfügung steht. Einfache Monitore haben etwa zwischen 12 und 15, mittlere zwischen 15 und 20 und gute Monitore über 20 Megahertz Bandbreite. Bei einigen Studiomonitoren wird sogar eine Bandbreite von über 40 Megahertz benötigt. Wesentlich unsinniger ist die Angabe »Zeichen pro Zeile«.

Wer sich einen Monitor anschaffen möchte, sollte sich vorher überlegen, wofür er seinen Computer hauptsächlich verwenden will. Wer nur gelegentlich etwas programmieren, beziehungsweise spielen möchte, ist mit einem kleinen Farbfernseher sicherlich nicht schlecht bedient, zumal ein Fernseher ja auch als Zweitgerät nützlich ist. Wer aber höhere Ansprüche an die Bildqualität stellt, steht schnell vor der Frage, monochromer oder Farbmonitor? Für den Anwender, der selten mal ein Spiel- oder Grafikprogramm verwenden möchte, haben wir drei monochrome Monitore verschiedener Qualitäts- und Preislagen getestet. Für die größte Überraschung sorgte aber der ebenfalls getestete Farbmonitor Cable MC 3700. Bei der Beurteilung der verschiedenen Monitore verwendeten wir zusätzlich die 80-Zeichenkarte von Decam.

## Mit Tricks zum besseren Bild

Im Test zeigte sich, daß es gar nicht so einfach ist, dem Commodore 64 ein klares und kontrastreiches Bild zu entlocken. Zwar bieten der C 64 und der VC 20 auf ihrer Geräterückseite einen Videoanschluß an. Das dort bereitgestellte Videomischsignal (FBAS = Farb-, Bild-, Austast- und Synchronsignal) kann aber hohen Qualitätsansprüchen nicht genügen. Die besten Resultate lassen sich mit dem Weg erzielen, den Commodore bei seinen 1701/ 1702-Monitoren gegangen ist. Die zwei für das Bild zuständigen Signale Sync/Luminance (Synchronisation/Helligkeit) und Chrominance (Farbart und Farbton) werden extern im Monitor gemischt. Für den Anschluß eines monochromen Monitors ist es übrigens besser, nur das Sync/Lum-Signal zu verwenden, die Darstellung wird dann um einiges deutlicher.

## Handbuch mit Fehlern

Die Abbildung der Video-Buchse im Commodore 64 Handbuch Seite 142 bezieht sich auf den VC 20. Beim Commodore 64 findet eine achtpolige DIN-Buchse Verwendung. Die Pinbelegungen stimmen aber im wesentlichen überein, lediglich der mittlere Pin (im Handbuch nicht abgebildet) trägt das Chrominance-Signal, die ebenfalls unterschlagenen Pins sieben und acht sind nicht angeschlossen. Für Besitzer eines Farbmonitors, wie dem Taxan Vision EX bleibt zum Anschluß eines Monitors nur das Video-Mischsignal. Trickreicher sind die Konstrukteure des Cable MC 3700 vorgegangen. Sie entnehmen dem Commodore die Signale getrennt und mischen sie erst im Monitor. Das Ergebnis ist beeindruckend. Das Bild zeichnet alle Konturen extrem scharf und verträgt selbst stärkste Farbunterschiede. Dabei sind die Farben sehr kräftig und leuchtend. Der Cable verfügt nicht nur über ein exzellentes Bild, sondern auch über einen guten Ton, der ebenso wie alle anderen Einstellungen an der Gehäusevorderseite geregelt wird. Ebenso wie seine Qualität, fällt auch das äußere Erscheinungsbild des Cable sehr positiv auf. Der Monitor wird komplett mit einem beweglichen Standfuß geliefert, der wie das Gehäuse beigefarbig ist. Der Cable ist ein gutes Beispiel für gelungenes Design und funktionelle Leistung. Lediglich der auf der Gehäuserückseite befindliche Netzschalter ist etwas schwer zugänglich. Die größte Überraschung erlebt man aber beim Aufschrauben des Cable. Normalerweise sind Produkte einer relativ unbekannten Firma mit Innereien aus dem Lande Nippons ausgestattet. Nicht so der Cable, er trägt auf allen seinen Bauteilen das Philips-Siegel. Bleibt die Frage, warum nicht gleich unter diesem Namen? Fürchtet Philips etwa die eigene Konkurrenz? Trotzdem ist der Cable ein sehr gutes Gerät, das als Farbmonitor sogar für eine erträgliche Darstellung von 80 Zeichen pro Zeile geeignet ist. Hierzu muß allerdings ein neues Kabel gelötet werden, denn die Decamp-Karte bietet ein BAS-Signal (monochrom) auf einem Chinchstecker an. Wer mit dem Cable ohne Farbe arbeiten will, findet auf der Rückseite des Gehäuses übrigens einen kleinen Schalter, der das Chrominance-Signal abschaltet. Schneller geht das allerdings mit dem Farbsättigungsregler.

## Es muß nicht immer Farbe sein

Die drei zum Test zur Verfügung stehenden monochromen Monitore waren alle mit einer grünen Anzeige ausgestattet. Damit erschöpften sich aber schon weitgehend die Gemeinsamkeiten, denn es gab erhebliche Qualitätsunterschiede. Das erste Gerät war der Taxan KX 12 (Bild 3), der über eine Bandbreite von 20 Megahertz verfügt. Er wird mit grüner und bernsteinfarbener Farbträgerschicht sowohl für den deutschen, als auch für den amerikanischen Markt gebaut. Hierin liegt bereits sein größter Nachteil. Der von jedem Monitor benötigte Rasterfrequenzwert steht technisch bedingt in engem Zusammenhang mit der Frequenz des jeweiligen Stromnetzes (Deutschland 50 Hz, USA 60 Hz). Viele Umbau- und Anschlußschwierigkeiten rühren von diesem Umstand her. In der Regel ist es mit einem Austausch des Trafos im Netzteil nicht getan. Viele frequenzbestimmende Teile sind auf die 60 Hertz abgestimmt und funktionieren mit der Frequenz in Europa nicht mehr richtig. Das Ergebnis sind häufig Zittereffekte. Beim Taxan KX 12 treten diese Effekte kaum auf, dafür hat dieser Monitor bei einem sonst guten Bild eindeutig Schwierigkeiten, verzerrungsfrei zu bleiben. Das erste getestete Gerät wies so starke Verzerrungen an den Rändern auf, daß eigentlich nur ein Transportschaden vorliegen konnte. Als aber, in etwas verminderter Form, das gleiche Problem auch beim zweiten Gerät auftrat, mußte auf einen Konstruktionsfehler geschlossen werden. Ganz besonders kraß fiel dieser Effekt bei Verwendung der Decam-Karte auf. Die Ränder verzerrten so stark, daß ein ordentliches Arbeiten kaum noch möglich war (Bild 4). Selbst die auf der Geräterückseite befindlichen, umfangreichen Einstellpotentiometer konnten nicht helfen. Obwohl mit einer hervorragenden Bandbreite von 20 Megahertz ausgestattet, hielt der zirka 400 Mark teure Taxan dem Test mit seinen Konkurrenten nicht stand. Auch wenn die eigentliche Zeichendarstellung gut war.

Die beiden anderen monochromen Testkandidaten sind eigentlich sehr nahe Verwandte, denn rein äußerlich unterscheiden sie sich kaum, wohl aber in ihren Leistungsmerkmalen. Der Hersteller beider Monitore ist BMC. Der BM 12 ES für etwa 400 Mark (Bild 5) ist sowohl in grün, als auch in bernstein erhältlich. Seine Bandbreite wird mit 18 Megahertz angegeben. Die eigentliche Besonderheit dieses Monitors ist aber seine Filterscheibe. Direkt auf der Bildröhre wurde eine synthetische Folie aufgebracht, die für ein blend- und reflexarmes Bild sorgen soll. Tatsächlich werden alle einfallenden Lichtquellen etwas diffuser, was bei längerem Arbeiten in stark erhellten Räumen als angenehm empfunden wird. Die Bildqualität des BMC BM 12 ES ist durchaus gelungen und die Ränder werden verzerrungsfrei abgebildet. Beim Einsatz der Decam-Karte waren die dargestellten Zeichen sehr gut lesbar und zeigten an den Zeichenrändern keinerlei Fadeout-Effekte (Bild 6). Auch im Dauereinsatz von mehreren Tagen wurde keine Verschlechterung der Bildqualität festgestellt.

## Hervorragende Bildqualitäten

Obwohl zwischen zwei so guten Monitoren wie dem BM 12 ES und dem BM 12 EN (Bild 7) bei der Beurteilung der Bildqualität immer ein gewisser Anteil Subjektivität dabei ist, gefiel der BM 12 EN ein wenig besser. Mit einem Preis von 425 Mark ist er allerdings auch einer der teuersten getesteten Geräte. Für den BM 12 EN wird eine Bandbreite von über 20 Megahertz angegeben. Das Bild ist sehr deutlich und absolut ruhig. Auch beim Einsatz der 80-Zeichenkarte wartete der BM 12 EN mit dem besten Ergebnis auf (Bild 8). Alle Zeichen waren gestochen scharf, so daß der Eindruck entstehen konnte, daß der Commodore 64 nie für weniger als 80 Zeichen pro Zeile konzipiert wurde. Auch beim BM 12 EN ist die Bildröhre entspiegelt, allerdings nicht durch eine Folie, sondern durch leichtes Anätzen der Oberfläche. Das Resultat fiel allerdings nicht so überzeugend wie beim ES-Modell aus.

## Kein eindeutiger Sieger

Ist die Entscheidung zwischen einem farbigen- und einem monochromen Monitor erst einmal gefallen, so sind bis auf den Taxan Monitor alle getesteten Geräte durchaus empfehlenswert. Mit einem Preis von etwa 800 Mark zuzüglich 18 Mark für das Verbindungskabel ist der Cable MC 3700, der auch in einer RGB-Version geliefert wird, zwar nicht gerade billig, bietet aber von allen bisher getesteten Farbmonitoren das beste Bild.

Ein monochromer Monitor sollte in der Regel dann eingesetzt werden, wenn auch eine 80-Zeichenkarte vorhanden ist, dabei ist es wichtig, daß die Zusammenarbeit mit einer solchen Karte problemlos funktioniert. Die beiden BMC-Monitore bieten hierfür die besten Voraussetzungen. Wer sich allerdings für alle späteren Anwendungen gerüstet wissen will, sollte die 25 Mark Mehrkosten aufbringen und sich gleich das bessere EN-Modell zulegen.

## Die 80-Zeichen-Karte

Gute Dienste während des gesamten Tests leistete die 80-Zeichenkarte der Firma Decam. Wie schon im Monitortest angesprochen, sorgt sie für ein exzellentes Schriftbild in einer 5x8-Zeichenmatrix. Die Decam-Karte liefert zu einem Preis von 285 Mark aber nicht nur die notwendige Zeichenumdefinierung, sondern hat auch noch einige andere nützliche Funktionen. So wurden beispielsweise einige der Sonderbefehle des CBM 8032 implementiert. Alle Sonderbefehle werden über CTRL in Verbindung mit einer anderen Taste ein- beziehungsweise ausgeschaltet. Mit CTRL L und CTRL N wird beispielsweise zwischen dem Grafikmodus (sonst CBM + SHIFT) und dem Textmodus umgeschaltet.

Wesentlich interessanter ist aber die Fensterdefinition. Die Größe des Fensters wird durch die Position des Cursors bestimmt. Ist ein solches Fenster definiert, wirken sämtliche Befehle nur noch auf dieses Fenster. Erst durch zweimaliges Drücken der HOME-Taste wird die ursprüngliche Bildschirmgröße wieder hergestellt. Weitere Funktionen sind das zeilenweise Herauf- und Herabblättern des Bildschirms sowie das zeichen- und zeilenweise Löschen und Einfügen.

Wesentliches Kriterium für die Bewertung einer 80-Zeichenkarte ist ihr Grad der Kompatibilität. Bei der Decam-Karte ist der gesamte Basic-Speicher für den Anwender freigeblieben. Das bedeutet, daß alle Programme, die keine wesentlichen Veränderungen außerhalb des Basic-Speichers vornehmen, weiterhin verwendet werden können. Richtig interessant wird es bei der Frage, wie verschiedene Basic-Erweiterungen mit der Karte zusammenarbeiten. Die Bedienungsanleitung zur Decam-Karte gibt hier einige Hilfen. Möchte man beispielsweise Exbasic Level II mit der Karte verwenden, wird empfohlen: 1. Das Programm zu laden. 2. zu starten und 3. den Befehl SYS 49263 zu geben. Zusammen mit einem Expansionsstecker und dem Modul funktioniert die beschriebene Methode aber nicht.

Wesentlich besser gestaltet sich das Zusammenspiel mit der CP/M-Karte. Nach dem Laden eines kleinen Zusatzprogrammes kann tatsächlich mit der 80-Zeichenkarte und dem Modul zusammengearbeitet werden. Allerdings gelang es während des Tests nicht, eine Version des Textverarbeitungsprogramms »Wordstar« einzusetzen, da sich die Bildschirmausgabe bis auf die erste Zeile sperrte. Dieser Fehler muß aber nicht unbedingt auf die Karte zurückgeführt werden, denn wie jeder CP/M-Besitzer weiß, hat die CP/M-Karte ihren eigenen Willen. Problemlos war aber das Zusammenspiel mit Simons Basic, für das ebenfalls ein kurzes Programm geladen werden mußte. Sogar der normale High-Resolution-Bildschirm für die Grafiken bleiben erhalten, wenn ein zweiter Monitor angeschaltet ist. Lediglich die Befehle TRACE, COLD, CENTRE und PRINT AT sind in ihrer Funktion eingeschränkt, beziehungsweise sollten nicht angewendet werden.

Leider gibt es bisher kein Textverarbeitungsprogramm, das mit der 80-Zeichenkarte zusammenarbeitet. Gerade hier wäre aber der sinnvollste Einsatz zu sehen. Hier sind die Softwarehäuser gefordert, denn Vizawrite 64 oder Textomat mit einer vollen Darstellung von 80 Zeichen auf dem Bildschirm wäre schon eine tolle Sache.

(Arnd Wängler/aa)

Bezugsquellen: Taxan Monitore, Melchers & Co., Postfach 102229, 2800 Bremen 1, Tel. (0421) 176989
BMC Monitore: Weber Computertechnik, Eulenspiegelstr. 56, 8000 München 38, Tel. (0 89) 6 0125 54
Cable Monitore: Boston Computer, Rosenheimer Str. 145A, 8000 München 80, Tel. 4910 73
Decam Karte: Decam Electronic, Pappelweg 3, 7517 Waldbronn, Tel. (0 72 43) 6 92 64

# Print 64 – das universelle Interface

> Interface ist nicht gleich Interface. Jede Schnittstelle zum Anschluß von Druckern mit Centronics-Schnittstelle hat ihre eigenen Vor- und Nachteile. Ein Universalkönner ist Print 64.

Manche Schnittstelle eignet sich gut zum Ausdruck von Texten, versagt aber bei den Commodore-eigenen Zeichen für Grafik und Cursorsteuerung. Andere wieder streiken bei den Grafiksymbolen und selbst definierten Zeichen. Nur ganz wenige beherrschen die Kunst des Bildschirmausdrucks hochauflösender Grafik. Für Print 64 gehören diese Funktionen aber zur Standardausstattung. Das Interface besteht aus einem unscheinbaren braunen Kasten (Bild 1), der zwischen dem C 64 (beziehungsweise Floppy) und dem Drucker zwischengeschaltet wird. Die notwendige Stromversorgung holt sich das Interface aus dem Drucker. Bei manchen Geräten (zum Beispiel Epson), ist es, bevor der Drucker sich rührt, notwendig, eine Stromversorgung von 5 V auf Pin 18 des Centronics-Ports zu legen. Der etwas Geübte entnimmt die Spannung einem der vielen TTL-Bausteinen auf der Druckerplatine und verbindet sie mit dem Port im Drucker selbst. Eine zweite Möglichkeit besteht darin, ein externes Netzteil anzuschließen.

Nach dem erfolgreichen Überwinden dieser Schwierigkeit steht dem Anwender ein leistungsfähiges Hilfsmittel zur Verfügung, das er bald nicht mehr missen möchte. Print 64 ist durch seine Konzeption als »Hardware-Schnittstelle« zu fast allen kommerziellen Programmen kompatibel. Bei der Wahl der Geräte und Sekundäradressen wurde darauf geachtet, möglichst dem Commodore-Standard zu entsprechen. Die Sekundäradresse 7 bewirkt beispielweise, wie bei Commodore-Druckern, die Groß- und Kleinschrift. Damit sind die Fähigkeiten des Interfaces natürlich noch bei weitem nicht erschöpft. Im wesentlichen kann man bei Print 64 zwischen zwei Bereichen von Funktionen unterscheiden. Zum einen sind das die Druckbefehle, die direkt auf den Drucker (über Sekundäradressen) wirken, zum anderen sind das einige Erweiterungen, die von der mitgelieferten Diskette nachgeladen werden.

Die Sekundäradressen finden Verwendung beim Ausdrucken von Texten und zum Auflisten von Programmen. Alle ASCII-Codes werden dabei so umgewandelt, daß sie der Standardtabelle entsprechen. Für besondere Zwecke kann das Interface auch als reines Verbindungskabel verwendet werden, ohne das eine Umwandlung der ASCII-Codes vorgenommen wird. Zusätzlich stehen aber auch fast alle Commodore-Grafikzeichen zur Verfügung. »Fast« alle Grafikzeichen muß deshalb gesagt werden, weil einige der Zeichen umdefiniert wurden und nun den deutschen Zeichensatz beinhalten. So ist beispielsweise die eckige Klammer links das kleine »ä« und das Pfundzeichen das kleine »ö«. Erstmals hat der Commodore-Besitzer die Möglichkeit, in seinen Basic-Programmen, den deutschen Zeichensatz einzusetzen. Die Bildschirmdarstellung ist dann allerdings gewöhnungs- beziehungsweise umprogrammierungsbedürftig. Für Grafikzeichen benutzt das Interface den 8-Bit-Grafikmodus, wie er bei Epson-, Star- oder Seikonic-Druckern zur Verfügung steht, der Hintergrundspeicher bleibt deshalb zur eigenen Verwendung frei. Alle Zeichen werden bildschirmgetreu ausgedruckt, selbstverständlich auch invertiert. Dabei werden für jeden Modus zwei verschiedene Sekundäradressen eingesetzt. Die erste bewirkt, daß zur besseren Lesbarkeit alle Zeichen (auch die Cursorzeichen) mit einem kleinen Abstand gedruckt werden. Die zweite läßt alle Zeichen wie gewohnt aneinandergereiht. Beim Auflisten von Programmen ist diese Funktion besonders nützlich, denn die Deutlichkeit aller Steuerzeichen ist auffallend verbessert (Bild 2).

Der zweite interessante Bereich dieses voll grafikfähigen Interfaces bedarf des Nachladens einiger kurzer Programmteile von Diskette. Diese Programme sind reine Erweiterungen, wie sie eigentlich zu jedem Interface gehören sollten. Den großen Pluspunkt sammelt Print 64 durch seinen beigelegten Druckerkursus »Ein Interface stellt sich vor«, in dem alle wichtigen Funktionen ausführlich und grafisch ansprechend erläutert werden. Da der gesamte Druckerkursus auf Diskette gespeichert ist, können alle gerade gelernten Befehle sofort ausprobiert werden. Die beiden anderen Programme sind schon richtige Basic-Erweiterungen. Mit ihnen wird der Grafikausdruck fast schon zum Hobby. Mit einem speziellen Hardcopy-Programm können alle Bilder der bekannten Grafikhilfen Paint Magic, Supergrafik, Doodle und vor allem vom Koala-Painter und dem Sketch-Pad ausgedruckt werden (Bild 3 und 4). Die Bedienung ist menügesteuert und anwenderfreundlich.

Besonders reizvolle Effekte lassen sich aber durch Veränderungen der verschiedenen Graustufen für die Farbwerte des Bildes erreichen. Ein einziges Bild kann auf diese Weise in vielfältiger Weise variiert werden. Zum Ausdruck von eigenen Grafiken ist dieses Programm allerdings nicht unbedingt erforderlich. Dazu genügt schon das dritte Programm auf der Diskette. Es bereichert das Commodore-Basic um einige wichtige Befehle. Durch einfaches Ändern eines Befehls (beispielsweise !CTN oder !CTD) wird der Ausdruck sowohl in der Punktdichte als auch in der Breite beeinflußt. Es ist dabei gleichgültig, ob es sich um einen Textbildschirm oder um einen HiRes-Bildschirm handelt, es braucht nur ein anderer Befehl verwendet werden.

Schenkt man dem Fehlen einiger weniger Grafikzeichen keine Beachtung, so sind der etwas langsame Ausdruck der Grafikzeichen und die Lötarbeiten beim Einbau in Epson-Drucker, die einzigen Nachteile dieses Interfaces. Print 64 arbeitet mit verschiedenen Textverarbeitungsprogrammen zusammen. Es kann deshalb und wegen seines insgesamt gelungenen Konzepts, als eines der besten Interfaces zum Anschluß von Druckern mit Centronics-Schnittstelle bezeichnet werden. Bei einem Preis von 320 Mark, einschließlich der Diskette mit den Hilfsprogrammen, eine starke Leistung.

(Arnd Wängler/aa)

Bezugsquelle: Rolf Rocke Computer, 5090Leverkusen 3, Auestraße 1, Tel. 02171/2624

# Floppy mit Nachbrenner

> Schimpfen Sie nicht mehr über die nervenzermürbende Langweilerin Commodore-Floppy 1541. Jetzt kommen auf einmal gleich mehrere Systeme auf den Markt, die der 1541 die Sporen geben. Die besten drei stellen wir Ihnen vor.

Es ist schon nervig. Wieder einmal sitzt man vor seinem C 64 und lädt ein Programm nach dem anderen in den Speicher. Vielleicht ordnen Sie gerade Ihre Programmsammlung. Diskette wechseln, Programm laden, kurz anschauen, danach wieder Diskette wechseln und abspeichern. Die Wartezeiten beim Laden und Speichern machen ganz müde. Die Finger trommeln einen %-Takt auf den Schreibtisch. Im Geiste rechnet man schon aus, wieviel wertvolle Zeit wieder verloren geht. Voller Neid denkt man an Disketten-Laufwerke anderer Hersteller und Computer, die die Nerven nicht so stark beanspruchen.

## Ein erster Lichtblick

Eines Tages boten zwei junge Männer ein Programm an, das die Floppy 1541 beim Laden von Programmen um ein mehrfaches beschleunigt. Den Erfolg kennen Sie bereits. In der Ausgabe 10/84 wurde HYPRA-LOAD zum Listing des Monats gemacht.

Setzt man dieses Programm ein, werden sofort Sehnsüchte wach. Wenn schon das Laden von Programmen schneller geht, dann bitte auch das Speichern und wenn möglich auch Direktzugriffe und Dateihandling.

Es ist seltsam: Kaum hatten wir HYPRA-LOAD in den Händen, kam die nächste Überraschung. Ein Vertreter der holländischen Firma Computing International präsentierte uns ein System, daß alle oben genannten Wünsche in Erfüllung gehen ließ. Allerdings reicht eine reine Software-Lösung nicht mehr aus. Auch an der Hardware muß jetzt manipuliert werden (siehe Bild).

Der Grundgedanke ist klar. Es gibt eigentlich nur zwei Hemmschuhe für die Floppy. Zum einen ist es die serielle Datenübertragung, und zum anderen die umständlichen Routinen des Floppy-DOS (Disk-Operation-System). International Computing löst beide Probleme. Sie schrieben die Busroutinen um, machten sie schneller und gleichzeitig wurde ein paralleler Anschluß hergestellt und zwar interessanterweise ein IEEE-488- Bus. Das ist nicht unbedingt notwendig, aber ein Vorteil, wenn Sie auf größere Commodore-Peripherie zugreifen wollen. So schlossen wir versuchsweise die Commodore-Floppy SFD 1001 mit 1000 KByte Diskettenspeicherkapazität an. Es war eine wahre Wonne, daß Gerät in Aktion zu sehen. Auf die SFD 1001 stellten wir die 1541 und ließen die beiden zusammen arbeiten. Die Übertragung von einem Gerät zum anderen, ganz gleich in welcher Richtung, ging problemlos über die Bühne. Und die Geschwindigkeit war so verblüffend, daß wir zuerst an einen Fehler dachten, als die READY-Meldung so schnell wieder zu sehen war. Aber es gab keine Fehler.

Wie steht es mit der Kompatibilität? Diese Frage ist noch wichtiger als das Maß der Geschwindigkeitssteigerung. Denn davon hängt die Einsetzbarkeit ab. Es wäre schlimm gewesen, wenn man lediglich die parallele Übertragung gegen die serielle getauscht hätte. Jedoch stehen beide zur Verfügung. Mit einem kleinen Schalter läßt sich jederzeit die gewünschte Übertragungsart einstellen. Das ist in zwei Fällen wichtig. Einmal kann es sein, daß Programme sich doch nicht über das parallele Kabel laden lassen (das kann passieren, wenn diese Programme selber den seriellen Bus abfragen und verändern). Zum anderen muß auf einen am seriellen Port angeschlossenen Drucker zugegriffen werden können. Leider ging das nicht, wenn der Schalter auf parallel stand. Durch einfaches Umschalten ließ sich das Problem beseitigen. Wir konnten zwei Vorab-Versionen testen. In der einen Version mußte beim Umschalten ein Reset durchgeführt werden, in der anderen Version war das nicht nötig. Ein im Speicher befindliches Programm wird dann nicht gelöscht. Nach Aussage von Computing International werden die ausgelieferten Versionen einen Druckerbetrieb unabhängig von der eingestellten Übertragungungsart garantieren.

Bei den Programmen gab es keine Lade- oder Speicherprobleme, ausgenommen einiger Programme mit eigenen Busroutinen, die jedoch relativ selten sind. Wenn das Programm aktiv ist, kann kein Kassettenrecorder angeschlossen werden. Dieses Problem kann jedoch auch mit einem Schalter gelöst werden, der den vorher belegten Speicherbereich wieder freigibt.

Die RS232-Schnittstelle ist nach Angabe des Herstellers voll funktionstüchtig.

Die Tests ergaben bei diesem System eine zwei- bis vierfache Steigerung der Geschwindigkeit beim Laden und Speichern von Programmen sowie eine geringfügigere Steigerung um den Faktor 1,2 bis 2 beim Arbeiten mit Dateien.

Es gibt zwei Wege, seinen Commodore 64 umzurüsten. Sie können entweder einen Bausatz bestellen (zirka 250 Mark, inbegriffen sind alle Bauteile), oder Sie schicken Ihre Geräte (C 64 und Floppy 1541) ein, die Lösung für den Nichtbastler. Dann kostet der Umbau voraussichtlich 375 Mark. Den Umbau erledigt in Deutschland die Firma Optronik Service International.

## Speeddos - die Erweiterung mit Pfiff

Eine weitere Alternative zu diversen Fastload-Programmen und IEC-Bus-Floppy-Laufwerken vertreibt S&S-Soft und nennt sich Speeddos: Eine kleine Hardware-Erweiterung für den C 64, deren Einbau sich auf einfaches Einstecken beschränkt.

Alle Programme, die mit »Speeddos« abgespeichert wurden, sollen sich bis zu zehnmal schneller laden lassen. Mit normalem Betriebssystem gespeicherte Programme werden mit rund sechsfacher Geschwindigkeit geladen.

Da die reine Datenübertragung etwa achtmal schneller ist, ergibt sich bei floppyinternen Operationen eine generelle Geschwindigkeitssteigerung um den Faktor 2 bis 5. Das Formatieren einer Disk benötigte m unserer Demonstrationsversion 39 Sekunden, in der Verkaufsversion soll der Formatierungsvorgang nur noch 17 Sekunden dauern und das Laden soll mit der zehnfachen Geschwindigkeit möglich sein. Auch der Betrieb von zwei 1541 mit Speeddos ist kein Problem.

Zusätzlich zum Geschwindigkeitsvorteil wurden einige Verbesserungen und Erweiterungen an den Betriebssystemen von Computer und Floppy eingebaut. Dem Benutzer steht ein komplettes DOS zur Verfügung, mit dessen Hilfe man auch den zusätzlichen Löschschutzbefehl der Floppy ansprechen kann oder das Inhaltsverzeichnis ohne Programmverlust erhält. Die Funktionstasten wurden mit einigen häufig benötigten Funktionen belegt (zum Beispiel List, Run, Directory ohne Programmverlust, etc.). Die Belegung ist abschaltbar. Außerdem wurde eine softwaremäßige Centronics-Schnittstelle integriert, die automatisch aktiviert wird, wenn ein Centronics-Drucker (zum Beispiel Itoh oder Epson) am User-Port angeschlossen ist. Entsprechende Kabel dazu können ebenfalls geliefert werden.

In der Verkaufsversion soll außerdem ein komfortabler Maschinensprache-Monitor (mit Auf- und Abwärts-Scrolling) enthalten sein.

Darüber hinaus bietet Speeddos noch einen laufwerks- und diskettenschonenden Effekt: Bei auftretenden Fehlern hört man kein lautes Rattern mehr, sondern nur noch ein leises »Taktak«, das den Steppermotor und den Endanschlag nur noch minimal belastet. Beim Einlegen von Disks in das Floppy-Laufwerk läuft der Motor automatisch an und zentriert die Diskette gleich beim Einlegen.

Speeddos benötigt keinen Speicherplatz und läuft mit allen Programmen, die nicht auf den Datasette-Recorder oder die RS232-Schnittstelle zugreifen. Das sind rund 98% der derzeit verfügbaren Software. Somit ist aber auch hier zum Beispiel die Verwendung eines Akustikkopplers in Verbindung mit Speeddos nicht möglich. In diesem Fall muß das EPROM vom C 64 abgezogen werden. Der Betrieb mit CP/M läuft da hingegen ohne Einschränkungund geht ungefähr dreimal schneller als normal.

Besonders hervorzuheben an dieser Erweiterung ist die außerordentliche Geschwindigkeit und Kompatibilität zur erhältlichen Software.

Speeddos wird als Bausatz voraussichtlich 269 Mark kosten. Der Einbau beschränkt sich auf einfaches Einstecken von EPROMs und Steckern in den Computer und ist von jedem Laien durchführbar. Für diejenigen, die einen C 64 mit eingelötetem Betriebssystem besitzen, ist gegen einen Aufpreis von 20 Mark eine Platine erhältlich, die in diesem Fall das Löten erspart.

Die Entwickler von Speeddos, 0. Joppich und 0. Eikemeier, arbeiten an einem Backup-Programm für Speeddos, das bei einem Laufwerk eine ganze Disk in unter zwei Minuten kopieren soll. Ein noch schnelleres Backup für zwei Laufwerke ist ebenfalls in Planung.

## Geschwindigkeit ist (k)eine Hexerei

Auch mit dem dritten System, das wir Ihnen vorstellen, dem »Turbo Access« von Roßmüller, werden Träume wahr: Die »lahme Ente« — gemeint ist natürlich die Floppy 1541 — lernt fliegen. Zehnmal schnelleres Laden, dreimal schnelleres Abspeichern, das sind Werte, die sich sehen lassen können. Ja selbst die großen Commodore-Floppies mit ihrem Parallelbus können auf einmal nicht mehr mithalten.

Die Engstelle der 1541 ist seit langem bekannt: Alle großen CBM-Computer benutzen einen 8-Bit-Parallelbus, nur die kleinen arbeiten mit einer seriellen Schnittstelle. Dabei wird jedes übertragene Byte m 8 Bit zerlegt, die einzeln über den Bus geschickt werden. Und das braucht Zeit...

## Acht Drähte machen noch keinen Bus

Was liegt also näher, als einfach mehr Leitungen zur Übertragung zu spendieren? Doch damit ist das Betriebssystem der Floppy, das DOS, nicht so ohne weiteres einverstanden. Man muß es daher umgehen und eine eigene Verwaltung aufbauen. Davon machen Programme wie »HYPRA LOAD« gebrauch: In das RAM der Floppy wird ein eigenes Programm geschrieben, das die Datenübertragung abwickelt. Der Nachteil einer solchen Software-Lösung liegt auf der Hand: Vor jeder Übertragung muß das Programm erst in die Floppy geschoben werden, und dazu braucht man wieder ein Programm, das geladen werden muß ...

## ... ohne Lenkung geht nichts!

Beim »Turbo Access« hat man daraus die Konsequenz gezogen: Es handelt sich um eine reine Hardware-Lösung, die aus drei Platinen und einem Flachbandkabel für die Parallelübertragung besteht.

Zur Ausstattung gehören zwei EPROMs, die neue Betriebssysteme sowohl für die Floppy, als auch für den C 64 enthalten. Sie befinden sich zusammen mit den alten umschaltbar in Floppy beziehungsweise Computer. Die dritte Platine steckt im Expansion-Port und ist mit einem zusätzlichen PIA, ähnlich dem User-Port, bestückt. Für Interessierte sei hier angemerkt, daß sie auf keinen Port verzichten müssen — der benutzte Expansion-Port ist durchgeschleift.

Allerdings lag zum Test noch nicht die endgültige Fassung, sondern eine vorläufige »Arbeitsversion« vor. Nach Angaben des Herstellers wird die endgültige Version auch berücksichtigen, daß die Floppy 1541 in zwei Versionen gebaut wird, die sich in der Platinenform unterscheiden.

Wer jetzt Holz aufs Feuer legt, um den Lötkolben aufzuheizen, muß allerdings enttäuscht werden. Alles ist steckbar, mit wenigen Griffen einzubauen.

## Was leistet »Turbo Access«

Stellt man die Floppy wie oben beschrieben auf Parallelübertragung um, erreicht man aus dem Stand die 6fache Ladegeschwindigkeit. Noch sind die Files ja nach alter DOS-Manier abgelegt. Dies ist mittlerweile schon fast »Standard«. Mit »Turbo Access« abgespeicherte Programme werden allerdings zirka zehnmal schneller geladen. Hier einige Testzeiten:

158 Blöcke werden in 10,4 Sekunden geladen. Die 4040 braucht dafür immerhin 23 Sekunden, die »normale« 1541 1 Minute und 40 Sekunden.

Eine Diskette wird in 29 Sekunden formatiert. Die 1541 braucht etwa 1 Minute 30 Sekunden.

Die Befehle SCRATCH und VALIDATE werden zirka doppelt so schnell wie bisher ausgeführt.

SAVE erfolgt mit der dreifachen Geschwindigkeit. Das entspricht ungefähr der Geschwindigkeit der 4040. Bei jedem SAVE wird anschließend verifiziert. Daraus erklärt sich der erhöhte Zeitbedarf gegenüber LOAD.

Wodurch werden diese Zeiten möglich? Ursache ist, wie bei den beiden anderen Systemen, daß nicht nur die Übertragung selbst, sondern das gesamte DOS umfassend überarbeitet wurde. Dabei wurde auch die Verwaltung auf der Diskette abgeändert, und das bringt die Floppy ganz schön auf Trab. Die Kopfpositionierung wird dreimal schneller, das zahlt sich vor allem bei relativen Files aus. Und einige Fehler im alten DOS wurden gleich mitkorrigiert. Das lästige »Gerappel« beim Formatieren, Ursache für viele verstellte Schreib-Lese-Köpfe, wird auf ein Mindestmaß reduziert und noch einiges andere mehr.

Keine Angst, bei allen Änderungen wurde darauf geachtet, daß alle Befehle genauso funktionieren wie bisher. Denn was nützt die schnellste Floppy, wenn kein Programm damit zusammenarbeitet. Bei allen Versuchen gab es bisher nur ein Programm, das nicht mit »Turbo Access« zusammen lief. Selbst Programme, die intensiv mit Diskettenbefehlen arbeiten (zum Beispiel »EX-DOS« und Kopier-Programme wie »FCOPY« oder »Quick-Copy«), machten ebensowenig Schwierigkeiten wie Datenverwaltungs- oder Testprogramme. Spiele, die häufig Teile von Diskette nachladen, werden zum echten Streß, da man nicht einmal mehr dazu kommt, Bier aus dem Keller zu holen ...

Relative oder sequentielle Files werden genauso problemlos verarbeitet. Und sollte einal etwas nicht laufen, drückt man CTRL + £, legt einen Schalter um und hat wieder den alten Zustand hergestellt. In den meisten Fällen ist das sogar mitten im Programm ohne Programm- oder Datenverlust möglich.

## Und der Haken bei der Sache?

Natürlich, das dicke Ende mußte ja noch kommen, aber so dick ist es nun auch wieder nicht. Um im Rechner-Betriebssystem Platz zu bekommen, wurden die Kassetten-Routinen entfernt. Für den Betrieb der Datasette muß man auf die alten Betriebssysteme umschalten. Dafür wurden im neuen Betriebssystem noch einige äußerst nützliche Routinen eingebaut. So ist jetzt mit CTRL + D jederzeit eine Directory-Ausgabe — natürlich ohne Programm-

TODO Fortsetzung auf Seite 163

# Nichts ist ewig

> Zugegeben, der Commodore 64 hat einige Nachteile. Aber warum sollte man sich damit abfinden? Alles kann mit dem ROM-Change-Programm verändert werden.

Jedem Computer, auch dem Commodore 64 wird ab Werk eine bestimmte Ausstattung an Software mit auf den Weg gegeben. Damit ist nicht die Demo-Diskette gemeint, sondern die fest im Computer eingebaute, auf PROMs gespeicherte Firmware. Sie sorgt dafür, daß der Commodore überhaupt auf Eingaben reagiert oder einen Basic-Befehl ausführt.

Der gesamte C 64 (und jeder andere Computer) ist eigentlich nichts anderes als eine Anzahl miteinander verdrahteter Baugruppen, die allein zu nichts fähig sind. Leben eingehaucht wird dem ganzen erst durch ein sehr wichtiges Programm, das sogenannte Betriebssystem. Dieses Programm initialisiert und verwaltet die gesamte Hardware. Beim Commodore 64 ist es genau 8 KByte lang und liegt im Bereich von $E000 bis $FFFF. Der zweite wichtige Festwertspeicher ist der Basic-Interpreter. Er ist ein Übersetzungsprogramm, das eine Anweisung in ein maschinengerechtes Signal umwandelt. Auch der Interpreter benötigt 8 KByte und liegt im Bereich von $A000 bis $C000. Jetzt fehlt nur noch der Charakter-Set von 4 KByte, der ebenfalls in einem eigenen ROM untergebracht ist.

Diese drei Programme sind für das äußere Erscheinungsbild und die Funktionalität des Commodore 64 verantwortlich. Hier eröffnet sich ein extrem interessanter Bereich der Programmierung. Dazu bieten sich zwei Wege an: Der erste Weg beruht auf der glücklichen Tatsache, daß es beim Commodore möglich ist, den RAM-Bereich unter einem ROM zu nutzen. In der Praxis sieht das folgendermaßen aus: Die Speicherinhalte des ROMs werden zum Bearbeiten in den darunter liegenden RAM-Bereich kopiert. Ob nun das RAM oder das ROM aktiv ist, entscheidet das 6510 Datenrichtungsregister (Speicherstelle 1). Vom Basic aus ist dieses Register allerdings nur dann zu verändern, wenn sowohl der Basic-Interpreter, als auch das Betriebssystem in das RAM kopiert wurden. Das geschieht entweder mit einer POKE-Schleife oder mit dem ROM-Change Programm. (Betriebssystem kopieren: FOR A = 57344 TO 65535: POKE A,PEEK (A): NEXT)

(Basic kopieren: FOR A = 40960 TO 49152: POKE A, PEEK (A) : NEXT). Der Normalwert dieses Registers ist 55 (probieren Sie es aus). Soll das RAM (für Basic) selektiert aktiv sein, muß hier der Wert 54 eingeschrieben werden. Für Basic und Betriebssystem zusammen beträgt der Wert 53. Alle Veränderungen des Basic und Betriebssystems sind dann aktiv. Bekannte Programme wie Quickcopy und viele Basic-Erweiterungen funktionieren nach diesem Prinzip.

Der zweite und wesentlich reizvollere Weg die Firmware zu beeinflussen ist, das Betriebssytem dauerhaft zu verändern. Dazu ist aber ein Eingriff im Computer notwendig, denn die oben beschriebenen Bausteine müssen gegen andere ausgetauscht werden. Wer also noch Garantie auf seinen Commodore hat, sollte besonders vorsichtig sein. Im ersten Teil dieses Artikels wollen wir, zum Einüben sozusagen, die Funktionstasten des Commodore 64 mit bestimmten, oft gebrauchten Werten belegen. Im zweiten Teil wird das Hypra-Load aus der Ausgabe 10/84 im Betriebssytem verankert. Der Nachteil dieser Änderungen soll nicht verschwiegen werden. Da alle neuen Funktionen natürlich Speicherplatz benötigen, müssen andere Teile des Betriebssystems entfallen. Wir haben uns entschlossen, die Kassettenroutinen ab $F800 herauszunehmen und zu überschreiben. Das Laden von Kassette wird dadurch unmöglich, es sei denn, das alte Betriebssystem wird parallelgeschaltet.

Bevor wir nun auf das Hilfsprogramm für diese Veränderungen, das ROM-Change-Programm, eingehen, sollen die Hardware-Voraussetzungen für die Änderung des Betriebssystems erklärt werden. Nach dem Öffnen des Computers finden wir auf der linken hinteren Seite drei kleine Bausteine, hinter denen auf der Platine die Bezeichnungen U3 bis U5 stehen. U3 ist der Basic-Interpreter, U4 das Betriebssytem, U5 das Charakter-ROM (Bild 1). Heute interessieren wir uns aber nur für den U4-Steckplatz. Wer Glück hat, findet dort einen Stecksockel. Wer Pech hat, muß seinen Händler oder einen Lötkolbenfachmann bitten, ihm hier einen Stecksockel einzulöten. Anstelle des dort befindlichen ROMs kann aber, und das ist die wesentlichste Veränderung, auch ein EPROM stecken. Am besten eignen sich hierzu die 2564-Typen, denn sie sind pinkompatibel zu den Commodore-ICs. Leider sind sie sehr schwer zu beschaffen. Im Normalfall wird aber wahrscheinlich ein 2764-EPROM Verwendung finden. Der Nachteil dieses EPROMs besteht in einer anderen Belegung der Anschlußpins. Hier hilft allerdings ein einfacher Adaptersockel. Dazu braucht man einen 24- und einen 28-Pin-Stecksockel. Diese beiden Sockel werden miteinander verdrahtet (Bild 2 und 3). Bild 2 zeigt die beiden Sockel mit den Beinen nach unten stehend. Der kleine Sockel steckt später im U4-Steckplatz, der größere Sockel trägt das geänderte Betriebssystem und steckt auf dem kleineren Sockel. Vor dem Einbau ist es aber ratsam, alle Kontakte auf richtigen Anschluß und Leitfähigkeit zu überprüfen. Schon ein einziger falscher Anschluß führt zum »Absturz« des gesamten Systems. Bild 4 zeigt, wie der neue Sockel mit der EPROM-Kerbe zur Gehäuse-Rückseite auf der Platine steht.

Nun aber zur Praxis, dem ROM-Change-Programm. Es ermöglicht das gefahrlose Ändern und Ausprobieren aller Umprogrammierungen. Dazu wird nach dem Start der selektierte ROM-Bereich (Betriebssytem oder Basic) ab Adresse $6000 ins RAM kopiert. Das geschieht mit einem kurzen Maschinenprogramm, das im Kassettenpuffer steht. Das Programm ist für den Betrieb mit einem Diskettenlaufwerk gedacht, läuft aber auch im Kassettenbetrieb, wenn ein eigener Monitor zum Laden und Abspeichern Verwendung findet. Nach dem Kopieren erscheint das Hauptmenü, von dem aus alle wichtigen Funktionen erreichbar sind. Die erste dient dem Einlesen von fest im Programm eingebauten DATA-Zeilen. In unserem Beispiel sind ab Zeilennummer 8000 die DATAs für die Funktionstasten einprogrammiert. Hier können natürlich auch eigene Werte stehen. Die erste Zahl gibt dabei die reelle Adresse an, ab der die DATAs geschrieben werden sollen (zum Beispiel 57612 = $E10C). Der Computer errechnet dann die entsprechende Stelle im RAM. Die zweite Zahl gibt an, wieviel Bytes übertragen werden sollen. Die dritte Zahl ist die Prüfsumme. Danach folgen die Programm-DATAs. Bei einem Prüfsummenfehler zeigt der Computer die falsche Prüfsumme an. Eigene Daten werden einfach an die vorhandenen DATAs angehängt. Die ersten drei Bytes müssen natürlich auch die obige Bedeutung haben. Als letzte Zeile muß stehen: DATA 0, da es sonst zu einem OUT OF DATA ERROR kommt. Der zweite Menüpunkt liest Maschinenprogramme direkt an die vorgesehene Stelle. Damit kann man beispielsweise ein Programmfile, das von einem Assembler erzeugt wurde, direkt einlesen. Wichtig ist, daß die Startadresse des Programms im ROM-Adreßbereich beziehungsweise im Bereich $6000 liegt. Der mit Punkt 3 wählbare Minimonitor hilft beim schnellen Ändern einzelner Bytes im hexadezimalen Zahlensystem. Die Startadresse entspricht dabei der Adresse im ROM. Der Minimonitor wird durch Eingabe einer Zahl größer $FF oder des Buchstabens X verlassen. Will man keine Speicherstelle ändern, genügt RETURN für die Übernahme des alten Wertes. Für größere Änderungen reicht dieser Minimonitor natürlich nicht mehr aus. Dazu wird mit Punkt 4 ein eigener Monitor aktiviert. Dieser muß allerdings vor dem Start des ROM-Change-Programms bereits geladen sein. Der Monitor darf im Bereich von $8000 bis $9FFF oder von $C000 bis $CFFF stehen. Zum Starten genügt das Eingeben der Startadresse des Monitors hexadezimal!). Mit den Menüpunkten 5 und 6 wird der Speicherbereich von $6000 bis $7FFF geladen beziehungsweise abgespeichert. Das Laden eines kompletten Betriebssystems dauert allerdings mehrere Minuten. Einer der wichtigsten Menüpunkte ist aber der siebte. Er startet das gerade veränderte oder geladene neue Betriebssystem (es wird natürlich zuerst in seinen richtigen Speicherbereich verschoben). Vor dem Ausprobieren dieser Funktion muß in jedem Fall der Punkt 5 angewählt werden, wenn die Änderungen nicht verlorengehen sollen. Es kann vorkommen, daß das Betriebsystem beim Starten »abstürzt«. Dann genügt ein RESET und die erneute Aktivierung des geänderten ROMs durch POKE 1,53.

Sind alle Tests im RAM positiv verlaufen, können wir uns an die Speicherung des neuen Betriebssytems auf EPROMs heranwagen. Das neue Betriebssystem wird von Diskette in den RAM-Bereich ab $6000 absolut, das heißt mit LOAD"Ihr Betriebssytem",8,1 geladen. Ab dieser Adresse beginnt auch die Programmierung des EPROMs. Sie endet bei $8000 (8 KByte). Das neue EPROM wird anschließend in den beschriebenen Stecksockel eingesetzt und in Steckplatz U4 befestigt. Fertig ist das Betriebssytem.

Was noch zu klären bleibt, ist die im ROM-Change-Programm bereits eingebaute Funktionstastenbelegung. Die Abfrage der Tastatur geschieht im Betriebssytem über den Interrupt. Wird eine Taste gedrückt, hält der Prozessor das laufende Programm an und springt in die Interrupt-Unterroutine bei $EA31. Dort wird festgestellt, welche Taste gedrückt wurde. Der ASCII-Code der Taste wird im Tastaturpuffer gespeichert. Das Funktionstastenprogramm greift an dieser Stelle ein, indem es den Wert der gedrückten Tasten mit den ASCII-Codes für die Funktionstasten (133-140) vergleicht. Stimmt der Wert nicht überein, so wird das Programm normal weitergeführt. Ansonsten vergleicht das Programm den Tastenwert mit einer Tabelle, in der die Belegungen für die Funktionstasten stehen. Hat das Programm die zur Funktionstaste gehörige Belegung gefunden, wird diese in den Tastaturpuffer geschrieben. Damit auch Programme, die auf einer Abfrage der Funktionstaste aufbauen, funktionieren, wurde eine Autoabschalt-Unterroutine mitprogrammiert. Kommt es dennoch einmal zu Schwierigkeiten, werden die Funktionstasten mit POKE 2,1 abgeschaltet und mit PO-KE 2,0 wieder aktiviert.

Abschließend sei nochmals darauf hingewiesen, daß alle Arbeiten an der Hardware des C 64 mit einem nicht geringen Zerstörungsrisiko verbunden sind. Wer also im Umgang mit Lötkolben und EPROMs nicht geübt ist, sollte sich an einen Fachmann wenden.

(Arnd Wängler/Ernst Schöberl/aa)

Beim Abtippen des Programms sind die Werte in Klammern am Ende einer Zeile nicht miteinzugeben. Sie sind erst für eine spätere Ausgabe von Bedeutung. Unterstrichene Buchstaben sind mit der Shift-Taste, überstrichene mit der Commodore-Taste einzugeben. Bei Ausdrücken in eckigen Klammern ist die jeweilige Taste zu drücken.

# Joystick-Vielfalt

> Das Angebot auf dem Joystick-Markt ist groß. Doch allzuoft vergeht bei der ersten Belastungsprobe die Lust am »Lustknüppel«. Wir sind der Frage nachgegangen, welcher Joystick nun der beste ist. Dabei wurden 20 Joysticks auf Herz und Nieren gerüft.

Gespannte Gesichter. Die Spielfigur läuft über den Bildschirm. Nur noch eine Gefahr ist zu überstehen. Endlich, endlich haben wir die Lösung vor Augen. Kurz nach links, dann rechts und ... knacks. Das typische Geräusch eines brechenden Joysticks ist zu hören.

Nur eine Szene aus unserem Joysticktest. Nicht immer spielt man mit einem Joystick, der genausoviel aushält, wie es in der Werbung versprochen wird und man es sich wünscht.

Spiele wie »Soccer« und »Summer Games« haben schon manchem Joystick das »Leben« gekostet.

Somit haben wir schon das erste und wohl auch wichtigste Kriterium in der Beurteilung eines Joysticks: die Stabilität und Verarbeitung.

Der zweite, nicht minder wichtige Beurteilungspunkt: die Handhabung und die Standfestigkeit. Zur Standfestigkeit sei nur erwähnt: Auch Saugnäpfe halten nicht immer, was sie versprechen. Das vierfache »Plopp«, wenn sich der Joystick von der Tischplatte löst, war auch mehr als einmal bei uns zu hören.

## Bewährungsprobe

Nach dem Blick in das Innenleben wurden die Joysticks an unsere Tester gegeben. Getestet wurde mit den Spielen »Soccer«, »Summer Games« und »Zeppelin«. Die ersten beiden Spiele stellten sich als wahre »Joystick-Killer« heraus, das dritte aber war eine Herausforderung an die Richtungsgenauigkeit. Auf Richtungs- und Punktgenauigkeit kommt es auch in Zeichenprogrammen an. Nicht immer nützt Fingerspitzengefühl. So wurde auch die Verwendungsfähigkeit auf diesem Gebiet überprüft.

Beurteilt wurden außerdem die allgemeine Handhabung, die Standsicherheit und die Stabilität. Die Tester durften Noten von 1 bis 6 vergeben.

Uns standen bei dem Blick ins Innenleben einige Überaschungen bevor. Es ist verblüffend und erschreckend, wie primitiv und reparaturanfällig manche Joysticks aufgebaut sind. So wurde die Mechanik in die Wertung mit einbezogen. Mikroschalter erlauben eine hohe Richtungsgenauigkeit und sind sehr stabil. Deshalb wurden diese Schalter von uns mit 1 bewertet. Mit einer 2 wurden Metallstreifen-Schalter bewertet. Folien- und Gummischalter wurden wegen ihrer meist schlechten Qualität in der Genauigkeit und ihrer Reparaturanfälligkeit mit 4 und 5 beurteilt. Die Note ging normal in die Wertung ein, denn auch ein von der Technik mittelmäßiger Joystick kann seine Vorteile haben.

## »Der« Joystick überhaupt!

Alle von uns haben ihren »Joystick-Traum«. Jeder von uns stellt an einen Joystick spezielle Anforderungen. Gut beweglich muß er sein, und leicht zu handhaben. Der Feuerknopf sollte einen Druckpunkt haben. Dauerfeuer und Reset-Knopf könnten auch dabei sein. Ob nun Saugnäpfe oder »Joystick ohne Boden«, gefallen soll er natürlich auch.

Wir halten sechs Joysticks für empfehlenswert, acht für gut, drei für befriedigend und zwei für mangelhaft.

Plant man die Anschaffung eines Joysticks, so sollte man auf jeden Fall selbst ausprobieren, »seinen« Joystick herauszufinden. Unsere Testtabelle soll nur eine Hilfestellung auf diesem fast unüberschaubaren Markt sein.

Kaum ein Händler wird erlauben, daß man einen Joystick stundenlang ausprobiert oder gar aufschraubt.

Die Gesamtnote des Tests ergibt sich aus den einzelnen Zensuren. Alle einzelnen Bewertungen sind gleich gewichtet. Zieht man die Noten zusammen, so hat man zwei eindeutige Sieger. Doch testen Sie nur selbst. Sind es auch Ihre Sieger?

(rg)

# Graphics-Basic

> Ein neuer Stern am Himmel der Befehlserweiterungen. Obwohl der Name sich auf die Grafik bezieht, gehen die zusätzlichen Befehle weit über diesen Bereich hinaus.

Eines sei vorweggenommen, der Befehlssatz des »Graphic-Basic« läßt kaum einen Wunsch offen. Vergessen sie den POKE-Befehl, denn von der einfachen Farbänderung bis zur imposantesten Grafik- und Tonprogrammierung, stehen für alle Zwecke eigene Befehle zur Verfügung. Einfach und einprägsam, aber leistungsfähig, das sind die »Graphic-Basic«-Befehle. Das gilt auch für die Spriteprogrammierung. Denn hier haben sich die Programmierer selbst übertroffen. Bereits die Spriteerstellung geht mit dem eingebauten Sprite-Editor fast wie von selbst, der Eingabekomfort ist beispielhaft. So ist beispielsweise das Sprite, das gerade entworfen wird, in wirklicher Größe, in Y-Richtung und in X-Richtung vergrößert, abgebildet.

Ebenso besteht die Möglichkeit, die ganze 24x21 Punktmatrix um beliebig viele Spalten beziehungsweise Reihen zu verschieben. Wer schon früher mit ähnlichen Programmen gearbeitet hat, wird diesen Vorteil zu schätzen wissen. Selbstverständlich können sowohl Single- als auch Multicolorsprites definiert werden, die Vorder und Hintergrundabfrage, sowie die Kollisionserkennung sind eingebaut. Ein Sprite-Editor wie dieser wird noch lange Zeit seinesgleichen suchen.

Doch was kann man nun mit seinem eben erstellten Sprite-Kunstwerk alles anfangen? Sehr viel, denn dem Benutzer steht eine Vielzahl von neuen, sinnvollen Befehlen zur Verfügung. Diese Befehle zeichnen sich durch eine interessante Besonderheit aus, denn sie sind allesamt Interrupt-gesteuert. Das heißt, Sprites bewegen sich nach einmaligem Aufruf selbständig. Der Effekt ist, daß jedes Basic-Programm mit höherer Geschwindigkeit weiterläuft. Mancher Befehlserweiterung geht hier schon langsam die »Luft« aus, nicht so »Graphic-Basic«. Diese Supererweiterung sammelt weitere Pluspunkte, etwa durch die Befehle »Copy Hires To Sprite, Copy Sprite To Hires«. Zeitlupengrafiken und Bewegungsstudien wie etwa der Flug eines Vogels, werden innerhalb weniger Minuten zur Realität. Wesentlich unterstützt wird der Programmierer bei seinen Entwürfen durch wichtige Befehle wie »Dot, Line, Box, Circle« und andere bekannte Grafikhilfen.

Weil die Programmierer bei HESware mit Vorliebe die Interrupttechnik verwendet haben, lassen sich Text und Grafik beliebig mischen. Zusammen mit der umfangreichen Farbgebung sind so Bilder auf der Diskette speicherbar und stehen bei Bedarf, beispielsweise in einem Adventure, rasch zur Verfügung.

Fast ebenso umfangreich wie der Befehlssatz für die Sprite-Programmierung sind die neuen Kommandos zur Tonerzeugung. Alle Musikfunktionen werden wie die Sprites interruptgesteuert. Man kann sich sogar beim Programmieren mit Musik unterhalten lassen. Alle wichtigen Parameter wie Attack, Sustain, Release, Decay und Wellenform werden über simple Basic-Befehle eingestellt.

Nach all diesen Erläuterungen entsteht vielleicht der Eindruck, bei »Graphic-Basic« handle es sich um eine reine Grafikerweiterung. Weit gefehlt!. Es gibt Befehle zur Funktionstastenbelegung, ebenso wie solche zur Abfrage der Joysticks und zur Diskettenhandhabung (Dir, Disk). Auch über die typischen Befehle vieler Erweiterungen für bedingte Sprünge (If-Then-Else oder On-Error-Goto) verfügt die Hes-Grafik. Am ungewöhnlichsten ist aber der »Window«-Befehl, der es erlaubt, den Bildschirm in mehrere »Aktivitätszonen« zu unterteilen. Abschließend soll noch angemerkt werden, daß sowohl Text als auch Grafik auf verschiedenen Druckern (Copy) ausgegeben werden kann.

Wer die Grafik- und Tonprogrammierung zu seinem Lieblingsthema gewählt hat, aber auf den Komfort einiger Hilfen zur strukturierten Programmierung nicht verzichten möchte, findet in der Hes-Grafik den richtigen Partner. Für relativ wenig Geld erhält er ein Werkzeug, mit dem der eigenen Kreativität keine Grenzen mehr gesetzt sind. Für meinen C 64 ist »Graphic-Basic« jedenfalls zum gern gesehenen Prinzen geworden.

(Arnd Wängler/Martin Gaksch/ev)

# Oxford-Pascal für den Commodore

> Dieser leistungsfähige Compiler unterstützt den vollen Pascal-Standard — und noch etwas mehr.

Schon der erste Blick in das Handbuch zeigt es: Oxford-Pascal ist im Wesentlichen das gute alte TCL-Pascal, das es auch schon für die CBM-Computer gibt.

Oxford-Pascal wird auf einer Diskette zusammen mit einem Handbuch in englischer Sprache geliefert (eine Kassettenversion soll demnächst folgen). Der Text des Handbuches sowie die abgedruckten Beispielprogramme sind überwiegend wörtlich vom TCL-Pascal übernommen. Neu am Oxford-Pascal sind Erweiterungen für Grafik, Ton und Farbe speziell für den C 64.

Nach einem recht langen Ladevorgang meldet sich das System schließlich mit einem »READY«. Oxford-Pascal ist im Gegensatz zum UCSD-Pascal nicht menügesteuert, was in meinen Augen insbesondere für den Computeranfänger ein wesentlicher Vorteil ist.

Auf Nachfrage teilt das System mit, daß etwa 13 KByte freier Speicherplatz zur Verfügung steht. Das ist beachtlich: TCL-Pascal auf dem CBM 3032 bietet nur etwas mehr als 7 KByte an. Der Compiler und der Executer sind resident, es kann also gleich losgehen mit den ersten Gehversuchen. Programm eintippen (mit Zeilennummern, damit man leichter editieren kann), auf »L« tippen und sich das Programm langsam vorlesen lassen. Dabei findet eine Syntaxprüfung und eine Compilierung in den P-Code statt. Mit »RUN« kann dann gestartet werden. Währenddessen findet kein Rückgriff auf die Floppy statt, dadurch ist das System relativ schnell. Sollte ein Fehler im Programm sein, wird eine Fehlermeldung mit Nummer und Klartext eingefügt. Die Eingabe von »P« statt »L« bringt Listing und Fehlermeldungen auf den Drucker. Editierkommandos wie CHANGE, FIND und DELETE vereinfachen Fehlersuche und Programmänderungen.

Leider vermißt man eine DOS-Unterstützung. Das Inhaltsverzeichnis ist nur mit »LOAD”$”,8« zu erreichen, dabei geht ein eventuell im Speicher vorhandenes Programm, das nicht vorher mit PUT auf der Diskette abgespeichert wurde, verloren.

Was tut man jetzt, wenn 13 KByte nicht ausreichen? Oxford-Pascal bietet die Möglichkeit, den residenten Compiler aufzugeben. Damit stehen dann etwa 32 KByte nur für den Programmquelltext zur Verfügung. Das Programm muß nach Fertigstellung abgespeichert werden, dann wird mit »COMP« der Diskcompiler aufgerufen, der ein Object-File erstellt, das mit »EX« ausgeführt werden kann. Diese Prozedur ist typisch englisch: Teatime ist angesagt. Die Zeit ist ausreichend. Interessanterweise ist der P-Code von TCL-Pascal mit dem von Oxford-Pascal aufwärtskompatibel. Ich konnte mein Stundenplanprogramm, das vom CBM 3032 compiliert wurde, sofort auf dem C 64 laufen lassen.

Die Abwärtskompatibilität ist natürlich nicht gewährleistet. Mit einigen Spezialitäten wurde den Möglichkeiten des Commodore 64 Rechnung getragen. Mit BORDER wird die Rahmenfarbe definiert, mit SCREEN die Bildschirmfarbe, mit PEN die Schreibfarbe. PAPER und INC setzen die Farben für die hochauflösende Grafik (der Multicolormodus wird nicht unterstützt), HIRES (1) schaltet die Grafik ein, HIRES (0) führt in den Textmodus zurück. WINDOW teilt den Bildschirm in einen Grafik- und einen Textteil ein. EXAMINE (X,Y) dient zum Testen, ob der Punkt (x,y) gesetzt ist. Für alles weitere ist der PLOT-Befehl zuständig. PLOT (F,Xl,Yl,X2,Y2) hat in Abhängigkeit von F folgende Aufgaben:

Ist F=0, so wird der Hintergrund auf die PAPER-Farbe gesetzt, ist F=1, so wird die Grafik gelöscht, ist F = 2, so wird eine Linie von (X1,Y1) nach (X2,Y2) gezeichnet, ist F = 3, so wird diese Linie gelöscht, ist F=4, so wird das Gebiet um (X1,Y1) gefüllt, ist F = 5, so wird dieses Gebiet gelöscht.

Für das vollständige Löschen der Grafik ist also die Anweisungssequenz PLOT (0,0,0,0,0); PLOT (1,0,0,0,0) notwendig. Man beachte, daß von den neun Nullen acht lediglich aus formalen Gründen angegeben werden müssen. Der Pascalästhetiker wird dabei ein ungutes Gefühl haben. Durch den gewiß lobenswerten Versuch, die Anzahl der Spezialitäten gering zu halten, leidet die Selbstdokumentation doch erheblich.

Immerhin braucht sich der Programmierer nicht so viele neue Vokabeln zu merken. Es ist möglich, im PLOT-Befehl x-Werte zwischen 0 und 255 sowie y-Werte zwischen 0 und 199 anzugeben. Da der Bildschirm aber 320 Pixel breit ist, bleibt rechts ein Streifen, auf den man nicht zugreifen kann.

Falls eine Darstellung von Text und Grafik gleichzeitig gewünscht wird (ein Einblenden von Buchstaben in die Grafik ist nicht vorgesehen), so wird man mit dem WINDOW-Kommando, so nützlich es auch ist, nicht so ganz glücklich. Da die Umsteuerung des Bildschirms durch den Interrupt erfolgt, flackert er bei Diskettenzugriffen erheblich.

So mager und ungeschickt die Grafik auch ausgestattet ist, so vollständig ist der von Wirth geforderte Sprachumfang. Man wird nichts vermissen. Hier zeigt sich die Abstammung vom TCL-Pascal mit allen Vorteilen. Erwähnenswert ist auch, daß einige der von mir im Artikel »Für Schulen gerade richtig« (Computerjournal Januar/Februar 1983) monierten Fehler beseitigt sind. File-Identifier können jetzt als VAR-Parameter an Prozeduren und Funktionen übergeben werden (übrigens: im Apple-UCSD-Pascal geht das nicht einmal mit Funktionsnamen und trotzdem gibt es Schulen, die es im Unterricht verwenden), und Mengen, die Bestandteile eines Records sind, werden jetzt unter der WITH-Anweisung korrekt bearbeitet. Vermutlich hat es schon TCL-Versionen gegeben, die diese Fehler nicht mehr hatten, und dies wurde einfach übernommen.

Zusammenfassend muß festgestellt werden, daß man hier für 199 Mark ein vollwertiges Pascal-System in der Hand hat, das sowohl dem Lernenden als auch dem Anwender sehr viel zu bieten hat.

(Norbert Stüven/ev)

Info: Vertrieb in Deutschland durch Computer Plus Soft GmbH, Bahnstr. 22-26, 4220 Dinslaken

# Die Turbo-Pascal-Story

> Das Super-Pascal aus der Welt der CP/M- und MS-DOS-Personal Computer ist jetzt auch für den C 64 erhältlich — das CP/M-Modul macht’s möglich.

Um Turbo Pascal auf dem C 64 nutzen zu können, sind Floppy-Laufwerk und CP/M-Modul notwendige Voraussetzungen. Zum optimalen Betrieb sollten Grundkenntnisse von CP/M-80, der Sprache Pascal und etwas Z80-Maschinensprache hinzukommen. Benutzt man einen Drucker mit Centronics-Schnittstelle, sollte man das Betriebssystem des C 64 und 6502 Maschinensprache kennen, denn mit den Interfaces, die Treibersoftware im Bereich C000 — CFFF<sub>16</sub> bereithalten, könnte man Überraschungen erleben.

## Die Lieferung

Die Sendung von Heimsoeth Software, München, zum Preis von 225,72 Mark, enthält die Diskette und ein Handbuch in englischer Sprache von etwa 300 Seiten Umfang. Das Handbuch versteht sich nicht als Einführung in Pascal, sondern beschreibt in drei Teilen den Gebrauch des Turbo Systems, die Besonderheiten für einzelne Betriebssysteme wie CP/M-80 und 86 sowie MS/PC-DOS, die Sprachelemente (Syntax) von Turbo Pascal. Den Schluß bilden recht brauchbare Übersichten zum Pascal, zum Compiler und den Fehlermeldungen. Die Diskette enthält die Files

- **TURBO.COM**, also den eigentlichen Pascal-Compiler, der laut STAT-Meldung etwa 31 KByte belegt,
- **TURBO.OVR**, eine Routine, die Programmoverlaying im CP/M ermöglicht. Damit können auch Programme, die mehr als den zur Verfügung stehenden Speicherplatz (zwischen 6100 und 11600 Byte je nach Konfiguration) benötigen, gefahren werden.
- **TURBO.MSG** ist ein Textfile, das die 100 Fehlermeldungen im englischen Wortlaut enthält. TURBO.MSG kann beim Initialisieren wahlweise hinzugeladen werden und belegt dann etwa 1400 Byte. Wer will, kann sich alle Fehlermeldungen ins Deutsche umschreiben. Ohne TURBO.MSG werden nur die Nummern der Fehler nach dem Compilieren angegeben. Ihre Bedeutung schaut man dann im Handbuch nach. Leider habe ich noch keine Möglichkeit gefunden, TURBO.MSG zwischenzeitlich nachzuladen. Man muß TUR-BO.COM erst mit Q verlassen und dann mit »TURBO« neu laden.
- **TLIST.COM** ist eine Druckerroutine, die es nicht nur ermöglicht, Pascal-Quellcode mit vorgestellten Zeilennummern auszudrucken, sondern auch Pascal-Schlüsselwörter durch Unterstreichen zu markieren.
- **READ.ME** gibt eine Erklärung darüber, warum Run-Time-Fehler in Overlay-Programmen nur schwer zu lokalisieren sind, falls die Overlay-Area mehr als ein Programm enthält. Die beiden Programme TINST.COM und CALC.PAS, die man auf Lieferungen für andere CP/M-Versionen (zum Beispiel Osborne und TA) findet, waren nicht vorhanden. Ich erkläre mir dies damit, daß das Demoprogramm zur Tabellenkalkulation nicht in den Speicher des C 64 paßt und das Tastatur-Installationsprogramm sich für die auf den C 64 zugeschnittene Version von selbst erübrigt.

## Starten des Systems

Wer liest sich, wenn er Software erhält, schon ein ganzes Handbuch durch, um danach erst in die Praxis einzusteigen? Also schob ich nach einem Blick auf die ersten paar Seiten des Handbuches mein CP/M-Modul ein, legte die CP/M-Arbeitsdiskette ins Laufwerk und zählte nach »LOAD ”CPM”, 8« und »RUN« die 28 Sternchen, bis sich CP/M meldet. Dies dauert in der Regel etwa eine Minute, kann aber auch mal ins Auge gehen, je nachdem wie sorgfältig das Modul eingesteckt wird. Nach Meldung des CP/M stieg die Spannung, denn ich legte die Turbo-Diskette ein und tippte, da Turbo Pascal als CP/M-Kommando gestartet wird, einfach TURBO ein. Mit Freude stellte ich fest, daß sich das Laufwerk in Bewegung setzte. Meine Freude wurde etwas getrübt, dauerte der Ladevorgang doch fast 2 Minuten (genauer 106 Sekunden). Damit verbraucht das Hochfahren des Systems also insgesamt fast 3 Minuten. Dies liegt jedoch nicht am CP/M, sondern am langsamen Arbeiten des 1541-Laufwerks. Immerhin wurde mein Warten mit einer recht klaren Turbo-Meldung begrüßt, wobei die gelbe Schrift auf schwarzem Hintergrund sich wohltuend gegenüber dem Commodore-Blau abhob.

Nun mußte wieder das Handbuch zu Rate gezogen werden, denn mit einer simplen Meldung wollte ich mich nicht begnügen. Zumindest ein kleines Programm sollte laufen. Also wurde nach Eingabe von »N« (keine Fehlermeldung im Wortlaut) mit »W« eine Arbeitsdatei (Workfile) angelegt. Dabei muß man zunächst den Namen angeben. Will man eine bereits existierende Datei bearbeiten, so wird diese jetzt geladen. »DIR« zeigt das Inhaltsverzeichnis der Diskette. Da noch kein .PAS-File existierte, erklärte die Meldung »NEW FILE«, daß nun eine neue Arbeitsdatei eingerichtet wird. Nach Eingabe von »E« meldete sich ein auf den ersten Blick recht komfortabler Editor, der eine Teilmenge der Wordstar-Befehle bereithält und 80 Zeichen pro Zeile unterstützt. Leider wurde die Repeat-Funktion für die Corsorbewegungen vergessen. Was mich zuerst sehr erschreckte, als ich daran ging zwei Tippfehler meines ersten eingetippten Programms auszumerzen, war die Tatsache, daß der Cursor alle Zeichen löschte, die er überstrich. War damit meine ganze Eingabe umsonst? Konnte man mit Turbo auf dem C 64 gar nicht arbeiten? Verwundert hätte mich das nicht, denn bisher findet man ja nur ganz wenig CP/M-Software, die an das eigenwillige CP/M des C 64 zufriedenstellend angepaßt ist. Im ersten Moment war ich ratlos und las wieder Seite um Seite im Handbuch. Doch dies ist allgemein gehalten und kann, will es nicht zu einer Enzyklopädie ausarten, nicht auf alle CP/M-fähigen Computer eingehen.

Also raus aus dem Editor mit CTRL K, CTRL D und mit E wieder hinein, um mein Glück aufs Neue zu probieren. Aber, welche Freude! Da stand mein Programm TEST1, so wie ich es eingegeben hatte.

Nun war die Sache wohl klar: Beim Schreiben des Editors hat man vermutlich vergessen, die Routine BASIN des C 64-Betriebssystems sorgfältig umzuschreiben. Deshalb wird an der Stelle, wo die Farbinformation des Zeichens unter dem Cursor ins Farb-RAM geschrieben wird (also im Bereich $E45F-$EB7F), genau dies einfach vergessen.

Da ich eine sehr »frische« Disk der Version 2.0 A vorliegen hatte, dürfte dieser vom Prinzip her kleine, in der Wirkung aber störende Fehler, in nächster Zeit behoben sein. Das dem so ist, sicherte auch die Münchener Vertriebsfirma telefonisch zu. Eine Weile wird man dennoch warten müssen, denn Kalifornien ist immer noch weit und bis die Eingaben aus der »Provinz BRD« berücksichtigt werden, wird einige Zeit ins Land gegangen sein.

Turbo Pascal lehnt sich eng an den durch Jensen und Wirth festgelegten Pascal-Standard an. Folgende Unterschiede, die wohl nur den eingefleischten »Wirth Pascaler« tiefer berühren werden, sind zu vermerken:

- Der Programmkopf ist optional gestaltbar.
- Im Deklarationsteil muß die Reihenfolge und Anzahl der Vereinbarungen nicht sklavisch eingehalten werden.
- Als Label können Zahlen und Namen dienen.
- Die verpönte GOTO-Anweisung darf nur im laufenden Block verwendet werden.
- Das »Packen« insgesamt fehlt, da der Turbo-Compiler ohnehin einen sehr dichten Code generiert. Während PACKED nichts bewirkt, rufen die Prozeduren PACK und UNPACK eine Fehlermeldung hervor.
- Wie in vielen anderen Versionen sind auch Funktionen und Prozeduren als Parameter nicht zugelassen.

Hält nun der Name Turbo das, was er verspricht? Diese Frage kann man in zweierlei Hinsicht guten Gewissens bejahen: Einerseits ist die Compilierzeit auf Grund des RAM-residenten Compilers erheblich schneller als bei anderen, vergleichbaren Pascal-Systemen. So ist der Turbo-Compiler bis zu zehnmal schneller als der 2-Pass-Compiler des Apple-UCSD-Systems. Aber auch die Abarbeitung von Programmen ist auf Grund der Tatsache, daß der Turbo-Compiler nicht nur 8080-Code generiert, sondern auch die vielen zusätzlichen, leistungsfähigen Befehle des Z80 optimal nutzt, meist schneller als bei vergleichbaren Systemen. Daß dabei natürlich der mit nur 2 MHz betriebene Z80 des C 64 langsamer ist als der mit 4 MHz betriebene Z80 anderer CP/M-Computer, liegt auf der Hand.

Wenn man nun in Pascal arbeitet und das 1541-Laufwerk mal nicht benutzt, kann man manchmal vergessen, daß man eigentlich vor einem Computer der unteren Preisklasse sitzt. Dieses Gefühl, vor einem wesentlich teureren Gerät zu sitzen, wird durch die elfstellige Rechengenauigkeit nur noch bestärkt. So ergibt 1.0000001 27mal mit sich selbst quadriert, immerhin noch den Wert 674423,34803. Dies entspricht einem Fehler von 0,016 Prozent im Vergleich zum 15stelligen Wert von 674530,470741078 einer CDC-Cyber-Anlage(Die Fehlerquote bei Basic liegt bei über 100 Prozent!). Welches andere Pascal rechnet dazu die ersten 1000 Primzahlen in knapp 3 Sekunden aus?

Neben dem Vorzug effizienter Compilierung und hoher Ausführgeschwindigkeit, bietet Turbo Pascal selbstverständlich auch nützliche Erweiterungen an, die über das Standard-Pascal hinausgehen. Dabei erkennt man schon vom Handbuch her die Vorzugsstellung von IBM; denn für den IBM und Kompatible finden sich zusätzlich Grafik- und Soundbefehle als »IBM-Goodies«. Vielleicht wird man in Turbo auch mal »C 64 Goodies« finden, falls der Hersteller Borland International den C 64-Markt und die C 64-Benutzer Borland entdecken.

Um den Rahmen nicht ganz zu sprengen, seien hier nur einige Erweiterungen knapp skizziert:

- Strings sind voll implementiert. Dazu kommen acht Funktionen/Prozeduren, die den Umgang mit Strings erleichtern.
- Eine Gruppe von Funktionen unterstützt den direkten Zugriff auf absolute Speicheradressen ähnlich PEEK, POKE und VARPTR.
- Durch das Schlüsselwort EXTERNAL werden externe Unterprogramme (speziell in Maschinensprache) in das laufende Programm eingebunden. Analog ist es möglich, durch das Schlüsselwort INLINE Maschinenprogramme im Z80-Code direkt als Prozeduren in Pascal-Programme zu schreiben.
- Dazu bietet der Compiler zehn Direktanweisungen. Die Compileroption C beispielsweise wandelt Pascal-Programme in CP/M 80-Befehle um. Diese neuen CP/M-Kommandos in Verbindung mit dem SUBMIT, besser noch mit XSUBMIT des CP/M, öffnen die Türe weit, um auch komplexe Probleme elegant und übersichtlich zu lösen.

Abgesehen von einzelnen behebbaren Mängeln ist Turbo Pascal die ideale Erweiterung und Ergänzung zum CP/M-Modul des C 64. Durch das langsame Diskettenlaufwerk ist jedoch am kommerziellen Einsatz primär nicht zu denken.

Wo das C 64/Turbo-Pascal-System jedoch optimal hingehören könnte, ist der gesamte Komplex der Aus-Fort- und Weiterbildung, sei es im privaten Bereich, wo man ein preiswertes und schnelles Pascal-System sucht, oder im öffentlichen Bildungsbereich.

Mit dem schnellen Compiler entstehen keine Geduldsproben durch einen stundenlagen Kampf gegen Tippfehler. Syntax- wie Laufzeitfehler werden rasch entdeckt, denn hat der Compiler einen Fehler gemeldet, so wird nach dem Drücken der CLR/HOME-Taste das Programm im Editor gelistet, und der Cursor steht an der Fehlerstelle.

Wenn jetzt die Stunde genutzt wird, können der C 64 und Turbo-Pascal eine für alle Beteiligten gewinnbringende Ehe eingehen. Was im Moment noch fehlt, ist eine deutsche Einführung in das Turbo-System, unter Berücksichtigung der Eigenheiten des C 64. Sonst stehen wirklich alle Möglichkeiten offen. Denn wo ist ein anderes System, das zu einem Preis von etwa 2 500 Mark nicht nur Drucker, Laufwerk und Zentraleinheit bereithält und eine Einführung in das weitverbreitete Betriebssystem CP/M-80 gestattet, sondern auch darüber hinaus eine der modernsten Sprachen, nämlich Pascal, mit allen Möglichkeiten der modularen Top-Down-Programmierung (weshalb Pascal in einzelnen Bundesländern als verpflichtend für den Informatikunterricht der S II gilt) ohne Abstriche und Einschränkungen zur Verfügung stellt? Hier ist eine große Chance, entweder für Commodore oder auch für andere Hersteller, das leider zu früh »gestorbene« CP/M-Modul für den C 64 wieder zum Leben zu erwecken.

(Hans-Ulrich Korzilius/ev)

Vertrieb für Deutschland, Heimsoeth-Software, Frauenhoferstr. 13, 8000 München 5, 0 89-26 40 60

# Was bringt die Lern-Software?

> Das Leben ist voller Entscheidungen. So muß mancher Schüler darüber nachdenken, ob er den Nachmittag mit Lernen oder mit seinem Computer verbringt. Warum nicht beides miteinander verbinden?

Ist erst einmal ein Computer im Haus, dann bleibt das Lernen meist auf der Strecke. Fallen die Schulnoten in den Keller, muß ein Nachhilfelehrer her. Dieser kostet dann zwischen zwanzig und dreißig Mark pro Stunde, wenn nicht sogar mehr. Doch was soll man machen?

Ob Lernsoftware einen Nachhilfelehrer ersetzen kann, ist wohl von Fall zu Fall unterschiedlich. Die besseren Programme dürften aber zumindest in diese Richtung gehen.

Schenkt man der Werbung oder der Verpackung Glauben, so ist jedes Programm das »non plus ultra«. Wirft man dann einen Blick hinter die Kulissen, kann man von der einfachsten Programmierung bis hin zu gut durchdachten Programmen alles entdecken.

Besorgte Eltern, die ihren Kindern Lernprogramme kaufen wollen, stehen oft auf verlorenem Posten. Meist fehlt die Sachkenntnis zu dem Lehrstoff, zum anderen sehen viele Programme auf dem Bildschirm interessanter aus, als sie eigentlich sind. Und wer wollte schon den pädagogischen Nutzen anhand einer kurzen Vorführung beurteilen?

Deshalb beginnt das 64’er Magazin ab dieser Ausgabe mit einer Serie, die sich mit Lernsoftware beschäftigt. Sie soll zeigen, welche Programme qualitativ das halten, was sie versprechen, und an welche Anwendergruppen sie sich richten.

(rg)

# Melodienschreiber und Musik-Synthesizer

> Melodienschreiber und Musik-Synthesizer sollen Lernprogramme für den angehenden Musiker sein. Lohnt es sich, Gitarren oder Geigenunterricht dafür aufzugeben?

Das Programm »Musik-Synthesizer« gibt es in je einer Version für das Commodore Basic V.2.0und Simons Basic. Ist das Programm geladen, erscheint bei der Simons Basic-Version nach Nennung des Autors das einzige Bild des Programms (Bild 1).

Trotz einiger Ungenauigkeiten des Handbuches lassen sich bei intensiver Lektüre interessante Tonzusammenstellungen erzeugen. Ein lästiger Nachteil: Zur Einstellung und Erzeugung von Tönen muß man immer eine der drei Kontrolltasten bedienen.

Das Programm erlaubt, durch Drücken einer Taste (plus Kontrolltaste) die Hüllkurven der drei verfügbaren Stimmen zu verändern. Dabei kann man Attack, Decay, Sustain und Relase ändern. Dies wird auch grafisch angezeigt. Weiterhin hat man die Auswahl zwischen Rechteck-, Sägezahn- und Dreieckswellenform sowie Rauschen. Man kann eine Ringmodulation und Synchronisation zuschalten, um andere Stimmen zu beeinflussen.

Zur Änderung der Oktaven stehen zwei Tasten zur Verfügung, wobei die oberste Oktave nicht über die ganze Tastatur reicht.

Eine weitere Möglichkeit bietet ein zuschaltbarer Filter, den man als Hochpaß, Bandpaß und/oder Tiefpaßfilter schalten kann. Das mehrstimmige Spielen von Tönen beschränkt sich auf das Spielen eines Tons mit maximal drei Schwingungsformen. Die Version in Basic V.2.0 ist bis auf die Grafik mit der Simons Basic-Version identisch.

Das Programm unterstützt das Musikverständnis und erfüllt damit die gestellte Aufgabe, aber es gibt mittlerweile weitaus bessere Synthesizer und Musikprogramme.

Das Programm Melodienschreiber läuft nur mit Simons Basic. Für jemanden mit wenig Erfahrung in der Musiklehre ist das Programm fast ungeeignet. Das Handbuch setzt ein recht großes Grundwissen voraus.

Es beginnt mit dem Thema, das eigentlich an den Schluß gehört: Mit dem Ändern der Melodie. Es sollte deshalb gleich zu Punkt 3 übergegangen werden. Dort werden die Eingabemöglichkeiten einer Melodie erklärt. Dabei stehen drei Arten zur Auswahl. Bei der manuellen Eingabe zeigt das Menü die Töne und die Tonlänge an. Die Eingaben erfolgen alle durch Input-Befehle. Die zweite Variante benutzt die beiden oberen Tastenreihen als Klaviertastatur. Im Hintergrund ist ein Metronom zu hören. Wählt man diese Eingabeart, sollte man ein wenig Klavier spielen können.

Die letzte Funktion erlaubt, das Tempo selbst zu bestimmen. Die Eingabe wird wie gewohnt gehandhabt. Nach jeder Eingabe erscheint ein Notenbild, bei dem man eventuelle Fehlinterpretationen des Computers erkennen kann.

Auch dieses Programm hat seine Grenzen. Bei mehr als 200 Einzeltönen wird die Zeitspanne zum Auffinden der Daten zu groß. Um trotzdem mehr Töne einzugeben muß die Basic-Zeile 7 geändert werden.

Dieses Programm ist für den Hobby-Musiker sicher eine feine Sache, doch als Lernprogramm erscheint es ungeeignet. Besonders die mangelhaften »Handbücher« fallen dabei schwer ins Gewicht.

(Sven Seynsche/rg)

# So macht man Basic-Programme schneller – Teil 2

> Diesmal wollen wir den Basic-Programmen, was die Geschwindigkeit anbelangt, mit einem Ausflug in die Assemblerprogrammierung, auf die Sprünge helfen.

Hier soll Ihnen kein Maschinensprache-Kurs zugemutet werden. Doch ein Programm in Maschinensprache besteht genauso aus Befehlen, Adressen und Variablen, wie ein Basic-Programm, nur sind sie in einem speziellen Zahlencode geschrieben. Dieser Zahlencode muß in den Arbeitsspeicher geladen werden. Die für uns einfachste Möglichkeit besteht darin, die Zahlen in den Speicher hineinzuPOKEn. Damit wir aber nicht unmäßig viele POKE-Befehle schreiben müssen, legen wir alle Code-Zahlen hinter DATA-Befehle und holen sie dann mit READ in eine einzige POKE-Schleife. Ich sage das deswegen, weil dieses Einlesen natürlich nicht zu dem Testprogramm gehören darf, dessen Laufzeit wir messen wollen. Das Testprogramm selbst sitzt zwischen den drei Zeilen der »Stoppuhr«. Das heißt, genauer gesagt sitzt das Programm in den Speicherzellen, in die wir es hinein-POKEn. Aber zwischen der Stoppuhr rufen wir es auf, der dem RUN entsprechende Befehl bei Maschinensprache heißt SYS.

Wie Sie gleich noch sehen werden fängt unser Testprogramm ab Speicherzelle 7168 an. Das Ganze sieht dann so aus:
10 TI$ = "000000"
20 PRINT CHR$ (147)
30 SYS 7168
1000 POKE 214,18:PRINT:PRINT TI/60 ”SEKUNDEN”:END

Ab Zeile 2000 setzen wir jetzt das Programm, welches uns das Maschinenprogramm einliest. Um mit dem Einlesen zu beginnen, setzen wir noch eine Umleitung vor das Meßprogramm:
5 GOTO 2000

In Zeile 2000 löschen wir den Bildschirm. Zeile 2010 und 2020 und 2030 liest die Codezahlen, die von Zeile 2050 bis 2090 stehen, und POKEt sie in die Speicherplätze 7168 bis 7200.

Die Codezahlen sind für beide Computer fast identisch, nur die Adressen sind verschieden. Deshalb sind Zeile 2060 und 2080 beim C 64 anders als beim VC 20.

Sobald die Zahlen eingelesen sind, können Sie das Meßprogramm mit dem Befehl GOTO 10 (direkt eingetippt) starten.

Im Abdruck unten wird das etwas eleganter gemacht. Zuerst meldet das Programm das Ende des Einlesens (Zeile 2100 und 2101). Dann kommt die Anweisung, wie das Meßprogramm zu starten ist, nämlich durch Drücken irgendeiner Taste, die durch eine GET-Schleife abgefragt wird. Wenn eine Taste gedrückt wird, springt das Programm auf Zeile 10 (das geschieht in Zeile 2160).
5 GOTO 2000
10 TI$ = "000000"
20 PRINT CHR$(147)
30 SYS 7168
1000 POKE 214,18:PRINT:PRINT TI/60 ”SEKUNDEN”:END
2000 PRINT CHR$(147)
2010 FOR A = 7168 TO 7200
2020 READ B
2030 POKE A,B
2040 NEXT
2050 DATA 162,0,169,1,157
2060 DATA 0,30,169,6,157,0,150
(2060 DATA 0,4,169,14,157,0,216)
2070 DATA 232,224,0,208,241,169,1,157
2080 DATA 254,30,169,6,157,254,150
(2080 DATA 254,4,169,14,157,254,216)
2090 DATA 232,224,120,208,241,96
2100 PRINT"DAS MASCHINENPROGRAMM"
2110 PRINT"IST JETZT EINGELE-SEN.":PRINT
2120 PRINT"ZUM STARTEN DES PRO-"
2130 PRINT"GRAMMS "CHR$(18) "TASTE"CHR$(146)"DRUECKEN"
2140 GET A$
2150 IF A$ = ""THEN 2140
2160 GOTO 10

So, inzwischen haben Sie sicher Ihre Überraschung gehabt! 0,066 Sekunden Laufzeit beim C 64 und 0,033 beim VC 20.

Ich hoffe, daß ich Sie mit dem Virus der Maschinensprache infiziert habe.

Wir wollen im Folgenden ein paar arithmetische Funktionen untersuchen und beschleunigen. Als erste nehmen wir uns in Version 17 die Multiplikation vor. Die Messung der Laufzeit erfolgt auf dieselbe Weise wie bei allen Programmen vorher auch. Deshalb bleiben die Zeilen 10, 20 und 1000 gleich. Die Multiplikation selbst soll 300 mal ausgeführt werden (Zeile 30). Dann wird das Ergebnis gedruckt (Zeile 60).
30 FORZ = 1 TO 300
50 NEXT
60 PRINT A

Als Multiplikation nehmen wir den Extremfall einer kurzen Zahl multipliziert mit einer langen.
40 A = 3*0,123456789

Nach RUN bleibt der Bildschirm zuerst leer, bis dann nach 11,85 (14, 15) Sekunden das Ergebnis der Multiplikation und die Laufzeit ausgedruckt wird.

In **Version 18** vertauschen wir die beiden Zahlen, die in Zeile 40 multipliziert werden.
40 A = 0.123456789*3

Diese einfache Manipulation bringt natürlich nach Adam Riese dasselbe Resultat wie vorher, aber die Laufzeit ist kürzer. Wir gewinnen beim VC 20 0,37 Sekunden, beim C 64 0,44 Sekunden. Dieser Gewinn ist nicht überwältigend, aber überraschend. Aber denken Sie nach!

Wie ist das, wenn Sie so eine Multiplikation auf dem Papier durchführen? Da ist die Rechnung im zweiten Fall auch einfacher. Der Computer hat genau dasselbe Problem.

In **Version 19** nützen wir noch eine kleine Eigenheit der Commodore-Computer aus, die auf ihre amerikanische Herkunft zurückzuführen ist. Bei den Angelsachsen ist es nämlich erlaubt, eine Null vor dem Dezimalpunkt wegzulassen. Beim Computer dürfen wir das auch. Obwohl das mit der Multiplikatikon direkt nichts zu tun hat, bietet sie uns doch eine gute Gelegenheit, die Einsparung durch das Weglassen der Null auch zeitlich zu messen. Also, Zeile 40 sieht jetzt so aus:
40A = .123456789*3

Das bringt nicht sehr viel, 0,17 Sekunden beim VC 20, 0,20 Sekunden beim C 64. Aber Kleinvieh macht auch Mist.

Eine ähnliche Verbesserung, die wir hier nicht ausprobieren, wird erzielt durch den Ersatz einer alleinstehenden Null durch einen Punkt, zum Beispiel:
statt IF X = 0 THEN –
jetzt IF x = . THEN –

Eine gewaltige Beschleunigung erfährt das Multiplikationsbeispiel, wenn wir die Regel 1 anwenden und die Variablen vordefinieren.

Regel 7
★ Bei einer Multiplikation soll die längere Zahl vor der kürzeren stehen (langer Multiplikant, kurzer Multiplikator).
★ Eine einzelne Null wird durch einen Punkt ersetzt, eine Null vor dem Dezimalpunkt wird weggelassen.

In **Version 20** ersetzen wir in Zeile 40 beide Zahlen durch Buchstaben, die wir in einer neuen Zeile 25 diese Werte zuweisen.
25 B = .123456789:C = 3
40 A = B*C

Dieser Lauf bleibt nach 1,23 (1,48) Sekunden stehen, das heißt wir gewinnen 10,25 (12,23) Sekunden (von 11,48!). Also bitte Regel 1 unbedingt beachten!

Eine andere betrachtenswerte arithmetische Funktion ist das »Potenzieren« (Quadrat-/Kubikzahlen), ausgelöst durch das Zeichen 1. Version 21 erzielen wir durch Löschen der Zeile 25 und Abänderung der Zeile 40:
40 A= 4 ↑ 3
»Vier hoch drei« ergibt 64 und braucht 8,81 (10,53) Sekunden.

In **Version 22** wollen wir sehen, ob vordefinierte Variable auch so einschlagen, wie bei der Multiplikation.
25 B = 4:C = 3
40 A = B↑C

Man kann sich doch auf nichts verlassen! Diesmal sind wir nur um 0,18 (0,22) Sekunden schneller. Wir dürfen aber nicht aufgeben. Version 23 macht alles wieder wett und zwar durch den simplen Trick, daß wir das Potenzieren in seine Grundelemente zerlegen.

Sie wissen doch: 4 hoch 3 (413) ist dasselbe wie »4 zweimal mit sich selbst multipliziert« (4*4*4).
25 B = 4 (C entfällt)
40 A = B*B*B

Ja, da schauen Sie, gell? Beim VC 20 braucht das Programm nur 1,68, also fast 7 Sekunden weniger. Beim C 64 sind es 8,31 Sekunden, die wir sparen.

Regel 8
Die Funktion Potenzieren (t) soll durch Mehrfach-Multiplikation ersetzt werden.

Als letztes Objekt möchte ich oft aufgerufene Unterprogramme messen. Wir erreichen das ganz einfach dadurch, daß wir das letzte Programm (Version 23) abändern. So erhalten wir **Version 24**: Die Definition der Variablen(Zeile 25) und die Multiplikation (Zeile 40) verbannen wir als Unterprogramm an das Ende des Programms und springen innerhalb der 300fachen Schleife mit GOTO darauf.
25 löschen; 30 FOR Z = 1 TO 300; 40 GOTO 40000

Alles andere bleibt, aber neu kommt dazu: 40000 B = 4; 50000 A = B*B*B; 60000 GOTO 50

Es ist nicht weiter erstaunlich, daß dieser Umbau diese Version 24 gegenüber Version 23 verlangsamt. Aber merken Sie sich die Laufzeit, VC 20: 2,75 Sekunden, C 64: 3,28 Sekunden. Als nächstes ersetzen wir die beiden GOTO-Zeilen durch GOSUB-RETURN.
40 GOSUB 40000
60000 RETURN

Diese **Version 25** spart uns 0,14 (0,15) Sekunden. GOSUB ist schneller als GOTO!

Sie haben vielleicht schon gelesen, daß oft gebrauchte Unterprogramme am Anfang eines Programms stehen sollen. Den Grund dafür will ich Ihnen mit den nächsten zwei Versionen vorführen.

**Version 26** macht das zunächst für die GOTO-Version. Wir bauen sie auf der Version 24 auf, mit folgenden Änderungen:

Die Zeitmessung lassen wir wie gehabt in den Zeilen 10, 20 und 1000, die Schleife und den Ausdruck des Resultats in den Zeilen 30, 50 und 60.

Nur beim Unterprogramm streichen wir alle Nullen der Zeilennummern, so daß es jetzt in den Zeilen 4, 5 und 6 steht. Um zu vermeiden, daß das Programm gleich mit dem Unterprogramm beginnt, fügen wir davor (Zeile 3) noch eine Umleitung ein, die sofort auf der Zeile 10 weitermacht. Schließlich brauchen wir noch den Sprung in das Unterprogramm, den wir in die Zeile 33 setzten. Das Ganze sieht jetzt so aus:
3 GOTO1O
4 B = 4
5 A = B*B*B*
6 GOTO 50
10 TI$ = "000000"
20 PRINT CHR$(147)
30 FORZ = 1 TO 300
33 GOTO 4
50 NEXT
60 PRINT A
1000 POKE 214,18:PRINT:PRINT TI/60 "SEKUNDEN":END

Nach RUN erhalten wir beim VC 20 2,6 Sekunden, beim C 64 3,1 Sekunden. Gegenüber Version 24, unserem Vergleichsobjekt, sparen wir 0,15 (0,18) Sekunden.

Dasselbe passiert, wenn wir in der **Version 27** die GOTOs mit GOSUB-RETURN ersetzen.
6 RETURN
33 GOSUB 4

Gegenüber der anderen GOSUB-Version (Version 25) sparen wir beim VC 20 0,13 Sekunden, beim C 64 0,17 Sekunden.

Regel 9
★ Der Aufruf von Unterprogrammen mit GOSUB ist schneller als mit GOTO.
★ Häufig gebrauchte Unterprogramme gehören ganz an den Anfang eines Programms. Sie müssen dann allerdings zuerst mit einem GOTO umgangen werden.

Ich bin überzeugt, daß in Basic noch mehr spektakuläre Zeitgewinne stecken.

Falls Sie eine REGEL 10 oder noch mehr entdecken, ermuntere ich Sie um Mitteilung.

Wenn Sie Fragen haben, können Sie mich mit einer Leserzuschrift ansprechen.

(Dr. Helmuth Hauck/aa)

Spiel des Jahres: Soccer II

> Viele Spiele wurden in der 64’er Redaktion angeschaut, gespielt, getestet. Eines fesselte uns immer wieder.

20.00 Uhr. Das Spitzenspiel »Bayern Albert« gegen »VC Volker 20« wird vom Schiedsrichter angepfiffen. Jetzt entscheidet sich, wer die Tabellenführung übernimmt. Anstoß von VC Volker. Langer Paß in die gegnerische Hälfte. Doch was ist das? Bayern Albert fängt den Ball ab, kontert, stürmt vor das Tor, schießt und ... der Torwart von VC Volker wirft sich in die falsche Ecke. 1:0.

Nach nervenaufreibenden drei Minuten der langerwartete Halbzeitpfiff.

Weitere drei Minuten später ist es entschieden. Die Legende um den in dieser Saison bisher ungeschlagenen »VC Volker 20« ist beendet. Der neue Tabellenführer »Bayern Albert« sitzt schweißgebadet auf seinem Stuhl und kann es noch gar nicht glauben. Es ist geschafft.

Die ersten Kommentare sind zu hören: Der Boden sei viel zu hart, der Rasen viel zu grün und das Bier für Trainer Volker viel zu warm ...

Oft trafen wir uns abends oder am Wochenende, um unsere Spieler über den Rasen laufen zu lassen. Die Soccer-Sucht hatte uns befallen.

Doch warum gerade dieses Spiel, und nicht »Summer Games«, »Pharaoh's Curse« oder eines der anderen aus der Vielzahl der Spiele für den C 64?

Soccer kann man alleine gegen den Computer oder gegen einen Partner spielen. Der Computer läßt sich auf neun Schwierigkeitsstufen einstellen. In Stufe 1 fällt es auch dem Anfänger nicht allzu schwer, den Computer zu besiegen. In der Stufe 9 muß man fast schon Profi-Kicker sein. Die Spiele gegen den Computer machen allerdings nicht halb soviel Spaß, als gegen einen zweiten Spieler.

## Andere Taktik bei jedem neuen Gegner

Hier treten die Qualitäten dieses Spieles erst richtig hervor. Einfach nur nach vorne schießen, nützt in den wenigsten Fällen. Man ist gezwungen, sich Taktiken zurechtzulegen, den Gegner zu berechnen und dies, mit dem Joystick auch noch umzusetzen. Wieviele verschiedene Tricks, den Ball zu spielen, zu schaffen sind, merkt man erst mit der wachsenden Anzahl der Spiele.

Die Fußballregeln beherrscht der Computer im allgemeinen recht gut. Die Abseitsregel wurde ignoriert, da es nicht möglich ist, ins Abseits zu gelangen. Auch Spieler mit Neigung zur Ruppigkeit haben keine Chance. Fouls sind einfach nicht vorgesehen. Mit dieser Regelung entfallen also Freistöße, Elfmeter, gelbe und rote Karten.

Soccer erschien schon 1983. Wieso wird dieses Spiel zum »Spiel des Jahres 1984« gewählt?

Da unser Preis in diesem Jahr zum ersten Mal vergeben wird, erschien es uns fair, auch die früher veröffentlichten Programme mit einzubeziehen. Unter allen Spielen, die uns in der Redaktion erreichten (und das waren sehr viele!), hatte fast jeder der Redakteure seinen Favoriten. Aber nur von Soccer waren alle begeistert. So wählten wir gemeinsam ein »altes« Spiel.

Zum Thema Fußball gehört eine Fußballmannschaft. Für einen Fototermin konnten wir den FC Bayern München gewinnen. Wie schon auf der »Systems ’83« wurde hierbei natürlich Soccer gespielt. Einstimmige Meinung: »Spitze«. Vielleicht wird Soccer in Zukunft sogar als Trainingshilfsmittel eingesetzt?

## Auch die Profis waren begeistert

Der C 64 war kaum aufgebaut, da saßen die ersten Bayern-Spieler auch schon davor, obwohl sie gerade erst vom Training kamen. Dieter Hoeness und Raimund Aumann waren die ersten, die sich einen Platz am Joystick sicherten. Der Pfiff des Computerschiedsrichters lockte dann immer mehr Spieler an. Selten wird in der Kabine Fußball gespielt, doch hier waren dann fast alle dabei. Nur Lothar Matthäus, der mit der Nationalmannschaft im Trainingslager war, verpaßte diese Gelegenheit. Aber vielleicht wird auch in der Nationalmannschaft schon mit Soccer taktiert und trainiert.

Jean Marie Pfaff erzählte, daß bei ihm zuhause der C 64 fast den ganzen Tag läuft. Wenn seine Kinder nicht davor sitzen, spielt auch er sehr gerne. Natürlich nicht nur Soccer.

Soccer wird von Commodore zu einem Preis von 59 Mark angeboten.

(rg)

# XQ 9

> QX 9 macht Schluß mit der plattgetretenen »Space-Invaders-Variante«.

Viele Computer-Fans sind es sicherlich leid, ständig neue Schießspiele, im altbekannten Invaders-Prinzip »vorgesetzt zu bekommen. Nur der Feind sieht anders aus, die Grundidee bleibt die gleiche. Für diejenigen, die dennoch mit Lasern und Photonen ihre Freizeit verbringen wollen, gibt es seit kurzem für den C 64 ein Spiel, das im Happy-Software-Verlag erschienen ist. Es heißt QX 9, und basiert auf dem »Ich-sitze-im-Raum-schiff-Prinzip«. Im Klartext heißt das: Der Monitor zeigt das Innere eines Raumschiffs mit Blick nach draußen. So sind bei QX 9 an beiden Seiten Instrumente angebracht, die zur Navigation des Schiffes nötig sind. OX 9 steht für ein Raumschiff im Weltraum, den eine Flotte feindlicher Raumschiffe bedroht. Letztere besteht aus einer Gruppe von Jägern und deren Mutterschiffe. Zwischen beiden schwebt ein Meteoritengürtel. Er trennt sie voneinander. Die Aufgabe des Spielers ist nun denkbar einfach: Weg damit, und zwar soviel wie möglich! Zunächst weckt das Spiel den Anschein, als könne man nie erlernen, seinen Kreuzer sicher durch das feindliche Abwehrfeuer zu steuern; doch dies vergeht mit der Zeit, und QX 9 entwickelt sich zu einem rasanten Actionspiel. Die Grafik schwebt in der Mittelklasse, dafür ist die Sounduntermalung um so besser. Da das Spiel erst mit der Zerstörung des Schiffs endet, werden einem High-Score keinerlei Grenzen gesetzt. Anders als die anderen "Star-Raiders«-Variaten kann man mit seinem Raumkreuzer auch auf dem Satelliten aufschlagen beziehungsweise bei der Landung abstürzen. Das jedoch wertet das Spiel nur auf, und formt das Endbild zu einer gelungenen Abwechslung in der Welt der Schießspiele. Preis: 48 Mark.

(Oliver v. Quadt/aa)

# Catastrophes

Die Grundidee ist endlich einmal nicht die eines »Miners« beziehungsweise die eines »Pac-Man«. Vielmehr geht es um ein waghalsiges Geschäft. Sie haben nämlich die Aufgabe, ein wind- und wetterfestes »Häuschen« zu bauen. Gleichzeitig müssen Sie ein bestimmtes Score-Limit erreichen und noch dazu möglichst den Gegner übertrumpfen. Nun, das ist jetzt ziemlich viel auf einmal. Zuerst jedoch zum Bildschirm: Zu erkennen sind nach der Einleitung eine schöne Meeresbucht, umgeben von hohen Bergen, ein zierlicher Leuchtturm, der später eine wichtige Rolle einnimmt, und zuletzt zwei recht unförmige, gebäudeähnliche Gebilde. Eines davon gehört Ihnen. Versuchen Sie nun, in sechs Tagen ein ansehnliches Hochhaus daraus zu machen. Steigen Sie in Ihren Hubschrauber, fliegen Sie damit zu einem Transportkutter, der geduldig am Bildrand wartet. Er hat je ein Fertigteil-Appartment geladen. Dieses muß jetzt von Ihnen zum Haus gebracht werden und schließlich richtig draufgesetzt werden. Unter »richtig« sei verstanden: hurricane-, erdbeben-, gewitter- und überschwemmungsfest! Eine gewiß nicht leichte Aufgabe, doch das ist der Reiz an dem Spiel. Nach jedem Tag (man sieht die Sonne richtig wandern) wird eine neue Mindestpunktzahl festgesetzt. Wird sie nicht erreicht, scheidet der Spieler aus.

Am Ende des sechsten Tages erscheint der »Daily Mirror«, der über den Erfolg des Bauvorhabens berichtet. Große Pluspunkte erzielt das Spiel, das von Happy-Software vertrieben wird, wegen der originellen Grundidee und deren Ausführung. Grafik und Musik sind ebenfalls sehr gut. Besonders die Unterbrechung des Spielvorgangs ist positiv zu bewerten: Nach wenigen Sekunden springt der Computer für den Spieler ein. Die leider englische Anleitung im Programm kann auf- beziehungsweise abgescrollt werden. Grundsätzlich formen die einzelnen Reize des Spiels und seine Finessen im Detail »Catastrophes« (für C 64: Preis: 48 Mark) zu einem lustigen, aber auch sehr spannenden Geschicklichkeitsspiel, das sogar dem actionliebenden Arcade-Fan viel Spaß machen wird.

(Oliver v. Quadt/aa)

# Wizard – ein würdiger Nachfolger für Jumpman

> Mit Wizard hat die amerikanische Softwarefirma PP & S (Progressive Peripherals and Software) ein Spiel auf den Markt gebracht, das den Rennern Jumpman und Jumpman Junior in nichts nachsteht.

Wizard ist nicht etwa, wie der Name vermuten läßt, ein Zaubererspiel, sondern ist eher in die Kategorie der intelligenten »Jump- and Run-Spiele« einzuordnen. Intelligent deshalb, weil man auch selbst kreativ das Spiel gestalten kann.

## Das Spiel

Das Ziel des Spieles ist es, möglichst viele Punkte zu sammeln. Diese erhält man, indem man möglichst viele Schätze sammelt, oder möglichst schnell das Ende des Levels erreicht. Das Ende einer Spielstufe erreicht man dann, wenn man es geschafft hat, den Schlüssel zu ergattern und damit das Schlüsselloch (also den Ausgang) zu erreichen. Daß dies nicht so einfach ist, wird sich wohl jeder denken können: Schließlich hat man mit 20 verschiedenen Arten von Feinden zu rechnen, und mit der Gefahr, irgendwo zwischen den vielen Leitern, Seilen, Treppen und gefährlichen Feuern abzustürzen. Weitere Gemeinheiten wie Teleporter und Transporter sind in höheren Levels in immer stärkerem Maße eingebaut.

Hätte man da nicht noch so tolle Dinge wie Zaubersprüche, dann wäre man spätestens nach der 15. Spielstufe dem Tod geweiht. Bei sinnvoller Nutzung der zur Verfügung stehenden Sprüche kann man den letzten, also den 39. Level mit ein bißchen Übung erreichen.

Keine Sorge, auch nachdem man den letzten Schwierigkeitsgrad geschafft hat, wird das Spiel nicht so schnell langweilig: Wer will, kann sich seine eigenen Levels erstellen.

## Das »Construction Kit«

Bei der Entwicklung eigener Bilder steht dem »Bildschirmkünstler« die Wahl zwischen fünf Menüpunkten offen: Die Wahl der Monster, die Zaubersprüche, das Editieren des Bildschirms, die Startposition des »Wizard« und die Farbwahl. Der Bildschirmeditor besteht aus einer Kombination von Cursorbewegung per Joystick und Gegenstandsauswahl durch zwei Tasten. Hat man den Bildschirmeditor verlassen, kann man beginnen, die ersten Bosheiten einzubauen. Zur Wahl stehen 128 verschiedene Sprites, deren Auftrittshäufigkeit und Animationsgeschwindigkeit durch den Spieler bestimmt werden können. Falls Sie sich zu viele »Shadow Lords«, Riesenratten oder »Slimes« eingebaut haben, besteht noch immer die Möglichkeit, den Level durch Zaubersprüche (Unsichtbarkeit, Teleport, Feuerball etc.) zu erleichtern.

Auf eine Diskettenseite passen insgesamt 100 Levels. Wer sich nicht sattspielen kann, braucht sich also deswegen nicht gleich massenweise Disketten kaufen.

## Eine Fortsetzung ist geplant

Wizard ist ein Spiel, das durchaus mit Hüpfspielklassikern wie Jumpman konkurrieren kann, und das zu kaufen es sich lohnt.

Übrigens: Die Herstellerfirma PP & S plant für Anfang 1985 ein »Wizard Expansion Set« mit erweiterten Möglichkeiten und 40 neuen, gut durchdachten Levels. Einem Erfolg dieses Spiels dürfte eigentlich nichts mehr im Wege stehen.

(Manfred Kohlen/aa)

# Mathematical-Basic: Das Super-Basic für den VC 20

> Einen echten Knüller für alle Besitzer eines VC 20 mit 8 KByte Erweiterung haben wir zum »Listing des Monats« gewählt. Mathematical Basic steift über 50 neue Befehle und Funktionen zur Verfügung und setzt damit einen Standard, an dem andere Toolkits künftig gemessen werden müssen.

Das Programm ist vollständig in Assembler geschrieben und liegt zum Eintippen als Basic-Lader vor. Nach dem Starten des Laders wird das eigentliche Maschinenprogramm ab Adresse 29211, also am oberen Ende von Speicherblock 3 abgelegt und gleichzeitig vor dem Überschreiben durch Basic-Programme oder Variable geschützt. Bei einem voll ausgebauten VC 20 (+ 24 KByte) kann das Programm ohne weitere Veränderungen benutzt werden. Aber auch Besitzer einer 8-KByte-Erweiterung können diese Basic-Erweiterung nutzen. Allerdings muß dann diese 8-KByte-Erweiterung hardwaremäßig auf den Adreßbereich von $6000 bis $7FFF, also auf Speicherblock 3 umgeschaltet werden. Schlagen Sie bitte die erforderliche Vorgehensweise im Handbuch für die 8-KByte-Erweiterung nach. Es ist die gleiche Umstellung, die auch nötig wird, wenn Sie das 8-KByte-Modul zusammen mit einer 16-KByte-Erweiterung als 24 KByte RAM nutzen wollen.

Haben Sie allerdings keine zusätzliche 16-KByte-Erweiterung, dann steht Ihnen für das Arbeiten mit Mathematical-Basic nur der Grundversionsspeicher zur Verfügung. Leider ist es nicht möglich, nur das 16-KByte-Modul zu verwenden, da dieses immer auf Speicherblock 1 und 2 eingestellt ist. Doch nun zum Programm selbst: Mathematical-Basic erweitert den Wortschatz des Basic-Interpreters um zusätzliche Befehle und Funktionen. Insbesondere wurde die Handhabung der trigonometrischen Funktionen verbessert (man kann zwischen Altgrad, Neugrad und Bogenmaß wählen). Daneben wurden Spezialbefehle für Diskettenbetrieb wie CATALOG, DLOAD, DSAVE etc. eingebaut. Strukturierte Programmierung wird durch DO...UNTIL-Schleifen unterstützt. Viele weitere Befehle und Funktionen vereinfachen die Programmierung zum Teil ganz erheblich.

Auf jeden Fall braucht »Mathematical-Basic« den Vergleich auch mit kommerziellen Softwareprodukten dieser Art nicht zu scheuen.

(ev)

## Der Autor des »Mathematical Basic« stellt sich vor

Ich bin am 9.7.1963 geboren und zur Zeit Praktikant in einem Softwarehaus in Bad Kreuznach.

Für die Entwicklung des Programms ist hauptsächlich der Ärger über das permanente Fehlen der gebräuchlichsten naturwissenschaftlichen Funktionen in jedem Basic-Interpreter von Commodore verantwortlich.

Um mehrere Funktionen über den USR-Vektor zu implementieren, müßte man vor jedem Aufruf auch lästigerweise die jeweilige Adresse in diesen Vektor schreiben. Das ist sehr umständlich; also müssen mehrere USR-Funktionen her. Wenn nun aber schon eine Routine für das Selektieren der Adressen geschrieben wird, so kann man auch gleich das Ganze etwas komfortabler gestalten und eine Interpreter-Erweiterung basteln. Das waren meine anfänglichen Überlegungen und heraus kam »Mathematical Basic«. Das Programm wurde so gehalten, daß es jederzeit weitere Befehle und Funktionen aufnehmen kann. 6502-Freunde mit Kenntnissen über das VC 20-Betriebssystem werden sich schnell mit »Mathematical Basic« zurechtfinden und auch eigene Änderungen durchführen können.

(Wolfgang W. Wirth)

# Musik, Musik, Musik

> Das Programm ist als Werkzeug zum Experimentieren mit dem hardwaremäßig phantastischen aber softwaremäßig völlig vernachlässigten »Sound Interface Device« (SID) im C 64 gedacht. Nicht zuletzt kann man mit dem Synthesizer auch musizieren!

Um die Möglichkeiten zu nutzen, sind folgende Parameter einstellbar und werden übersichtlich — teilweise grafisch unterstützt — auf dem Bildschirm dargestellt.
1) Die Tastenreihe »Q« bis »RETURN« bildet die Orgeltastatur. Sie umfaßt zwei Oktaven mit allen Halbtönen und erscheint oben auf dem Bildschirm. Beim Drücken einer Taste erklingt der Ton so lange, bis sie wieder losgelassen wird. Gleichzeitig zeigt ein gelber Balken (Sprite) die aktivierte Orgeltaste an.
2) Anschlag (Attack), Abschwellen (Decay), Haltepegel (Sustain Level) und Ausklingen (Release) sind mit den Funktionstasten einstellbar. Die geshifteten Tasten verringern, die ungeshifteten erhöhen den Wert. Die relative Lautstärke (Pegel) des Tones wird ständig rechts oben als Balken auf dem Bildschirm gezeigt.
3) Als Wellenformen kann man Dreieck, Sägezahn, Rechteck, Rauschen und die ringmodulierte Dreieckschwingung (RING) mit der Taste »Z« wählen. Die beiden letzten sind in Klammern eingefaßt, da sie sich zum Musizieren nicht eignen.
4) Wählt man die Rechteckschwingung, wird das Tastverhältnis angezeigt und kann mit den Tasten »N« und »M« in Sechzehntel-Abstufungen verändert werden. Das Low-Byte des Tastverhältnisses beträgt immer 128.
5) Der Synthesizer nutzt das im Anhang P des Handbuchs gezeigte Frequenzspektrum voll aus: Der tiefste Ton ist der Halbton unter C0 und der höchste ist das Ais-7 (!).
Da die Tastatur aber nur zwei Oktaven umfaßt, kann man mit den Cursortasten den Frequenzbereich um jeweils eine Oktave ändern.
6) Mit der Taste »C« wird der Filtermodus umgeschaltet, wobei das entsprechende Wort auf dem Bildschirm revers geschrieben wird. Ist kein Filtermodus eingeschaltet, werden die Schaltbits 0,1 und 2 im Register 23 gelöscht, also für alle drei Stimmen die Filter ausgeschaltet. Auch die Verwendung mehrerer Filtermodi ist zugelassen.
7) Die folgenden Parameter sind nur bei eingeschalteten Filtern hör- und sichtbar:
7a) Mit den (ungeshifteten) Tasten »[« und »]« verändert man die Grenzfrequenz der Filter in Sechzehntelschritten. Es werden also die höchstwertigen vier Bits im Register 22 variiert.
7b) Die Filterresonanz wird mit den Tasten » < « und » > « vergrößert oder verkleinert.
7c) Die Tasten »?« beziehungsweise ».« schalten den »Wah-wah«-Effekt (er heißt wie er klingt) ein und aus. Nach dem Einschalten wird die Filtergrenzfrequenz (Register 22) gemäß dem Verlauf der Hüllkurve (Register 28) verändert. Die eingestellte Filterfrequenz (siehe 7a) hat dann keine Bedeutung.
8)  Mit der Stopp-Taste verläßt man das Programm. Da es jetzt im Speicher ist, kann es mit RUN 1000 unverzüglich wieder gestartet werden. Nun haben alle Parameter wieder die ursprünglichen Werte.

Ich möchte nicht verheimlichen, daß der »Synthesizer« natürlich auch einige Einschränkungen hat:
1) Alle Parameter werden jeweils für alle drei Stimmen gleichzeitig eingestellt, denn bei nur einem Manual wäre es sinnlos, den verschiedenen Stimmen zum Beispiel verschiedene Wellenformen zu geben.
2) Es gibt natürlich grenzenlos viele Möglichkeiten, Parameter (zum Beispiel die Filterfrequenz) während des Erklingens eines Tones zu verändern. Ihr Einbau würde aber ebenfalls den Rahmen dieses Programms sprengen.
3) Die Lautstärke ist fest auf 15 eingestellt. (Wozu hat man schließlich den Regler am Fernseher?)
4) Eine Computertastatur ist kein Orgel-Keyboard. Dies setzt dem Spieler von Musikstücken natürlich Grenzen. Für Bastler dürfte es aber nicht allzu schwierig sein, parallel zur Tastatur ein in der richtigen Matrix verdrahtetes Keyboard anzuschließen.

### Abspeichern des Programms

Wer es ganz elegant machen möchte, kann das Maschinenprogramm (den »Objektcode«) als solches auf Band oder Diskette schreiben. Ich habe die dazu nötigen POKEs und SYS-Aufrufe zusammengestellt, die man im Direktmodus eingeben kann. Allerdings sind die PRINT-Befehle (Zeilen 1000-1200) nicht im Maschinenprogramm enthalten! Aus diesen Zeilen sollte man also ein kleines Basic-Programm schreiben, das mit der Zeile »LOAD ’’SYNTHESIZER-OBS”«, Gerätenummer, 1« beginnt und mit »SYS12800« endet.

Wer einen Monitor besitzt, kann natürlich diesen zum Abspeichern benutzen. Die Startadresse ist $ 2F00 und die Endadresse $ 35DD.

Nun noch ein Hinweis für diejenigen, die den SID selbst programmieren wollen und nur das Handbuch zum Commodore 64 besitzen: Wer die Beispielprogramme schon ausprobiert hat, dem sollte aufgefallen sein, daß die Töne nie ausklingen — egal, welchen Wert man hierfür eingestellt hat. Das liegt daran, daß der Tongenerator dort immer mit POKE W, 0 »abgewürgt« wird. Zum korrekten Ausschalten eines Tones darf man aber nur das 0. Bit des Wellenform-Registers löschen, das sogenannte »KEY«-Bit! Richtig heißt es also POKE W, 16 (bei der Dreieckschwingung).

(Martin Ahlborn/rg)










# Mathematical Basic

Fortsetzung von Seite 50

Eine gute Nachricht für alle Freunde des VC 20: Unser »Listing des Monats« macht mit über 50 neuen Befehlen das Programmieren zum Vergnügen.

Leider gibt es aber auch eine schlechte Nachricht. Sie müssen gut und gerne 150 DATA-Zeilen eintippen. Lassen Sie sich aber davon nicht entmutigen. Der Aufwand lohnt sich ganz bestimmt. Das Programm hilft Ihnen bei der wohl unvermeidlichen Suche nach Tippfehlern durch das blockweise Bilden von Prüfsummen.

### Befehle des Mathematical Basic

':	
erlaubt eine REM-Anweisung innerhalb einer Zeile ohne sofortige Programmfortsetzung ab folgender Zeile.
**BEEP** h, I:
gibt einen Ton variabler Höhe (h) und Länge (I) aus. h ist im Bereich von 0 bis 126 und I von 0 bis 255 definiert. Beträgt l=O, so wird kein Ton ausgegeben.
**CATALOG**:
bringt das Inhaltsverzeichnis der Diskette auf den Bildschirm. Dieser Befehl ist nur für das Gerät mit der Nummer 8 definiert. Wird während der Ausgabe die STOP-Taste betätigt, so wird die Ausgabe sofort abgebrochen. Wird die Leertaste gedrückt, so wird die Ausgabe nur unterbrochen und kann mit einer weiteren Betätigung dieser Taste fortgesetzt werden.
**COLOR**
c,h,r: setzt die Farben für Cursor (c), Hintergrund (h) und Rahmen (r). r und c erstrecken sich von 0 bis 7 und h von 0 bis 1 5. Die einzelnen Farben bezüglich der Nummercodes können dem VC 20-Handbuch entnommen werden.
**CLS**:
löscht den Bildschirmspeicher.
**DEFUSRn TO x**:
definiert einen der neun möglichen USR-Vektoren. Die einzelnen USR-Funktionen werden durch das Zeichen n unterschieden. n kann dabei A, B, C, D, E, F, G oder H sein. Die neunte USR-Funktion ist die, welche über den Vektor in den Adressen 1 und 2 angesprungen wird. Soll dieser Vektor definiert werden, so muß n weggelassen werden. Die Variable x steht für den Vektor selbst, also der Adresse, ab der die U8R-Funktion starten soll. Beispiel: DEFUSRA TO 30000. Die USR-Funktion U8RA erhält die Einsprungadresse 30000.
**DEGREE**:
stellt die Routinen für trigonometrische Funktionen auf Normalgrad (0 bis 360) ein.
**DELETE a-b**:
löscht Zeilen eines Basic-Programms von Zeile a bis Zeile b. Für a und b sind nur Konstanten erlaubt.
**DIRECTORY**:
siehe CATALOG
**DLOAD** pn$.
lädt ein Programm mit dem Namen pn$ vom Floppy-Laufwerk mit der Nummer 8. Außer dem Namen sind keine weiteren Parameter erlaubt.
**DO**:
erlaubt zusammen mit UNTIL eine Schleife. Der zwischen diesen beiden Schlüsselwörtern liegende Programmteil wird so oft wiederholt, bis der Ausdruck, der UNTIL folgt, nicht mehr auf logisch 0 ist. Dazu ein Beispiel: DO GET a$: UNTIL a$="". Das Programm verläßt die Schleife nicht eher, bis die Leertaste gedrückt wird. DO-UNTIL-Schleifen können acht Ebenen tief geschachtelt werden. Eine neunte DO-Anweisung würde die Meldung »out of memory« zur Folge haben. Sollte UNTIL einmal ohne einen vorangegangenen DO-Befehl aufgerufen werden, so gibt der VC 20 »until without do« aus.
**DSAVE** pn$:
sichert ein Programm mit dem Namen pn$ auf dem Floppy-Laufwerk mit der Nummer 8. Außer dem Namen sind keine weiteren Parameter zulässig. Sollte dem Befehl DSAVE, DLOAD oder DVERIFY kein Parameter folgen, so wird automatisch »*« als Parameter gesetzt.
**DVERIFY** pn$:
vergleicht das Programm mit dem Namen pn$ im Speicher mit dem gleichen auf der Diskette. Als Parameter ist nur der Name erlaubt.
**EXECUTE** a$:
wandelt den String a$ in Interpretercode und führt die darin enthaltenen Anweisungen aus. Beispiel: a$=”a=22”:EXE-CUTE a$. Der Variablen a wird der Wert 22 zugewiesen. Der Befehl darf nicht im Direkt-Modus gegeben werden und der Befehlsstring (a$) darf eine Länge von 88 Zeichen nicht überschreiten.
**GRAD**:
stellt die trigonometrischen Routinen auf Neugrad (0 bis 400). IF:
Die IF...THEN-Anweisung ist in ihren Aufbaumöglichkeiten erweitert worden. Es ist nicht mehr zwingend erforderlich, den THEN-Dummy zu schreiben. Beispiel: IF A=4 THEN PRINT B$ läßt sich auch als IF A=4 PRINT B$ eingeben.
**INITIALIZE**:
initialisiert die Floppy mit der Nummer 8.
**LOCATE** z,s:
setzt den Cursor in Zeile z und Spalte s. z liegt im Bereich von 1 bis 23 und s von 1 bis 22. Folgende Variationsmöglichkeiten sind gegeben: LOCATE z definiert nur eine neue Zeilenposition. LOCATE ,s setzt den Cursor innerhalb einer Zeile nur an eine neue Spaltenposition.
**LPRINT**:
verhält sich wie PRINT. Die Zeichen werden aber nicht auf den Bildschirm, sondern auf den Drucker (Nummer 4) ausgegeben. LPRINT und PPRINT sollten nur bei angeschlossenen Geräten benutzt werden, da sonst der lEC-Bus blockiert wird.
**RADIAN**:
stellt die trigonometrischen Routinen auf Bogenmaß ein.
**RENUMBER** z,s:
reorganisiert die Zeilennummern eines Basic-Programms. z ist dabei die Startzeile und s die Schrittweite, z und s dürfen nur Konstanten sein. Sollten dem Befehl keine Parameter folgen, so gilt z = 100 und s = 10.
**RESTORE TO** z:
positioniert den DATA-Pointer auf die Zeile z. Das Wort TO kann dabei wegfallen. RESTORE allein setzt den Pointer wie gewohnt auf den Programmstart.
**RETURN TO** z:
ermöglicht es, aus einem Unterprogramm in eine bestimmte Zeile z zurückzukehren.
**RUN** ”name”:
hat die gleiche Funktion wie DLOAD. Zusätzlich wird aber noch der String RUN +CHR$(13) in den Tastaturpuffer geschrieben. Das hat zur Folge, daß das gerade geladene Programm sofort gestartet wird.
**PPRINT**:
verhält sich wie PRINT. Die Zeichen werden aber, anstatt auf den Bildschirm, auf den Plotter (Nummer 6) ausgegeben.
**QUIT**:
führt ein Total-Reset aus. Mathematical Basic wird dabei gelöscht.
**UNITL** a: siehe DO.
**! a**:
ist ein Äquivalent zur CHR$(a)-Funktion. Hierbei sind aber keine Klammern nötig, a ist nur als Konstante erlaubt.
**&**:
ist das »Hexadezimal-Vorzeichen« für Hex-Konstanten. Beispiel: &aO2b ist das Äquivalent für 41003. Die Anzahl der Hex-Ziffern ist beliebig, es wird maximal eine 16-Bit-Zahl errechnet.
**←**:
entspricht dem Ausdruck CHR$(13) und kann auch genauso gehandhabt werden.
**[a]**:
hat die gleiche Wirkung wie die ABS-Funktion. Unterscheidet sich aber durch die bessere Selbstdokumentation.
**ACS**(a):
berechnet abhängig von derjeweiligen Einstellung durch RA-DIAN, DEGREE oder GRAD den Arcus-Cosinus von a. Die hier angesprochene Abhängigkeit gilt für alle trigonometrischen Funktionen.
**ACT**(a):
bestimmt den Arcus-Cotangens von a.
**ASN**(a):
ergibt den Arcus-Sinus von a.
**CHR$**(z,l).
ist eine Variante von CHR$(z). z entspricht dabei dem Zeichen des normalerweise nur 1 Byte langen Strings. Mit I läßt sich nun aber zusätzlich auch die Länge variieren. I ist dabei von 0 bis 255 definiert.
**COT**(a):
berechnet den Cotangens von a.
**CRSCOL**:
holt die momentane Spaltenposition des Cursors.
**CRSLIN**:
holt die momentane Zeilenposition des Cursors.
**CVF**(a$):
wandelt den fünf Zeichen langen String a$ in eine Fließkommazahl um.
**CVI**(a$):
wandelt den zwei Zeichen langen String a$ in eine Integerzahl um.
**DEC**(a$):
berechnet aus dem 4-Byte-String a$, der sich aus Hex-Ziffern aufbaut, eine dezimale 16-Bit-Zahl.
**DIV**(a,b,):
ist gleichwertig mit dem Ausdruck INT(a/b).
**FRC**(a):
holt die Nachkommazahl von a.
**FUNCTION**(a$).
wandelt den maximal 88 Zeichen langen String a$ in Interpretercode und berechnet ihn. Beispiel: y=FUNCTION(”5 + 2”). y wird der Wert 7 zugewiesen. Diese Funktion darf nicht im Direktmodus stehen.
**HEX$**(a):
wandelt die 16-Bit-Zahl a in einen 4-Byte-Hex. String.
**INSTR**(a$,b$):
testet, an welcher Stelle a$ sich in b$ befindet. Ist a$ nicht in b$ enthalten, so ist das Ergebnis 0, ansonsten entspricht es der Position von a$ in b$. a$ und b$ müssen mindestens 1 Zeichen lang sein und a$ darf nicht länger als b$ sein. INSTR darf nicht im Direktmodus stehen.
**LGD** (a):
berechnet den dekadischen Logarithmus von a.
**LGU**(a,b):
bestimmt den Logarithmus von a zur Basis b.
**MKF$**(a):
wandelt die Zahl a in einen fünf Zeichen langen String.
**MKI$**(a):
wandelt die Integerzahl a in einen zwei Zeichen langen String. MOD(a,b):
bestimmt den ganzzahligen Rest aus der Division von a durch b.
**RANDOM**:
entspricht dem Ausdruck RND(1).
**RANDOM**(a,b):
entspricht dem Ausdruck RND(1)*b+a.
**TIME$**:
ist eine modifizierte Form von Tl$. Der Unterschied liegt darin, daß bei TIME$ noch zwei Trennzeichen eingefügt werden.
**USR**n:
entspricht im Prinzip der USR(a)-Funktion. Unterschiede liegen darin, daß n (was der Kennung A, B, C, D, E, F, G oder H entspricht) folgen muß, aber keine »Klammer-auf-Klammer-zu«-Sequenz. Diese Routine (Aufruf durch JSR$cef1) muß zusätzlich an USR-Routinen, die für die Standard-USR-Funktion ausgelegt sind, angehängt werden. DerVorteil bei den USRn-Funktionen liegt nun darin, daß man den USR-String mit mehreren Parametern übergeben kann. Die dazu nötigen Routinen sind:

TODO table
cefa Test auf Klammer auf und nächstes Zeichen holen. cd9e Ausdruck holen und String- und lnteger-Flag setzen. cd8d Test auf numerischen Ausdruck.
cd8f	Test auf String.
cef7 Test auf Klammer zu und nächstes Zeichen holen.
cefd Test auf Komma und nächstes Zeichen holen.
Damit sind alle neuen Befehle und Funktionen vorgestellt. Bleibt nur noch, Ihnen viel Spaß beim Programmieren mit »Mathematical Basic« zu wünschen.

(Wolfgang W. Wirth/ev)

# Ohne gutes Werkzeug geht es nicht: SMON Teil 2

> Der Maschinensprache-Monitor SMON wird immer leistungsfähiger. Dieser 2. Teil erweitert ihn um wichtige Ausgabe-Routinen, läßt das Verschieben eines Programms mit und ohne Adreßumrechnung zu und kann Zahlen vom Dezimal- in das Binärsystem und umgekehrt umrechnen.

Wir hoffen, daß wir Ihnen in der letzten Ausgabe nicht zuviel zugemutet haben, und daß sich Ihre wunden Finger inzwischen wieder erholen konnten. Bestimmt haben Sie im vergangenen Monat schon eifrig mit dem neuen Monitor gearbeitet und sind inzwischen mit den bisherigen Befehlen vertraut. Denn nun folgt der zweite Teil und mit diesem natürlich wieder einige neue Befehle, die es zu erklären gilt.
Und das bieten wir Ihnen heute:
I/O-SET, LOAD, SAVE, PRINTER-SET, die verschiedenen Zahlenumrechnungen (HEX-DEZ-BIN-ADD-SUB), OCCUPY CONVERT, VERSCHIEBEN und WRITE.

### I/O-SET

I01 legt die Device-Nummer für LOAD und SAVE auf I (Kassette). Jedes Laden und Abspeichern erfolgt jetzt auf das angegebene Gerät. Die voreingestellte Device-Nummer ist 8 (für die Floppy also: I 08). Wenn Sie nur mit der Floppy arbeiten, brauchen Sie diesen Befehl also nicht.

### LOAD

L ”Name” lädt ein Programm vom angegebenen Gerät (wie oben beschrieben) an die Originaladresse in den Speicher. Die Basic-Zeiger bleiben bei diesem Ladevorgang unbeeinflußt, das heißt, sie werden nicht verändert.

Beispiel: Unser Monitor soll an seiner Originaladresse ($C000) im Speicher stehen. Also brauchen Sie ihn nur mit »L ”SMON”«zuladen, damit er dort erscheint. Wenn Sie einmal ein Programm an eine andere als die Originaladresse laden wollen, dann bietet Ihnen SMON dazu folgende Möglichkeit: ’L ”Name” ADRESSE lädt ein Programm an die angegebene Adresse. Nehmen Sie doch bitte noch einmal unser letztes Test-Programm und geben es mit dem Assembler ab Adresse $4000 ein. Speichern Sie es mit »’S ’’SUPERTEST” 4000 4023« ab und laden es dann

1.	an die Originaladresse (L "SUPERTEST”) und
2.	an eine andere Adresse (mit L ”SUPERTEST”5000 zum Beispiel nach $5000).

Schauen Sie sich danach mit dem Disassembler-Befehl beide Routinen einmal an. Sie werden feststellen, daß beide Programme zwar bis auf die BRANCH-Befehle gleich aussehen, daß das Programm in $5000 aber nicht funktionieren kann, da es eine falsche Adresse verwendet (5002 LDA 400E,Y). Ein anderes Beispiel dazu: Ein Autostart-Programm beginnt bei $0120, läßt sich aber in diesem Bereich nicht untersuchen, da dort der Prozessor-STACK (im Bereich von $0100 bis $01FF) liegt, der vom Prozessor selbst ständig verändert wird. Wenn Sie nun L”Name” 4120 eingeben, befindet sich das Programm anschließend bei $4120 (nicht an der Originaladresse $0120) und Sie können es ohne Einschränkungen — von den falschen Absolut-Adressen abgesehen — disassemblieren.

### SAVE

S ”Name”, ANFADR ENDADR speichert ein Programm von ANFADR bis ENDADR-1 unter »Name« auf die Floppy ab, da diese — wie wir ja inzwischen wissen — das voreingestellte Gerät ist. Wenn Sie auf Kassette abspeichern wollen, setzen Sie vorher mit »I 01« die Device-Nummer auf 1.

Beispiel: S”SUPERTEST”4000 4020 speichert das Programm mit dem Namen »SUPERTEST« (es steht im Speicher von $4000 bis $401F) auf Diskette ab. Bitte beachten Sie auch bei diesem Befehl, daß die Endadresse auf das nächste Byte hinter dem Programm gesetzt wird.

### PRINTER-SET

P 02 setzt die Primäradresse für den Drucker auf 2. Voreingestellt ist hier die 4 als Gerätenummer (zum Beispiel für Commodore-Drucker). Vielleicht haben Sie es ja schon bemerkt: Bei allen Ausgabe-Befehlen (wie D, M etc.) können Sie auch den Drucker ansprechen, wenn Sie das Kommando geshiftet eingeben. Die Ausgabe erfolgt dann gleichzeitig auf Bildschirm und Drucker. (Beachten Sie bitte die Änderung für die Druckerausgabe am Schluß des Artikels.)

## Ein bißchen Rechnerei

Die folgende Befehlsgruppe enthält Befehle zur Zahlenumrechnung. Sie wissen ja: Der Mensch mit seinen zehn Fingern neigt eher zur dezimalen Rechenweise, aber der Computer bevorzugt das Binärsystem, weil er nur zwei Finger hat (siehe Netzstecker). Ein Kompromiß ist das Hexadezimalsystem, denn das versteht keiner von beiden. Um Verständnis-Schwierigkeiten mit Ihrem Liebling aus dem Weg zu gehen, haben Sie aber SMON.

### UMRECHNUNG DEZ → HEX

\# (Dezimalzahl) rechnet die Dezimalzahl in die entsprechende Hexadezimalzahl um. Hierbei können Sie die Eingabe in beliebiger Weise vornehmen, da SMON Zahlen bis 65 535 umrechnet. Beispiel: #12, #144, #3456, #65533 und so weiter.

### UMRECHNUNG HEX → DEZ

$ (Hexadezimalzahl) rechnet die Hexadezimalzahl in die entsprechende Dezimalzahl um. Die Eingabe muß hierbei zweistellig beziehungsweise vierstellig erfolgen. Ist diese Zahl kleiner als $100 ( = 255), wird zusätzlich auch der Binärwert ausgegeben.

Beispiel: $12, $0012, $0D, $FFD2, etc. In den ersten drei Beispielen erfolgt die Anzeige auch in binärer Form.

### UMRECHNUNG BINÄR → HEX,DEZ

% (Binärzahl (achtstellig) rechnet die Binärzahl in die entsprechenden Hexa- und Dezimalzahlen um. Bei diesem Befehl müssen Sie genau acht Binärzahlen eingeben. Falls Sie einmal versehentlich mehr eingeben sollten, werden nur die ersten acht zur Umrechnung herangezogen. Beispiel: %00011111, %10101011

### ADD-SUB

? 2340 + 156D berechnet die Summe der beiden vier(!)-stelligen Hex-Zahlen. Neben der Addition ist auch Subtraktion möglich.

## Programme auf dem Rangierbahnhof

### OCCUPY (Besetzen)

0 (ANFADR ENDADR HEX-Wert) belegt den angebenen Bereich mit dem vorgegebenen HEX-Wert. Beispiel:O 5000 8000 00 füllt den Bereich von $5000 bis $7FFF mit Nullen.

Man kann mit »OCCUPY« aber nicht nur Speicherbereiche löschen, sondern auch mit beliebigen Werten belegen. Häufig hat man das Problem, festzustellen, welcher Speicherplatz von einem Programm wirklich benutzt wird. Wir füllen den in Frage kommenden Bereich dann zuerst zum Beispiel mit »AA« und laden dann unser Programm. Probieren Sie bitte das folgende Beispiel: Füllen Sie den Speicherbereich von $3000 bis $6000 mit $AA, und laden Sie dann unser SUPERTEST-Programm. Beim Disassemblieren können Sie erkennen, daß unser kleines Programm exakt zwischen vielen AAs eingebettet ist.

### WRITE

W (ANFADRalt ENDADRalt ANFADRneu) verschiebt den Speicherbereich von ANFADRalt bis ENDADRalt nach ANFADRneu ohne Umrechnung der Adressen! Unser kleines Testprogramm möge noch einmal als Beispiel dienen: W 4000 4020 6000 verschiebt das oben angesprochene Programm von $4000 nach $6000.

Hierbei werden weder die absoluten Adressen umgerechnet noch die Tabellen geändert. Letzteres ist sicherlich erwünscht, aber denken Sie daran, daß das verschobene Programm nun nicht mehr lauffähig ist, da die absoluten Adressen nicht mehr stimmen (zum Beispiel bei dem Befehl LDA 400E,Y). Falls Sie jetzt »G6000« eingeben, um das Programm zu starten, werden Sie sich sicherlich wundern, daß es dennoch läuft. Doch löschen Sie einmal das Programm in $4000 (mit »04000 4100 AA«) und starten das Programm in $6000 noch einmal! Seltsam, nicht? Abhilfe schafft der nächste Befehl.

### VARIATION

V (ANFADRalt ENDADRalt ANFADRneu ANFADR ENDADR) rechnet alle absoluten Adressen im Bereich von ANFADR bis ENDADR, die sich auf ANFADRalt bis ENDADRalt beziehen, auf ANFADRneu um. Kompliziert? Nicht, wenn Sie sich klarmachen, daß die ersten drei Adressen exakt den Eingaben beim »W«-Befehl entsprechen. Neu hinzukommen nur die beiden Adressen für den Bereich, in dem die Änderung tatsächlich erfolgt.

Um unser mit »W« schon verschobenes Programm auch wieder lauffähig zu machen, geben Sie folgendes ein: V 4000 4020 6000 6000 600E. Damit werden alle Absolutadressen, die im Bereich von $6000 bis $600E — dahinter steht die Tabelle — liegen und sich bisher auf $4000 bis $4020 bezogen haben, auf den neuen Bereich umgerechnet. Probieren geht wie immer über kapieren.

Eine Zusammenfassung dieser beiden Befehle ermöglicht:

### CONVERTIEREN

verschieben eines Programmes mit Adreßumrechnung)

C (ANFADRalt ENDADRalt ANFADRneu ANFADRges END-ADRges) verschiebt das Programm von ANFADRalt bis ENDADRalt zur ANFADRneu und zwar mit Umrechnung der Adressen zwischen ANFADRges und ENDADRges

An unserem kleinen Testprogramm läßt sich wieder einmal demonstrieren, wie der Befehl eingesetzt wird. Laden Sie es also mit »L’SUPERTEST”« und schauen es mit »D 4000« an. Jetzt wollen wir an der Adresse $4008 einen 3-Byte-Befehl einfügen: C 4008 4020 400B 4000 4011 verschiebt das Programm von $4008 bis $4020 zur neuen Anfangsadresse $400B. Dabei werden im Bereich von $4000 bis $4011 (neue Endadresse des »aktiven« Programmes!) die Sprungadressen umgerechnet. Nun können Sie ab Adresse $4008 einen 3-Byte-Befehl einfügen, zum Beispiel STY 0286. Dazu geben Sie bitte ein:
A 4008
4008 STY 0286
F

Überzeugen Sie sich davon, daß SMON die Befehle korrekt umgerechnet hat, indem Sie unser Beispiel disassemblieren (D 4000) und anschließend mit G 4000 starten. Besitzer eines Farbmonitors werden in helle Begeisterung ausbrechen. Vorsicht ist geboten, wenn Tabellen oder Text vorhanden sind. SMON wird versuchen, diese als Befehle zu disassemblieren und gegebenenfalls umzurechnen. Dabei können unvorhersehbare Verfälschungen auftreten. Aus diesem Grunde ist im Beispiel die Endadresse des zu ändernden Bereiches auf $4011 und nicht etwa auf $4023 gelegt worden. Wenn Sie größere Programme zu verschieben haben, sollten Sie die Kommandos W und V anwenden, beziehungsweise einen Assembler einsetzen, der es Ihnen gestattet, beliebige Einfügungen, Verschiebungen und sonstige Änderungen vorzunehmen. Das C-Kommando eignet sich in erster Linie für kleinere Änderungen innerhalb eines Programms.

## Der Blick hinter die Kulissen

Wie beim letzten Mal wollen wir noch einen kleinen Blick auf das Programm werfen. Wir haben zwei häufig vorkommende Programmteile ausgewählt. Wenn Sie nach erfolgreichem Eintippen der neuen DATAs einmal mit »D C84F« die »LOAD-SAVE«-Routine listen, sehen Sie, daß diese sehr wenig Platz beansprucht. Das Geheimnis dieser Beschränkung liegt in der Tatsache begründet, daß wir hier auf Betriebssystem-Routinen zurückgegriffen haben. Doch dazu nachher mehr; erst einmal die angesprochene Routine von Anfang an:

TODO

Die Speicherstellen $BB/$BC enthalten jetzt die Adresse $0201, also den Beginn des Basic-Eingabepuffers. In $B9 befindet sich der Wert 01, das bedeutet, daß die Sekundäradresse für absolutes Laden voreingestellt ist. Die Speicherstelle $B7 enthält die Länge des Dateinamens, hier erst einmal 0.

TODO

Überprüft, ob Anführungsstriche eingegeben wurden. Falls nicht, springt unser Programm in die Routine »LSERROR« und bricht ab.

TODO

In diesem Programmteil wird der Filename eingelesen und in die Adresse gespeichert, die in $BB/$BC enthalten ist ($0201). Gleichzeitig wird $B7 als Zähler für die Namenlänge so lange erhöht, bis das zweite Anführungszeichen auftaucht. Damit ist der Filename gespeichert, beginnend bei $0201.

TODO

Da die Namenlänge um eins zu groß geraten ist (das letzte Zeichen war ein »”«), muß sie dekrementiert werden. Die gewählte oder voreingestellte I/O-Nummer (Device-Nummer) soll in $BA gespeichert werden, damit die Betriebssystemroutine nachher das richtige Gerät anspricht. Zum Abschluß überprüft der Compare-Befehl, ob das Kommando »S« gewählt ist, um dann dorthin zu verzweigen.

TODO

Wir sind nun an der Stelle des Befehls angelangt, an der sich herausstellen muß, ob das Programm an seine Originaladresse (absolut) oder an eine andere Adresse geladen werden soll. Die Unterroutine »GETRET« prüft, ob unmittelbar nach dem Namen ein »RETURN« folgt und führt eine Verzweigung nach »LOAD1« durch, falls dieses eintritt. Ansonsten holen wir uns die Adresse und laden das vorgesehene Programm dorthin, nachdem in Speicherstelle *$B9 eine Null gespeichert ist, da ein absolutes Laden nicht erfolgt. Die Routine »GETADR« ist so aufgebaut, daß sie die nächsten 2 Bytes an die mit dem X-Register gewählte Stelle in der Zeropage ablegt. Dann führen wir ebenfalls »LOAD1« durch.

In »LOAD1« erfolgt der indirekte Sprung über $0330 in die LOAD-Routine des Betriebssystems.

Die SAVE-Routine erfragt vorher noch die fehlenden Adressen (Anfangs- und Endadresse des Programmes, das gespeichert werden soll), speichert sie nach $C1/C2 und $AE/AF und springt dann in die SAVE-Routine. Noch ein Wort zu den angesprochenen Betriebssystem-Routinen: Mittlerweile gibt es für den C 64 mindestens drei verschiedene Versionen des Betriebssystems von Commodore. Es sind zwar meist nur kleine Änderungen, aber die können fatale Folgen haben, wenn sich die Einsprungadressen ändern. Deshalb gibt es einen besonderen Bereich, das KERNAL, der einen Sprungverteiler für die wichtigsten Routinen enthält. Dieser wird grundsätzlich nie geändert. Beziehen Sie deshalb Ihre Einsprungadressen immer auf die KERNAL-Routinen, um sicher zu sein, daß Ihr Programm auch noch mit der zwölften Version des Betriebssystems läuft. Die KERNAL-Einsprünge stehen ganz hinten ab $FF81 im Speicher.

Als zweites ein Vergleich, der in Maschinenprogrammen häufig und in allen Variationen auftaucht: Es handelt sich dabei um den Vergleich zweier Adressen. Nun sind Adressen leider 16-Bit-Werte, unser Prozessor aber kann nur 8 Bit auf einmal verarbeiten. Gehen wir einmal von folgenden Bedingungen aus: Ein Programm soll von $4000 bis $4020 gelistet werden. Die Zeiger für das Ende befinden sich in Speicherstelle ENDLO (Lowbyte) und ENDHI (Highbyte). »PCL« (Programm-Counter-Low) und »PCH« (Programm-Counter-High) geben den augenblicklichen Stand des Programmes an. Dann erfolgt die Abfrage auf erreichtes Ende mit dieser Befehlsfolge:

TODO

Solange PCL und PCH kleiner sind als die Endwerte geht das Programm »WEITER«.

Sobald aber PCL und PCH die Werte von ENDLO und ENDHI erreicht haben, wird das Carry-Flag gesetzt und die Abfage mit BCS FERTIG würde das Auflisten anhalten. Daß es bei der Anwendung einige Probleme geben kann, sieht man daran, daß die Ausgabe auch schon unterbrochen wird, wenn gerade erst das Programmende erreicht ist. (Der letzte Befehl könnte »unter den Tisch fallen«.) Aber kein Problem ohne Problemlösung — und natürlich ohne weitere Probleme, die Sie aber mit ein bißchen Nachdenken sicher selbst lösen können.

### Hinweise zum Abtippen

Tippen Sie das Ladeprogramm sorgfältig ab, speichern Sie es (!) und starten Sie mit RUN. Sollte es sich wider Erwarten auf Anhieb mit READY melden, haben Sie das Schlimmste geschafft. Ansonsten beseitigen Sie nun alle Fehler bis es zum READY durchläuft. Jetzt laden Sie das alte Ladeprogramm aus der letzten Ausgabe und starten es. Nach dem READY starten Sie SMON mit SYS 49152. Als erstes probieren Sie nun den Befehl »S«, um SMON selbst abzuspeichern, diesmal nicht mehr als Basic-Lader, sondern als Maschinenprogramm.
S ”SMON $C000” C000 CAB7

SMON belegt jetzt 11 Blöcke auf der Diskette. Ab jetzt können Sie SMON direkt mit »LOAD ”SMON $C000”,8,1« laden und mit SYS 49152 starten.

Noch zwei Hinweise in eigener Sache: Einige wenige (!) Leser haben uns darauf aufmerksam gemacht, daß die Druckerausgabe auf bestimmten (exotischen) Druckern bisweilen kleinere Unzulänglichkeiten aufweist. Kurz und schlecht, uns ist in der letzten Folge ein Programmierfehler unterlaufen: Beim Disassemblieren verschwindet die letzte Zeile vor dem Strich (-----) im Drucker und ward nicht mehr gesehen. So etwas passiert, wenn man kurz vor Redaktionsschluß noch auf die Schnelle kleine »Verbesserungen« vornimmt.

Für die Korrektur ist folgendes notwendig: Listen Sie mit »M C56C C57B« zwei Zeilen, gehen mit dem Cursor in die betreffenden Zeilen und geben folgende Änderung ein:

TODO

Nur die fetten Werte müssen geändert werden, alle anderen können Sie stehen lassen. Denken Sie bitte bei jeder Änderung daran, daß Sie die Zeile nur mit Drücken der RETURN-Taste an den Computer übergeben. Zur Probe können Sie ja noch einmal listen...

Wir haben nach dem letzten Artikel eine Menge Anrufe erhalten, von Lesern, die größtenteils Schwierigkeiten beim Eintippen der DATAs beziehungsweise bei der Fehlersuche hatten. Deswegen hier Hinweise zu den häufigsten Problemen:

1.	Wenn nach Beendigung der Tipparbeit nach dem RUN eine Fehlermeldung ».... ERROR in 40« (oder 70) erfolgt, dann ist sicherlich nicht die Zeile 40 oder 70 daran schuld, sondern Sie haben aller Wahrscheinlichkeit nach einen Wert (ein »Datum«) falsch eingetippt. Der Computer bringt eine Fehlermeldung, wenn er beim POKE-Befehl auf eine Kommazahl trifft oder einen anderen nicht POKEbaren Wert. Dafür gibt es — neben schlichten Tippfehlern — mehrere Möglichkeiten: Es kann ein Komma fehlen oder durch einen Punkt ersetzt worden sein. Gerade dies ist nämlich auf dem Bildschirm sehr schlecht zu erkennen.
2.	Überprüfen Sie nach dem Programmabbruch anhand des Direktbefehls »PRINT I« in welchem Block ( + 1) der Fehler steckt. Also bei der Antwort »1« steckt der Fehler in Block 2. 3. Der Direktbefehl »PRINT A« zeigt Ihnen den Wert, der den Fehler verursacht hat.

Versuchen Sie es erst einmal mit dieser kleinen Hilfe. Übrigens ist unser Listing mit 99prozentiger Wahrscheinlichkeit fehlerfrei, von uns und der Redaktion mehrfach durchprobiert. Das Dreckfuhlerteufelchen hat kaum eine Chance, da das Listing direkt von der Diskette auf den Drucker läuft.

Ich hoffe, daß Sie bis jetzt nicht in Ihren Bemühungen nachgelassen haben, möglichst häufig die verschiedensten Befehle zu probieren. Sie wissen doch: Nur die Übung macht den Meister — und das gilt speziell für die Maschinensprache. In der nächsten Ausgabe bekommen Sie dann die letzten Raffinessen des SMON, der dann komplett ist.

(Norfried Mann/gk)

# Bewegte Grafik und Text mischen
Wer an Sprites denkt, stellt sich meist kleine Männchen oder Raumschiffe vor. Aber auch beim Einsatz in Anwendungsprogrammen können Sprites zur grafischen Illustration sehr nützlich sein.
Als ich die Grafik entwarf, wollte ich ein Programm unter folgenden Gesichtspunkten schreiben: kein Spielkram und von Basic aus verwendbar. Damit diese Erweiterung auch mit anderen Basic-Erweiterungen ohne weiteres funktioniert, sollten die Befehle über »SYS« aufgerufen werden. Nun sollte es kein Allerweltsprogramm sein, sondern irgend etwas Neues. Da fielen mir die Sprites ein. Mit dem richtigen Programm könnten damit kleine aber deutliche Grafiken erstellt werden, zum Beispiel Niederschlags-Temperatur- oder Umsatztabellen. Als ideal fand ich vier Sprites hintereinander und das zweimal untereinander. Das gibt eine Auflösung von immerhin 95 x 42 = 4032 Punkten. Damit läßt sich schon einiges machen. Zur Handhabung werden vier Routinen benötigt. Eine zum Einschalten der Grafik, eine zum Setzen beziehungsweise Löschen der Punkte und eine zum schnellen Löschen der gesamten Grafik. Weiterhin noch eine, die die ganze Grafik auf eine Farbe setzt.
Das Einschalten und Positionieren der Grafik
Dazu sind vier Parameter nötig, zwei für die x,y-Koordinaten und zwei für die x,y-Ausdehnung, also das Spreizen der Sprites. Je nachdem, ob gespreizt oder nicht, werden die Koordinaten berechnet und in die jeweiligen Register abgelegt. Zum Schluß werden noch alle Sprites aktiviert. Der Einfachheit halber kann x nur Werte zwischen 0 und 255 haben. Bei x=255 und ungespreizt ragt die Grafik sowieso schon aus dem Bildschirm heraus. Auch sollte man mit dem y-Wert nicht zu hoch gehen, da sonst die Grafik möglicherweise oben in den Bildschirm hereinkommt. Diese Einschränkungen sind aber in den meisten Fällen unwesentlich.
Das Setzen beziehungsweise Löschen von einem Punkt
Dazu muß genau das Byte errechnet werden, in dem sich der Punkt befindet. Dafür braucht man nur die obere Spritereihe zu betrachten. Sie ist genau eine Speicherseite (256 Byte) groß. Sollte nun die y-Koordinate größer als 20 sein, so wird einfach eine Seite weitergeblättert, das heißt das Hi-Byte des Zeigers inkrementieren. Als erstes wird das Sprite errechnet. Es wird solange #24 (= eine Spritelänge) vom x-Wertabgezogen bis der x-Wert kleiner als 24 (24 < x < = 0) ist. So ist man praktisch im ersten Spriteblock gelandet. Nun wird vom x-Wert solange #8 abgezogen, bis der x-Wert kleiner als 8 (8<x> =0) ist. Jetzt weiß man, welches Bit gesetzt werden soll, und welches Byte in der Reihe gemeint ist (eins von dreien).
Nun der y-Wert. Ist er größer als 20, dann muß das Hi-Byte des Zeigers inkrementiert und vom y-Wert 21 abgezogen werden. Man will ja die Byteposition in einem Spriteblock errechnen. Ist der y-Wert jetzt noch größer als 0 so müssen noch einmal 3 * y dazugezählt werden, denn ein Sprite hat die Ausdehnung von 3 Byte. Damit hat man das Byte, das in einem Spriteblock verändert werden soll. Nun wird das Low-Byte des jeweiligen Sprites dazuaddiert und in der Zeropage für den Zeiger abgelegt. Nachdem das Bytemuster hergestellt ist, kann nun der Punkt gelöscht beziehungsweise gesetzt werden.
Das Löschen der Grafik und Setzen der Farbe versteht sich wohl von selbst. Das Ausschalten der Grafik geschieht durch POKE 53269,0.
Die Befehlsliste sieht dann so aus:

TODO

Die Routine INIT bereitet das RAM auf S-Grafik vor. Sie schiebt den Speicher- und Programmstart auf $0A00, davor liegt jetzt der Speicher für die Sprites. Danach wird ein Kaltstart durchgeführt, das heißt der Basicspeicher gelöscht. Technische Daten:

Sprites von $0800 bis $09FF

S-Grafik ab $C000 bis C1A0

Basic-RAM ab $0A00
Anwendung der S-Grafik:

Mit ein wenig Routine läßt sich mit der S-Grafik viel realisieren. Setzt man zum Beispiel die Farbe der oberen Spritereihe auf Rot und die der unteren Reihe auf Grün, so hat man einen roten und einen grünen Bereich. Nun kann man bei Säulengrafiken sofort erkennen, wo es kritisch wird (zum Beispiel Alkoholkonsum). Die Möglichkeiten sind fast unbegrenzt. Dazu kommt, daß man ja die Grafik überall hinschieben kann und auch noch spreizen kann. Sie kann im Textmodus beschriftet werden, im »Dunklen« aufbereitet werden, ruckzuck invertiert werden und so weiter.

Man lädt die S-Grafik mit LOAD”S-GRAFIK“,8,1 (Bild 1). Nun kann S-Grafik ohne Bedenken eingesetzt werden.

Achtung! Wenn sich ein Basicprogramm im Speicher befindet, wird es durch Aufruf der Routine INIT gelöscht

Der Grundgedanke zum Setzen eines Punktes.
Zum Beispiel (34/23)
**A**: 34 : 24 = 1 Rest 10

Der Punkt befindet sich in Sprite 1 und ist das 10 Bit
**B**: 10 : 8 = 1 Rest 2

Der Punkt befindet sich im 1. Byte, als 2. Bit

Y( = 23) ist größer als 20, also wird Grundadresse 2 gewählt (Grundadresse 1 = $0800, Grundadresse 2 = $0900
**C**: 23-21 = 2

Das Byte befindet sich in der unteren Spritereihe in Reihe 2, das heißt 2*3 Byte müssen zur Adresse zugezählt werden.
Daraus ergibt sich:

64 Grundadresse von Sprite 0, Rechnung A
+	1 Byte aus Rechnung B
+	2*3 Byte aus Rechnung C
+ $0900 Grundadresse der 2. Spritereihe
= Adresse des Bytes, in der sich der Punkt befindet.

Dazu ist noch zu bemerken, daß eine Spritereihe mit Sprite 0 beginnt. Wem das jetzt noch zu theoretisch ist, schaut sich einfach das Listing des Demo-Programms (Bild 2) an.

(F. Espitalier/rg)

# Von allen Seiten betrachtet

> Um dreidimensionale Körper von allen Seiten betrachten zu können, benötigen Sie den C 64, Simons Basic, einen Drucker und dieses Programm.

Das Programm soll einmal dreidimensionale Körper auf dem Bildschirm darstellen und zum anderen die hervorragende Grafikfähigkeit des C 64 demonstrieren.

Bei der Darstellungsart entschied ich mich für die normale Axonometrie. Sie ist einerseits leicht in eine für den C 64 verständliche Syntax zu packen und weist zum anderen einen räumlichen Effekt auf.

So entstand dann bald die erste Version von »Simons-Axo«. Allerdings war ich mit dieser Version noch nicht zufrieden. So tüftelte ich noch einige Routinen aus, die dem Programm erst den richtigen Schliff geben.

Nun fügten sich an die einfache Zeichenroutine noch weitere, die das Abspeichern der Körperdaten als sequentielle Datei auf Diskette, das Drehen des Körpers um die drei Koordinatenachsen (in beliebiger Variation), das Verschieben des Körpers, das Einzeichnen der Koordinatenachsen mit ihren Bezeichnungen und das Ausdrucken des Hires-Bildschirmes auf einen angeschlossenen Drucker ermöglichen.

Das Programm beginnt in der Zeile 10, wo der Bildschirm gelöscht und ebenso wie der Rahmen auf schwarz gesetzt wird. In den folgenden Zeilen gibt das Programm eine kurze Anleitung und wartet mit der Fortführung in Zeile 95, bis 8ie eine beliebige Taste gedrückt haben.

In der Zeile 100 werden die Felder PT (Eckpunktkoordinaten, mitdenen laufend gearbeitet wird) und PA (Eckpunktkoordinaten des Ausgangszustandes) mit 100,3 dimensioniert. Das bedeutet, daß Sie Körper mit bis zu 100 Eckpunkten eingeben können. Das ArrayZP, ebenfalls mit 100 dimensioniert, gibt die Verbindungsvorschrift (Reihenfolge, in der die Punkte miteinander verbunden werden) an.

In Zeile 105—120 erfolgt eine Abfrage, ob die Körperdaten von der Diskette eingelesen werden sollen (Einleseroutine ab 1000) oder, ob Sie diese »von Hand« eingeben wollen. Sie können hier mit J’ oder ’N’ antworten, jede andere Antwort wird ignoriert.

Ab Zeile 125 steht die eigentliche Eingaberoutine, in der Sie mittels INPUT um die einzelnen Eckpunktkoordinaten gebeten werden. Diese werden den Feldern PT und PA zugeordnet. In dieser Eingabeschleife fungierten PX, PY und PZ als Zwischenvariablen und A als Zähler. Die Eingabe können Sie jeweils mit »Ende« abschließen. Hierbei empfiehlt es sich, den oben genannten Term einzufügen, da das Programm ja drei Variablen verlangt und sonst nur noch nachfragt, bis es alle drei hat. Mit »£« können Sie die vorige Eckpunkteingabe nocheinmal korrigieren (deswegen habe ich PX$ anstelle von PX verwendet).

Von 200 bis 270 wird die Verbindungsvorschrift eingelesen. Hier geben Sie zuerst den Startpunkt ein und dann jeweils einen weiteren Eckpunkt. Die Nummern dieser Eckpunkte werden nacheinander in ZP(B) abgelegt. In der Zeichenroutine werden die Eckpunkte dann in dieser Reihenfolge durch Linien verbunden, wodurch der Körper gezeichnet wird. Auch hier können Sie mit der »£«-Taste Korrekturen ausführen. In dieser Schleife dient B als Zähler und A$ als Zwischenspeicher. A1 enthält die Nummer des zuvor eingegebenen Eckpunktes (für die Korrektur notwendig).

In 300 bis 360 können Sie das Koordinatenkreuz festlegen, indem Sie die Winkel zwischen der z- und y-Achse (AL) und z- und x-Achse (BT) eingeben. Das Programm ist für jeweils 120° voreingestellt, Sie können diese Vorschläge aber einfach überschreiben.

ACHTUNG: Sie wählen hier die Winkel zwischen den projezierten Koordinatenachsen. Die Winkel zwischen den realen Achsen im Raum sind natürlich immer je 90°!

Durch geeignete Wahl dieser Winkel können Sie den Sichtwinkel, unter dem Sie den dargestellten Körper betrachten, ändern. Sind beide Winkel 90°, so blicken Sie frontal von vorne auf den Körper, sind beide kleiner als 90°, so sehen Sie von unten her auf Körper und bei Winkeln über 90° von oben her.

Die nächsten Zeilen, von 400 bis 490 stellen die Zeichenroutine dar. Hier wird zunächst in Zeile 405 in den Hires-Modus umgeschaltet und die Zeichenfarbe grün bei schwarzem Hintergrund gewählt. In 410 bis 420 werden die Zeichenkoordinaten (zweidimensional) des Anfangspunktes, welcher durch ZP 0 gegeben ist, errechnet und in XA und YA abgelegt. In der nachfolgenden Schleife werden nach dem gleichen Schema die Endpunktkoordinaten für den LlNE-Befehl des Simons Basic berechnet und die Linie gezeichnet. In Zeile 450 wird der Endpunkt nun zum Anfangspunkt für die nächste Linie definiert. Die Variable B dient hier als Zähler, während A als Index verwendet wird. Wenn alle Punkte miteinander verbunden sind, so wie es die Verbindungsvorschrift ZP(B) angibt, wird die Schleife beendet und das Programm prüft, ob das Flag für das Einzeichnen der Koordinatenachsen, KO auf 1 (zeichnen) gesetzt ist. Ist dies der Fall, so wird nach 1410 verzweigt.

In 480 und 485 wird in der linken oberen Ecke die Fertig-Meldung ausgegeben und in die Endlosschleife in 490 gesprungen, die nach Drücken der F1-Taste beziehungsweise RETURN verlassen wird.

Nun sind wir im Hauptmenü, welches uns zehn Möglichkeiten bietet. Die Abfrage erfogt in 585 mittels GET. In 590 steht die Sprungtabelle auf die einzelnen Routinen. Wenn Sie 0 eingegeben haben, wird das Programm nun in 595 abgebrochen. Mit GOTO XXXX oder CONT können Sie wieder einsteigen, ohne daß Sie die Daten verlieren.

In den Zeilen 600 bis790 steht nun die Routine, die erlaubt, die erstellte Figur in beliebiger Variation um die Koordinatenachsen zu drehen. Doch zuerst gelangen Sie wieder in ein Menü, in dem Sie die momentane Drehung auswählen müssen. Der Drehwinkel ist in Grad einzugeben. Ist dieser positiv, wird die Figur gegen den Uhrzeigersinn um die gewählte Achse gedreht. Bei einem negativen Winkel erfolgt die Drehung im Uhrzeigersinn. Die Drehroutine ist in drei Abschitte unterteilt, je nach Drehachse, wobei alle drei mit den Polarkoordinaten arbeiten. Diese werden in den Zeilen 660 bis 670, 710 bis 720 sowie 760 und 766 berechnet. EO ist der Winkel und R der Radius. Zu EO wird nun einfach der Drehwinkel addiert und die neuen kartesischen Koordinaten berechnet. In diesen Schleifen dient X als Zähler, während EP die Anzahl der Eckpunkte angibt. In Zeile 790 wird wieder auf die Grafik zurückgeschaltet und in die Zeichenroutine nach 400 gesprungen. Nun kann man am Bildschirm wieder das Entstehen des Körpers in gedrehter Lage beobachten.

Die kurze Ausgangszustand-Routine in 800 bis 850 kopiert einfach die Anfangsdaten der Eckpunkte, die ja im PA-Feld festgehalten sind, in das Arbeitsfeld PT. Hier dienen X und Y wieder als Zähler. Danach wird die Zeichenroutine aufgerufen.

In den Zeilen 1000bis 1097 steht die Einleseroutine, die die Körperdaten (Eckpunkte und Verbindungsvorschrift) von der Diskette, wo sie als sequentielle Datei stehen müssen, einliest und sie den entsprechenden Feldern zuordnet. Dem abgefragten Dateinamen, der auch den Joker enthalten kann, wird gleich »,S,R« angehängt und dann die Datei geöffnet, nachdem der Fehlerkanal geöffnet wurde (1010). Nun werden EP (Anzahl der Eckpunkte) und SP (letzte Nummer der Verbindungsvorschrift), die beiden wichtigen Steuervariablen, eingelesen. Danach werden zunächst die Felder PT und PA gefüllt und schließlich noch die Verbindungsvorschrift eingelesen und dem ZP-Feld zugeordnet. Zwischendurch wird in die Fehlerkanalroutine verzweigt, die sich in den Zeilen 1250 bis 1290 befindet und das Programm stoppt, wenn es zu einem Diskettenfehler kommt. Dann wird die komplette Fehlermeldung, die in den Variablen F1, F1$, F2 und F3 festgehalten ist, ausgegeben. Nun hat man die Möglichkeit (meistens, wenn man den Dateinamen falsch eingegeben hat) in die Zeile, in der der Fehler entstanden ist, zurückzukehren, indem man mit RETURN bestätigt, oder das Programm abzubrechen, indem man die SPACE-Taste betätigt.

Ab Zeile 1100 finden Sie die Schreibroutine. Diese funktioniert im wesentlichen genauso wie die Einleseroutine mit dem Unterschied, daß die momentanen Körperdaten auf Diskette gespeichert werden.

Ab Zeile 1300 bis 1360 befindet sich die Verschieberoutine, die das Verschieben der erstellten Figur um einen Vektor, der in Zeile 1320 abgefragt wird (wieder mit drei Koordinaten) ermöglicht. Mit dieser und der Drehroutine ist es möglich, einen Körper zuerst in einer einfachen Lage zu erstellen und dann in eine komplizierte Lage zu drehen und zu schieben. Nach der Neuberechnung des PT-Felder wird wieder zur Zeichenroutine verzweigt.

Das Zeichnen der Koordinatenachsen, ab Zeile 1400 stellt die vorletzte Routine dar. In Zeile 1405 wird zunächst getestet, ob das Flag KO schon auf 1 gesetzt ist. Ist dies der Fall, so werden die bereits gezeichneten Achsen gelöscht, indem der Zeichentypusvariable TY der Wert Null zugeordnet wird. War KO jedoch Null, so werden beide auf 1 gesetzt, als Zeichen dafür, daß die Achsen gezeichnet werden sollen. In den nächsten Zeilen werden den Variablen XS und YS die Endpunkte der Koordinatenachsen übergeben, während X1 und Y1 die Koordinaten zur Ausgabe der Bezeichnungen mit dem CHAR-Befehl darstellen. Es werden nun die Achsen nacheinander berechnet und dann gezeichnet und bezeichnet. Anschließend wird wieder auf den Grafikbildschirm umgeschaltet und nach 480 verzweigt, wo die Fertig-Meldung wieder ausgegeben wird.

In den Zeilen 1500 bis 1535 steht die letzte und gleichzeitig die einfachste Routine, das Ausgeben des Bildschirminhaltes auf einen angeschlossenen Drucker mit dem COPY-Befehl.

Vor der Hardcopy wird jedoch D$ mit »HARDCOPY« Meldung ausgegeben. Wer diese Meldung als störend empfindet, da sie auch auf dem Drucker ausgegeben wird, kann sie auch weglassen, indem er einfach die Zeilen 1515 und 1510 wegläßt. Ist die Hardcopy fertig, wird wieder nach 480 verzweigt und die Fertig-Meldung ausgegeben.

(Peter Steger/rg)

# Trace und Single Step für Maschinenprogramme

> Maschinenprogramme stürzen bei Fehlern meist ohne Hinweis auf den Fehlerort ab. Mit Trace lassen sich Maschinenprogramme Befehl für Befehl abarbeiten. Es werden dabei die momentanen Registerwerte (Programmcounter, X-, Y-Register, Akku, Stackpointer und Flags) angezeigt. Diese Werte lassen sich ohne weiteres ändern. Als Dreingabe erscheinen auch noch der Zustand des User-Ports und des Datenrichtungsregisters B auf dem Bildschirm.

Das Programm läßt eine Ausführung von Maschinenprogrammen im Einzelschrittmodus zu. Dabei wird das Programm wirklich ausgeführt also nicht simuliert. Es bietet Einzelschritt, langsam und schnellen Trace. Alle Register werden angezeigt und können verändert werden. Zusätzlich wird der Befehl disassembliert. Laden und Abspeichern des Programms geschieht je nach Assemblerversion des Lesers. Das Assemblerprogramm erlaubt ein freies Verschieben von Trace durch Änderung in Zeile 100: *=$XXXX. Der Startwert für PC (Programmcounter) kann in Zeile 270 frei gewählt werden.

### Programmfunktionen

Nach dem SYS-Befehl befindet man sich im Tracemodus. Es sind nur die Tasten F1 bis F7 und X für Exit aktiv. Folgende Register werden angezeigt:

1.	PC = Programmcounter.
2.	SP = Stackpointer.
3.	YR = Y-Register.
4.	XR = X-Register.
5.	AC = Akkumulator.
6.	Prozessorstatusflags.
7.	User-Port mit Datenrichtungsregister. Entsprechende Eingangsleitungen sind revers dargestellt.
8.	Es werden 1 bis 3 Hexbytes angezeigt, die verändert werden können, dann wird der Befehl disassembliert dargestellt. Trace wartet jetzt auf einen Tastendruck. Der Programmcounter zeigt am Anfang auf Hex C000.

Folgende Tastenfunktionen stehen zur Verfügung:
**Taste F7** = Einzelschritt. Pro Tastendruck wird ein Befehl des Testprogramms ausgeführt (genauer gesagt beim Loslassen von F1). Danach werden wieder die Register angezeigt und disassembliert.
**Tast F5** = Slow Trace. Solange diese Taste gedrückt ist, wird das Testprogramm Befehl für Befehl abgearbeitet, die Register angezeigt und pro Befehl noch zusätzlich um zirka 65 ms verzögert.
**Taste F3** = Tast Trace. Wie F5 jedoch ohne Verzögerung.
**Taste F1** = Set Register, Editmodus. Durch Drücken von F1 kommen Sie in den Editmodus.

### Beschreibung Editmodus

Die erste Ziffer des Programmcounters wird zur Kennzeichnung des Cursororts revers dargestellt. Sie können jetzt alle angezeigten Werte überschreiben. Der Stackpointer und die Userport-Anzeige können zwar überschrieben werden, dies hat aber keinen Einfluß auf die Werte. Eine Veränderung des SP würde meist zum Absturz des Systems führen, da die CPU nach dem Interrupt nicht mehr die korrekten Rücksprungadressen auf dem Stack vorfindet. Die Cursor-Right-Taste bewegt den Cursor nach rechts, die Cursor-Up-Taste nach links. Neben diesen Steuertasten sind nur die Tasten A bis F, 0 bis 9 für die Hexziffern, der »Pfeil nach oben«, um ein Flag zu setzen, und das »Minuszeichen«, um ein Flag zu löschen, sinnvoll. Die Spacetaste ist auch erlaubt.

Die DELETE-Taste funktioniert nicht. Entsprechen die Änderungen in der PC-Zeile Ihren Wünschen, dann drücken Sie (RETURN) und können die disassemblierte Zeile editieren. Hier sind je nach Befehlslänge 1 bis 3 Hexbytes am Anfang der Zeile veränderbar, das heißt Sie können die Operanden oder auch den Opcode selbst noch vor der Ausführung verändern, was zum Austesten von Programmen sehr praktisch ist. Verlassen können Sie die disassemblierte Zeile wieder mit (RETURN). Sie befinden sich jetzt wieder im Tracemodus, das heißt die Tasten F1, F3, F5, F7 und X sind wieder aktiv.

Den Tracemodus können Sie durch Drücken der X-Taste verlassen, der Computer ist jetzt im Basic-Editmodus. Trace kann mit SYS 49152 wieder gestartet werden, wobei hier der Disassembler immer aktiviert ist. Starten Sie mit SYS 49160, dann ist der Disassembler nur beim Editieren an, Trace ist dann etwas schneller. Setzen Sie Trace nicht auf sich selbst an.

### Funktionsweise

Siehe hierzu auch Assemblersourcelisting. Zuerst schalte ich den normalen Tastaturinterrupt über Timer A aus und benütze den Timer B in CIA 1 für meine Interruptroutine. Timer A läuft zwar weiter, aber sendet keine IRQ mehr. Dann setze ich den IRQ-Vektor auf Trace. Trace initialisiert beim Start den Stack und beginnt dann mit der eigentlichen Einzelschrittroutine. Diese Routine dient als neue Interruptroutine, da der IRQ-Vektor auf Trace geändert wurde. Der Interrupt wird aber nicht mehr alle 1/60 Sekunde durch den Timer A ausgelöst, sondern durch Timer B und zwar alle 25 Mikrosekunden nach Start des Timers.

In dieser Zeit kann der Prozessor das Ende der normalen IRQ-Routine durchlaufen (Register vom Stack holen). Jetzt bleibt aber nur mehr Zeit, um einen Befehl des Testprogramms abzuarbeiten, da Timer B ja schon in genau einer Mikrosekunde erneut einen IRQ sendet. Der Prozessor legt nach diesem einen Befehl alle Register auf den Stack und verzweigt entsprechend dem IRQ-Vektor wieder auf Trace. Für genauere Information siehe Listing. Innerhalb der Traceroutine wird ein IRQ nicht akzeptiert, da sich sonst das Programm immer selbst unterbrechen würde. Trace läßt sich also nur durch einen NMI unterbrechen.
Beispiel:
SYS 49152 = Trace starten. Disassembler an.
Taste F1 drücken = Editmodus wählen.
PC auf $AF08 setzen. Diese Systemroutine gibt »Syntax Error« aus. Sie können zum Spaß auch die Register verändern, benützen Sie auch die Cursorsteuertasten.

RETURN drücken = Edit für disassemblierte Zeile. Hier können Sie die Hexbytes editieren. Eine Änderung hätte aber keinen Sinn, da wir ja eine ROM-Routine tracen. Drücken Sie nur (RETURN), und Sie gelangen wieder in den Tracemodus.
F7 drücken = Einen Befehl ab PC ausführen.
F5 drücken = Trace. Anzeige läuft. Flags werden in schneller Folge geändert. Die disassemblierte Zeile ändert sich sehr schnell. Halten Sie die Taste gedrückt, nach ein paar Sekunden sehen Sie schön langsam Buchstabe für Buchstabe »Syntax Error« erscheinen. Befindet sich der Cursor zufällig gerade am unteren Bildschirmrand und ist der Bildschirm vollgeschrieben, dann kann man schön verfolgen, wie die Scrollroutine arbeitet, der Bildschirminhalt wird Zeile für Zeile nach oben geschoben, um Platz für die Meldung zu machen.

(Jürgen Göbel/aa)

# Maschinenprogramme auf Tastendruck

> Mit einer kleinen Routine kann man ein Maschinenprogramm mit einem Tastendruck aufrufen. Dafür benutzt man ein Zeichen, das normalerweise nicht oder nur selten verwendet wird. Ich habe mich für das @-Zeichen entschieden.

Im Interpreter existiert eine Schleife, die einen Basic-Befehl holt und ausführt.

<pre>
A7E1	JMP	(0308)	; zeigt normalerweise auf A7E4
A7E4	JSR	0073	; nächstes Zeichen aus Basic-Text holen
A7E7	JSR	A7ED	; Statement ausführen
A7EA	JMP	A7AE	; zurück zur Interpreterschleife
</pre>

In den Speicherzellen 0308 und 0309 (776 und 777 dez) liegt ein Zeiger, der normalerweise auf den Beginn dieser Schleife zeigt. Verbiegt man nun den Zeiger auf eine eigene Routine, kann man den Basic-Befehl auf das eigene Zeichen überprüfen.

Wird es erkannt, springt man auf den Anfang des gewünschten Unterprogramms. Wurde das Zeichen nicht vorgefunden, macht man in der Schleife normal weiter.

Dieses Verfahren verwende ich bei der Programmierhilfe »Merge« aus Ausgabe 4/84, die normalerweise mit SYS 50000 gestartet werden muß. Es kann aber auch für andere Maschinenprogramme umgeschrieben werden.

»Merge« belegt den Speicherbereich 50000 bis 50264. Die eigene Routine beginnt auf Adresse 49152 (C000 hex). Der Wert in den Adressen 0308 und 0309 muß deshalb auf C000 abgeändert werden. Der Computer durchläuft dann vor jedem Befehl, den er ausführen soll, folgende Schleife:

<pre>
C000 JSR 0073 ;nächstes Zeichen holen
C003 CMP 40   ; Vergleich mit @-Zeichen
C005 BEQ      ; verzweigen wenn erkannt
C007 JSR 0079 ; Flags setzen
C00A JMP A7E7 ; Rücksprung
COOD JSR 0073 ; nächstes Zeichen holen
C010 JSR C350 ; zur eigenen Routine
C013 JMP A7AE ; Rücksprung
</pre>

Nach dem Drücken von @ und RETURN wird nun das Programm ab Adresse 50000 (C350 Hex) ausgeführt. Auf die anderen Befehle hat diese Routine keinen Einfluß. Eine Hürde gibt es noch zu meistern. Die Änderung der Adressen 0308 und 0309 ist auf der Basic-Ebene mit POKE nicht möglich. Dies ist auch verständlich, da POKE auch ein Basic-Befehl ist und durch die Änderung der ersten Adresse der Einsprung verändert wird.

Deshalb muß diese Adreßänderung in Maschinensprache durchgeführt werden.

<pre>
C100 LDA 00   ; Lade Akku mit 00
C102 STA 0308 ; Speichere Akku nach 0308
C105 LDA C0   ; Lade Akku mit C0
C107 STA 0309 ; Speichere Akku nach 0309
C10A RTS      ; Rückkehr nach Basic
</pre>

Basic-Lader für Befehlserweiterung

<pre>
240 FOR I= 49152 TO 49152 + 21
250 READ Q : POKE I, Q
260 NEXT
300 FOR I = 49408 TO 49408 + 10
310 READ Q : POKE I, Q
320 NEXT : SYS 49408
11000 DATA 32,115,0,201,64,240,6,32,121
12000 DATA 0,76,231,167,32,115,0,32,80
13000 DATA 195,76,174,167
14000 DATA 169,0,141,8,3,169,192,141,9,3,96
</pre>

# Fast Tape — die schnelle Kassette

> Dieses Programm für den VC 20 ermöglicht Ihnen einen zehnmal schnelleren Lade- und Abspeichervorgang, das lange Warten bei 16- oder 8-KByte-Programmen hat nun ein Ende.

Das Maschinenprogramm benötigt etwa 750 Byte Ihres Basic-Speichers, was aber bei einer 16-KByte-Erweiterung nicht viel ausmacht. Das Programm läuft auch auf der Grundversion, doch ist es dann nicht so rentabel, weil es zu lange dauert, bis man FastTape geladen hat, und außerdem sind die Ladezeiten bei Programmen für die Grundversion noch erträglich. Aufgerufen wird Fast Tape mit »!L« zum Laden eines Programms und mit »!S« zum Abspeichern.

Auf die Ausgabe von »Loading« während des Ladevorgangs sowie »Saving« während des Abspeicherns wurde verzichtet. Ebenfalls muß auf den Befehl »VERIFY« und das schnelle Laden/Abspeichern von Daten-Files verzichtet werden. »Fast Tape« liegt als Basic-Lader vor.

Das Eintippen der DATAs erfordert sehr viel Sorgfalt. Speichern Sie das Programm auf jeden Fall ab, bevor Sie es starten, denn es löscht sich selbständig. Auf gröbere Fehler in den DATAs macht Sie das Programm selbst aufmerksam.

(Thomas Kolbe/ev)

# Master Mind als Vierzeiler

Als Nebenprodukt meiner Einzeilerbemühungen entstand dieses Programm: Bei Master Mind geht es darum, eine Zahl, die sich der Computer »denkt«, zu erraten. Am Anfang gibt man die Stellenzahl der zu erratenden Zahl ein, sie darf maximal acht sein (man hat aber schon mit drei oder vier genug zu knobeln). In der ersten Spalte muß man nun jeweils eine Zahl eingeben, der Computer zeigt in den folgenden drei Spalten an: 1. Anzahl der richtigen Ziffern an der richtigen Stelle 2. Anzahl der richtigen Ziffern an der falschen Stelle 3. Anzahl der Versuche

<pre>
Beispiel eines Spiels:
Stellen? 4
?1123	1	0	1
?4456	0	0	2
?7789	2	1	3
?8989	1	0	4
?7979	1	1	5
?7187	4	0	6
</pre>

Es geht natürlich darum, die Zahl mit möglichst wenig Versuchen zu erraten. Hier noch die Tabelle der Variablen:

TODO

(Hans Haberl/aa)

# Programmierter Direktmodus

> Programmierter Direktmodus hört sich wie ein Widerspruch in sich an. Entweder man befindet sich im Direktmodus oder es läuft ein Programm, beides gleichzeitig scheint kaum vereinbar. Dennoch gibt es eine Verbindung, die bisher ungeahnte Möglichkeiten eröffnet.

Das Geheimnis dieser Verbindung liegt im Tastaturpuffer (Tabelle 1) und dem Umstand, daß der Computer, nachdem er im Programm auf eine END-Anweisung trifft, so viele Zeichen aus dem Tastaturpuffer holt, wie der Anzahlspeicher angibt und sofort ausführt. Dies kann man sich zunutze machen, indem man mittels PRINT eine Anweisung auf den Bildschirm bringt, den Cursor veranlaßt, in diese Zeile zu springen und den Computer durch ein im Puffer abgelegtes RETURN mit der Abarbeitung der eingegebenen Bildschirmzeile fortfahren läßt. Dabei werden alle Zeichen über ihren ASCII-Code in den Puffer gebracht. Ein kleines Beispiel soll dieses Vorgehen verdeutlichen:
Geben Sie Beispiel 1 ein.
Was passiert? — Der Computer geht nach der END-Anweisung in den Direktmodus über und führt die beiden Steuerzeichen CURSOR/HOME und RETURN (CHR$(19 beziehungsweise 13)) aus. Der Cursor springt also in die erste Bildschirmzeile, wo zu lesen ist:

I = I + 1 : GOTO 20
Diese Zeile führt der Computer nun aus und springt, nachdem er die Variable I um 1 hochgezählt hat, zurück in Programmzeile 20. Jetzt hilft nur noch RUN/STOP.

Beispiel 2
Dieses Programm bewirkt folgendes:

— Zeile 100 wird in das Programm eingefügt
— Zeile 350 wird aus dem Programm gelöscht
— der in Zeile 70 stehende Spruch wird durch einen — meiner Meinung nach treffenderen — ersetzt
— das geänderte Programm wird gelistet.

Anstelle des LIST-Befehles könnte auch ein GOTO beziehungsweise GOSUB-Befehl wieder in das Programm zurückspringen. Allerdings ist auch hier zu beachten, daß, sobald man neue Basic-Zeilen einfügt (beziehungsweise löscht), die Variablenwerte verloren gehen.

Mittels dieser Methode kann man zum Beispiel ein Programm entwickeln, das die DATA-Zeilen eines Sprites berechnet, ins laufende Programm übernimmt und dann die restlichen Programmzeilen herauslöscht, so daß nur ein Sprite-Ladeprogramm übrigbleibt, welches sofort abgespeichert werden kann. Eine weitere sinnvolle Anwendungsmöglichkeit des »Programmierten Direktmodus« können Sie den folgenden Ausführungen entnehmen.

## System Lademenü

Das System soll die folgenden Aufgaben erfüllen:

(1)	Mit verschiedenen Programmen (eventuell auf verschiedenen Disketten) arbeiten, ohne daß ständig LOAD und RUN gegeben werden muß.
(2)	Den ärgerlichen »file not found error« verhindern, der bereits auftritt, wenn man ein Leerzeichen zuviel oder zuwenig eingibt.
(3)	Programmiertes Aufrufen von Programmen (eventuell mit Parameterübergabe). Arbeiten mit dem Programmsystem ohne genaue Kenntnis der verwendeten Filenamen.

### Die Idee

Mit Hilfe des Commodore-Programmes DOS 5.1 und der Methode des Programmierten Direktmodus kann man das oben genannte Ziel erreichen. Man geht dabei folgendermaßen vor:

Auf jede Diskette, die nach diesem System arbeiten soll, bringt man das Programm DOS 5.1 sowie dessen Lader unter einem möglichst kurzen einprägsamen Filenamen (hier»£«-Listing 1).

Weiterhin kopiert man das Programm »Lademenü« auf jede der Disketten und trägt in dieses die Filenamen ein (Listing 2). Dabei ist darauf zu achten, daß die Filenamen »£« und »Lademenü« überall exakt gleich sind.

Der Arbeitsablauf gestaltet sich dann in folgender Weise: Nach dem Einschalten von Computer und Floppy legt man die gewünschte Diskette ein und lädt »£«. Dieses Programm initialisiert nach dem Starten die bekannten DOS 5.1-Befehle. Das RUN für »£« soll auch gleichzeitig das letzte sein, da nun der DOS-Befehl »t« zur Verfügung steht. Mit dessen Hilfe wird das Lademenü dieser Disk geladen und gestartet, welches die Programme anbietet und automatisch richtig lädt und startet. Zusätzlich bietet das Lademenü auch einen Überblick über die wichtigsten DOS-Befehle, die ja nun zur Verfügung stehen.

Um den Kreis zu schließen wird an jedes Programm auf der Diskette anstelle des üblichen END die folgende Zeile eingefügt:
PRINT CHR$(147); »Lademenü« :POKE 631,19:POKE 632,13:POKE 198,2:END
Dadurch wird nach jedem regulären Programmabbruch wieder das Lademenü dieser, oder wenn die Diskette vorher gewechselt wurde, einer beliebigen anderen Disk geladen. Nun wird durch das Lademenü das nächste ausgewählte Programm geladen und gestartet. Will man Parameter an andere Programme übergeben, so erreicht man dies über sequentielle Dateien.

Die Lösung

* Listing »£«
* Listing »Lademenü«
* Listing »Beispielprogramm«

### Ausblick

Schreibt man noch einen Autostart für »£« (eventuell mittels des Beispiels in Ausgabe 6/84) so kann man das »System Lademenü« zu einem System »Nie wieder RUN« ausbauen.

(Bernhard Lauer/rg)

# Automatische Zeilennumerierung

> Das lästige Durchnumerieren der Zeilen bei der Programmierung kann Ihnen dieses kleine Programm abnehmen.

Die Syntax des AUTO-Befehls ist:
←A anfangszeilennummer, schrittweite

Nach Eingabe dieses Befehls wird die Zeilennummer vorgegeben und nach RETURN um »schrittweite« erhöht.

Um aus dem AUTO-Modus wieder herauszukommen, muß man nach Vorgabe einer Zeilennummer
»←« RETURN eingeben.

Falls man nach Vorgabe einer Zeilennummer die RETURN-Taste betätigt, wird die entsprechende Zeile, falls sie vorhanden ist, gelöscht. Hiermit lassen sich auch sehr schnell Programmblöcke löschen, falls man die RETURN-Taste gedrückt hält, die Zeilenvorgabe weiterläuft und die entsprechenden Zeilennummern gelöscht werden.

»←«=CHR$(95)

»A«=CHR$(65)

Das Programm als Basic-Lader eintippen, anschließend mit RUN starten. Falls »FEHLER IN DEN DATAZEILEN« erscheint, DATAS auf Tippfehler überprüfen. Falls »OK«, kann die Basic-Erweiterung mit SYS 49152 initialisiert werden. Nun hat man das Basic um den Befehl »A« erweitert.

(Frank Siedel/rg)

# Musik aus der Datasette

> Mit dieser Routine ist es beim C 64 möglich, die Datasette ohne technichen Umbau als normalen Kassettenrecorder zu betreiben.

Die Maschinenroutine, die mit SYS 49152 gestartet wird, stellt eine Endlosschleife dar, die mit der SHIFT-Taste jederzeit abgebrochen werden kann. In der Schleife selber werden die Datenbits aus der Datasette kommend von dem Interrupt-Control-Register der CIA 1 isoliert. Der Lautsprecher im Fernseher oder Monitor wird dem logischen Zustand des einzelnen Datenbits entsprechend ein- oder ausgeschaltet. Die für uns daraus resultierende Frequenz wird originalgetreu wiedergegeben, nur nicht die Tonqualität. Der Vorteil der Maschinenroutine ist, daß von der Datasette nichts geladen, sondern nur wiedergegeben wird. Es kann also bei einer Kassette irgendwo »hineingehört« werden. Als Alternative zu Programmen sollte man zur einfachen Musikkassette greifen. Mit Phantasie kann die Musik erkannt werden, doch die Tonqualität läßt noch zu wünschen übrig.

(Jörg Wagner/rg)

# List- und Löschschutz leicht gemacht

> Es wurden schon viele Methoden veröffentlicht, um ein Basic-Programm gegen Listen zu schützen. Aber alle mir bekannten Möglichkeiten weisen entschiedene Nachteile auf. Entweder der Schutz ist nicht sicher genug und leicht zu entfernen, oder er ist viel zu aufwendig.

Ich habe mich daher entschlossen, ein Programm zu schreiben, das diese Mängel umgeht und sogar noch andere positive Merkmale aufweist.

Zunächst eine Zusammenfassung von drei mir bekannten Listschutzmöglichkeiten mit ihren Vor- und Nachteilen:

### 1. Möglichkeit

In die erste Zeile des Basic-Programms (zum Beispiel Zeilennummer 1) wird REM, gefolgt von zwei Anführungszeichen und SHIFT L, geschrieben.
1 REM””L (RETURN)

Der Cursor wird nun auf das zweite Anführungszeichen gesetzt und sechsmal SHIFT INST gedrückt (das Anführungszeichen wird um sechs Positionen nach rechts geschoben). Dann wird sechsmal DEL eingegeben (es erscheinen als Steuerzeichen sechs reverse T) und die Zeile mit (RETURN) abgespeichert. Wird nun der LIST-Befehl aufgerufen, meldet sich der Rechner mit:
"
?SYNTAX ERROR
READY.
Auf den ersten Blick sehr beeindruckend, aber durch Entfernen dieser Zeile ist der Listschutz wieder aufgehoben. Außerdem ist ein ’LIST 2’ noch möglich.

### 2. Möglichkeit
In jede Basic-Zeile werden synthetische Steuerzeichen eingefügt (genaue Beschreibung im 64’er-Magazin, Ausgabe 6/84). Diese Methode ist zwar recht sicher, will man aber alle Zeilen eines längeren Basic-Programms schützen, ist der Aufwand viel zu groß, vom Speicherplatzbedarf der Steuerzeichen ganz abgesehen.

### 3.	Möglichkeit

Durch POKE 775,200 wird der Listbefehl außer Kraft gesetzt, durch POKE 775,167 wird diese Wirkung wieder aufgehoben. Dieser Listschutz ist zwar wirkungsvoll, aber er muß erst durch diesen POKE-Befehl aktiviert werden. Nach dem Laden eines Programms ist er daher noch nicht aktiv.

Das hier vorgestellte Programm erzeugt nicht nur einen sicheren Listschutz, sondern schützt auch vor dem Löschen einzelner Basic-Zeilen. So können zum Beispiel Hinweise auf ein Kopierrecht und auf den Autor eines Programms nicht geändert oder entfernt werden. Auch kann ein so gesichertes Programm nur mit RUN gestartet werden, ein RUN, gefolgt von einer Zeilennummer, führt zu einer Fehlermeldung. Jede Zeile des Programms ist geschützt, es können also auch einzelne Zeilen nicht gelistet werden. Einzige Bedingung für die Verwendung dieses Schutzes: Das zu schützende Programm darf keine Zeilennummern 0 und 1 enthalten. Ansonsten wird eine Fehlermeldung ausgegeben und das Programm bleibt unverändert.

Das Listschutzprogramm liegt als Basic-Lader vor. Nachdem es richtig abgetippt wurde, kann es durch RUN gestartet werden. Das Maschinenprogramm steht dann im Speicher ab der Adresse 50000 zur Verfügung. Das zu schützende Basic-Programm kann nun geladen werden, durch SYS 50000 wird das Schutzprogramm aktiviert und das Basic-Programm geschützt. Es kann nun wieder auf Kassette/Diskette gespeichert werden. Das mit dem Listschutz versehene Programm ist nur um wenige Bytes größer als vorher.

### Funktionsweise

Das Maschinenprogramm generiert zwei Basic-Zeilen mit den Zeilennummern 0 und 1. Die Zeile 0 ist eine REM-Zeile, in der ein unlistbares Zeichen (SHIFT L) steht. Hinter diesem Zeichen stehen dann noch zwei kurze Maschinenprogramme, deren Funktionen im folgenden noch erklärt werden. In der zweiten Zeile steht ein SYS-Befehl, der eine der beiden Maschinenroutinen in Zeile 0 startet. Sind diese beiden Zeilen nun erzeugt, wird die Zeilennummer 0 durch eine höhere, eigentlich unerlaubte Zeilennummer (größer 64000) ersetzt. Diese Zeile kann daher auch nicht gelöscht werden.

Da alle nun folgenden Zeilen des Programms kleiner sind als die erste, können diese vom Computer nicht mehr erkannt werden. Ein Sprung in eine solche Zeile führt zu der Fehlermeldung: ?UNDEF’D STATEMENT ERROR. Es kann daher auch keine Zeile gelöscht werden, da diese für den Computer ja nicht mehr vorhanden sind.

Der einzige Nachteil ist, daß es nicht nur ein perfekter List- und Löschschutz, sondern auch ein RUN-Schutz ist (auch Sprungziele innerhalb des Programms können nicht gefunden werden).

Wird das geschützte Programm gestartet, trifft der Interpreter als erstes auf den SYS-Befehl in Zeile 1. Es folgt ein Sprung in das Maschinenprogramm in der REM-Zeile. Dort wird die Zeilennummer wieder auf 0 gesetzt, und der Vektor auf den Basic-Warmstart wird auf die zweite Maschinenroutine gesetzt.

Nun kann das Basic-Programm ohne Fehler ausgeführt werden. Wird der Programmlauf unterbrochen (durch STOP-Taste, Fehlermeldungen, Programmende und so weiter), wird das zweite Maschinenprogramm über den Basic-Warmstartvektor angesprungen. Dort wird die Zeilennummer wieder hochgesetzt, der Warmstartvektor wieder auf den normalen Wert gebracht und die Warmstartroutine angesprungen. Das Programm liegt nun wieder in der geschützten Form vor.

(Ulrich von Gaisberg/rg)

# Stringy: C64-Erweiterung

> Stringy stellt eine Basic-Interpretererweiterung dar, die den Befehlssatz des C 64 um acht Befehle ergänzt. Mit diesen Befehlen ausgestattet, kann man sich einen Programmgenerator von Basic aus programmieren.

Das Listing zu Stringy entstand mit Hilfe von Stringy. Dabei wurden die Zahlen formatiert, die Prüfsummen berechnet und nach jeder vierten Zeile angefügt. Mit Stringy kann man Strubs-ähnliche Erweiterungen programmieren (Der Grund, weshalb ich Stringy schrieb). Man könnte auch ein Programm schreiben, das die in einem Basic-Programm vorkommenden Grafikzeichen durch die entsprechenden CHR$-Funktionen ersetzt, damit sie im Listing besser zu erkennen sind. Auch Sprite- oder Bildschirmmasken-Generatoren sind recht einfach zu programmieren. Der wichtigste Befehl von Stringy ist der !INPUT-Befehl. Mit ihm kann man einen String, der eine Basic-Zeile mit Zeilennummer darstellt, bei laufendem Programm in das Basic-Programm übernehmen — ohne, daß dabei die Programmausführung unterbrochen wird.

Umgekehrt kann es sinnvoll sein, eine Zeile aus dem Basic-Programm herauszuholen, um sie einer Stringvariablen zuzuordnen. Dies ermöglicht der !GET-Befehl.

Damit es keine Komplikationen mit den Basic-Zeilennummern gibt, teilt der !NEXL-Befehl Ihnen die Folge der Zeilennummern mit.

Die anderen fünf Befehle dienen der Stringverarbeitung. Vier davon sind dem Sinn nach identisch mit den entsprechenden Stringoperationen aus Simons Basic, mit dem Unterschied, daß die Parameter beliebig komplizierte Ausdrücke sein können (dies gilt für alle Befehle von Stringy).

Der letzte der fünf Stringbefehle ist der !REPLACE-Befehl.

## Die Stringy-Befehle

Nachfolgend bedeuten str1, str2, str3 immer Stringausdrücke und m, n, p, w, z immer numerische Ausdrücke.

### !PLACE

Format:
!PLACE (str1,str2)
!PLACE (str1,str2,m)
!PLACE (str1,str2,m,n)

Funktion: Bestimmung der Position, an der str2 in str1 steht. Die Angabe von m und n grenzt str1 auf einen Teilstring ein. Nur dieser Teilstring von str1 wird dann durchsucht, und nicht der ganze String, m gibt den Beginn dieses Teilstrings an, gerechnet vom Anfang von str1, n bestimmt das Ende des Teilstrings. Vorsichtig: n wird vom Ende von str1 aus gezählt, also in anderer Richtung als m.
Beispiel: »PRINT !PLACE (’’COMMODORE”, ”0”)« liefert 2 als Antwort.
»PRINT !PLACE (’’COMMODORE”, ”O”,3)« liefert 5 als Antwort, da nur in ’’MMODORE” gesucht wurde
»PRINT !PLACE (’’COMMODORE”, ”E”, 1, 4)« liefert 0 als Ergebnis, da ”E” nicht in dem Teilstring ’’COMMOD” enthalten ist.

### !REPLACE

Format:
!REPLACE (str1,str2,str3)
!REPLACE (str1,str2,str3,m)
!REPLACE (str1,str2,str3,m,n)

Funktion: Ersetzen aller str2, die in str1 vorkommen, durch str3. Dabei kann str1, wie beim !PLACE-Befehl beschrieben, durch n und m eingegrenzt werden.
Beispiel:	10 A$=”INDEX=B$ + C$”
20 B$ = !REPLACE(A$,”INDEX”,”IN$”) Nach Ausführung gilt: B$=”IN$ = B$ + C$”
10 N$ = ”PETER PAUL MARY”
20 M$ = !REPLACE (N$,”PETER”, ” ”) Nach Ausführung gilt: M$ = ”PAUL MARY”

### !INSERT

Format: !INSERT(str1,str2,p)

Funktion: Fügt str2 in str1 ein. Die Position p bestimmt, an welcher Stelle str2 in str1 eingefügt werden soll.
Ist dabei p=0 oder p=len (str1), so wird angefügt.
Beispiel: »PRINT !INSERT (”ABCEF”,”D”,3)« liefert: ’ABCDEF” »PRINT !INSERT (”ABCEF”,”D”,0)« liefert: ’’DABCEF” »PRINT !IN8ERT (”ABCEF”,”D”,5)« liefert: ’’ABCEFD”

### !STOVER

Format: !STOVER (str1,str2,p)

Funktion: Überschreibt str1 mit str2.
Die Position, ab der str1 überschrieben werden soll, wird durch p angegeben.
Ist str2 länger als str1, oder ist wegen der Positionsangabe p ein Überschreiben nicht möglich, so erfolgt ein ILLEGAL QUANTITY ERROR.
Beispiel: »PRINT !STOVER (”GOTO XXXX”, ”0169”,6)« liefert: ”GOTO 0169”

### !DUP

Format: !DUP (str,w)

Funktion: Es wird str w-mal dupliziert.
Beispiel: A$ = !DUP(”.”,255) lieferteinen String mit255 einzelnen Punkten.

### !INPUT

Format: !INPUT(str)

Funktion: Hat str keine Zeilennummer am Anfang, so geht der Computer in den Direktmodus über und führt str sofort aus. Soll der Computer anschließend zum Programm zurückkehren, so muß der letzte Befehl in str ein »GOTO (Zeilennummer)« sein.

Beginnt str mit einer Zeilennummer, so wird str als Basic-Zeile in das laufende Programm eingefügt, sofern in dem Programm nicht bereits eine Zeile mit derselben Zeilennummer existiert. Andernfalls wird die betreffende Zeile vor dem Einfügen gelöscht. Wenn allerdings diese zu löschende Zeile eine noch offene FOR...TO-Anweisung oder ein noch nicht durch RETURN abgeschlossenes GOSUB enthält, so erfolgt ein CAN’T CONTINUE ERROR.

Die gleiche Fehlermeldung erscheint auch, wenn Sie eine Zeile löschen wollen, in der sich der DATA-Zeiger momentan befindet. Beispiel:
10 DATA56
20 READA:!INPUT(STR$(10))

Nach RUN erfolgt ein CAN’T CONTINUE ERROR, da sich der DATA-Zeiger in Zeile 10 befindet. Durch einen RESTORE-Befehl, läßt sich diese Zeile dennoch löschen:
10 DATA56
20 READA:RESTORE:!INPUT(”10”)

Nach Ausführung dieser beiden Zeilen ist die Zeile 10 gelöscht. Enthielt die gelöschte Basic-Zeile eine DEF-Anweisung, so gilt diese Funktion als nicht definiert. Enthielt die gelöschte Basic-Zeile eine Stringvariablenzuordnung der Art »AA$=”ABCD”« oder »A$(n)=”ABCDE”«, so ist anschließend die Variable nur noch als Leerstring definiert.

Soll der !INPUT-Befehl direkt nach einem THEN stehen, dann ist ein Doppelpunkt einzufügen »...THEN:!INPUT...«

### !GET

Format: !GET(z)

Funktion: Es wird die Basic-Zeile mit der Zeilennummer z in Stringformat geholt. Der Parameter z darf dabei nicht den Wert 0 haben. Beispiel:
10 REM !GET-DEMO
20 PRINT!GET(10):PRINT!GET(20)
30 A$ = !GET(30)
40 PRINT MID$(A$,!PLACE(A$,” ”) + 1)

### !NEXL

Format: !NEXL(z)

Funktion: Es wird die auf z folgende Basic-Zeilennummer geholt. Hat !NEXL(z) den Wert 0, so bedeutet dies, daß auf z keine Basic-Zeilen mehr folgen. Beispiel:
10 REM !NEXL-DEMO
20 REM SIMULATION DES LIST-BEFEHLS
30 Z = 0
40 Z=!NEXL(Z):IF Z = 0 THEN END
50 PRINT !GET(Z):GOTO 40

Zum Schluß noch einige Daten zu Stringy. Stringy belegt den Speicher von $c100 bis $c85a. Der Bereich von $c000 bis $c0ff dient als Stringzwischenspeicher (je nach Befehl wird dieser Raum benutzt). Die Speicherplätze $c85b bis $c865 dienen als Zwischenspeicher für einige wichtige Betriebssystemdaten. Der unter dem Basic-ROM liegende Speicherbereich wird mitbenutzt.

(Karl Szameitat/ev)

# Bücher

## Basic-Pragrammier-Handbuch

Wer sich endlich seine mehr oder weniger teure Computer-Anlage angeschafft hat, wird auch gerne die Kunst des Programmierens erlernen wollen. Die meisten Computerneulinge betätigen sich hier als Autodidakten, doch steht ihnen zumeist nur eine unzureichende Dokumentation im Handbuch zur Verfügung. Das nun in zweiter Auflage in deutscher Übersetzung erschienene »Basic-Programmier-Handbuch« aus der Reihe der Computer-Persönlich-Bücher ist ein weiteres Buch in der Masse der Literatur, die dem Neuling die Auswahl erschwert. Doch dieses Buch unterscheidet sich in einigen Punkten deutlich vom sonstigen Angebot.

Zunächst fällt einmal der Umfang dieser Einführung auf: Ganze 508 Seiten, in gut lesbarem Druck gesetzt, stehen dem Basic-Anfänger zur Durcharbeitung bevor. Doch das Arbeiten mit diesem Handbuch ist ausgesprochen leicht. Der Inhalt ist klar in Kapitel und Abschnitte unterteilt. Es beginnt mit einer allgemeinen Einführung in die Praxis der Programmierung, und über die Grundlagen der Programmierung bis hin zu den Höhen der Maschinencode-Programmierung wird dem Interessierten alles Wissenswerte vermittelt.

Im ersten Kapitel werden die Grundlagen einer Programmiersprache vermittelt, so die Ein- und Ausgabe und das Erstellen einfacher Listings. Im zweiten Kapitel werden dann Programmerstellung und -Steuerung vorgestellt. Alles wird mit einfachen, durchweg »netten« Beispielen verdeutlicht. Überhaupt findet sich in diesem Buch nicht der Ernst, der das Arbeiten mit anderen Veröffentlichungen manchmal schnell verleidet. Einige humorstische Abbildungen und ein leichter Schreibstil lassen dieses Handbuch zu einer Lektüre werden, bei der jeder neue Abschnitt mit anhaltendem Interesse angegangen wird.

Am Ende jedes Kapitels stehen einige Fragen, die den Lernerfolg bestätigen sollen. Die in den ersten beiden Kapiteln vermittelten Grundkenntnisse werden im dritten Kapitel anhand eines Spielprogramms vertieft und mit einigen Raffinessen angereichert.

In die Feinheiten von Basic führen dann die Kapitel vier und fünf ein, Stringfunktionen und Programmierhilfen lernt der Leser ebenso kennen wie den Umgang mit der Peripherie. Nachdem schließlich das Kapitel sechs ebenso wichtige wie interessante Funktionen und Routinen für eine gute Programmierung, wie Fehler-, String- und Variablenbehandlung vorstellt, wird im letzten Kapitel ein komplettes Programm entwickelt. Hier kann der inzwischen zum »Fast-Profi« gewordene Leser alle Kenntnisse anwenden, um den Zauberwürfel auf seinem Computer zu simulieren.

Ein umfangreicher Anhang, in dem die verschiedenen Zahlensysteme sowie Tips zum Speichersparen und Programmbeschleunigen ebenso aufgelistet sind wie die Lösungen zu den Aufgaben am Ende jedes Kapitels schließt das Buch dann ab.

In diesem Basic-Programmierhandbuch wird kein spezieller Basic-Dialekt zugrunde gelegt, jedoch finden sich viele Befehle und Funktionen, die auf einem Kleinstcomputer wohl kaum anzutreffen sind. Der Umfang und der verwendete Sprachschatz deuten hingegen an, daß dieses Buch auf Computer der gehobenen Klasse zugeschnitten ist. Da Dinge wie Grafik, Ton oder Peripherieansteuerung sehr rechnerspezifisch sind, wird im Buch nicht darauf eingegangen.

Wer also eine gut zu lesende allgemeine und noch dazu umfangreiche Einführung ins Basic-Programmieren sucht, für den ist dieses Buch das Richtige. Sowohl als Lektüre zwischendurch wie bei der Arbeit am Computer bietet es sich an. Die sehr übersichtliche Gestaltung lädt direkt zum Nachschlagen ein, womit der Titel durchaus seine Berechtigung findet.

(Bernd Schulte)

Mitchell Waite/Miachel Pardee, Basic-Programmier-Handbuch, Markt&Technik 1984, 506 Seiten, ISBN 3-922120-92-X, 78 Mark

## Das Maschinensprachebuch für Fortgeschrittene zum Commodore 64

Wer glaubt, daß das Thema »C 64« buchmäßig abgeschlossen sein müßte, wird von Data-Becker eines Besseren belehrt. Inzwischen sind über zwanzig Bücher dieses Verlags auf dem Markt. Eines davon ist das »Maschinensprachebuch für Fortgeschrittene zum Commodore 64«. Der Rückseitentext verspricht eine Einführung in die professionelle Maschinenspracheprogrammierung, angefangen bei der Problemanalyse, bis zu stets verwendbaren Tips und Tricks.

Wer jetzt erwartet, eine Art Lehrbuch oder Kursus zu bekommen, wird allerdings enttäuscht. Denn der tatsächliche Inhalt läßt sich grob in drei Teilgebiete aufteilen:

— Fließkommaarithmetik auf dem C 64 unter Ausnutzung schon vorhandener ROM-Routinen
— Interruptprogrammierung
— Selbstprogrammierte Basic-Erweiterungen

Diese drei Teilgebiete werden auf je zirka 70 Seiten ausführlich und mit sehr vielen Beispielen besprochen.

Dabei ist das Buch sehr verständlich geschrieben. So lernt man, wie versprochen, beim Lesen der einzelnen Kapitel und Ausprobieren der Beispiele, nicht nur etwas über die entsprechende Thematik, sondern auch über Maschinensprache im allgemeinen.

Nur ein Detail hat mir an diesem Buch mißfallen: Die ständige »Werbung« für den Data-Becker-Assembler Profimat.

Insgesamt kann ich das Buch folgenden zwei Gruppen wärmstens empfehlen:

Denen, die ihren C 64 besser kennenlernen wollen und denen ein ROM-Listing dazu nicht reicht, sowie denen, die gerne in Maschinensprache »weiterkommen« wollen.

(Boris Schneider)

Lothar Englisch, Maschinensprache für Fortgeschrittene, Data Becker 1984, 200 Seiten, 39 Mark

## PEEKs und POKEs zum Commodore 64

Die große Reihe der Data-Becker-Bücher zum Commodore 64 ist um ein Buch reicher geworden. Es handelt sich um »PEEKs & POKEs zum Commodore 64« des Autors Hans Joachim Liesert.

Dieses Buch erweckte sofort mein Interesse, versprach doch der Titel endlich einmal ein Werk, mit dessen Hilfe man sich durch den »POKE-Wald« des Commodore 64 kämpfen konnte, ohne dabei an den Rand des Wahnsinns zu gelangen.

Dieses Buch ist für Anfänger gedacht und beginnt mit einer lockeren Einführung in die Arbeitsweise des Mikroprozessors 6502 und schließlich des gesamten Computers. Da die Informationen sehr ausführlich und genau nahegebracht werden, wird auch der blutigste Einsteiger schon innerhalb kürzester Zeit das Konzept eines Mikrocomputers verstehen.

Nach den Grundlagen beginnt der Autor die wichtigsten Adressen des Speichers zu erläutern und die Funktionsweise anhand von Beispielen ausführlich darzustellen. Das fängt bei der Peripherieverwaltung an, geht über die Grafik und den Ton, bis hin zur Tastatur und schließlich zu Basic und Betriebssystem.

Da praktisch keine Vorkenntnisse verlangt werden und das Buch zudem sehr erfrischend und spannend geschrieben ist, wird auch der Anfänger bei der Lektüre nicht überfordert, und er wird schnell mit den Möglichkeiten seines C 64 vertraut.

Etwas negativ bewerte ich nur den »Minikurs« für Maschinensprache am Ende des Buches, der eigentlich überflüssig ist, da sich die Adressaten des Buches, die noch ihre Anfangsschwierigkeiten mit PEEK und POKE überwinden müssen, sicherlich nicht in der Lage sehen, auch schon in Maschinensprache einzusteigen.

Insgesamt sicher ein empfehlenswertes Buch, bei dem auch der wichtige Speicherbelegungsplan zum C 64 nicht fehlt.

(Karsten Schramm)

Liesert, Peeks & Pokes zum Commodore 64, Data Becker 1984, 150 Seiten, 29 Mark

# Auf das »!« kommt es an

> Das folgende Programm wurde aus der Not geboren. Es erleichtert das Laden von Diskette und macht das umständliche Laden und Listen des Directory überflüssig. Nebenher lernen Sie eine Reihe nützlicher Maschinenroutinen kennen.

Geht es Ihnen auch so: Ich weiß nie genau, ob das Programm, das ich laden willl, nun »Disk Copy V 1.0« oder »Disk Copy V1.0« heißt. Versuche ich es mit »Disk*«, lade ich mit Sicherheit »Disk Monitor«.

Es hilft also nichts: Ich lade das Directory, liste es und — ärgere mich, weil das Programm, das ich laden wollte, ganz oben steht und beim Scrollen verschwindet. Also nochmal »LIST«, dann mit dem Cursor in die richtige Reihe fahren, »LOAD« eingeben, Cursor hinter den Programmnamen, »,8«eintippen. Der Computer antwortet mit einem verächtlichen »SYNTAX ER-ROR«, weil ich den Doppelpunkt mal wieder vergessen habe...

Vielleicht stelle ich mich besonders dumm an, aber es sollte auch anders gehen. Für Tätigkeiten, die meine geistigen Fähigkeiten übersteigen, gibt es doch Computer! Aus diesem Gedanken entstand das Programm.

Es wird mit »LOAD”!”,8,1« geladen, startet automatisch, liest das Directory ein und schreibt hinter jedes Programm eine Nummer. Wenn der Bildschirm voll ist, wartet es auf meine Eingabe. Tippe ich »+«, bekomme ich die nächsten Programme angezeigt. Tippe ich aber die Programmnummer und dahinter ein »L«, wird das entsprechende Programm automatisch geladen. Handelt es sich um ein Maschinenprogramm, das absolut geladen werden muß (mit »,8,1«), tippe ich hinter die Nummer ein »A«.

## So funktioniert es

Da ich nicht auf einen Autostart verzichten wollte, mußte das Programm vollständig in Maschinensprache geschrieben werden. Außerdem mußte es sehr kurz sein, denn ich hatte nur den Bereich von Speicherstelle 2 56 bis 600 ($0100 — $0258) zur Verfügung. Zu allem Unglück benötigen die Betriebssystemroutinen, die das Programm verwendet, auch noch Platz in diesem Bereich (Prozessorstack). Deshalb mußte ich auf alles verzichten, was nicht unbedingt nötig war. Es gibt also kein Menü für den Benutzer, ebenso keine Möglichkeit, das Programm zu unterbrechen, wenn man nichts laden will. Man kann nur »OL« eingeben, dann springt es mit einer Fehlermeldung ins Basic zurück. Trotzdem ist der verfügbare Speicher bis auf das letzte Byte belegt.

Die folgende Programmbeschreibung ist zwangsläufig sehr theoretisch. Das Programm läuft ja aber auch, wenn man sie nicht versteht. Machen Sie sich aber ruhig einmal die Mühe. Vielleicht können Sie doch den einen oder anderen nützlichen Tip bekommen. Wem es zu kompliziert wird, der kann bei den »Hinweisen zum Abtippen« weiterlesen.

Nehmen Sie also das Assembler-Listing zur Hand und folgen Sie mir in die Tiefen der Maschinensprache... Zur besseren Übersicht habe ich die einzelnen Teile beschrieben und immer die entsprechenden Zeilennummern dahintergesetzt.

Im Programmkopf bis Zeile 320 werden die Betriebssystemroutinen und die Variablen definiert. Sie sind nochmals im Kasten erläutert. Als Startadresse wird $010A festgelegt, der Maschinencode kann aber nicht direkt dorthin assembliert werden, sonst würde ja der Autostart anlaufen. Deshalb wird er zunächst in den Bereich $C00A — $C158 geschrieben.

Das Programm selbst beginnt mit Zeile 1510. Die Routine »DIRIN« lädt das Directory in den Speicher. Dazu benutzen wir die Betriebssystemroutine »LOAD«. Diese braucht zur Vorbereitung die Routinen SETLFS und SETNAM. SETLFS bestimmt die logische Filenmmer (01), die Geräteadresse (08) und die Sekundäradresse (0 für Lesen). SETNAM übergibt den Filenamen, in unserem Falle »$«. LOAD muß schließlich noch wissen, wohin das Directory geladen werden soll. Diese Adresse (Anfang des Basic-Speichers, steht in ($2B/$2C) wird im X- und Y-Register übergeben. Um die richtigen Koppeladressen zu erhalten, muß anschließend noch die Basic-Routine aufgerufen werden, die das für uns erledigt ($A533). Jetzt steht unser Directory genauso im Speicher wie sonst und wartet darauf, auf dem Bildschirm ausgegeben zu werden.

Die Ausgabe kann aber nicht wie beim normalen Listen erfolgen, denn wir wollen ja hinter jedem Namen eine Nummer ausgeben. Also müssen wir das selbst in die Hand nehmen. Mit einem kühnen Sprung geht es deshalb jetzt nach DIROUT. Sehen wir uns nun den Speicherausdruck eines Directory etwas genauer an:

Es geht los bei $0801. Dort steht die Adresse des nächsten Eintrages $081F. Wie immer steht im Speicher zuerst das Low-Byte und dahinter das High-Byte. Es folgt der Diskettenname, der in diesem Falle mit dem des Verfassers auffallend übereinstimmt. Der erste Eintrag beginnt also mit Adresse $081F. Dort finden wir wieder die Adresse des nächsten Eintrages ($083F). Jeder Eintrag hat übrigens die gleiche Länge, nämlich 32 Byte. Wir werden davon später noch Gebrauch machen.

Die 2 Byte hinter der Koppeladresse enthalten die Länge des Programms in Blöcken, in unserem Falle also $0002. Nun kommen ein paar Leerzeichen ($20). Wieviele, hängt davon ab, ob die Blocklänge ein, zwei oder drei Ziffern benötigt. Die Namen sollen ja beim Listen schließlich ordentlich untereinander stehen. Jetzt folgt der Filename, von Anführungszeichen eingeschlossen. 8ie haben es sicher schon bemerkt: Das Directory dieser Diskette hat als erstes Programm das »!« wie sich das für anständige Disketten gehört!

Jetzt wieder einige Leerzeichen und schon ist der nächste Fileeintrag erreicht. Das geht so weiter bis eine Koppeladresse erreicht wird ($089D in Adresse $087F), die aus dem Rahmen fällt. In Adresse $089D stehen nämlich zwei jämmerliche Nullen. 8o, sagt sich das Betriebssystem, jetzt ist aber Schluß. Und es hat wie so oft recht...

Zurück zu unserem Programm. Es soll ja jetzt ein Directory auf den Bildschirm ausgeben, und zwar schöner, als es das Betriebssystem jemals könnte. Wir initialisieren also unsere Variable USE mit dem Basic-Anfang ($0801). In Zeile 390 beginnt eine Schleife, die immer eine Zeile ausgibt. Zuerst holen wir uns die Koppeladresse und speichern sie in NEXT (Zeile 410 — 460). Als nächstes müssen wir die 2 Byte mit der Blocklänge in eine ordentliche Dezimalzahl umwandeln. Das erledigt für uns die Basic-Routine »NUMOUT« (470 — 520). Jetzt brauchen wir nur noch den Namen mit allen Leerzeichen davor und dahinter, auszugeben (530 — 580).

Eigentlich müßte nun die Programmnummer ausgegeben werden, aber damit warten wir noch. Aus folgendem Grund: Wir wollen diese Schleife ja für jede Zeile benützen, auch für die letzte. In der steht aber die »BLOCKS FREE«-Meldung und dahinter darf ja keine Nummer mehr erscheinen. Wir müssen also vorher prüfen, ob wir schon die letzte Zeile erreicht haben.

Dazu übertragen wir die Adresse des nächsten Files, die wir in NEXT aufbewahrt haben, nach USE. Zeigt USE jetzt auf eine Null, sind wir fertig und springen ans Ende unserer Routine, nach DIR4 (590 — 650). Ist das aber noch nicht der Fall, geben wir unsere Programmnummer aus. Den Cursor stellen wir dazu auf Spalte 27 ($1B) und benutzen wieder NUMOUT, um FILENR als Dezimalzahl auszugeben (660 — 700). Eine Zeile wäre geschafft! Im folgenden bereiten wir uns auf die nächste Filenummer vor und springen wieder nach oben zu DIR1 zurück. Sollten aber schon 20 Zeilen auf dem Bildschirm stehen, merken wir uns im ENDFLG, daß wir noch nicht fertig sind und verlassen die Ausgaberoutine vorerst. Erinnern Sie sich, wir wollten vermeiden, daß der Bildschirm ohne unseren ausdrücklichen Befehl wegscrollt (710 — 800).

Der Bildschirm hat sich inzwischen gefüllt, unsere Nummern stehen fein säuberlich hinter den Programmen, nun sollte uns ein freundlich blinkender Cursor dazu animieren, dem Computer mitzuteilen, wie es weitergehen soll. Also hinein in die Routine WAHL

Das Wichtigste erledigt hier die Betriebssystemroutine CHRIN. Sie läßt den Cursor blinken, bis »RETURN« gedrückt wird, schreibt die eingegebenen Zeichen auf den Bildschirm und liest sie anschließend vom Bildschirm wieder ab, damit wir sie schön der Reihe nach bearbeiten können. Wir speichern alle Zeichen zunächst im BUFFER und sehen uns dann das letzte Zeichen genauer an (820 — 900). Als erstes prüfen wir, ob ein »+« eingegeben wurde. Wenn ja, setzen wir FILEANZ wieder auf Null, und, je nachdem ob das ENDFLG Ende signalisiert oder nicht, auch die FILENR. Anschließend erfolgt der Rücksprung in die Directory-Ausgabe (910 — 980).

Wurde kein »+« eingegeben, prüfen wir weiter auf »L« beziehungsweise »A«. In Abhängigkeit davon setzen wir das ABSFLG (990 — 1070). Jetzt müssen wir herausfinden, welche Programmnummer geladen werden soll. Dazu müssen wir die ein oder zwei Dezimalzahlen in ein Hexbyte umwandeln, weil unser Computer nun mal nichts anderes versteht. Andererseits ist es ja nicht einzusehen, daß wir uns auf sein mathematisches Niveau herabbegeben und unsere Zahlen demnächst als Hex- oder noch schlimmer als Binärzahlen eingeben. Das Umwandeln ist ja gar nicht so schwierig. Wir holen uns die Einerziffer und zählen dann so oft 10 ($0A) dazu, wie die Zehnerziffer angibt. Da der Computer sich unsere Ziffern aber nicht als 0,1...9 merkt, sondern als $30, $31... $3A, müssen wir jeweils die oberen 4 Bits ausmaskieren. Das war’s denn auch schon. In FILENR steht zur Belohnung tatsächlich die gewünschte Filenummer mundgerecht für unseren Computer (1080 — 1200).

Jetzt haben wir das Schlimmste — fast — hinter uns. Wir brauchen nur noch den passenden Filenamen zu suchen. Den holen wir uns aus dem Directory. In bewährter Weise benutzen wir unsere Variable USE. Um den Diskettennamen zu überlesen, zählen wir zum Basic-Anfang in $2B/$2C 35 ($23) dazu. Damit liegen wir so ungefähr richtig, auf jeden Fall vor dem ersten Namen. Erinnern sie sich, jeder Eintrag im Directory belegt genau 32 Byte. Allerdings beginnen die Filenamen nicht immer so schön regelmäßig wie in unserem Beispiel, immer an der selben Stelle. Wir müssen den Anfang des Namens also noch genau suchen. Vorher brauchen wir aber erst einmal die richtige Stelle im Directory. Wir addieren zu USE jetzt daher so oft 32 ($20), wie in FILENR angegeben (1250 — 1400).

Jetzt müssen wir in unserem Programm ein Stück überspringen, weil die folgenden Bytes wegen des Autostarts auf 2 gesetzt werden müssen. Weiter geht es mit LAD2 in Zeile 1780. Vorher steht allerdings im Programm noch die Subroutine FIN-DA.E, was so viel wie »Finde den Anfang beziehungsweise das Ende des Namens« bedeutet. Sie durchsucht den Text, auf den USE zeigt, nach einem Anführungszeichen und übergibt im Akku, wieviel Zeichen es bis dahin sind (1680 — 1750).

Diese Zahl addieren wir zu USE — eins mehr, denn das Anführungszeichen selbst gehört ja nicht mit zum Namen. Mit FINDA.E erhalten wir im Akku die Länge des Namens, so wie es die Routine SETNAM, die wir oben schon benutzt haben, verlangt. Noch ein kurzer Sprung nach SETLFS, wo wir in Abhängigkeit vom ABSFLG als Sekundäradresse Null oder Eins übergeben. Den Rest erledigt die Basic-Routine BASICLOAD (1780—1940). Geschafft, die schönste Zeile im Assemblerlisting ist erreicht: .EN heißt ENDE.

Sicher, es war nicht ganz einfach, aber wenn Sie mir bis hierhin gefolgt sind, haben Sie eine ganze Reihe kleiner Routinen gelernt, wie sie in jedem Maschinenprogramm gebraucht werden.

TODO table!
NUMOUT ($BDCD) — wandelt zwei Hexbytes in eine Dezimalzahl um und gibt sie aus. (HByte im Akku, LByte im X-Reg)
SETLFS ($FFBA) — übergibt logische Filenummer (Akku), Geräteadresse (X-Reg) und Sekundäradresse (Y-Reg).
SETNAM ($FFBD) — übergibt den Filenamen. Akku enthält die Länge des Namens, X-Reg das LByte, Y-Reg das HByte der Adresse, an der der Name beginnt.
LOAD ($FFD5) — lädt das durch SETLFS und SETNAM bezeichnete File an die Adresse, die im X-Reg (LByte) und im Y-Reg (HByte) angegeben ist. Der Akku enthält 0 für LOAD und 1 für VERIFY.
CHRIN ($FFCF) — holt Zeichen von dem in $99 festgelegten Eingabegerät. Der Cursor blinkt, bis RETURN eingegeben wird. Die Zeichen werden dann vom Bildschirm gelesen und im Akku übergeben.
CHROUT ($FFD2) — gibt das ASCII-Zeichen im Akku aus.
Variable
BUFFER — ist ein Zwischenspeicher.
USE und NEXT — enthalten die Adresse des gegenwärtigen beziehungsweise nächsten Directory-Eintrages.
FILENR — ist die aktuelle Filenummer im Directory.
ABSFLG — ist ein Flag, das normales oder absolutes Laden signalisiert. FILEANZ — enthält die Anzahl der auf dem Bildschirm ausgedruckten Files.
ENDFLG — ist ein Flag, das signalisiert, ob das Ende des Directory bereits erreicht ist.

Betriebssystem-Routinen

### Hinweise zum Abtippen

Das Programm kann nicht an die Stelle geschrieben werden, an der es endgültig stehen soll, weil sonst ja der Autostart anlaufen würde. Wir schreiben es daher zuerst nach 49152 ($C000). Tippen Sie zuerst den Basic-Lader ein. Nach RUN muß der Text aus Zeile 30 erscheinen, sonst haben Sie einen Fehler gemacht. Legen Sie nun eine neue Diskette ein, und drücken Sie eine Taste. Das Programm wird nun auf die Diskette geschrieben, allerdings mit der falschen Startadresse. Schalten Sie danach bitte den Computer aus und wieder ein. Um die falsche Startadresse zu ändern, geben Sie das Programm »Startadresse« ein und starten Sie es mit RUN. Jetzt wird die Adresse geändert, und Sie haben das »!«lauffähig auf Ihrer Diskette. Um es auf andere Disketten zu übertragen, verwenden Sie ein Kopierprogramm, zum Beispiel »Super Copy«.

Und dann lehnen Sie sich zurück, geben LOAD »!«,8,1 ein und genießen die Früchte Ihrer Arbeit.

(Dietrich Weineck/rg)

# Spielen in der dritten Dimension

> »3D-Vier gewinnt« ist eine interessante Variante des bekannten Strategiespiels. Bemerkenswert ist auch, daß der Autor ohne Steuerzeichen ausgekommen ist.

Bei »3D-Vier gewinnt« setzen die beiden Spieler abwechselnd einen Spielstein auf eines der 16 Felder, die in vier Reihen und vier Spalten angeordnet sind. Hierbei werden Türme von maximal vier Steinen Höhe gebildet. Sieger ist, wer als erster eine beliebige Reihe oder Diagonale — auch Raumdiagonale — mit vier Steinen besetzt. Sollten zuvor alle 64 möglichen Felder besetzt sein, so geht das Spiel unentschieden aus.

### Zum Programm:

Man kann wahlweise gegen einen Spielpartner oder, bei unterschiedlicher Spielstärke, gegen den Computer antreten. Der Computer benötigt hierbei, obwohl das Programm in reinem Basic geschrieben ist, weniger als zehn Sekunden Bedenkzeit. Es ist auch möglich, den Computer sich selbst zu überlassen. Das Programm übernimmt die dreidimensionale Darstellung, überwacht die Korrektheit der Züge und ermittelt den Sieger.

Während des Spieles kann man sich jederzeit vom Computer einen Zugvorschlag holen, der allerdings mit Vorsicht zu genießen ist (da Spielstärke 1 voreingestellt ist) und auf Wunsch die Seiten wechseln. Alle nötigen Eingaben werden im Dialog erfragt. Bleibt nur zu erklären, wie man einen Zug ausführt: Während des Spieles ist in der linken Bildschirmhälfte die dreidimensionale Darstellung des Spielfeldes zu sehen. Rechts erscheint in schematisierter Form eine Draufsicht auf das Spielfeld, wobei in deren unteren linken Ecke ein Cursor erscheint. Dieser läßt sich nun, entweder mit einem Joystick in Port 2 oder mittels der Cursortasten an die gewünschte Position dirigieren. Drückt man nun den Feuerknopf beziehungsweise die Return-Taste, wird der gewünschte Zug — sofern er den Regeln entspricht — ausgeführt.

Bei Spielende ertönt eine kleine Melodie, und das Programm verdeutlicht durch Blinken der entsprechenden Spielsteine die Gewinnsituation. Außerdem wird der Name des Siegers angezeigt. Durch Drücken einer beliebigen Taste startet man ein neues Spiel.

### Detailbeschreibung — Spielstrategie:

Jedes Feld ist durch eine x-, y- und z-Koordinate eindeutig bestimmt. Damit der Computer etwas zu rechnen hat, wird jedem möglichen Zustand der einzelnen Felder ein Zahlenwert zugeordnet, der im dreidimensionalen Feld FE gespeichert wird. Hierbei bedeutet
3 = das Feld ist von Spieler 2 besetzt
2 = das Feld ist von Spieler 1 besetzt
1 = das Feld ist unbesetzt, kann aber im nächsten Zug besetzt werden
0 = unbesetztes Feld

Ist der Computer am Zug oder wird ein Zugvorschlag gewünscht, geschieht folgendes: Der Computer berechnet für jedes mögliche Feld (FE(X,Y,Z)=1) eine Bewertung (im Programm ab Zeile 2000) und entscheidet sich dann für das Feld mit der höchsten Bewertung. Mit einem kleinen Trick wurde der Zeitaufwand hierfür minimiert: Für die Entscheidung, ob ich in die linke untere Ecke setze, ist es unwesentlich, wie es rechts oben aussieht. Das Programm bewertet also jede Viererreihe getrennt und ermittelt die Bewertung eines Feldes als Summe der Bewertungen aller Viererreihen, an denen dieses Feld beteiligt ist. Der große Zeitvorteil ergibt sich jetzt dadurch, daß nach jedem Zug nur einfach jene Reihen neu bewertet werden müssen, in denen sich wirklich etwas geändert hat (ab Programmzeile 2 500).

Bei der Spielstärke 2 wird im Gegensatz zur Spielstärke 1 mit berücksichtigt, daß das darüberliegende Feld im nächsten Zug vom Gegner besetzt werden kann. Deshalb wird dieses Feld (mit negativem Vorzeichen) ebenfalls bewertet. Dadurch verdoppelt sich allerdings die Bedenkzeit bei Spielstärke 2.

In den Programmzeilen 3010, 3100 und 3180 steht der Aufruf »SYS 58732«. Hierbei handelt es sich um eine Betriebssystem-Routine, die nach der Cursorpositionierung (durch Setzen der Speicherstellen 211 und 214) die Bildschirmparameter neu bestimmt.

(Uwe Weiß/rg)

# Druckfehlerteufelchen

### Hardcopy mit dem VC 1520, Ausgabe 7/84, Seite 108

Die korrekte Zeile lautet:
POKE44,64:POKE64*256, 0:NEW
und nicht 64-256!

### Einzeiler, Ausgabe 11/84, Seite 155

Die Spaces bei dem Einzeiler DI-AS müssen als Shift-Space eingegeben werden.

### Die Ebenen des Absturzes, 11/84, Seite 93

Das letzte Datum in Zeile 360 (Programm UNNEW) lautet 255.

### User-Port-Tastatur, Ausgabe 10/84, Seite 93

Das Datum 28 in Zeile 880 muß in 82 umgewandelt werden.

### FLIST, Ausgabe 10/84, Seite 90

Der Hinweis für Druckerbesitzer muß natürlich lauten:
OPEN1,4:CMD1:FLIST und nach dem Drucken: PRINT#1:CLOSE1

Außerdem bin ich durch Zufall auf einen Programmfehler gestoßen, der bei aktivem Programm auftritt und bei einer Variablenzuweisung, bei der die Variable mit F beginnt einen SYNTAX ERROR erzeugt (zum Beispiel beiF=l, FX = 100 etc.).

Dies kann man auf zwei Arten verhindern:

Entweder schaltet man die Erweiterung vor dem Starten eines Basic-Programms durch SYS 58451 ab, oder man ändert den Basic-Lader wie folgt:

Den Endwert der FOR-NEXT-Schleife auf 981 setzen, in Zeile 230 den letzten Wert 8 durch 195 und in Zeile 240 den ersten Wert 175 in 3 abändern.

Dann fügt man diese DATA-Zeilen an:
440 DATA 56,165,122,233
450 DATA 1,133,122,165
460 DATA 123,233,0,133 470 DATA 123,32,121,0 480 DATA 76,231,167

Michael Weidlich

### So macht man Basic-Programme schneller, Ausgabe 10/84, Seite 55

Bei den Versionen 1 für C 64 und VC 20 wurde in den Zeilen 40 jeweils nach dem Z ein »,1« vergessen. Also: 40 POKE 7680 + Z,1: POKE 38400 + Z,6 etc.
Seite 58, Version 13: 40 PRINT"A”;

### MSD-Super-Disk-Drive, Ausgabe 11/84, Seite 15

Die vollständige Bezugsadresse von Softline lautet: Softline, Schwarzwaldstraße 8a, 7602 Oberkirch, Tel.: 07802/3707

### Titelfoto, 11/84, Seite 1

Das Titelfoto dieser Ausgabe wurde von Limelight Studio, Karolinenstraße 3, 8000 München 22, Tel.: 0 89/22 23 97 erstellt.

# Dem Klang auf der Spur – Teil 1

> Im C 64 steckt jede Menge Musik. Doch wie man dem Heimcomputer die richtigen Klänge entlockt, wissen viele nicht. Sie erfahren es in diesem Kurs.

Zunächst wollen wir ein wenig auf die Hardware und auf die Grundzüge der Tonerzeugung eingehen. Zuständig für den Sound des C 64 ist ein unscheinbares kleines Chip, das als SID (Sound Interface Device) bezeichnet wird. Dieser hochentwickelte Synthesizerbaustein enthält drei Stimmen, die ein Synthi-Freak als DCOs (Digital Controlled Oscillators) bezeichnet. Sie realisieren polyphone (mehrstimmige) Klänge oder Sequenzen. Für jeden dieser Oszillatoren stehen vier Wellenformen zur Verfügung (Bild 1).

## Wellenformen

Ein gespielter Ton besteht aus einer Grundfrequenz, sowie den Obertönen. Die Tonhöhe wird durch die Grundfrequenz bestimmt. Oberwellen sind Sinusschwingungen, deren Frequenzen ein ganzzahliges Vielfaches der Grundfrequenz sind. Ein monophoner Klang besteht also aus einer Grundfrequenz und seinen Obertönen. Eine Ausnahme hiervon bildet das Rauschen, bei dem es sich um ein Frequenzgemisch handelt.

Ein akustisches Instrument, wie etwa ein Klavier oder eine Trompete, hat eine komplizierte Oberwellenstruktur. Diese kann sich beim Spielen auch ändern, zum Beispiel bei einem Klavier: Der Anschlag eines Klaviertones ist relativ obertonreich, die Note klingt dann jedoch dumpf aus. Im folgenden möchten wir auf die im SID vorhandenen Wellenformen kurz eingehen:

### 1.	Die Dreieckschwingung:

Diese Wellenform ist der Sinusschwingung sehr ähnlich. Die Dreieckswelle enthält ebenfalls sehr wenig Obertöne. Der Klang erinnert an eine Holzflöte.

### 2.	Die Sägezahnschwingung:

Diese Welle enthält alle Oberwellen und klingt daher sehr hell. Sie erinnert vom Klang her an eine Violine.

### 3.	Die Rechteckschwingung:

Dies ist eigentlich die vielseitigste Wellenform. Durch Änderung der Pulsbreite lassen sich extreme Klangveränderungen erzielen. Der Grundton erinnert an eine Klarinette.

### 4.	Weißes Rauschen:

Dieses Frequenzgemisch läßt sich insbesondere in Verbindung mit dem Filter sehr vielseitig für Geräuscheffekte einsetzen. Beispielsweise zur Imitation eines Schlagzeugs.

## Filter

Zur Beeinflussung eines Klanges fehlt jetzt noch ein Filter. Er verändert den Oberwellengehalt einer Welle. Der SID besitzt drei verschiedene solcher Filter: einen Tiefpaßfilter, einen Bandpaßfilter und einen Hochpaßfilter. Diese werden unabhängig voneinander oder auch kombiniert verwendet.

### 1. Tiefpaßfilter:

Dieser Filter läßt alle tieferen Töne passieren, während er die hohen Freqenzen abschwächt. Dieser »Effekt« wird durch eine variierbare Grenzfrequenz des Filters geregelt. Man bestimmt mit ihm, wieviele Obertöne zum Beispiel aus einer Sägezahnschwingung herausgefiltert werden. Durch eine Filterung der Obertöne lassen sich Instrumente gut imitieren.

### 2.	Hochpaßfilter:

Dieser Filtertyp schwächt die tieferen Töne stark ab (nämlich wie der Tiefpaß genau um 12 dB). Durch Hochpaßfilter geformte Klänge klingen sehr »dünn«, da ihnen jegliches Baßfundament fehlt.

### 3.	Bandpaßfilter:

Der Bandpaßfilter läßt nur ein schmales Frequenzband hindurch, während er alle übrigen Frequenzen abdämpft. Die Klangergebnisse sind ähnlich wie beim Hochpaß, also sehr dünn. Dieser Filter besitzt eine Flankensteilheit von nur 6 dB.

### 4.	Notchfilter:

Der Notchfilter ist eine Kombination aus Hochpaß- und Tiefpaßfilter und gilt deshalb meist nicht als eigenständiger Filtertyp. Er heißt auch Bandsperre und übernimmt genau die umgekehrte Funktion eines Bandpaßfilters. Er schwächt ein kleines Frequenzband ab, während er alle restlichen Frequenzen durchläßt.

### Die Hüllkurve:

Um zum Beispiel ein Klavier zu imitieren. genügt es nicht, den Klang durch Einsatz von Filtern nachzuahmen. Auch der Lautstärkeverlauf eines Instruments muß berücksichtigt werden. Ein charakteristischer Klavierton hat einen harten Anschlag und klingt dann bald aus. Um diesen Lautstärkeverlauf nachzuahmen, bedient man sich in den meisten Synthesizern eines Hüllkurvengenerators (ADSR).

## ADSR

ADSR ist die Abkürzung für Attack-Decay-Sustain-Release. Man hat den Lautstärkeverlauf einfach in vier Phasen aufgeteilt. Attack nennt man die Zeit, die ein Ton benötigt, um seine Spitzenlautstärke zu erreichen. Die Zeit, in der der Ton wieder auf ein geringeres Lautstärkeniveau abfällt, nennt man Decay. Den Bereich mit dem geringeren Volumenpegel nennt man Sustain. Soll der Ton nachklingen, wie etwa bei einem Klavier mit gedrucktem Dämpferpedal, dann wird dies durch Release erreicht. Zum besseren Verständnis haben wir alle vier Parameter auf einem Schaubild zusammengefaßt (Bild 2). In der nächsten Ausgabe werden wir intensiv auf den Sound und seiner Programmierung am C 64 eingehen.

(Bernhard Carli/Christian Spitzner/aa)

# Memory Map mit Wandervorschlägen, Teil 2

> Bei der Durchforstung der ersten 1024 Speicherzellen werden wir in dieser Folge die Adressen 3 bis 17 etwas genauer beleuchten.

Das letzte Mal hatten die besprochenen Speicherzellen verschiedene Bedeutungen für VC 20 und C 64.

Ab diesmal, also ab Speicherzelle 3 über mehrere Folgen dieser Serie hinaus bis zur Speicherzelle 672 gelten alle Angaben für beide Computer, zumindest was die Bedeutung der Zellen betrifft. Ihr Inhalt kann entsprechend der verschiedenen Adressen der Betriebssysteme Voneinander abweichen. Wie üblich werde ich natürlich jeweils darauf aufmerksam machen.

### Adresse 3 und 4 ($3 — $4)<br>Vektor auf die Routine zur Umwandlung einer Gleitkommazahl in eine ganze Zahl mit Vorzeichen

In diesen beiden Speicherzellen steht also ein Vektor. Was das ist, wird in der Tabelle 1 näher erläutert. Beim VC 20 deutet dieser Vektor auf die Adresse 53674 ($D1AA), beim C 64 auf 45482 ($B1AA). Sie können das mit PRINT PEEK (3) + 256*PEEK (4) leicht nachprüfen. Ab diesen Adressen beginnt im Basic-Übersetzer (Interpreter) ein Programm, welches — natürlich in Maschinensprache — eine Gleitkommazahl in eine ganze Zahl umwandelt.

Diejenigen Leser, welche mit Gleitkommazahlen nicht so vertraut sind, möchte ich auf die Tabelle 2 verweisen. Er ist nur eine kleine Einführung. Später, bei der Behandlung der Speicherzellen 97 — 102 werde ich im Detail auf die externe und interne Darstellung und Verwendung von Gleitkommazahlen eingehen.

Dieses Umwandlungsprogramm steht nicht nur den Maschinen, sondern auch den Basic-Programmierern zur Verfügung, allerdings nur über den USR-Befehl und da auch nur, wenn der »Floating Point Accumulator« # 1 (FAC1) in den besagten Adressen 97 bis 102 mitbenutzt wird. Ich verschiebe daher alle weiteren Details auf unsere Ankunft bei diesen Speicherzellen.

Bis dahin haben Sie hoffentlich auch den Assemblerkurs weiter verfolgt, die Assembler-, Dissassembler- und Monitorprogramme eingetippt und können damit arbeiten. Dann können wir viel besser den ganzen Zusammenhang verfolgen.

### Adresse 5 und 6 ($5 - $6)<br>Vektor auf die Routine zur Umwandlung einer ganzen Zahl in eine Gleitkommazahl

Dieses Programm ist die Umkehrung der oberen Routine. Es beginnt beim VC 20 ab Speicherzelle 54161 ($D391), beim C 64 ab 45969 ($B391). Da hier prinzipiell dasselbe gilt wie oben, möchte ich nur kurz den Vorteil beleuchten, den derartige Vektoren haben. Eigentlich könnten wir direkt auf die im Vektor enthaltenen Adressen springen — wenn wir sie kennen.

Ein Sprung auf die Adresse des Vektors erlaubt uns jedoch immer die völlige Ignoranz seines Inhalts — und Commodore erlaubt die Änderung der Adressen im Basic-Übersetzer, wie es ja beim C 64 gegenüber dem VC 20 auch gemacht worden ist, ohne daß vorhandene Programme umgeschrieben werden müssen.

### Adresse 7 ($7)<br>Suchzeichen zur Prüfung von Texteingaben in Basic

Diese Speicherzelle wird viel von denjenigen Basic-Routinen als Zwischenspeicher benützt, die den direkt eingegebenen Text absuchen, um Steuerzeichen (Gänsefüße, Kommata, Doppelpunkte und die Zeilenbeendigung durch die RETURN-Taste) rechtzeitig zu erkennen. Normalerweise wird in der Zelle 7 der ASCII-Wert dieser Zeichen abgelegt. Die Speicherzelle 7 wird aber auch von anderen Basic-Routinen benützt. Sie ist daher für den Programmierer praktisch nicht zu verwerten.

### Adresse 8 ($8)<br>Suchzeichen speziell für Befehlsende und Gänsefüße

Wie Speicherzelle 7 dient auch die Zelle 8 als Zwischenspeicher für Basic-Texteingabe und zwar während der Umwandlung von Basic-Befehlen in den vom Computer verwendeten Befehlscode (Tokens). Die Speicherzelle 8 ist vom Programmierer nicht verwertbar.

### Adresse 9 ($9)<br>Spaltenposition des Cursors vor dem letzten TAB- oder SPC-Befehl

Speicherzelle 9 wird von den Basic-Befehlen TAB und SPC verwendet. Vor ihrer Ausführung wird die Nummer der Spalte, in der sich der Cursor befindet, aus der Speicherzelle 211 ($D3) nach 9 gebracht, von wo sie geholt wird, um die Position des Cursors nach der Ausführung von TAB und SPC auszurechnen.

Diese komplizierte Erklärung können wir durch Ausprobieren deutlicher machen. Dazu PRINTen wir 16mal den Buchstaben X hintereinander (Semicolon !), allerdings mit SPC (2) jeweils um 2 Spalten versetzt.
10 FOR I = 0 TO 15
20 PRINT SPC (2) ”X”;
30 PRINT PEEK (9);
40 NEXT I
Nach jedem X wird durch Zeile 30 die »alte« Cursor-Spaltenposition ausgedruckt und zwar in derselben Zeile, ausgelöst durch das Semicolon. Dadurch erhöht sich laufend die in Speicherzelle 9 stehende Positionsangabe des Cursors. Wir erhalten folgenden Ausdruck:

Sie können die Positionsnummer nachrechnen. Berücksichtigen Sie bitte aber dabei, daß bei PRINT vor und nach jeder Zahl eine Stelle frei bleibt, die erste für das Vorzeichen, die zweite wegen des Abstandes.

Wichtig ist außerdem, daß die maximal mögliche Spaltenzahl nicht die Bildschirmspaltenzahl, sondern die »logische« Spaltenzahl ist, also 88 beim VC 20 und 80 beim C 64.

Wir können die Cursorposition in Adresse 9 auch abfragen und ein Programm damit steuern. Fügen Sie einfach in das obige Programm die folgende Zeile 35 ein:
35 IF PEEK (9) = 33 THEN PRINT »END«: END

Sobald Position 33 erreicht ist, bleibt das Programm stehen.

### Adresse 10 ($A)<br>Flagge für LOAD oder VERIFY

In Zelle 10 steht eine 0, wenn geladen wird und eine 1 bei einem VERIFY. Warum das so ist, will ich kurz erläutern:

Die Basic-Routinen für LOAD beziehungsweise für VERIFY sind völlig identisch. Was das Betriebssystem hinterher daraus machen muß, ist natürlich unterschiedlich. Das Basic erspart sich eine doppelte Routine, zeigt aber mit der Flagge in Speicherzelle 10 den Unterschied an.

Erwähnenswert ist noch, daß das Betriebssystem in einer Art Nationalismus seine eigene Flagge aufzieht: Den Unterschied zwischen LOAD und VERIFY speichert es seinerseits in Zelle 147 ($93) ab. Soweit ich es sehen kann, sind Inhalt und Bedeutung beider Speicherzellen völlig identisch.

Ich habe für Sie zwar kein Kochrezept zur Anwendung der LOAD-VERIFY-Flagge in einem Programm vorrätig, möchte Sie aber trotzdem ein bißchen zum Spielen anregen. Um meine Erklärung nachzuvollziehen, tippen Sie bitte direkt LOAD ein. Den Ladevorgang brechen Sie mit der STOP-Taste ab und fragen dann den Inhalt der Zelle 10 ab mit

PRINT PEEK (10) Wir erhalten eine 0. Wiederholen Sie bitte diesen Vorgang, aber mit VERIFY. Wir erhalten jetzt eine 1 — Quod erat demonstrandum.

Wir können auch in die Zelle 10 hineinPOKEn. Die »Wachablösung« zwischen Basic und Betriebssystem unter Hissen der Flagge in Zelle 10 findet beim VC 20 in der Speicherzelle 57705, beim C 64 in 57708 statt. Bevor wir diese Maschinenroutine mit SYS 57705 (SYS 57708) starten, geben wir mit dem Inhalt der Speicherzelle 10 an, ob es ein LOAD oder ein VERIFY sein soll.

Legen Sie ein Band mit Programm in die Datasette. Um ein LOAD zu erzeugen, geben wir direkt ein:
POKE 10,0:SYS 57705
(POKE 10,0:SYS 57708)
Entsprechend der Anweisung auf dem Bildschirm drücken Sie PLAY und das Auffinden des ersten Programms wird mit LOAD gemeldet. Machen Sie das Ganze noch einmal, diesmal aber POKEn Sie bitte eine 1 in die Zelle 10. Jetzt meldet das Betriebssystem das Auffinden des Programms mit VERIFY.

Wie gesagt, vielleicht fällt Ihnen eine Anwendung dafür ein.

### Adresse 11 ($B)<br>Flagge für den Eingabepuffer/Anzahl der Dimensionen von Zahlenfeldern (Arrays)

Alle Buchstaben und Zeichen, die mit der Tastatur direkt eingetippt werden, kommen in einen Eingabe-Pufferspeicher. Er beginnt ab Speicherzelle 512 ($200). Sobald die RETURN-Taste gedrückt wird, wandelt eine Routine des Basic-Übersetzers den Text in Codezahlen (Tokens) um. Diese Routine und eine andere, welche die Zeilen eines Programms aneinanderhängt, verwenden die Zelle 11 als Zwischenspeicher.

Sobald die Textumwandlung beendet ist, steht in Zelle 11 eine Zahl, welche die Länge der Token-Zeile angibt.

Die Zelle 11 wird außerdem noch von den Basic-Routinen benützt, die ein Feld (Array) aufbauen oder ein bestimmtes Element in einem Array suchen. Was ein Feld oder Array ist, finden Sie in den Commodore-Handbüchern gut beschrieben.

Diese Routinen also verwenden die Speicherzelle 11, um die Anzahl der verlangten DIMensionen und den für ein neu aufgebautes Feld nötigen Speicherbedarf zu berechnen.

### Adresse 12 ($C)<br>Flagge für Basic-Routinen, die ein Feld (Array) suchen beziehungsweise aufbauen

Diese Speicherzelle wird von den Basic-Routinen als Zwischenspeicher benutzt, die feststellen, ob eine Variable ein Feld (Array) ist, ob das Feld bereits DIMensioniert worden ist, oder ob ein neues Feld die unDIMensionierte Zahl von 11 Elementen hat.

### Adresse 13 ($D)<br>Flagge zur Bestimmung des Datentyps (Zeichenkette/String oder Zahl)

Diese Flagge zeigt den Routinen des Basic-Übersetzers an, ob es sich bei den zur Verarbeitung anstehenden Daten um einen String oder um Zahlenwerte handelt. Zeigt die Flagge 255 ($FF), ist es ein String. Bei 0 handelt es sich um Zahlen. Diese Bestimmung erfolgt jedesmal, wenn eine Variable definiert oder gesucht wird. Diese Flagge kann leider nicht durch ein Basic-Programm abgefragt werden.

### Adresse 14 ($E)<br>Flagge zur Bestimmung des Zahlentyps (Ganze Zahl oder Gleitkommazahl)

Sobald durch die Flagge in der vorherigen Zelle 13 eine Zahl signalisiert wird, steht hier die Zahl 128 ($80) wenn es sich um eine ganze Zahl handelt, während eine 0 die Zahl als Gleitkommazahl identifiziert.

Damit wollen wir ein bißchen experimentieren. Zeile 10 definiert eine Gleitkommazahl, Zeile 20 druckt sie und die Flagge aus Zelle 14 aus.
10 A = 13.41
20 PRINT A,PEEK (14)
Wir erhalten die Zahl 13.41 und als Flagge eine 0.
30 B = INT (A)
40 PRINT B,PEEK (14)

INT bildet die ganze Zahl von 13.41. Also müßte die Flagge in Zelle 14 auf 128 stehen. Weit gefehlt! Da intern auch die 13 als Gleitkommazahl berechnet wird, erhalten wir immer noch eine 0.
50 B% = A
60 PRINT B%,PEEK (14)
Erst die Definition der Variablen B als ganze Zahl (mit %) ergibt die Flagge 128.
70 D = 16*B%
80 PRINT D,PEEK (14)

Die Multiplikation einer ganzen Zahl mit der Ganzzahl-Variablen B% fällt in dieselbe Kategorie wie Zeile 30 oben, da die Verarbeitung als Gleitkommazahl erfolgt. Also erhalten wir zu Recht eine 0. Erst wenn D als ganze Zahl (Zeile 90) ausgewiesen wird, steht die Flagge wieder auf 128: 90 D% = 16*B%
100 PRINT D%, PEEK (14)

### Adresse 15 ($F)<br>Flagge bei LIST, Garbage Collection und Textumwandlung

Die Routine des LIST-Befehls muß unterscheiden zwischen Basic-Befehlen und normalem Text. Wenn eine Zeichenkette durch ein »Gänsefüßchen« identifiziert worden ist, wird die Flagge gesetzt, und der Text wird ausgedruckt.

Unter »Garbage Collection« (Müllabfuhr) wird die Routine des Betriebssystems verstanden, welche zu bestimmten Anlässen im Variablenspeicher alle nicht mehr benötigten Strings entfernt, um Platz zu schaffen. Dabei wird eine Flagge in Zelle 15 gesetzt, die anzeigt, daß eine Müllabfuhr bereits stattgefunden hat. Wenn bei der Speicherung eines neuen Strings zu wenig Speicherplatz vorhanden ist, wird bei der Flagge nachgesehen, ob gerade vorher schon durch die Müllabfuhr (Garbage Collection) der Speicher entrümpelt worden ist. Falls das der Fall ist, wird OUT OF MEMORY angezeigt, falls nicht, wird eine Müllabfuhr durchgeführt.

Schließlich wird Zelle 15 auch bei der Umwandlung von Basic-Befehlen in internen Codezahlen (Tokens) eingesetzt.

Adresse 16 ($10) Flagge zur Anzeige eines Variablen-Feldes oder einer selbstdefinierten Funktion

Im Basic-Übersetzer gibt es eine Routine, die den Speicher absucht, ob es eine Variable mit bestimmten Namen bereits gibt. Wenn diese mit einer Klammer beginnt, wird die Flagge in Zelle 16 gesetzt, um anzuzeigen, daß es sich um eine Array-Variable oder um eine mit DEF FN selbst definierte Funktion handelt.

### Adresse 17 ($11)<br>Flagge für INPUT, GET oder READ

Die Basic-Routinen für INPUT, GET und READ sind zum großen Teil identisch. Um Speicherplatz zu sparen, verwendet der Basic-Übersetzer die identischen Teile nur einmal. Um in die nichtidentischen Teile verzweigen zu können, wird in Zelle 17 angezeigt, um welchen der drei Befehle es sich gerade handelt. Die Flagge steht auf 0 für INPUT, auf 64 ($40) für GET und auf 152 ($98) für READ.

Mit dem folgenden kleinen Programm können wir das leicht nachprüfen:
10 DATA 3
20 READ A
30 PRINT PEEK (17)
40 INPUT B
50 PRINT PEEK (17)
80 GET C$:IF G$ = ””THEN 60 70 PRINT PEEK (17)

Zeile 10 und 20, 40 sowie 60 sind Anwendungen der drei zur Debatte stehenden Basic-Befehle. Nach der Durchführung jedes Befehls wird in den Zeilen 30, 50 und 70 die jeweilige Flagge ausgelesen.

Nach RUN erhalten wir als Resultat der Zeile 20 die Zahl 152, als Resultat von Zeile 30 die INPUT-Aufforderung mit Fragezeichen. Geben Sie irgendeine Zahl und RETURN ein. Wir erhalten so die 0. Die GET-Schleife in Zeile 40 wartet auf einen Tastendruck, dann erhalten wir 64.

### Adresse 18 ($12)<br>Flagge für Vorzeichen des Ergebnisses bei SIN und TAN

Mit dieser Adresse fahren wir das nächste Mal fort.

(Dr. Helmuth Hauck/aa)

TODO
Tabelle 1. Was sind Zeiger, Vektoren und Flaggen?

### Zeiger, Vektoren und Flaggen

Zeiger und Vektoren sind 2 benachbarte Speicherzellen (Bytes), die eine wichtige Adresse enthalten.

Wir sprechen von einem **Zeiger**, wenn diese Adresse den Beginn von gespeicherten Daten angibt.

Ein **Vektor** kennzeichnet den Beginn eines Maschinenprogramms. (Ich muß zugeben, daß diese Unterscheidung nicht immer scharf angewendet wird beziehungsweise anwendbar ist).

Eine **Flagge** besteht aus einer Zahl, die von einem Programm verwendet wird, um sich das Resultat einer Operation zu merken beziehungsweise für eine spätere Verwendung festzuhalten.


TODO
Tabelle 2. Die Zahlendarstellung bei den Commodore-Systemen

### Gleitkomma-Zahlen

Für diejenigen Leser, die das Thema der Zahlendarstellung in den Commodore-Handbüchern großzügig übersprungen haben, stelle ich es hier noch einmal vor.

Sie kennen die gängigen vier Zahlentypen:

— ganze Zahlen: 15, 21, 244
— Brüche: 2/3, 26/8, 15/14
— negative Zahlen: —15, —255
— positive Zahlen: 10, 5, 123

Ganze Zahlen bereiten uns und dem Computer keine Probleme.

Bei Brüchen sieht es schon anders aus. Erinnern Sie sich an die Bruchrechnungsstunden in der Schule? Wieviel ist 51/52 + 3/4!!

Ohne lang zu überlegen, rechnen wir natürlich um, 51/52 = 0,9807692 und 3/4 = 0,75; addiert ist das Resultat 1,7307692 — und schon sind Sie mitten in den Gleitkomma-Zahlen.

Bei obigem Beispiel gleitet allerdings noch nichts. Bei sehr großen oder aber auch sehr kleinen Bruch-Zahlen reicht uns — und einem Computer — nicht der Platz, um sie darzustellen. Die Zahl 0,000000000000000123 sprengt jeden normalen Rahmen.

Daher schreiben wir sie anders. Wir lassen das Komma nach rechts gleiten, bis es die erste Ziffer, die von 0 verschieden ist, findet und für jede Null, die es passiert multiplizieren wir die Zahl mit 10.

Die Zahl oben sieht dann so aus:
0,123 x 10 hoch 15 (eine 1 mit 15 Nullen).

Die Grundzahl vorn heißt »Mantisse«, die 10 mit Hochzahl heißt »Exponent«.

Alle Commodore-Computer verarbeiten intern alle Zahlen in dieser Darstellung, also als Gleitkommazahl (siehe auch Assembler Kurs im 64’er-Magazin, Ausgabe 11)

# Assembler ist keine Alchimie – Teil 4

> In dieser Folge des Assembler-Kurses lernen Sie die wichtigen Arithmetik-Befehle des Prozessors kennen. Anhand von Beispielen und Übungen können Sie alle Schritte am Computer miterleben. Außerdem wird die Frage geklärt, wie Assembler-Programme in Basic eingebunden werden.

Neun neue Befehle haben wir in der letzten Folge kennengelernt und wir wissen nun, wie unser Computer ganze Zahlen (sogenannte Integers) abspeichert. Zur Erinnerung: Das geschieht im Zweierkomplement-Format. Das Bit 7 einer 8-Bit-Zahl dient dabei als Vorzeichen-Merkmal: Wenn es 0 ist, liegt eine positive Zahl vor, die genauso aussieht, wie wir bislang immer Binärzahlen kannten. Ist das Bit 7 aber eine 1, dann haben wir es mit einer negativen Zahl in der Zweierkomplement-Darstellung zu tun. Wenn wir — wie unser Computer — zur Verarbeitung ganzer Zahlen 16 Bits (also 2 Bytes) verwenden, dann isf eben Bit 15 anstelle von Bit 7 das Vorzeichenbit.

Wenn Sie nun am Ende der letzten Folge ein bißchen mit solchen Zahlen gerechnet haben, konnten Sie sicher feststellen, daß zwar oft das richtige Ergebnis herauskam — aber leider nicht immer. Warum das so ist und was man deswegen noch beim Arbeiten mit Zahlen per Computer beachten muß, soll in dieser Folge dran sein. Damit wir aber nicht nur im vergleichsweise trockenen Zahlendschungel herumirren, sollen Sie heute endlich auch die wichtigsten Befehle des 6502 (beziehungsweise 6510) zur Arithmetik kennenlernen. Außerdem gibt es dazu noch zwei Flaggen gratis und die Branch-Befehle (schon lange überfällig) sollen Ihnen nun vertraut werden. Zunächst aber noch etwas Zahlensalat:

## Herr Carry und der V-Mann

Keine Angst, wir sind nicht ins Krimi- oder Agentenmilieu gewechselt! Wir haben es mit zwei Flaggen zu tun, der Carry- und der V-Flagge. »To carry« heißt auf deutsch etwa »tragen«. In der Registeranzeige ist diese Flagge immer mit C gekennzeichnet. Was wird denn hier getragen? Das ergründen wir am besten an einem Beispiel. Dazu rechnen wir mit normalen Binärzahlen (also ohne Rücksicht auf Vorzeichenbits). Wir zählen die Zahlen 128 und 130 zusammen:

TODO
128	1000 0000
+ 130	+ 1000 0010
---
258 (1)0000 0010

Das Ergebnis 258 ist richtig — auch in der Binärdarstellung — nur es paßt nicht mehr in 8 Bits. Ein Bit wurde überTRAGEN in ein extra dafür vorgesehenes Plätzchen: In das Carry-Bit. Jedesmal also, wenn so ein Übertrag in einer Rechenoperation des C 64 stattfindet, zeigt die Carry-Flagge eine 1 (Bild 1).

Je nach Art der von uns programmierten Aufgabe können wir nun dieses Carry-Bit weiterverarbeiten. Es gibt Situationen, in denen man es einfach ignorieren darf (dazu kommen wir gleich noch) oder aber solche, wo man es weiter in der Rechnung verwendet. Schließlich kann es auch noch einen Fehler anzeigen: Dann nämlich, wenn das größte zulässige Ergebnis 11111111 sein darf. Natürlich kann das Carry-Bit auch gesetzt werden, wenn man in der Zweierkomplementform rechnet. Die Verhältnisse sind dann aber für ein leicht überschaubares Beispiel des Übertrages zu verwickelt, wie Sie gleich sehen werden.
Wenn wir nämlich mit den Zweierkomplement-Zahlen rechnen, dann interessieren uns auch Fälle wie bei der Addition von 64 und 66:

TODO
64	0100 0000
+	66	+ 01000010
---
(-126) 1000 0010

Das ist offensichtlich falsch. Bei der Addition ist durch das Zusammenzählen der Bits 6 plötzlich Bit 7 gesetzt worden. Da wir es aber mit einer Zweierkomplementzahl zu tun haben, bei der dieses Bit 7 eine negative Zahl anzeigt, folgt ein Fehler. Es ist also von Bedeutung, so einen Überlauf (englisch: 'overflow') erkennen zu können um eine entsprechende programmtechnische Reaktion zu starten. Es wird die Überlauf-Flagge V auf 1 gesetzt. Leider ist die Sache aber nicht so einfach, daß sie immer gesetzt würde, wenn von Bit 6 nach Bit 7 ein Übertrag stattfindet. Gesetzt wird diese V-Flagge nur in folgenden zwei Fällen:

1)	Es findet ein Übertrag von Bit 6 nächBit 7 statt, aber kein äußerer Übertrag (wie beim Carry)
2)	Es findet kein interner Übertrag von Bit 6 nach Bit 7 statt, aber ein äußerer Übertrag passiert.

Merken kann man sich das am besten so: Immer dann, wenn gewissermaßen das Vorzeichenbit 7 »versehentlich« verändert wurde, wird die V-Flagge auf 1 gesetzt. Das ist ein harter Brocken! Wir sind es ja gewohnt, daß wir uns um diese Dinge beim Computer eigentlich gar nicht mehr kümmern müssen. Außerdem würde das ja erfordern, daß man sich bei allen Operationen vorher überlegen muß, welche Zahlen auftreten können und welche Fehler also durch »versehentliches« Vorzeichenändern passieren können! Genauso ist es — in der Programmierpraxis wird Ihnen aber das ganze Problem nicht mehr so groß vorkommen. Wir wollen uns dieses Zusammenspiel der Überträge von Bit 6 nach Bit 7 und von Bit 7 nach Bit 8 (also ins Carry-Bit) noch anhand einiger Beispiele klarer machen.

Im obigen Beispiel der Addition von 64 und 66 haben wir einen Fall schon behandelt: Es fand ein Übertrag von Bit 6 nach Bit 7 statt, aber kein äußerer Übertrag ins Carry-Bit. Deswegen wurde dann auch die V-Flagge gesetzt. Das Problem läßt sich hier ganz einfach lösen zum Beispiel durch Verwendung von 16-Bit-Zahlen:

TODO
64 0000 0000 0100 0000
 + 66 + 0000 0000 0100 0010
---
130	0000 00001000 0010

Bei 16-Bit-Zahlen ist ja Bit 15 das Vorzeichenbit, welches hier keine Änderung erfährt.

Der andere Fall tritt auf bei der Addition von zwei negativen Zahlen wie —125 und —64:

TODO
—125	1000 0011
- 64	1100 0000
---
(+67) (1)01000011

Auch das ist offensichtlich falsch: Es hat wieder »versehentlich« ein Vorzeichenwechsel stattgefunden. Dies ist also der Fall, wo zwar ein Übertrag ins Carry-Bit stattfand aber kein Übertrag von Bit 6 nach Bit 7. Auch dieses Problem läßt sich durch Verwendung von 16-Bit-Zahlen lösen. Eine kleine Trainingsaufgabe für Sie!

Man kann also sagen: Immer dann, wenn bei 8-Bit-Rechnungen der mittels Zweierkomplementzahlen darstellbare Bereich (127 bis —128) über- oder unterschritten wird, fuhrwerkt man im Vorzeichen-Bit herum und verfälscht das Ergebnis. Dann leuchtet wie eine rote Ampel die Überlauf(V)-Flagge auf und sagt uns, daß wir besser in diesen Fällen mit 16-Bit-Zahlen arbeiten sollten.

Nun noch zum Ignorieren des Carry-Bits, das ich weiter oben erwähnt habe. Bei allen 8-Bit-Rechenoperationen mit Zweierkomplementzahlen kann das Carry-Bit vernachlässigt werden. Zwei Beispiele sollen das wieder illustrieren. Wir addieren +4 und —2:

TODO
+ 4	0000 0100
-2	11111110
+ 2	(1)0000 0010

Das Carry-Bit wird außer acht gelassen. Anderes Beispiel: Wir addieren zwei negative Zahlen, —4 und —6:

TODO
-4	11111010
-2	11111110
+ + 
-6	(1)11111000

Auch hier kann man (sogar: muß man) das Carry-Bit vernachlässigen. Beide Ergebnisse sind richtig.

Nun wissen Sie alles über die Art, wie unser Rechner mit ganzen Zahlen arbeitet. Probieren Sie mal ein paar Aufgaben aus zur Übung.

Wir verlassen jetzt den Zahlendschungel und widmen uns der Praxis.

### Der Computer rechnet: ADC, CLC

ADC ist der erste Arithmetik-Befehl des 6502 (und natürlich auch des 6510), den wir kennenlernen. Er bedeutet »add with carry«, also »addiere mit Carry-Bit«. An einem 8-Bit-Beispiel wollen wir uns das mal ansehen. ZAHL1 und ZAHL2 sollen addiert werden. Beide sollen positive 8-Bit-Zahlen sein, die so klein sind, daß kein Überlauf zu erwarten ist. Die ZAHL1 wird in den Akku gegeben:

LDA #ZAHL1

Wenn wir nun den Befehl
ADC #ZAHL2
folgen lassen, sorgt die ALU (arithmetisch-logische Einheit, siehe Folge 1) dafür, daß beide Zahlen addiert werden und das Ergebnis im Akku erscheint. ZAHL1 ist dann vom Ergebnis überschrieben worden. An sich ist damit alles erledigt. Weil wir aber häufig wissen wollen, was denn nun bei der Addition herausgekommen ist, speichern wir den Akku-Inhalt noch irgendwo ab mittels »STA Speicherstelle«. Außerdem war da ja noch die Sache mit dem Carry-Bit. Wir haben oben festgestellt, daß bei einer 8-Bit-Addition kein Carry-Bit berücksichtigt werden soll. Nun gibt es aber eine ganze Menge von Vorgängen in einem Assembler-Programm, die das Carry-Bit beeinflussen. Man kann eigentlich vor einer Addition nie ganz sicher sein, ob es denn nun 1 oder 0 ist. Weil jedoch ADC auch das Carry-Bit mitaddiert, sollte man dafür sorgen, daß es vor dem Zusammenzählen wirklich gelöscht ist. Dazu gibt es den Befehl CLC was die Abkürzung für »clear carry«, also »lösche Carry-Bit« ist. Sei ZAHLl = 12 und ZAHL2 = 7, dann würde unser vollständiges 8-Bit-Additions-Progrämmchen also lauten:
1200	CLC
1201	LDA	#$0C
1203	ADC	#$07
1205	STA	1500

Sehen wir mal davon ab, daß dieses Programm natürlich unsinnig ist (das kann man ja im Kopf schneller rechnen!), dann erkennen wir: CLC ist ein 1-Byte-Befehl mit impliziter Adressierung, welcher sich nur auf die C-Flagge (also das Carry-Bit) auswirkt. ADC ist in der hier verwendeten Form ein 2-Byte-Befehl und liegt in der »unmittelbar« genannten Adressierung vor. Wie wir oben gesehen haben, kann ADC — je nach Art der Rechnung — auf einige Flaggen wirken: Da wären zunächst natürlich die V-Flagge und die C-Flagge. Dann aber kann beim Auftreten eines gesetzten Bit 7 auch die N-Flagge und beim Überschreiten von $FF eventuell auch die Z-Flagge verändert werden.

Viel interessanter wird unser Mini-Programm schon, wenn man anstelle von
1201 LDA #$0C
jetzt die absolute Adressierung verwendet, zum Beispiel
1201 LDA 1400

Weil das ein 3-Byte-Befehl ist, verschiebt sich natürlich der Rest des Programmes um 1 Byte. So kann man immerhin schon zu unterschiedlichen Inhalten von 1400 den gleichen Betrag addieren.

Am interessantesten allerdings ist die Tatsache, daß auch ADC absolut adressierbar ist. Wir können so zum Beispiel den Inhalt der Speicherzelle 1300 zum Inhalt der Zeile 1400 hinzuzählen und dann das Ergebnis in 1500 ablegen:
1200	CLC
1201	LDA	1400
1204	ADC	1300
1207	STA	1500

Hier ist der ADC-Befehl dann 3 Bytes lang geworden.

Vergessen Sie bitte nicht — das gilt vor allem für die nachfolgenden Rechenoperationen — dann, wenn die Wahrscheinlichkeit besteht, daß der Dezimal-Modus eingeschaltet ist (also die D-Flagge auf 1 gesetzt ist), noch den Befehl CLD vor solche Programme zu stellen.

Solche 8-Bit-Rechnungen kommen recht häufig vor: Wenn man in Schleifen nicht mit mehrfach wiederholten INX (beziehungsweise INY oder INC, DEX, DEY oder DEC) arbeiten will, addiert man eben immer die Sprungweite mittels ADC hinzu. Der Akku kann nicht als Zähler dienen, denn es gibt für ihn keinen Befehl, der dem INX und so weiter vergleichbar wäre, weswegen man ihn — sollte es nötig sein — mittels ADC hochzählt.

Häufiger und in der Praxis bedeutender sind 16-Bit-Rechnungen. Wie Sie sicher noch aus den vorangegangenen Folgen wissen, teilt man so eine 16-Bit-Zahl auf in zwei Bytes (das LSB und das MSB). Nehmem wir für unser nachfolgendes Beispiel wieder an, daß die Zahlen so gebaut sind, daß kein Überlauf zu befürchten ist. ZAHL1 hätten wir vorher in die Speicherstellen 1300 (LSB) und 1301 (MSB) gepackt, ZAHL2 liegt in den Zellen 1400 (LSB) und 1401 (MSB). Zunächst wieder die Vorbereitungsmaßnahmen:
1200	CLD
1201	CLC

Dabei ist CLD nicht immer nötig, wie schon gesagt. Nun addieren wir zuerst die LSBs: 1202	LDA	1300
1205	ADC	1400
1208	STA	1500

Ein Überlauf kann hier nicht stattgefunden haben, denn das Vorzeichenbit ist ja im MSB als Bit 15 enthalten, wohl aber kann ein Übertrag stattgefunden haben: Das Ergebnis könnte größer als 255 ($FF) gewesen sein. War das der Fall, dann ist jetzt eine 1 im Carry-Bit. Wir addieren nun die MSBs:
120B	LDA	1301
120E	ADC	1401
1211	STA	1501

Egal, was im	Carry-Bit stand: Es wurde jetzt hinzuaddiert. Das Ergebnis unserer Rechnung steht nun in 1500 (LSB) und 1501 (MSB). Sehen wir uns das ganze nochmal am Zahlenbeispiel an. Wir addieren die Zahlen 2176 (binär: 0000 1000 1000 0000) und 1009 (binär: 0000 0011 1111 0001). Die Speicherinhalte sind dann:

TODO
1300 1000 0000 LSB Zahl1
1301 00001000 MSB
1400 11110001 LSBZahl2
1401 0000 0011 MSB

Jetzt addieren wir die LSBs:

TODO
1300	1000 0000
1400	11110001
Carry	0
1500	01110001
Carry:	1

Nun folgt der zweite Teil der Addition mit den MSBs:

TODO
1301	00001000
1401	00000011
Carry:	1
1501 00001100

Damit steht nun das Ergebnis 3185 (binär 00001100 01110001) säuberlich aufgeteilt in LSB (Speicher 1500) und MSB (Speicher 1501) fest. Das Carry-Bit steht auch nach vollendeter Rechnung noch auf 1, so daß es vor erneuter Addition wieder mit CLC zu löschen ist.

Damit wäre alles über die Addition berichtet. Wie immer in Programmiererkreisen die Empfehlung: Üben, üben,....

Wir wenden uns jetzt der gegenläufigen Operation zu: Der Subtraktion.

## Noch mehr Rechnen: SBC, SEC

Daß das Abziehen von Zahlen im Computer durch das Hinzuzählen des Zweierkomplementes geschieht, haben wir mit viel Gehirnschmalzverbrauch schon in vorangegangenen Abschnitten erfahren. Nun sollen Sie die dazu nötigen Befehlsworte des Assemblers kennenlernen. Zunächst einmal ist da SBC. Das heißt »subtract with carry« oder auf deutsch etwa »ziehe unter Berücksichtigung des Carry-Bits ab«. Ebenso wie bei der Addition mit ADC, wirkt das Argument des SBC-Befehls auf den Akku-Inhalt ein — wobei das Ergebnis im Akku landet, diesen also überschreibt. Komplizierter ist hier die Verwendung des Carry-Bits, worauf wir aber nicht detailliert eingehen wollen. (Wen es interessiert: Nachlesen in L.A. Leventhal, »6502 Programmieren in Assembler«, 3. Auflage, München 1983, Seite 3-100). Für uns soll einfach die nicht ganz korrekte Analogie zum »Borgen« bei der Subtraktion ausreichen. Für den Fall, daß ein solches Borgen eintreten muß, sollte auch das dazu nötige Carry-Bit vorhanden sein (also auf 1 gesetzt sein). Wie Sie sicherlich schon erraten haben, heißt SEC »set carry«, also »setze das Carry-Bit« (auf 1).

### Merke: Vor einer Addition immer Löschen des Carry-Bits mit CLC, vor einer Subtraktion immer Setzen des Carry-Bits mit SEC!

Zwei Beispiele für die Subtraktion sollen das bisher gesagte erläutern: Zunächst eine 8-Bit-Subtraktion von ZAHL1 (in Speicherzellle 1300) minus ZAHL2 (in Zelle 1400). Ds Ergebnis wird nach 1500 geschrieben:
1200	CLD
1201	SEC
1202	LDA 1300
1205	SBC 1400
1208	STA 1500

SBC kann — wie hier — absolut adressiert werden, aber auch unmittelbar (also zum Beispiel SBC $40). Der Befehl ist dann im ersten Fall ein 3-, im anderen Fall ein 2-Byte-Befehl. SEC ist ebenso wie vorher schon CLC ein implizit adressierbarer 1-Byte-Befehl.

Das zweite Beispiel ist eine 16-Bit Subtraktion. In den Speichern steht vor dem Aufruf dieser kleinen Routine:
1300 ZAHL1 LSB
1301 ZAHL1 MSB
1400 ZAHL2 LSB
1401 ZAHL2 MSB

Das Ergebnis soll nach 1500 (LSB) und 1501 (MSB) gebracht werden:
1200	CLD
1201	SEC
1202	LDA	1300
1205	SBC	1400
1208	STA	1500

Jetzt sind die beiden LSBs voneinander abgezogen und die Differenz abgespeichert als LSB des Erebnisses.
120B	LDA	1301
120E	SBC	1401
1211	STA	1501

Damit ist die Aufgabe beendet. Auch die MSBs sind subtrahiert und das MSB des Ergebnisses steht in 1501.

SBC beeinflußt die gleichen Flaggen wie der Befehl ADC.

## Ein Programmprojekt

Damit die so kennengelernten Arithmetik-Befehle nicht so trocken auf weiter Flur stehen, wollen wir nun ein Programm entwickeln, aus dem zweierlei zu lernen ist:

1)	Die Anwendung bisher gelernter Befehle und
2)	ein häufig angewendetes Verfahren, Assemblerprogramme in Basic-Programme einzubinden.

Besonders dieser 2. Aspekt scheint noch vielen Lesern unklar zu sein (das zeigen mir Zuschriften). Es gibt eine ganze Reihe von Möglichkeiten, zum Einbau von Assembler-Routinen in Basic-Programme; die werden wir alle nach und nach kennenlernen. Von Ihnen sicherlich schon häufig angewendet wurde der SYS-Befehl (zum Beispiel für SYS 58640 und vorherigem POKE214,Zeile und POKE211, Spalte zum Setzen des Cursors an die Stelle Zeile, Spalte). Damit haben Sie ein Maschinenprogramm aufgerufen, das im System unseres Computers schon enthalten ist. 58640 ist die Startadresse des Programmes und man kann diesen SYS-Befehl eigentlich wie eine Art »GOTO Maschinenprogramm-Startadresse« ansehen. Nichts hindert uns also, auf diese Weise eigene Assembler-Programme anzuspringen! Das Problem liegt nun nur noch darin, wie man Parameter, die unsere Maschinenroutine benötigt, übergeben kann. Eine offensichtliche — aber leider auch relativ langsame — Methode ist das POKEn der Werte im LSB/MSB-Format in die Speicherzellen, aus denen sie sich unser ML-Programm dann abholt. Wir wollen dieses Verfahren nun an einem Programmbeispiel verwenden.

Eine arithmetische Reihe werden viele von Ihnen schon kennen. Wenn man A als erstes Glied, D als Differenz und N als die Anzahl der Glieder bezeichnet, dann ist die Summe einer solchen Reihe:
S = A + (A + D) + (A + 2*D) + ... usw.... + (A + (N-1)*D)

Ein Beispiel ist die Summe der ersten zehn ganzen Zahlen: S=1+2+3+4+5+6+7+8+9+10

Hier ist A = 1, D = 1 und N=10. Daß die Summe S im Beispiel 55 ist, kann man schnell berechnen, was aber, wenn wir wesentlich mehr als nur zehn Glieder haben? Es gibt natürlich auch Formeln zur Berechnung von S. Aber eigentlich ist es ganz reizvoll, ohne solche Formeln den Computer die Summe bilden zu lassen. Wir bauen also ein Programm zur Berechnung der Summe der ersten N ganze Zahlen, wobei N frei gewählt werden kann. Das Ergebnis soll eine 16-Bit-Zahl sein, also nicht größer als 32767. Das beschränkt uns bei N auf Werte von 1 bis 255 (Warum, können Sie ja mal mit dem fertigen Programm ausprobieren). N benötigt also nur 1 Byte Speicherplatz und soll in $1300 abrufbar sein. A soll 1 sein ebenso wie D. Für eventuelle Programmänderungen ist es aber sinnvoll, A und D als 16-Bit-Zahlen aufzubewahren und zwar in $1310/1311 (A in LSB/MSB-Format) und in $1320/1321 (D im gleichen Format). Das Ergebnis soll in $1400/1401 zu finden sein. Das Maschinenprogramm legen wir nach $1200.

Zuerst kümmern wir uns um das Basic-Aufrufprogramm:

Zu diesem Programm gibt es nur noch zu bemerken, daß die Zahlen bei POKE, PEEK oder SYS die Dezimalwerte unserer oben gewählten Adressen sind.

Nun endlich zum Assemblerprogramm. Sehen Sie sich dazu bitte das Flußdiagramm im Bild 2 an.

Wir bereiten den Ablauf vor, indem wir aus $1300 die Anzahl der Glieder ins X-Register laden und zur Vorbereitung der Addition das Carry-Bit löschen. Schalten Sie also bitte den SMON ein und tippen Sie A1200 <RETURN>. Es erscheint die Startadresse 1200. Jetzt können Sie Zeile für Zeile das Assembler-Programm eingeben (nach jeder Zeile ein RETURN, das die nächste Zeilennummer erzeugt):
1200 LDX 1300
1203 CLC

Die nächsten sechs Zeilen summieren jeweils das neueste Glied zur bis dahin erzeugten Summe. Jetzt zu Beginn ist $1400/1401 noch leer und in $1310/1311 steht noch das Anfangsglied A = 1. Später mit Durchlaufen der Schleife, steht in $1400/1401 immer die bis dahin gebildete Summe und in $1310/1311 das letzte Glied der Reihe. Es handelt sich um die oben kennengelernte 16-Bit-Addition:
1204 LDA 1400
1207 ADC 1310
120A STA 1400

Das neue LSB ist berechnet und in $1400 geschrieben.
1200 LDA 1401
1210 ADC 1311
1213 STA 1401

Das war nun noch das neue MSB. Als nächstes berechnen wir das momentan letzte Glied der Reihe durch Addieren von D zum alten letzten Glied. Das entspricht dem Basic-Befehl A = A + D in einer Schleife. Dies ist eine neue 16-Bit-Addition, weshalb wir wieder CLC vorgeben müssen:
1216 CLC
1217 LDA 1310
121A ADC 1320
121D STA 1310

Das war wieder das LSB. Nun zum MSB:
1220 LDA 1311
1223 ADC 1321
1226 STA 1311

Wir zählen nun das X-Register um 1 herunter und prüfen, ob es schon Null geworden ist, ob also schon alle N-Glieder summiert worden sind:
1229 DEX
122A BNE 1203

Wenn noch nicht alle Glieder berechnet und summiert sind, kehren wir an den Schleifenanfang zurück. Ansonsten springen wir zurück ins Basic-Aufrufprogramm:
122C RTS

Wenn Sie beide Programme eingetippt haben, dann speichern Sie sie vorsichtshalber ab (das Assemblerprogramm mit dem S-Befehl des SMON). Beim neuen Einladen brauchen Sie den SMON nicht mehr. Nach dem Laden unseres Maschinenprogrammes (mit ,8,1 bei Diskette oder ,1,1 bei Kassette) geben Sie NEW <RETURN> ein, damit die Zeiger vor dem Einladen des Basic-Programmes wieder auf Normalwerte gesetzt werden. Zwischen dem dann eingeladenen Basic-Programm und unserer Assembler-Routine ist genug Platz. Sollten Sie aber irgendwann mal das Basic-Programm vergrößern, schützen Sie bitte unseren Bereich ab $1200.

Unser Assembler-Beispiel ist so aufgebaut, daß auch A und D variabel gehalten sind. Sie müßten dann nur noch Eingabemöglichkeiten im Basic-Programm schaffen und anstelle der Werte 1 oder 0 in Zeile 70 die LSBs und MSBs der von Ihnen eingegebenen Größen A und D einPOKEn. Auf diese Weise sind dann beliebige ganzzahlige, arithmetische Reihen berechenbar, wie zum Beispiel S = 7+10 + 13 + 16+... und so weiter. Das überlasse ich Ihrer Basic-Programmierfertigkeit. Nur eines noch: Sie müssen darauf achten, daß die Summe S nicht größer als 32767 wird. Ihrer Phantasie sind — wie immer in diesem Metier — keine Grenzen gesetzt. Sie könnten sich ja mal überlegen, wie man größere Summen zulassen kann (wer sagt denn, daß wir Zahlen immer nur in 2 Bytes darstellen dürfen?). Oder Sie könnten sich überlegen, welches eindeutige Merkmal auftritt, sobald der Maximalwert überschritten wird (ein Tip: Lesen Sie doch mal den Abschnitt über die V-Flagge nach).

## Die Branch-Befehle

Der 6502 (und auch der damit identische 6510) kennt acht bedingte Verzweigungen, von denen wir bisher BNE schon verwendet haben. Alle diese Branch-Befehle (von branch = verzweigen) prüfen Flaggen des Statusregisters.

BNE und BEQ beziehen sich auf die Z-Flagge, die anzeigt,ob im Verlauf der letzten Operation eine Null aufgetreten ist. Ist das der Fall, steht in der Z-Flagge eine 1. BNE verzweigt zur angegebenen Adresse, wenn in der Z-Flagge eine 0 enthalten ist. BEQ (branch if equal zero = verzweige, wenn gleich Null) tut das dann, wenn die Z-Flagge auf 1 gesetzt ist. Da muß man etwas aufpassen, daß man sich nicht vertut!

BCC und BCSLaben ihre Aufmerksamkeit auf die C-Flagge, also das Carry-Bit gerichtet. BCC kommt vom englischen »branch if carry clear«, was heißt: »verzweige, wenn das Carry-Bit gelöscht ist«. Ein gesetztes Carry-Bit (also Inhalt = 1) veranlaßt BCS (»branch if carry set« = verzweige, wenn das Carry-Bit gesetzt ist) zum Sprung an die angegebene Adresse.

Diese vier bedingten Verzweigungen sind an sich die bedeutsamsten und am häufigsten verwendeten Branch-Befehle. Man kann wohl getrost sagen, daß über 90% der von Programmierern verwendeten bedingten Sprünge, damit absolviert werden. R. Mansfield warnt sogar ausdrücklich in seinem Buch »Machine language for beginners«, einem in den USA sehr verbreitetem Werk, vor der Verwendung der Befehle BPL und BMI!

Dafür liegt absolut kein einsehbarer Grund vor. Viele programmtechnischen Aufgabenstellungen lassen sich elegant und leicht mit BPL, BMI, BVS und BVC lösen. Man muß nur wissen, wie sie funktionieren und — da liegt vermutlich der Hund begraben — man muß auch die Art kennen, wie Zahlen vom Computer behandelt werden. Genau das aber wissen wir und deswegen sollten wir diese Kenntnis für uns auch nutzen. Also ohne Scheu heran an die verfehmten Befehle!

BMI und BPL (branch on minus = verzweige, wenn negativ und branch on plus = verzweige, wenn positiv) hängen mit der Negativ-Flagge N zusammen. Das Rätsel dieser Flagge konnte in den vorangegangenen Folgen gelöst werden: Immer dann, wenn bei einer Operation eine Zahl auftrat, deren Bit 7 eine 1 war, wurde die N-Flagge auf 1 gesetzt. Wir wissen jetzt, daß dieses Bit bei 8-Bit-Zahlen das Vorzeichenbit ist. Bit 7 sagte uns bei einer 1, daß eine negative Zahl im Zweierkomplement-Format vorliegt oder aber überhaupt ein Speicherzelleninhalt vorhanden ist, der größer als 0111 1111 = 127 ist. BMI führt zum Sprung in diesem Fall, weil die N-Flagge auf 1 steht. Andernfalls führt BPL zur Verzweigung.

Ebenso einfach sind BVS und BVC zu erklären: Sie beziehen sich auf die V-Flagge, unsere rote Ampel, die Überlauf bei Rechenoperationen anzeigt. Kann es was bequemeres geben zur Behandlung solcher Fehlrechnungen als ein »branch on overflow set« = »verzweige, falls die Überlauf-Flagge gesetzt (= 1) ist« mit BVS? Oder anders herum bei BVC »branch on overflow clear« = »verzweige bei freier Überlauf-Flagge«. Wenn man — wie Sie jetzt nach dieser Folge — weiß, unter welchen Umständen diese V-Flagge auf 1 gesetzt wird, sollte man ohne Skrupel BVS und BVC ausgiebig benutzen. Man könnte damit zum Beispiel programmieren, daß die Rechengenauigkeit automatisch von 16-Bit auf 24- oder 32- (oder wie es gerade beliebt) Bit gesteigert wird, ohne daß man sich bei jeder Programmaufgabe Gedanken über das größtmögliche Ergebnis machen muß. Dazu aber ein andermal mehr.

Alle hier vorgestellten Branch-Befehle sind ebenso wie BNE 2-Byte-Befehle, was an der speziellen Art der Adressierung liegt: Der relativen Adressierung.

Eigentlich hatte ich Ihnen ja versprochen, diese relative Adressierung zusammen mit den Branch-Befehlen zu erklären. Ich werde ihr aber lieber einen eigenen Abschnitt widmen, weil’s zum genauen Verständnis doch etwas mehr an Aufwand braucht. Die nächste Folge fängt dann damit an, abgemacht?

Wie die anderen Folgen auch, soll auch diese hier noch mit einer Tabelle enden, in der die neu gelernten Befehle mit Zubehör gezeigt sind.

(Heimo Ponnath/gk)

# In die Geheimnisse der Floppy eingetaucht (Teil 3)

> In den letzten beiden Folgen sind die Möglichkeiten, die Basic bietet, ausgeschöpft worden. Heute soll deswegen die Bedienung der Floppy in Maschinensprache im Vordergrund stehen.

Wenn wir in dieser Folge von Routinen sprechen, die im Betriebssystem stehen, so werden wir die in Tabelle 1 dargestellten Kürzel verwenden, die Sie übrigens auch in Editorprogrammen gut benutzen können.

### FILPAR und FILNAM

Bei OPEN, LOAD und ähnlichen Befehlen müssen Sie entsprechenden Routinen mitteilen, welches File Sie wo öffnen wollen. Um Ihnen eine »Herumwurstelei« in der Zeropage zu ersparen, wo Sie die einzelnen Angaben von Hand setzen müßten, hat das Betriebssystem zwei entsprechende Routinen implementiert. FILPAR setzt für Sie die einzelnen Fileparameter. Diese müssen der Routine in den Prozessorregistern übergeben werden:

— Filenummer (Akku)
— Geräteadresse (X-Register)
— Sekundäradresse (Y-Register)

Ein Beispiel:
Sie wollen für ein File mit der Nummer 1, der Geräteadresse 8 und der Sekundäradresse 15 (Kommandokanal der Floppy) die entsprechenden Fileparameter setzen:

TODO

Wie Sie sehen, muß zu der betreffenden Sekundäradresse ein Wert von $60 addiert werden.

Aber in vielen Fällen müssen Sie ja auch einen Filenamen angeben. Dazu dient die FILNAM-Routine. Hier erfolgt die Parameterübergabe:

— Länge des Filenamens (Akku)
— Adresse LO des Namens (X-Register)
— Adresse HI des Namens (Y-Register)

Und wieder ein Beispiel. Um das Directory-File mit dem Namen »$« anzusprechen, geben Sie bitte folgende Befehle ein:

TODO

Sie müssen also wissen, wo der Filename im Speicher steht und wie lang er ist. Dies ist aber im allgemeinen kein Problem. Auf die gleiche Weise können Sie der Floppy über den Kommandokanal auch Befehle senden, wie Sie in der letzten Folge vorgestellt wurden. Das entspräche der Basic-Sequenz:
OPENx, 8, 15, "befehl”

Natürlich können Sie auch alle Parameter von Hand setzen, beziehungsweise noch einmal lesen. Wo sich die einzelnen Parameter in der Zero-Page nach Ausführung dieser und der anderen Routinen befinden, ist in Tabelle 2 angegeben.

### OPEN und CLOSE

Nachdem wir alle Fileparameter und den Filenamen übergeben haben, können wir die OPEN-Routine mit JSR OPEN aufrufen. Schon ist das entsprechende File geöffnet. Zu beachten wäre folgendes: Es können im Computer niemals mehr als 10 Files gleichzeitig geöffnet sein!

Die CLOSE-Routine arbeitet analog zu OPEN, mit der Ausnahme, daß nur die Filenummer übergeben werden muß. Geräteadresse und Sekundäradresse sucht sich der C 64 aus einer Tabelle heraus, auf die wir später noch zu sprechen kommen:
LDA # $01 ; Filenummer
JSR CLOSE in Akku

Der Filename wird beim Schließen überhaupt nicht mehr benötigt.

### LISTEN und UNLIST, TALK und UNTALK

Nach dem Öffnen eines Files kann die Datenübertragung noch nicht beginnen. Sie müssen dem entsprechenden Gerät zuerst mitteilen, ob es senden oder empfangen soll.

Bestes Beispiel ist wieder der Kommandokanal. Über diesen kann die Floppy sowohl Befehle empfangen, als auch Fehlermeldungen senden. Um ein Gerät zum Empfangen zu veranlassen, verwenden wir die Routine LISTEN. Das hat nichts mit dem Basic-Befehl LIST zu tun, sondern kommt vom englischen Wort für »Hören«. Beim Aufruf vom LISTEN ist das angesprochene Gerät auf Empfang und der Computer auf Senden eingestellt.

Wichtig ist, daß der Akku beim Aufruf die Geräteadresse enthält. Dies gilt für alle vier hier beschriebenen Routinen. Wenn Sie mit dem Senden der Daten fertig sind, sollten Sie ein UNLISTEN zum entsprechenden Gerät schicken, um dieses wieder freizugeben. Dies geschieht mit Hilfe der UNLIST-Routine. Analog verhält es sich mit den Routinen TALK und UNTALK. Sie veranlassen das angesprochene Gerät, Daten zu senden, beziehungsweise mit dem Senden aufzuhören und wieder in den Wartezustand zurückzukehren.

### SECTLK und SECLST

Die beiden Routinen SECTLK und SECLST sind ebenfalls sehr wichtig für die Datenübertragung. Denn obwohl wir beim OPEN-Befehl eine Sekundäradresse angeben, muß diese bei jeder weiteren Übertragung nochmals an das aktuelle Gerät gesendet werden. Dies hat zwei Gründe: Einerseits können Sie ja mehrere Floppykanäle gleichzeitig geöffnet halten. Damit die Floppy nun weiß, für welchen Kanal der nächste Schwung von Daten bestimmt ist, beziehungsweise, welcher Kanal senden soll, muß nach dem Aufruf von TALK SECTLK, beziehungsweise nach dem Aufruf von LISTEN SECLST durchgeführt werden. Außerdem merkt sich der Computer zwar die angegebene Sekundäradresse, sendet sie aber nicht. Dies hat praktische Gründe, wie wir noch bei den LOAD/ SAVE-Routinen sehen werden. SECTLK und SECLST benötigen die jeweilige Sekundäradresse + $60 im Akku. Diese kann, wie in unseren Beispielen, direkt geladen oder aber auch der entsprechenden Zero-Page-Adresse entnommen werden.

### IECOUT und lECIN

Nachdem wir nun endlich alle Vorbereitungen getroffen haben, können wir munter Bytes von der Floppy zum Computer und umgekehrt übertragen. Dies ist mit den ROM-Routinen denkbar einfach. IECOUT überträgt das im Akku befindliche Byte an das aktuelle Gerät; IECIN empfängt eines und legt es im Akku ab.

### Busfehlerbehandlung

Bei aller Sorgfalt; Fehler können immer auftreten, so auch beim Busbetrieb. Um einen in einer Busroutine aufgetretenen Fehler zu signalisieren, verwendet das Betriebssystem das Carry-Flag. Generell gilt: Ist das Carry-Flag gesetzt, so ist etwas nicht in Ordnung, und wir sollten das Statusbyte überprüfen. Dieses Statusbyte steht in der Speicherstelle $90. Immer wenn es ungleich Null ist, liegt irgendein Sonderfall vor. Jedes Bit des Statusbytes hat eine andere Funktion; Tabelle 3 zeigt diese Belegung. Ist zum Beispiel das Bit 7 gesetzt, so ist das angesprochene Gerät entweder nicht vorhanden oder abgeschaltet. In Basic bekämen wir in einem solchen Fall die Meldung »DEVICE NOT PRESENT ERROR«. Interessant ist für uns noch das Bit 6. Ist es gesetzt, so bedeutet das, daß das letzte Byte der angeforderten Informationen übertragen wurde. Dies können wir uns auch in Basic zunutze machen, um beispielsweise die Fehlermeldung der Floppy auszulesen:
10 OPEN1,8,15
20 GET#1, A$: PRINTA$;: IF ST<>64 THEN 20
30 CLOSE1

Wie Sie an diesem Beispiel sehen, ist der Inhalt der Speicherstelle $90 in der Variablen ST enthalten. Vor jeder neuen Datenübertragung sollten Sie darauf achten, daß das Statusbyte gelöscht wird, da sonst irrtümlich Fehler festgestellt werden könnten. Zur Verdeutlichung des bisher Gesagten dienen die Listings 1 und 2, die jedoch nur Anhaltspunkte geben sollen. Sie sind weder perfekt noch eintippfertig und sollten auf den jeweiligen Bedarf abgestimmt werden.

### Bearbeiten mehrerer Files

Sie werden festgestellt haben, daß wir bisher immer nur mit einem einzigen File gearbeitet haben. Was aber, wenn Sie gleichzeitig zwei Files offen halten müssen, zum Beispiel, um einen Block von Diskette zu lesen. Sie erinnern sich ja, daß wir dazu sowohl den Kommandokanal als auch einen Übertragungskanal benötigen. Wir könnten zwar jeweils, wenn wir den Kanal wechseln wollen, mit CLOSE den alten schließen und mit OPEN den neuen öffnen, aber es geht auch einfacher.

Voraussetzung ist, daß alle benötigten Files schon geöffnet sind. Dann kann mit Hilfe einer, schon erwähnten, Filetabelle zwischen — bis zu 10 — Files beliebig umgeschaltet werden. Diesen Zweck erfüllen die Routinen FILTAB und FILSET.

FILTAB benötigt im Akku die Nummer des Files, auf das Sie umschalten wollen. Die Routine sucht dann in der Filetabelle nach den entsprechenden anderen Parametern. Tritt hier ein Fehler auf, weil das File noch gar nicht geöffnet wurde, so wird das Zero-Flag gelöscht und es kann mit BNE auf einen Fehler überprüft werden.

FILSET schreibt dann die gefundenen Parameter in die entsprechenden Zero-Page-Adressen. Die komplette Routine zum Umschalten auf das File x lautet also:

TODO

Die ERROR-Routine müssen Sie natürlich noch selbst schreiben. Danach ist das angewählte File zum aktuellen File geworden. Alle LISTEN, TALK und so weiter, beziehen sich jetzt auf dieses neue File.

In den Zero-Page-Adressen aus Tabelle 2 stehen nun die für dieses File aktuellen Parameter, da sie aus der großen Filetabelle automatisch übertragen werden. Eine Ausnahme bildet hier der Filename, da er nur beim Öffnen des Files benötigt wird.

Diese große Filetabelle befindet sich übrigens an den Speicherstellen $0259 bis $0276.

Denken Sie immer daran, vor einem erneuten Umschalten UNLIST oder UNTALK aufzurufen. CLOSE braucht dagegen erst aufgerufen zu werden, wenn die Bearbeitung eines Files völlig abgeschlossen ist.

### LOAD und SAVE

Prinzipiell könnten Sie mit dem bisher Erwähnten auch schon Programme laden und speichern, allerdings nur sehr mühselig. Da unser Computer das aber schon von selbst beherrscht, geben wir ihm gern diese Arbeit ab.

Betrachten wir zunächst die LOAD-Routine. Auch hier muß wieder eine Vielzahl an Parametern übergeben werden. Mit FILPAR werden Gerätenummer und Sekundäradresse gesetzt. Eine Filenummer braucht nicht gesetzt zu werden. Für die Sekundäradresse gilt folgendes:

Ist sie gleich Null, so wird das Programm an eine, von Ihnen festgelegte, Speicherstelle geladen. Ist sie gleich Eins, so wird das Programm an die Speicherstelle geladen, an der es bei SAVE stand. Der erste Modus wird vom Betriebssystem ausgenutzt, um Programme ab $0800 zu laden, wenn beim LOAD-Befehl keine Sekundäradresse angegeben wird. Prinzipiell kann aber an jede beliebige Adresse geladen werden! Der Filename wird, wie gewohnt, mit FILNAM gesetzt. Vor dem Aufruf der LOAD-Routine treten zwei, uns neue, Parameter hinzu, die wie folgt übergeben werden: LOAD/VERIFY Flag (Akku) Ladeadresse LO (X-Register) Ladeadresse HI (Y-Register)

Steht beim Aufruf der Routine im Akku 0, so wird geladen. Steht dort hingegen eine 1, so wird ein VERIFY durchgeführt.

Die Startadresse in den X/Y-Registern wird nur beachtet, wenn die Sekundäradresse gleich Null ist. Alles übrige erledigt die LOAD-Routine, und Sie brauchen nur noch deren Ende abzuwarten. Zur Sekundäradresse wäre noch folgendes zu bemerken:

Egal, was Sie für eine Adresse angeben, zur Floppy wird immer nur 0 gesendet. Wie Sie schon wissen, ist diese Sekundäradresse floppyintern für den LOAD-Befehl reserviert und darf nicht ohne weiteres bei OPEN-Befehlen verwendet werden. Nach Beendigung der LOAD-Routine wird im X und Y-Register die Endadresse des Programms übergeben.

Die SAVE-Routine hat eine etwas kompliziertere Parameterübergabe. FILPAR braucht nur mit der Gerätenummer im X-Register aufgerufen zu werden, da weder Sekundäradresse noch Filenummer benötigt werden. Das Setzen des Filnamens erfolgt normal über FILNAM.

Übergeben werden müssen nun noch Anfangsadresse und Endadresse + 1 des zu speichernden Bereichs. Die Anfangsadressen müssen Sie irgendwo in der Zero-Page in der Reihenfolge LO/HI ablegen. Empfehlenswert wären die Adressen $FB/FC, da diese nicht vom Betriebssystem oder Basic benutzt werden. Im Akku muß dann die Adresse des LO-Byte übergeben werden; wenn Sie die Adresse also unter $FB/FC spreichern, muß im Akku $FB stehen.

Die Endadresse übergeben Sie wie folgt:
LO-Byte im X- und HI-Byte im Y-Register. Es muß immer 1 zur Engadresse addiert werden, da sonst das letzte Byte des Programms nicht abgespeichert wird. Danach kann die Routine SAVE aufgerufen werden. Wieder haben wir für Sie zur Verdeutlichung zwei Listings: Listing 3 zeigt, wie man ein Programm an eine beliebige Adresse lädt; Listing 4 wie man einen beliebigen Bereich auf Diskette speichert. Erwähnenswert ist noch die Routine CLALL, die alle Files im Computer schließt; die Kanäle in der Floppy bleiben davon jedoch unberührt. Hier müssen Sie also sorgfältig mit CLOSE arbeiten, da Sie sonst Daten verlieren können.

Nachdem wie Sie nun mit Theorie überschwemmt haben, sollen Sie sogleich in den Genuß Ihrer neuen Kenntnisse kommen. Haben Sie schon einmal etwas von Spooling gehört? Nein? Macht nichts, wir werden uns mit dieser Technik nämlichjetzt auseinandersetzen, und Sie werden dabei die Vorzüge dieser Möglichkeit genießen lernen.

## Spooling? Was ist das?

Unter dem Begriff Spooling verbirgt sich eigentlich eine ganz einfache Technik, die jedoch enorme Vorteile besitzt: Es handelt sich um das Drucken direkt von Diskette. Haben Sie nicht auch schon öfters versucht, ein meterlanges Listing auf Papier zu bringen und den Drucker dabei mit wütenden Blicken zu größerer Eile aufgefordert, weil Sie nämlich unter Zeitdruck standen und sich bei der Arbeit keine Verzögerung erlauben konnten? Dann ist Spooling genau das Richtige für Sie. Bei dieser Methode wird ein Listing, das ausgedruckt werden soll, auf Diskette gebracht. Danach starten Sie ein Spooling-Programm und siehe da; der Drucker beginnt Ihr Listing auf Papier zu bringen, und der Computer meldet sich betriebsbereit mit READY.

Dies ist kein Wunder, sondern die Eigenschaft des seriellen Bus Ihres Computers. Sie haben vorhin gelernt, wie man den Bus des Computers in Maschinensprache bedient. Dabei fielen auch Worte wie TALK, LISTEN, SENDEN und EMPFANGEN. Der Trick des Spooling ist nun der: Mit Hilfe des CMD-Befehls in Basic können Sie ein Listing auf Diskette »umleiten«, und zwar geschieht dies ähnlich wie beim Drucker: Sie eröffnen ein File und schicken mit dem CMD-Kommando alle weiteren Bildschirmausgaben auf den Bus. Nur ist jetzt nicht der Drucker der Adressat sondern die Floppy. Hier ein Beispiel:
Sie haben ein Listing im Speicher und wollen dieses auf Diskette ablegen, sein Name soll »TEST« sein:
OPEN 1,8,2,"TEST,U,W"
CMD1
LIST

## Drucken ohne Umwege

Nach dieser Befehlsfolge wird Ihr Listing als USR-File auf Diskette geschrieben. Wie wäre es nun, wenn die Floppy ein TALK-Kommando erhalten würde, das sie veranlaßt, das eben geschriebene File auf den Bus zu bringen? Der »Hörer« ist aber jetzt nicht, wie üblich, der Computer sondern der Drucker, den wir zuvor mit einem LISTEN dazu aufgefordert haben. Die Folge wäre das, was Sie sich jetzt schon denken können:

Die Floppy schickt das gesamte Listing über den Bus, und der Drucker, der ja auf Empfang programmiert ist, bekommt dieses Listing und druckt es aus. Der Computer hat mit der ganzen Sache nichts zu tun, da er sich nach Senden der Kommandos »zurückgezogen« hat und bleibt demzufolge frei für weitere Arbeit.

Der Zugriff auf den Bus ist dem Computer natürlich für die Zeit der Übertragung verwehrt, aber Sie können währenddessen intern weiterarbeiten. Ist die Übertragung beendet, so sind beide Peripheriegeräte noch auf Sendung und müssen erst »zur Ruhe gebracht« werden, bevor sie wieder ansprechbar sind. Aber auch das erledigt ein kleines Programm für uns. Sehen Sie sich jetzt einmal Listing 5 an. Es enthält ein Spooling-Programm, das mit SYS828,”filename” aufgerufen wird. Danach meldet sich der Computer mit
SPOOLING filename
READY
und der Drucker beginnt zu arbeiten. Ist der Druckvorgang beendet, so tippen Sie noch einmal
SYS828
ohne Filenamen, und die Leuchtdiode an der Floppy erlischt. Es erscheint die Meldung END OF SPOOLING
READY
Dieses Programm ist, im Gegensatz zu unseren anderen Listings, zum sofortigen Eintippen gedacht.

Wie Sie aus diesem Beispiel sehen, kann es von großem Nutzen sein, wenn Sie das Prinzip des seriellen Bus verstehen und dessen »Verkehrsregeln« kennen, da viele Programme nur deshalb mit geringem Aufwand große Effekte und Nutzen erzielen. Ein weiteres Beispiel in dieser Reihe dürfte wohl HYPRA-LOAD sein, das Sie in Ausgabe 10 des 64'er-Magazins fanden. Dieses Programm nutzt aber noch einige weitere Tricks der Maschinenspracheprogrammierung, die wir in den nächsten Ausgaben besprechen wollen.

## Was kommt demnächst

In Teil 4 unseres Kurses wollen wir nämlich in die direkte Programmierung der Floppy einsteigen, das heißt, das Abspeichern von Maschinenprogrammen in ihren Pufferspeicher und das Ausführen derselben. Als Beispiel werden wir unser HYPRA-LOAD ein wenig »zerlegen«, um Ihnen die Möglichkeiten dieser Programmiertechnik nahezubringen.

Bis zum nächsten Mal also noch viel Spaß in der Busprogrammierung und in der Anwendung des Druckerspooling.

(B. Schneider/K. Schramm/gk)

# Comal - eine Einführung (Teil 2)

> Nachdem wir in der ersten Folge die Grundkenntnisse erworben haben, um mit Comal umgehen zu können, wollen wir jetzt die ersten kleinen Programme erstellen.

Die Verwandtschaft zwischen Basic und Comal wird uns dabei den Einstieg in die einfache Programmierung sehr erleichtern. Wir brauchen uns also nicht wie beim Erlernen anderer Programmiersprachen mit völlig neuen Befehlsstrukturen herumzuschlagen, sondern kommen weitgehend mit unserem Basic-Wissen aus. Man kann sagen, daß zwischen Basic und Comal eine Art Aufwärtskompatibilität besteht. Basic-Programme lassen sich mit minimalen Änderungen in Comal übersetzen; in der anderen Richtung können allerdings größere Schwierigkeiten auftreten. So sind zwar alle numerischen Funktionen und Operatoren von Basic auch in Comal vorhanden, es gibt jedoch zusätzlich einige Comal-Funktionen, die in Basic nicht vorkommen (Tabelle 1), beispielsweise MOD (Restbildung bei Division). Auch die Datenein- und Ausgabe ist in Comal um einiges komfortabler.

Betrachten wir einmal das folgende kleine Beispiel einer Mehrwertsteuer-Berechnung, zunächst in Basic:
10 rem Mehrwertsteuer
20 input ”Betrag”;b
30 s = b*0.14
40 b = b + s
50 print ”Mehrwertsteuer:”;s
60 print ”Gesamtbetrag:”;b

Dies ist zugegebenermaßen ein sehr einfaches Beispiel, und man hätte es auch gut in einer Zeile unterbringen können. Aber sehen wir uns dieses Programm doch einmal in Comal an:
10 // Mehrwertsteuer
20 input "Betrag?” : betrag
30 mwert := betrag * 0.14
40 betrag := betrag + mwert
50 print "Mehrwertsteuer:” mwert
60 print "Gesamtbetrag:” , betrag

Man erkennt sofort die sehr große Ähnlichkeit beider Programme. Allerdings gibt es auch einige mehr oder weniger auffällige Unterschiede. Zunächst versteht Comal auch lange Variablennamen, wodurch die Programme generell übersichtlicher werden. Als nächstes fällt die Verwendung von »:=« für die Wertzuweisungen auf. Bei der Eingabe braucht man allerdings nur ein Gleichheitszeichen zu schreiben. Comal merkt dann, was gemeint ist und wandelt das Gleichheitszeichen in »:=« um.

Bei genauerem Hinsehen entdeckt man schließlich noch die Verwendung des Doppelpunktes statt eines Semikolons bei der INPUT-Anweisung und die Verwendung des Kommas statt eines Semikolons bei den PRINT-Befehlen.

Befassen wir uns zunächst mit dem INPUT-Befehl. Genau wie in Basic werden damit Daten vom Benutzer erfragt und an die im Befehl angegebenen Variablen zugewiesen. Mehrere Variablen können dabei durch Komma getrennt eingegeben werden.

Enthält die INPUT-Anweisung nur eine Variablenliste und keinen Text, dann erscheint beim Programmlauf ein Fragezeichen, um dem Benutzer mitzuteilen, daß jetzt eine Eingabe erwartet wird.

Im Unterschied zu Basic kann hinter INPUT nicht nur ein Text in Anführungszeichen stehen, sondern auch ein beliebiger Stringausdruck. Hinter diesem Stringausdruck muß ein Doppelpunkt folgen, und dahinter wiederum die Liste der einzulesenden Variablen. In unserem kleinen Beispiel könnten wir also die Zeile 20 ersetzen durch:
20 frage$ := "Betrag"
25 input frage$ : betrag

Wir müssen allerdings beachten, daß Strings in Comal dimensioniert werden müssen, da vor dem eigentlichen Programmlauf die Adressen aller Variablen festgelegt werden (siehe Teil 1). Um die Adressen von Stringvariablen aber festlegen zu können, muß Comal deren maximale Länge kennen. Bevor wir also die Stringvariable »frage$« das erste Mal benutzen können, muß eine Dimensionierung erfolgen. Dies geschieht, indem wir noch eine weitere Zeile einfügen:
15 dim frage$ of 20

Durch diese Anweisung wird Speicherplatz für eine Stringvariable »frage$« mit einer maximalen Länge von 20 Zeichen reserviert. Die Stringlänge ist in Comal übrigens grundsätzlich nur durch den Speicherplatz begrenzt. Nach »dim text$ of 3000« beispielsweise kann text$ bis zu 3000 Zeichen enthalten.

Doch kommen wir nun zur Print-Anweisung, die im wesentlichen analog zu Basic ist, darüber hinaus aber einige zusätzliche Feinheiten kennt.

## Formatierte Ausgabe ohne Probleme

Die einzelnen zu druckenden Argumente (numerische oder Stringausdrücke) werden grundsätzlich durch Komma getrennt. Wünscht man die Ausgabe an einer bestimmten Tabulatorstelle, kann man wie in Basic die TAB(n)-Funktion verwenden. Die durch Komma getrennten Ausdrücke werden normalerweise unmittelbar nebeneinander gedruckt — so, als hätte man in Basic ein Semikolon verwendet. Zum Drucken von Tabellen ist das natürlich nicht besonders sinnvoll. Es ist jedoch mit dem Comal-Befehl »ZONE« möglich, die Spaltenbreite für die Print-Anweisung festzulegen. Mit ZONE 10 erhält man eine Spaltenbreite wie bei Basic.

Zur weiteren Formatierung von Zahlenausgaben kann man »PRINT USING« verwenden. Hinter »USING« muß dabei ein String stehen, der das Ausgabeformat bestimmt. Für jede Ziffernstelle der auszudruckenden Zahl steht in diesem String ein Nummernzeichen »#«. Außerdem kann die Position des Dezimalpunktes angegeben werden. In unserem kleinen Mehrwertsteuer-Programm wäre es zum Beispiel sinnvoll, die Geldbeträge mit zwei Nachkommastellen auszugeben. Dazu ersetzen wir die Zeilen 50 und 60 durch die folgenden vier Comal-Zeilen:
50 print »Mehrwertsteuer:«,
55 print using ”#####.##”: mwert
60 print "Gesamtbetrag:”,
65 print using ”#####.##”: betrag
Jetzt werden die Beträge rechtsbündig mit fünf Stellen vor und zwei Stellen nach dem Komma (oder besser Dezimalpunkt) ausgegeben. Die beiden zusätzlichen PRINT-Befehle waren nötig, da hinter dem Doppelpunkt im Anschluß an das »USING«-Statement nur noch numerische Parameter folgen dürfen. Die Konstruktion »PRINT USING”# ##”: ”Hallo”,5« führt zu einer Fehlermeldung, weil »USING« sich an dem String ’’Hallo” — etwas salopp gesagt — die Zähne ausbeißt.

Der zur »USING«-Anweisung gehörende Formatierungsstring darf übrigens auch andere Zeichen enthalten. Probieren Sie doch einmal folgende Zeile (im Direktmodus) aus: PRINT USING ”DM ###.##”: 12.6

Experimentieren Sie ruhig einmal mit diesen Formatierungsmöglichkeiten, auch unter Verwendung des ZONE-Befehls.

## Strukturiert programmieren

Jede höhere Programmiersprache kennt sogenannte »Kontrollstrukturen«, um den Programmablauf in Abhängigkeit von bestimmten Bedingungen beeinflussen zu können. In Basic gibt es zwei derartige Strukturen, nämlich die Wiederholung mit FOR...NEXT und die Bedingungsabfrage mit IF...THEN. Die Realisierung der IF-Abfrage in Basic hat dabei zwei entscheidende Nachteile. Zum einen fehlt, zumindest im Commodore-Basic, die Angabe einer Alternative (ELSE-Teil einer IF-Anweisung), zum anderen ist die Beschränkung auf eine Zeile in vielen Fällen sehr störend. Man behilft sich in Basic dann mehr schlecht als recht mit GOTO-Sprüngen vor, nach und innerhalb von IF-Anweisungen, was die Übersichtlichkeit eines Programms nicht gerade fördert.

Comal unterstützt nun strukturiertes Programmieren durch eine Vielzahl von Strukturbefehlen (Tabelle 2). Zur Bildung von Programmschleifen stehen neben der von Basic bekannten FOR...NEXT-Struktur noch WHI-LE...ENDWHILE und REPE-AT...UNTIL zur Verfügung. Am einfachsten davon ist die Schleife mit REPEAT...UNTIL (»Wiederhole ... bis«). Hinter UNTIL muß eine Bedingung stehen. Ist die Bedingung nicht erfüllt, wird die Schleife ab REPEAT wiederholt, und zwar so oft, bis entweder die Bedingung wahr wird, oder bis der entnervte Programmierer die STOPTaste drückt. Der folgende Vierzeiler wartet zum Beispiel, bis die Taste »X« gedrückt wird.
10 DIM EINGABE$ OF 1
20 REPEAT
30 EINGABE$ : = KEY$
40 UNTIL EINGABE$ = ”X”

Die Systemvariable »KEY$« enthält stets die gerade gedrückte Taste. Ist keine Taste gedrückt, ist KEY$ = CHR$(0).

WHILE...ENDWHILE funktioniert ähnlich wie REPEAT...UN-TIL, nur steht hier die Bedingung direkt hinter WHILE, wird also überprüft, bevor die Schleife zum ersten Mal durchlaufen wird. Dadurch wird eine WHILE-Schleife möglicherweise nie durchlaufen, nämlich dann, wenn die Bedingung von Anfang an schon nicht erfüllt war. In diesem Fall werden alle Befehle zwischen WHILE und ENDWHILE übersprungen und das Programm nach ENDWHILE normal fortgesetzt.

Das genaue Format der WHILE-Schleife ist »WHILE (Bedingung) DO (Anweisungen) ENDWHILE«.

Mit dem »DO« hat es dabei eine besondere Bewandtnis. Steht hinter dem »DO« in der gleichen Zeile eine Anweisung, dann faßt Comal dies als eine einzeilige WHILE-Schleife auf. In diesem Fall darf kein ENDWHILE mehr folgen, sonst gibt es einen »Fehler in der Programmstruktur«. Mit dieser Kurzform einer WHILE-Schleife und dem Comal-Befehl »NULL« läßt sich sehr elegant eine Warteschleife auf einen Tastendruck aufbauen:
10 WHILE KEY$ = CHR$(0) DO NULL

Die Anweisung NULL ist eine »Dummy«-Anweisung mit der speziellen Eigenschaft, nichts zu bewirken. Die obige Zeile könnte man also etwas frei übersetzen mit »solange keine Taste gedrückt, tue nichts«.

Neben diesen beiden Schleifenstrukturen gibt es natürlich noch die Zählschleife FOR.. .TO... ENDFOR, die völlig analog zur FOR...NEXT-Schleife in Basic arbeitet, so daß die Besprechung der Arbeitsweise entbehrlich erscheint.

## Entscheidungen fällen

In praktisch jedem Programm müssen logische Entscheidungen, meist sogar in großer Anzahl, getroffen werden. Comal stellt dafür eine sehr mächtige IF.. .THEN...ELIF. ..ELSE...ENDIF-Konstruktion zur Verfügung die sich in der Regel über mehrere Zeilen erstreckt und ganze Programmblöcke umfassen kann. Daneben gibt es — wie bei »WHILE« — noch eine einzeilige Kurzform. Diese Kurzform besteht einfach darin, daß hinter dem »THEN« in der gleichen Zeile noch ein Befehl folgt. Das funktioniert dann völlig analog zu Basic, nur mit dem Unterschied, daß in Basic noch weitere Befehle, jeweils durch Doppelpunkt getrennt, in der gleichen Zeile folgen dürfen. Für derartige Fälle — und für Fälle, die man in Basic so gar nicht lösen kann — wird in Comal die mehrteilige Form der IF-Anweisung verwendet.

Bei dieser Form muß die Zeile nach dem »THEN« beendet werden. Dann werden, falls die Bedingung hinter dem IF erfüllt ist, alle folgenden Programmzeilen bis zum Ende der IF-Anweisung ausgeführt. Eine mehrzeilige IF-Anweisung muß immer mit dem Schlüsselwort »ENDIF« beendet werden. Außer »ENDIF« darf die entsprechende Zeile allenfalls noch einen Kommentar (//) enthalten. War die IF-Bedingung nicht erfüllt, dann wird das Programm in der auf das »ENDIF«-Statement folgenden Zeile fortgesetzt.

Doch damit sind wir noch längst nicht am Ende. Die IF-Anweisung kann auch um einen »ELSE«-Teil erweitert werden und hat dann das folgende Format:
IF (Bedingung) THEN (Teil 1) ELSE (Teil 2) ENDIF.

Der Programmteil (Teil 1) wird ausgeführt, falls die (Bedingung) erfüllt war, sonst wird (Teil 2) ausgeführt. Jeder dieser beiden Teile ist ein völlig unabhängiges Programmstück und kann seinerseits auch wieder IF-Abfragen enthalten.

Will man gleich mehrere verschiedene Bedingungen testen, dann kann man das Comal-Schlüsselwort »ELIF« verwenden. »ELIF« ist eine Abkürzung für »ELSE IF« und hat auch die gleiche Wirkung, nur mit dem Unterschied, daß keine zweite IF-Anweisung (zu der dann auch ein zweites ENDIF gehören müßte) eröffnet wird. Das folgende Beispielprogramm testet eine einzugebende Zahl auf bestimmte Werte:
10 INPUT ”ZAHL ?”: ZAHL
20 IF ZAHL = 1 THEN
30 PRINT ”EINS”
40 ELIF ZAHL = 2 THEN
50 PRINT ”Zwei”
60 ELSE
70 PRINT "WEDER EINS NOCH ZWEI”
80 ENDIF

Ich erspare mir — und Ihnen — an dieser Stelle, ein entsprechendes Basic-Programm vorzustellen (GOTO, GOTO, ...).

Für den Fall, daß die zu testenden Bedingungen durch einen Variablenwert dargestellt werden können, ist die CASE-Anweisung vorgesehen. Die Wirkungsweise wird wohl am besten klar, wenn wir unser Beispiel zur IF-Anweisung auf die CASE-Konstruktion umschreiben:
10 INPUT ”ZAHL ?”: ZAHL
20 CASE ZAHL OF
30 WHEN 1
40 PRINT "EINS”
50 WHEN 2
60 PRINT ”ZWEI”
70 OTHERWISE
80 PRINT "WEDER EINS NOCH ZWEI”
90 ENDCASE

In der Kopfzeile einer CASE-Anweisung wird also eine Variable angegeben, gefolgt vom Schlüsselwort »OF«.

Dann folgen beliebig viele Zeilen mit »WHEN«-Konstruktionen. Hinter WHEN ist immer ein Wert angegeben, der bei der Programmausführung mit dem aktuellen Wert der CASE-Variablen verglichen wird. Wird eine Übereinstimmung festgestellt, dann wird der Programmteil hinter der entsprechenden WHEN-Anweisung bis zum folgenden WHEN ausgeführt. Trifft keine WHEN-Bedingung zu, dann wird der Programmteil hinter OTHERWISE ausgeführt. OTHERWISE ist optional und muß nicht vorhanden sein. Trifft keine WHEN-Bedingung zu und ist kein OTHERWISE vorhanden, dann wird das Programm hinter ENDCASE normal fortgesetzt.

Kommen wir nun noch, sowohl last als auch least, zu einem Befehl, den hartgesottene Spaghetticode-Programmierer schon vermißt haben mögen. Gemeint ist die GOTO-Anweisung, die, obschon weitgehend entbehrlich, auch in Comal noch für Spezialfälle zur Verfügung steht. In Comal wird allerdings nicht zu bestimmten Zeilennummern gesprungen, sondern ein GOTO bezieht sich immer auf ein LABEL. Ein Label ist einfach irgendein Name, wie er auch als Variablenname verwendet werden könnte, gefolgt von einem Doppelpunkt. Vor diesem Namen kann, muß aber nicht, das Schlüsselwort LABEL stehen. Die betreffende Zeile darf nur dieses Label und keine weiteren Befehle enthalten. Wer also von GOTO wirklich nicht loskommt, kann das Warten auf einen Tastendruck auch folgendermaßen programmieren (nicht zur Nachahmung empfohlen):
5 DIM A$ OF 1
10 LABEL WARTEN:
20 A$ := KEY$
30 IF A$ = CHR$(0) THEN GOTO WARTEN

Es sollte auch nicht unerwähnt bleiben, daß man nicht in FOR...ENDFOR-Schleifen, Funktionen und Prozeduren hinein oder aus ihnen hinaus springen sollte. Mit »Funktionen und Prozeduren« ist im übrigen bereits das Stichwort für die nächste Folge gegeben. Bis dahin können Sie sich ja vielleicht die Zeit damit vertreiben, Ihre Basic-Programme in Comal umzuschreiben, und zwar selbstverständlich ohne GOTO!

(ev)

# 64'er Disk-Ecke

> Wie die Überschrift schon andeutet, hat sich eine Änderung vollzogen. Das »Ka« für Kassette ist weggefallen. Dafür hat sich »Di« zu Disk gemausert. Die Diskette ist aufgrund ihrer Verbreitung ausgewählt worden. Dafür sind jetzt alle Programme einer Ausgabe (VC 20 und C 64) auf einer Diskette erhältlich.

Eines hat sich aber nicht geändert: der Preis. Die Diskette für eine Ausgabe kostet demnach 29,90 Mark. Sie werden bei einigen Disketten bestimmte Programme vermissen. Deren Autoren konnten sich nicht entschließen, ihr Programm im Rahmen des Leserservice für eine Verbreitung auf Datenträger freizugeben. Bei den Ausgaben 5 und 6 können noch Kassetten (VC ...) bestellt werden. Auf kurze Programme wurde aus Gründen der Übersichtlichkeit verzichtet. Nun noch einige technische Details. Zu den Programmen sind immer die Seitenzahlen angegeben, unter der Sie die Beschreibungen in der entsprechenden Ausgabe finden können. Der Diskette liegen also keinerlei Informationen bei. Lesen Sie daher aufmerksam die Anleitung (ob SYS-Befehle nötig sind, in welcher Reihenfolge geladen werden muß, eventuelle Sprach- oder Speichererweiterungen und ähnliches mehr) in dem jeweiligen Artikel nach. Aus Aktualitätsgründen wird jeweils die abgedruckte Version angeboten. Eventuelle systematische Fehler, die sich noch im Programm befinden können, müssen von Ihnen selbst, nach Studium des Druckfehlerteufelchens, korrigiert werden.

**Fehlende Hefte erhalten Sie bei: Markt & Technik
Vertrieb 64’er
Hans-Pinsel-Str. 2,8013 Haar**

### Ausgabe 12/84

Bestell-Nr. CB 022 DM 29,90*
**Commodore 64**
Synthesizer (AdM)
SMON (2. Teil)
3D-Vier gewinnt
Trace
Stringy
Lader
PET-Simulator
Auto
Listschutz
Hires
Simons Axo (SB)
Kreuzworträtsel
**VC 20**
Mathematikal Basic (8K>) (LdM)
Fast Tape

### Ausgabe 11/84

Bestell-Nr. CB 020 DM 29,90*
** Commodore 64**
Turtle Grafik (LdM)	S.48
Schachmeister (AdM)	S.50
SMON (1. Teil)	S.59
Floppykurs	S.117
FPLOT-Befehlserweiterung S.73
Get Koala pic	S.66
Interrupttechnik	S.84
Exsort (UPB)	S.154
Einzeiler	S.158
Simons Basic
Befehlserweiterung (SB)	S.90
**VC20**
Pseudosprites (8K)	S.76
Laterna Magica (8K)	S.68
Betriebssystem-
Erweiterung (24K >)	S.88
Supergrafik (GV)	S.71
VG 20-Kurs(GV>)	S.126

### Ausgabe 10/84

Bestell-Nr. CB 019 DM 29,90*
**Commodore 64**
Finanzmathematik (AdM) S.68
Hypra-Load (LdM) S.67
Hardcopy
Compact 2	S.86
Hardcopy MPS 801	S.82
Hardcopy VC 1526 neu	S.83
Hardcopy Gemini-10X	S.85
Hardcopy FX-80	S.88
Hardcopy VC 1520 farbig	S.84
Apocalypse now	S.106
Supercopy	S.102
Disk-Dump	S.95
Diskettenorganisation S.97
User-Port-Tastatur	S.92
Maske-(UPB)	S.172
**VC20**
Epedemic	S.112
Video-Vorspann	S.81

## Ausgabe 9/84

Bestell-Nr. CB 014 DM 29,90*
**Commodore 64**
Indexsequentielle Adreßdatei, S. 54
- Spring Vogel (LdM), S. 68
— Orgel/Synthesizer (AdM), S. 70
— Sprite Aid +, S. 89
— Screen Change, S. 94
— List-Stop, S. 97
— Renew, Datawandler, S. 102
— Synthetische suchen, S. 104
— Geregelter Zahlungsverkehr, S. 164
**VC 20**
Schiebung (GV>), S. 77
— Deuzei (8K >), S. 79
— Hardcopy 1520 (GV>), S. 87
- RS232-Interface (GV>), S. 100
— Datawandler (GV>), S. 102

### Ausgabe 8/84

Bestell-Nr. CB 013 DM 29,90*
**Commodore 64**
Castle of Doom, S. 66
— Pac-Boy, S. 89
— Kopplung, S. 73
— User-Port-Display, S. 97
— RS232-Test, S. 77
- View BAM, S. 99
- Görlitz Hardcopy, S. 83
— Milchvieh, S. 156
**VC20**
Kudiplo (3K), S. 86 — Print at Restore n (GV), S. 101

## Ausgabe 7/84

Bestell-Nr. CB 017 DM 29,90*
**Commodore 64**

Terminalprogramm, S. 24
— Softwarekatalog, S. 72
— Russvok (SB), S. 76
— Crown No. 1, S. 80
— Space Invaders, S. 81
— 1520 Hardcopy, S. 108
— Centronics Interface, S. 110
— Kurvendiskussion, S. 116
— Copy Rel. Files, S. 132
— Autostart, S. 138
— Strubs (OP u. QP), S. 154
**VC20**
Rätsel, S. 122

## Ausgabe 6/84

**Commodore 64**
Bestell-Nr. CB 018 DM 29,90*
Lehrerkalender, S. 64 — Morsetrainer, S. 72 — Supervoc, S. 69 — Grafische Darst. (SB), S. 82 — Hot Wheels, S. 92
**VC 20** Bestellnummer VC 008
Movemaster (8K), S. 78 — Ghost Manor(GV), S. 104, Logic Disass. (3K>), S. 108, Underground (LdM 16K), S. 120 DM 29,90*

## Ausgabe 5/84

**Commodore 64**
Bestell-Nr. CB 016 DM 29,90*
Adreß- & Telefonregister, S. 64 — Fahrsimulator, S. 82 — Schatzsucher (LdM), S. 90
**VC 20** Bestellnummer VC 007
Relative Datei (8K), S. 69 — Schmatzer (GV) S. 76 - 3D-Grafik (8K), S. 78 - Rallye (28K), S. 128	DM 29,90*

Bedeutung der Abkürzungen
*LdM - Listing des Monats
*AdM - Anwendung des Monats
*SB = Simons Basic
*CV - Grundversion
*GV> - alle Speicherversionen können verwendet werden (einschließlich GV)
*3K - 3-KByte-Speichererweiterung wird benötigt
*8K> - Speichererweiterung größer als 8 KByte wird benötigt.
*UPB - Unterprogrammbibliothek

Bestellungen richten Sie bitte an:
M &T Buchverlag, Hans-Pinsel-Str. 2, 8013 Haar
*Alle Preise inklusive Mehrwertsteuer. Der Versand erfolgt mit offener Rechnung zuzüglich Porto und Verpackung.

# Kreuzworträtsel selber machen – 1000 Mark für den Gewinner

> Kreuzworträtsel sind bei jung und ah beliebt. Das beweisen die vielen Rätselzeitschriften. Aber ein Kreuzworträtselprogramm zu schreiben ist etwas ganz anderes, als ein Rätsel zu lösen. Diese Aufgabe ist eine Herausforderung für gute Programmierer. Das beste Ergebnis des Kreuzworträtsel-Wettbewerbs stellen wir Ihnen vor.

Es läßt kaum Wünsche offen. Der Bildschirmaufbau ist genauso gut gelöst wie die Druckerausgabe. Auch den Bedienungskomfort kann man sich kaum besser vorstellen.

Ein Kreuzworträtselprogramm zu schreiben ist eine knifflige Aufgabe. Nicht nur die für den Betrachter eines Rätsels selbstverständlichen Regeln, wie das Kreuzen von Worten senkrecht zueinander und die dichte Vernetzung von Wörtern, auch die Geschwindigkeit und der Komfort des Programmes spielen eine große Rolle. Damit blieb in diesem Falle nur der Einsatz von Maschinensprache übrig. Das Kreuzworträtselprogramm besteht also aus zwei Teilen. Einem Rahmenprogramm in Basic, sowie einer Maschinenroutine, die im Bereich ab $C000/ 49152 geladen wird und die die Schwerarbeit leistet (zirka 30 Wortvergleiche/Sekunde).

Um das Rätselprogramm nicht unnötig mit der Eingabe des Wortschatzes zu belasten, werden die Wörter vorher mit einem Editor eingegeben und bis zu 255 in einem File auf Diskette abgelegt. Das eigentliche Rätselprogramm liest diese Files dann ein und verwendet sie im Rätselfeld (Bild 1). Trotzdem ist die Eingabe von Hand möglich. Denn der große Wortschatz eines Menschen kann niemals auf Diskette gespeichert werden.

### Die Programme

Bevor also die Erzeugung eines Kreuzworträtsels starten kann, muß ein Wortschatz mit dem Lexikon-Editor eingegeben werden (Bild 2). Dieses Programm hat vier Aufgaben:
a)	Directory lesen. Dabei werden nur die bereits auf Diskette vorhandenen Wortschatzdateien angezeigt.
b)	Wortdatei anlegen. Mit diesem Programmteil können Sie bis zu 255 Wörter und die zugehörigen Fragestellungen eingeben und diese dann auf Diskette als Wortdatei ablegen. Eine spezielle Eingaberoutine (Zeile 1000 — 1099) sorgt dafür, daß nur erlaubte Zeichen eingegeben werden. Es ist zum Beispiel unsinnig, ein Kreuzwort einzugeben, das aus mehreren Teilen besteht, wie etwa »Level II Basic«, oder eine Mischung aus Zahlen und Buchstaben, wie »C 64«.

So können Sie sich also im Laufe der Zeit eine ganze Bibliothek von Wortschätzen aufbauen, die beliebig während der Rätselerzeugung einzusetzen sind.

Eine Besonderheit ist die Verkettung von Dateien. Sie können Nachfolgedateien benennen, die im Rätselprogramm automatisch nachgeladen werden, sobald der Vorgängerwortschatz erschöpft ist. Beispiel: Sie wollen ein Rätsel zum Thema »Computer« basteln. Geben Sie jetzt mit Hilfe des Lexikon-Editors den ersten Teil des geplanten Wortschatzes ein und benennen ihn mit»Computer.l«. Der Folgewortschatz soll »Computer.2« sein. Nachdem Sie den 1. Teil abgespeichert haben, geben Sie den 2. Teil ein und benennen den Nachfolger mit »Computer.3« und so weiter. Wollen Sie diese Kette beenden, wird einfach ein »q« (Quit) für den Nachfolger angegeben. Das Rätselprogramm bricht dann später an dieser Stelle mit dem automatischen Nachladen ab.

Bei dieser Methode hängt die Qualität des Rätsels entscheidend von der Staffelung der Dateien ab, das heißt im ersten File sollten lange Wörter stehen und mit jedem Folgefile die durchschnittliche Wortlänge abnehmen. Die Erstellung des Rätsels gerät dadurch wesentlich flüssiger, denn mit zunehmender Dichte des Wortfeldes müssen die Wörter natürlich immer kürzer werden, damit sie noch einzubauen sind.
c)	Wortdatei ändern. Mit Sicherheit tauchen irgendwann falsch eingegebene Kreuzwörter auf, so daß eine Datei verbessert werden muß. Unter diesem Programmpunkt kann daher die entsprechende Wortdatei geladen und editiert werden.
d)	Abbrechen. Mit Verlassen des Editors kann das Rätselprogramm geladen und gestartet werden, so daß ein fließender Übergang von der Worteingabe zur Rätselerstellung möglich ist.

Nun zum Kreuzworträtselprogramm. Wie schon gesagt, besteht dieses Programm aus zwei Teilen, einer Maschinenroutine und dem

Basic-Rahmenprogramm. Dieses Rahmenprogramm (Bild 3) will ich zuerst beschreiben.

Nach dem Start des Programmes beginnt zunächst eine Initialisierungsphase (Zeilen 27—39). In einem Unterprogramm (ab Zeile 970) werden die Maschinenroutine für das Kreuzworträtsel und Treibersoftware für den Drucker am User-Port geladen. Wenn Sie einen Drucker am IEC-Bus betreiben, ist dieser Programmteil (Zeile 976 + 979) natürlich nicht nötig und zu entfernen.

Im folgenden Unterprogramm zur Dimensionierung der Variablen und Definition einiger Konstanten (Zeile 915—969) erfolgt der erste Sprung in die Maschinenroutine (Zeile 937), um sie zu initialisieren.

Nach dem Bildaufbau (Unterprogramm ab Zeile 600), ist auf dem Monitor ein Kreuzwortfeld von 20x20 Zeichen zu sehen. Das Programm fragt jetzt nach dem Startwort, das als erstes Wort im Feld eingetragen werden muß, um der Maschinenroutine einen Kristallisationspunkt zu bieten (Zeile 34— 35). Geben Sie ein möglichst langes Wort ein, das Sie zum Beispiel unbedingt im Rätsel verarbeiten möchten. Bei dieser Eingabe findet, wie schon beim Editor, ein Zeichencheck statt, der es unmöglich machen soll, unerlaubte Zeichen im Rätselfeld unterzubringen. Danach müssen Sie sich zwischen einer waagerechten oder senkrechten Eintragung entscheiden, und ein Cursor taucht im Wortfeld auf. Fahren Sie wie gewohnt mit den Cursortasten die gewünschte Wortposition an und drücken die RETURN-Taste. Da es das erste Wort ist und genügend Platz im Wortfeld herrscht, wird Ihr Wort ohne Protest sofort eingetragen. Jetzt noch schnell die zugehörige Fragestellung eingetippt, und das erste Wort ist korrekt eingetragen.

Sie können dieses Spiel beliebig fortsetzen und theoretisch das ganze Rätsel auf diese Weise per Hand erstellen. Alle Eingaben von Hand sind frei von dem Zwang, ein Wort mit einem anderen kreuzen zu müssen. Sie können Ihre Wörter also beliebig positionieren, sollte ein Wort allerdings nicht passen, wird es zurückgewiesen und der Handeingabe-Modus abgebrochen.

Regulär verlassen Sie die Handeingabe, indem Sie anstelle eines neuen Wortes ein »q« eintippen. Später können Sie die automatische Rätselerzeugung jederzeit unterbrechen und mit F7 wieder in den Handmodus zurückkehren.

Im Wortfeld stehen nun ein oder mehrere Wörter, die als Startpunkte für andere Wörter dienen. Senkrechte Eintragungen sind weiß und waagerechte gelb gefärbt.

Bleibt nur die Angabe, welcher auf Diskette gespeicherte Wortschatz als erstes geladen werden soll (Zeile 37). Dabei können Sie sich mit »$« auch das Inhaltsverzeichnis der Diskette ansehen, für den Fall, daß Ihnen der Name eines Wortschatzes entfallen ist.

Nach erfolgreichem Laden des ersten Wortschatzes beginnt nun die automatische Rätselerzeugung (Hauptschleife Zeile 40—99). Zunächst überraschend schnell füllt sich das Wortfeld mit zufällig plazierten und gekreuzten Wörtern. Dieser Vorgang wird von der Maschinenroutine gesteuert. Auf die genaue Arbeitsweise dieses Programmteiles gehe ich noch gesondert ein. Links oben auf dem Bildschirm erscheint die Anzahl der Wörter, die bereits eingetragen sind (maximal 255 sind möglich) und daneben die momentane prozentuale Größe des noch zur Verfügung stehenden Wortschatzes im Speicher.

Bei jeder Eintragung wird die Liste der Kreuzwörter gekürzt und das benutzte Wort aus der Liste gestrichen. Dies geschieht durch Vertauschen der Stringvektoren des zu streichenden Wortes und des letzten Wortes im Array (Zeile 300—399). Diese Methode wurde gewählt, um die Bildung von neuen Strings im Speicher zu vermeiden und der schrecklich langsamen Garbage-Collection aus dem Wege zu gehen.

Während der Rätselerzeugung können Sie sich in Ruhe überlegen, ob Sie ein automatisches Nachladen von Wortschätzen gestatten wollen oder nicht. In der rechten Bildhälfte ist inzwischen die Belegung der Funktionstasten zu sehen, und mit der F6-Taste schalten Sie die Autolader-Option ein oder aus. Erscheint »Aus« im F6-Tastenfeld, ist das Nachladen gesperrt.

Die Maschinenroutine sucht derweil ständig nach passenden Stellen im Wortfeld. Dieser Vorgang kann im Prinzip endlos sein, da irgendwann natürlich kein geeignetes Wort mehr zu finden ist. Aus diesem Grund hat das Programm eine »Geduld-Schwelle«, eine Anzahl von Suchversuchen, innerhalb derer ein passendes Wort gefunden werden muß. Ist die Versuchszahl ohne Erfolg abgelaufen, geht das Programm davon aus, daß der Wortschatz nicht mehr ausreicht. Diese »Geduld-Schwelle« können Sie in Zeile 964 selbst bestimmen.

Bevor allerdings in der obersten Bildzeile die Meldung »Wortschatz ungenügend« erscheint (Zeile 64/Unterprogramm 110—15 8), hebt das Programm noch die »Blausperre« auf (Zeile 66). Dieses Flag hat dem Maschinenprogramm bisher mitgeteilt, daß nur dann eine Eintragung erlaubt ist, wenn dabei auch ein blaues, unbesetztes Feld abgedeckt wird. Eine Maßnahme, um das Rätsel möglichst dicht zu packen. Ab sofort ist also auch das Einpassen eines Wortes nur auf besetzten Feldern möglich. Läßt sich auch jetzt kein Wort mehr finden, erscheint endgültig der Hinweis auf mangelnde Wortauswahl. Wenn Sie das »Autoladen« zugelassen haben, wird nun der Folgewortschatz, falls vorhanden, gelesen und das Spiel beginnt von Neuem. Selbstverständlich ist auch das Laden von Wortdateien vor Ablauf der »Geduld-Schwelle« machbar. Dazu dient die Fl-Taste. Aber Vorsicht, auf die Gefahr, daß Sie einen bereits verbrauchten Wortschatz nochmal laden, müssen Sie schon selbst achten.

Es dauert gar nicht so lange, dann ist das Wortfeld so dicht gepackt, daß der Maschinenroutine keine Eintragung mehr gelingt. Jetzt sind Sie gefordert, und mit der F7-Taste wählen Sie die Handeingabe an. Genau wie bei der Eintragung der ersten Startwörter können Sie Ihre »Lückenfüller« positionieren und die Fragestellung dazu eingeben.

Zufrieden mit Ihrer Arbeit (hoffentlich!) bleibt nur noch der Ausdruck des Rätsels. Mit F4 wird er gestartet. Das Unterprogramm für die Druckausgabe nimmt im Programm den weitaus größten Platz ein (Zeile 740—914). Ich verwende einen Epson RX-80-Drucker, der mit Hilfe einer speziellen Treibersoftware (Epson Software-Interface) auch CBM-Sonderzeichen drucken kann. Dazu muß eine unübliche Geräteadresse (6) angegeben werden (Zeile 761 und 900). Sollten Sie also einen CBMgrafikfähigen Drucker am IEC-Bus betreiben, tauschen Sie diese Adresse gegen die gewohnte »4« (im Listing schon geändert).

Auch die Druckerinitialisierung ist von Drucker zu Drucker verschieden (Zeilen 754—758). Achten Sie darauf, daß Ihr Drucker hier folgende Einstellung erhält:

— Zeilenabstand = 0
— CBM-Grafikmodus
- Startposition des Druckkopfes = lr (Linker Rand, kann in Zeile 946 geändert werden).

Für den Ausdruck der Fragestellung wird der RX80 im Engschriftmodus versetzt, um Platz zu sparen (Zeile 824—827). Auf diesen Effekt können Sie natürlich verzichten, müssen dann aber die Zeilenlänge (cz, in Zeile 948) ändern, da der Ausdruck vom Programm mit Randausgleich versehen wird (Zeile 847 - 889).

Nun wie versprochen zum Maschinenprogramm, kurz genannt »Such« (Bild 4 und 5). Diese Routine liegt im Bereich $C000/49152, wo sie gut gegen überschreiben durch Basic geschützt ist. Der Einsprung erfolgt über den USR-Vektor (definiert in Zeile 931 bis 932), das heißt es findet eine Parameterübergabe zwischen Basic und Maschinenroutine statt. Basic übergibt in »dl« die Anzahl der Versuche, die die Routine durchlaufen sollen (Zeile 44). Mit der Rückkehr aus der Routine wird der Variablen »u« ein Wert zwischen 1 und 4 zugewiesen. Aus dem Wert von »u« kann also auf die Ursache für den Abbruch der Routine geschlossen werden:

— u = 1; eine Taste ist betätigt worden.
— u = 2; die Suche nach einem passenden Kreuzwort war vergeblich.
— u = 3; ein Wort wurde gefunden und in das Wortfeld eingetragen.
— u = 4; die maximale Anzahl (255) von eingetragenen Kreuzwörtern ist erreicht; keine weitere Eintragung möglich. Das Rahmenprogramm kann jetzt entsprechend reagieren und zum Beispiel im Falle u = 3 das benutzte Wort aus der Wortliste streichen. Im Falle einer Eintragung (von Hand oder automatisch) wird das Wort nicht nur in den Bildspeicher eingesetzt, sondern es werden auch einige weitere Informationen abgelegt:

a) Eintragung im »Wortbeginn/ende«-Speicher (50176 bis 50575); hier wird vermerkt, ob ein Rätselfeld den Start- oder Endpunkt eines Kreuzwortes repräsentiert. Der Speicher ist, wie die folgenden auch, in 20 Zeilen mit je 20 Positionen (Speicherstellen) aufgeteilt. Das linke Halbbyte (4 Bit) einer Speicherstelle trägt die Informationen über senkrechte, das rechte Halbbyte über waagerechte Start/Endpositionen. Das 1. Bit im Halbbyte wird für Endpunkte gesetzt, das 3. Bit für Startpunkte. Diese Informationen werden später bei der Ausgabe des Rätsels auf dem Drucker benötigt, um an den richtigen Stellen die Nummer der zugehörigen Fragestellung eintragen zu können.
b)	Eintragungen im »Senkrecht«-Speicher (50576 bis 50975); in dieser Speichermatrix werden die Ordnungsnummern der Fragestellungen für senkrechte Rätselwörter abgelegt. Bei der Druckausgabe wird diese Matrix abgefragt (Zeile 773 bis 777), um die Nummer der Fragestellung im entsprechenden Startfeld einzusetzen.
c)	Eintragung im »Waagerecht«-Speicher (50976 bis 51375), wie unter b) Zeile 796 bis 800).

Um die Speicherinhalte vor dem Start des Rätselprogramms zu löschen, springt man die Routine mit »sys 50016« an (Zeile 937).

Nun zur Arbeitsweise der Routine während der automatischen Rätselerzeugung. Zunächst muß das Maschinenprogramm erst einmal wissen, ob es wegen einer Handeintragung angesprungen wurde oder zur automatischen Wortsuche. Dazu liest die Routine die Speicherstelle 26 aus. Ist das Ergebnis Null, wird in den Automodus verzweigt. Andernfalls wird in 26 die Länge des von Hand eingetragenen Wortes übergeben (siehe Zeile 662 bis 663). Die Routine braucht dann nur den Paß des Wortes zu überprüfen und bei korrekter Eintragung ins Basic zurückzukehren. Paßt das Wort allerdings nicht, verfällt die Routine in den Automodus. Das Maschinenprogramm durchläuft im Automodus eine Schleife, die zunächst durch Auslesen des Rauschgenerators im Soundchip ein Wort aus dem Wortschatz per Zufall bestimmt. Dann erfolgt auf die gleiche Weise die Auswahl eines Startpunktes im Bildspeicher. Ist dieser Punkt nicht geeignet für eine Eintragung, wird Zeile für Zeile des Wortfeldes nach einer Alternative gesucht. Im Falle eines Treffers startet der Wortvergleich. Das gewählte Wort wird mit dem Inhalt des Bildspeichers auf Übereinstimmung geprüft. Paßt es nicht, kommt das nächste Wort aus dem Wortschatz-Array an die Reihe. Bei Erfolg kehrt »Such« ins Basic zurück, wenn nicht, beginnt die Schleife von Neuem.

Damit der Zugriff auf das Array klappt, muß es nur als erstes im Basic-Programm definiert worden sein (Zeile 925). »Primitiv« werden Sie vielleicht anmerken. Richtig, aber Computer sind nun mal (sehr) schnelle Idioten.

(Gert Büttgenbach/gk)

## Zur Person des Autors:

Gert Büttgenbach, geb. 20. 09. 53, Beruf: Nautischer Offizier.

Wer sich für eine Berufsausbildung als Deckoffizier in der Handelsschiffahrt entscheidet, so wie ich 1977, der ist ein potentielles Opfer der Computersucht. Denn auf der Brücke eines Frachters kann man eine ganze Menge schon mit einem Taschenrechner zaubern. Die Navigation bietet da ein weites Feld. So dauerte es auch kein halbes Jahr und ich stand klopfenden Herzens vor der schillernden Vitrine eines Kaufhauses in Houston/Texas und vernarrte mich in eines der ersten Exemplare des TI59. Ich mußte mir eine ganze Monatsheuer bei meinem Kumpel pumpen, um in den 7. Bytehimmel aufzusteigen. Von nun an gab es keine Langeweile mehr. Bald berechnete mein Rechenknecht simultan aus 7 Sternenbeobachtungen den Standort auf See.

Während meines Seefahrtstudiums an der Fachhochschule Hamburg lernte ich dann andere Computerfreaks kennen. Inzwischen marmelte ein TRS80 Modell I in meiner Bude und ich mußte erst einmal lernen, daß ein Computer nicht alles kann. Dabei ging der Respekt vor diesen Dingern endgültig flöten. In die weite Welt der CBMs bin ich durch meinen Physikprofessor geraten. Gemeinsam mit anderen Studenten bildeten wir bald einen harten Kern, der der zweitschönsten Sache auf der Welt ungehemmt frönte. Als das Ende des Studiums nahte, war das Thema meiner Abschlußarbeit Schuld an der »Ehe« mit dem C 64. Wir brauchten ein Grafikwunder für die Simulation eines Radarbildes. Und da kam gerade ein merkwürdiger »Spielcomputer« (man konnte einen Joystick anschließen, sehr verdächtig?) über den Speicherhorizont, der mehr zu können schien ...

Wie kam ich nun auf die verrückte Idee, ein Kreuzworträtsel-Programm zu schreiben?

Das hatte ich schon auf Modell I probiert, und gemerkt wie vielfältig die Probleme dabei sind. Als ich vom Preisausschreiben im 64'er-Magazin las, war es natürlich eine Herausforderung, die alte Nuß zu knacken.

Mein nächster Computer? Sorry, aber das könnte ein Macintosh sein, denn mein Buckel wird langsam krumm vom Maschinendenken!

(Gert Büttgenbach/gk)

# Pragrammierwettbewerb: Dokumentationshilfe

> Insgesamt 1000 Mark zu gewinnen. Möchte man ein Programm analysieren oder schreiben, und die Dokumentation ist nicht oder nur mangelhaft vorhanden, ist eine automatische Dokumentationshilfe ein interessantes Werkzeug.

Die Aufgabe, die wir diesmal stellen, ist nicht nur eine Herausforderung an Programmierer, sondern soll zudem für Software-Entwickler ein nützliches Utility sein. Es geht um die Programmierung einer erweiterten Crossreferenzliste. Eine Crossreferenzliste durchsucht per Definition ein beliebiges Programm nach Variablen und Sprungbefehlen und gibt sie auf einem Drucker in gut lesbarer Form aus. Wir wollen aber in diesem Programmierwettbewerb ein vollständiges Werkzeug zur Dokumentation eines sich in der Entwicklung befindlichen oder fertigen Programms erhalten. Im einzelnen sollte das Programm folgendes können:
1.	Alle Programmzeilennummern drucken, die Sprünge enthalten. Ausgegeben werden soll die Zeilennummer, dahinter die Zeilen, die angesprungen werden.
2.	Ausgabe aller Programmzeilen, die angesprungen werden, wenn möglich mit den Zeilen, von denen aus der Sprung erfolgt.
3.	Ausgabe aller im Programm verwendeten Variablen.
3.1	In der Reihenfolge, wie sie im Programm auftauchen.
3.2	In sortierter Reihenfolge: Sortiert nach Gruppe (Integer, Real, Strings und Felder) sowie alphabetisch.
3.3	In welcher Zeile sie definiert werden (Variable =) und in welcher Zeile sie benutzt werden (= Variable).
3.4	Es soll zu jeder Variable ein Kommentar eingegeben werden können.
4.	Denkbar wäre auch, die ganze Prozedur innerhalb wählbarer Grenzen (zum Beispiel zwischen Zeile 1000 und 2000) eines Programms ablaufen zu lassen.

Wie Sie aus dem letzten Punkt ersehen können, sind den Ideen keine Grenzen gesetzt. Wichtig ist vor allen Dingen, daß ein komplettes Dokumentationsprogramm für die eigene Entwicklung und zur Analyse fremder Programme zustande kommt. So könnte eine automatische Aufschlüsselung nach Zeilennummern oder die Erstellung eines Fluß- oder Nassi-Shneidermann-Diagramms durchaus mit eingebaut werden. Lassen Sie Ihre Phantasie spielen und dokumentieren eigene und fremde Programme auf die bestmögliche Art und Weise.

Es wird mindestens zwei Gewinner geben: Einer für die beste Lösung in Basic, der andere für das beste Assembler-Programm.

Wenn Ihre Lösung von der oben genannten Aufgabenstellung etwas abweicht, so ist das keine Disqualifikation. Bewertungskriterien werden vor allem sein: Nutzbarkeit, Übersichtlichkeit, Schnelligkeit und Komfort.

Schicken Sie Ihre Lösung unter dem Stichwort

»Programmierwettbewerb: Dokumentationshilfe« an folgende Adresse:
Markt & Technik Verlag AG, Redaktion 64’er, Hans-Pinsel-Str. 2, 8013 Haar bei München

# Vorschau

## Softlearning

Die Lehr- und Lernmethoden an den Schulen ändern sich laufend. Auch auf dem Gebiet des computerunterstützten Lernens können neue Wege beschritten werden. SM hat sich bei der Auslegung ihrer Lernsoftware an dem Erfolgskonzept des Superlearning, das bei der Schulung von Führungskräften in der Wirtschaft seit zwei Jahren für Furore sorgt, orientiert. Also Lernen mit dem C 64, ohne blockierende Ängste und Streßgefühle.

## Alles über Strings

Fast kein Programm kommt ohne Strings aus. Was ist eigentlich ein String? Warum gibt es manchmal »Zwangspausen« — die Garbage Collection — beim Verarbeiten von vielen Strings und wie kann man sie umgehen? Die Antworten und viele Tips und Tricks lesen Sie in der nächsten Ausgabe.

## Forth to Clarity

Voran zum Verständnis — nämlich zum Verständnis von Forth, dieser eigenwilligen Programmiersprache, die in letzter Zeit immer größere Verbreitung findet. Anhand eines konkreten Programmierbeispiels, nämlich dem Bau eines Decompilers, wird in leicht nachzuvollziehender Form in die grundsätzliche Struktur der Sprache eingeführt.

## Hypra-Load mal fünf

Das in Ausgabe 10 vorgestellte Hypra-Load war eine Sensation. Aus diesem Grund bringen wir viele Anregungen und Verbesserungen zu diesem Programm. Außerdem erfahren Sie, wie Hypra-Load fest in das Betriebssystem eingebaut werden kann.

## Außerdem...

— Hi-Eddi, ein faszinierendes Zeichen- und Grafikprogramm als Listing des Monats
— ein strategischer Handballtrainer als Anwendung des Monats
— sieben Kurse
— und wieder viele Tips und Tricks für C 64 und VC 20.

## Der Nachfolger

Der C 16, ursprünglich als Nachfolger des VC 20 konzipiert, ist dabei, sich einen eigenen Platz an der Sonne im heißumkämpften Markt der kleinen Computer zu sichern. Sein Basic 3.5 mit mehr als 75 Befehlen unterstützt Grafik, Sound und strukturierte Programmierung.
Ist der C 16 wirklich nur als Nachfolger des VC 20 gedacht, oder kann er sogar dem C 64 das Leben schwer machen? Unser großer Testbericht zeigt, was der C 16 wirklich kann — und wer ihn sich kaufen sollte.

## Assembler im Test

Immer mehr C 64-Besitzer wollen mehr als nur in Basic programmieren. Um jedoch effektiv in Maschinensprache arbeiten zu können, braucht man einen Assembler. Wir haben die bekanntesten und leistungsfähigsten für Sie herausgesucht und getestet, darunter MAE, Profimat, Pofisoft, ASS64, ASSI und TE.X.AS. Lesen Sie, welcher für Sie am geeignetsten ist.

## G-Basic, die Spracherweiterung für alle Fälle

Spracherweiterungen für den C 64 gibt es schon eine ganze Menge. Die bisher bekannteste dürfte wohl Simons Basic sein. Hat ein neues Produkt wie G-Basic eine Chance? Was leistet G-Basic? Gibt es Probleme oder Fehler? Ist es mit 259 Mark preiswert oder wieder nur eine Lösung mit Kompromissen?

## Digitalisierer

Digitalisierer verwandeln Videobilder oder Sprachimpulse in für den Computer verständliche Signale. Der Empfang von Satellitenbildern, die Auswertung durch den Computer und die Ausgabe auf einem Farbdrucker ist nur ein Beispiel für die Anwendung. Lassen Sie sich überraschen, was man mit Digitalisierern noch alles machen kann.
