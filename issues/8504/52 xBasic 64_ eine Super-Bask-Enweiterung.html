<!DOCTYPE html>
<html lang="de">

<head>
    <title>xBasic 64: eine Super-Bask-Enweiterung</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="../style.css">
    <meta name="author" content="Stephan Blietz, gk">
    <meta name="64er.issue" content="4/85">
    <meta name="64er.pages" content="52,59-63">
    <!-- <meta name="64er.toc_category" content="XXX"> -->
    <!-- <meta name="64er.toc_title" content="XXX"> -->
    <meta name="64er.id" content="XXX">
</head>

<body>
    <article>
        <h1>xBasic 64: eine Super-Bask-Enweiterung</h1>
        <blockquote>
            <p>Schon oft wurden Basic-Erweiterungen veröffentlicht, die aber immer nur einen bestimmten Bereich bevorzugten. xBasic 64 dagegen umfaßt das gesamte Spektrum des C 64 und stent insgesamt 44 neue Befehle zur Verfugung.</p>
        </blockquote>

        <p>XBasic 64 wurde für den Commodore 64 ohne besondere Peripherie geschrieben. Lediglich die Diskettenbefehle und die Hardcopy-Funktion benötigen die entsprechenden Geräte (Device 8 und 4).</p>

        <p>xBasic 64 belegt den Speicher von $8000-$9310. (Näheres hierzu siehe Speicherbelegung im Innenteil, Seite 59ff).</p>

        <p>xBasic 64 stellt Befehle für die Grafikprogrammierung, die Tonerzeugung, die Programmerstellung und Fehlersuche, das strukturierte Programmieren und die labelabhängige Verzweigung zur Verfügung.</p>

        <p>In Tabelle 1 eine Übersicht über die von xBasic 64 bereitgestellten Befehle.</p>

        <p>Insgesamt besitzt xBasic 64 mehr als 40 neue Befehle.</p>

        <h2>Befehlserklärung:</h2>

        <h3>1. Grafikbefehle</h3>

        <h3>1.1. Hochauflösende Grafik (320 x 200)</h3>

        <p><strong>HRG</strong> Syntax: HRG x,y<br />
            Effekt: Der Computer wird in den hochauflösenden Modus versetzt. Es werden die Punktfarben x und die Hintergrundfarbe y gesetzt.</p>

        <p><strong>TEXT</strong> Syntax: TEXT<br />
            Effekt: Der Computer wird wieder in den Textmodus (40 x 25 Positionen) zurückgeschaltet. TEXT wird bei jeder Programmunterbrechung und nach Beendigung eines Programms ausgeführt.</p>

        <p><strong>GCOLOR</strong> Syntax: GCOLOR (pf,hf,rf)<br />
            Effekt: Punktfarbe pf (0 bis 15), Hintergrundfarbe hf (0 bis 15) und Rahmenfarbe rf (0 bis 255) werden gesetzt.</p>

        <p><strong>SET</strong> Syntax: SET (x,y)<br />
            Effekt: Es wird ein Bildpunkt an die durch x (0 bis 319) und y (0 bis 199) festgelegte Koordinate gesetzt. Bei einer Bereichsüberschreitung wird 2INCORRECT XY VALUE gemeldet.</p>

        <p><strong>INVERS</strong> Syntax: INVERS x,y<br />
            Effekt: Es gilt das unter SET Gesagte, jedoch wird der Punkt mit den Koordinaten x/y.</p>

        <p><strong>REVERS</strong> Syntax: REVERS<br />
            Effekt: Der gesamte Grafikschirm wird invertiert.</p>

        <h3>1.2 Blockgrafik (40 x 25 Positionen) FILL</h3>

        <p>Syntax: FILL s, z, lx, ly, char<br />
            Effekt: Füllt einen rechteckigen Bildschirmbereich mit dem Zeichen char (Bildschirmcode) aus. Dabei ist s die Spalte und .z die Zeile der linken oberen Ecke des Rechtecks, lx ist die Länge in der Horizontalen und ly in der Vertikalen. Liegt das Rechteck nicht vollständig im zugelassenen Bereich, wird ?RANGE TOO LARGE angezeigt.<br />
            <strong>PAINT</strong> Syntax: PAINT s, z, lx, ly, col Effekt: Dieser Befehl wirkt fast wie der zuvor genannte, jedoch wird hier der Bereich mit der Farbe col angefüllt.<br />
            <strong>BORDER</strong> Syntax: BORDER col<br />
            Effekt: Der Bildschirmrahmen erhält die Farbe col.<br />
            <strong>PAPER</strong> Syntax: PAPER col<br />
            Effekt: Der Bildschirmhintergrund nimmt die Farbe col an.<br />
            <strong>INK</strong> Syntax: INK col<br />
            Effekt: Alle folgenden Bildschirmausgaben erfolgen in der Farbe col.<br />
            <strong>AT</strong> Syntax: AT PRINT (x,y) Ausdruck Ein in Anführungszeichen stehender Text oder der Wert einer Variablen wird auf dem Bildschirm ab Spalte x und Zeile y ausgegeben.
        </p>

        <h3>1.2.1. User defined graphics (UDG)</h3>

        <p>xBasic 64 gestattet auch die Erstellung eines eigenen Zeichensatzes. Dieser liegt ab $C800. Wird in diesem Modus gearbeitet, so verschiebt sich das Video-RAM nach $C400 (dez. 50176).<br />
            <strong>CHRCOPY</strong> Syntax: CHRCOPY<br />
            Effekt: Der Commodore-Zeichensatz wird an die oben erwähnte Stelle kopiert.<br />
            <strong>RAM</strong> Syntax: RAM<br />
            Effekt: Der Commodore 64 wird auf den kopierten Zeichensatz umgestellt.<br />
            <strong>CREATE</strong> Syntax: CREATE char, bl, b2, b3&hellip;, b8<br />
            Effekt: Mit diesem Befehl wird dem Zeichen char im neuen Zeichensatz ein anderes Bitmuster zugewiesen, welches durch die Bytes bl bis b8 festgelegt ist.
        </p>

        <p>Alle folgenden Befehle sind auch auf Sprites anwendbar. Darüber entscheidet der erste Parameter. Ist er 0, so bezieht sich der Befehl auf die UDG, ist er 1, wirkt er auf die Spritegrafik.</p>

        <p><strong>CHANGE</strong> Syntax: CHANGE 0, char, bnr, b oder CHANGE 1, sbl, x, y, b Effekt: UDG — Das Zeichen mit dem Code char wird verändert. Das Byte mit der Nummer bnr (0 bis 7) wird durch das Byte b ersetzt.</p>

        <p>Sprites — Der Sprite-Datenblock mit der Nummer sbl wird verändert. Das Byte, das im Block durch x und y maskiert ist, wird durch b ersetzt.<br />
            <strong>MOVE</strong> Syntax: MOVE 0, char 1, char 2 oder MOVE 1, sbl 1, sbl 2<br />
            Effekt: UDG — Das Zeichen mit dem Code char 2 erhält das Bitmuster von char 1.<br />
            Sprites — Der Spritedatenblock sbl 1 wird nach sbl 2 kopiert.<br />
            <strong>OVER</strong> Syntax: OVER 0, char 1, char 2 oder OVER 1, sbl 1, sbl 2<br />
            Effekt: UDG — Das Zeichen mit dem Code char 1 wird mit dem Bitmuster von Char 2 verflochten.<br />
            Sprites — Die Bitmuster von sbl 1 und sbl 2 werden verknüpft, wobei das Ergebnis in sbl 2 steht.<br />
            <strong>NEGATE</strong> Syntax: NEGATE mod, nr Effekt: Das Zeichen im neuen Zeichensatz mit der Nummer nr (mod = 0) oder das Sprite mit der Nummer nr (mod = 1) wird invertiert.
        </p>

        <h3>1.3. Spritegrafik SPRITE</h3>

        <p>Syntax: SPRITE snr, x, y sbl, col, mod<br />
            Effekt: Das Sprite mit der Nummer snr (0 bis 7) wird an der durch x (0-511) und y (0 bis 255) festgelegten Position auf den Bildschirm gebracht. Es hat die Farbe col und bezieht sein Bitmuster aus sbl. Ist mod 0, so wird das Sprite im HRG-Modus, ist mod 1, wird es im Multicolormodus dargestellt.<br />
            <strong>MOBEX</strong> Syntax: MOBEX snr,ex,ey
        </p>

        <p>Effekt: Das Sprite mit der Nummer snr wird expandiert. Bei ex gleich 1 wird es in X-Richtung expandiert, bei ey gleich 1 in Y-Richtung.<br />
            <strong>MULTI</strong> Syntax: MULTI col1,col2
        </p>

        <p>Effekt: Es werden die beiden zusätzlichen Farben col1 und col2 für Multicolorsprites festgelegt.<br />
            <strong>CLEAR</strong> Syntax: CLEAR oder CLEAR snr<br />
            Effekt: lm ersten Fall werden alle Sprites vom Bildschirm gelöscht, im zweiten nur das Sprite mit der Nummer snr.
        </p>

        <h3>1.4. Sonstige Grafikbefehle</h3>

        <p><strong>HCOPY</strong> Syntax: HCOPY</p>

        <p>Effekt: Es wird eine Hardcopy vom Textschirm im Groß-/Grafikmodus erzeugt (Gerätenummer 4).</p>

        <h3>2. Befehle für die Tonerzeugung</h3>

        <p><strong>VOL</strong> Syntax: VOL lt</p>

        <p>Effekt: Setzt Lautstärke It (0-15) für alle 3 Stimmen.<br />
            <strong>WAVE</strong> Syntax: WAVE st,wf,fl
        </p>

        <p>Effekt: Für die Stimme st (T3) wird die Wellenform wf (16,32,64 oder 128 gesetzt, fl schaltetdie Stimme ein (fl = 1) oder aus (fl = 0).<br />
            <strong>ENVELOPE</strong> Syntax: ENVELOPE st,an,ab,ha,au
        </p>

        <p>Effekt: Setzt die Hüllkurve für Stimme st. Die Parameter an (Anschlag), ab (Abschwellen), ha (Halten) und au (Ausklingen) dürfen im Bereich von 0 bis 15 liegen.<br />
            Anmerkung: Wird bei WAVE eine ungültige Wellenform angegeben, so meldet xBasic 64 »?NOT EXISTING WAVE«</p>

        <h3>3. Programmierhilfen</h3>

        <p><strong>HELP</strong> Syntax: HELP</p>

        <p>Effekt: Es werden alle von Exbasic 64 verstandenen Befehle aufgelistet.<br />
            <strong>MEMORY</strong> Syntax: MEMORY
        </p>

        <p>Effekt: Die momentane Speicheraufteilung wird angezeigt (Programm, Variable etc.).<br />
            <strong>DUMP</strong> Syntax: DUMP
        </p>

        <p>Effekt: Alle Variable und deren Inhalt werden ausgegeben (Real,lnteger=%,Strings=$,Funktionen=*).<br />
            <strong>START</strong> Syntax: START
        </p>

        <p>Effekt: xBasic 64 wird neu initialisiert. Das derzeitig im Speicher befindliche Programm kann mit RESCUE gerettet werden.<br />
            <strong>RESCUE</strong> Syntax: RESCUE
        </p>

        <p>Effekt: Zurückholen eines Programms nach NEW oder START.<br />
            <strong>RENUMBER</strong> Syntax: RENUMBER stz,sw
        </p>

        <p>Effekt: Das im Speicher befindliche Basic-Programm wird neu durchnumeriert. Dabei ist stz die erste Zeile des »neuen« Programms und sw die Schrittweite. Wird der für Zeilennummern erlaubte Bereich überschritten, so wird die erste nicht mehr unterzubringende Zeile mit der Nummer 0 belegt und »?ILLEGAL LINENUMBER« ausgegeben.</p>

        <h3>4. Diskettenbefehle</h3>

        <p><strong>DIR</strong> Syntax: DIR</p>

        <p>Effekt: Das Directory der momentan eingelegten Diskette wird angezeigt, ohne das im Speicher befindliche Programm zu löschen.<br />
            <strong>ERROR</strong> Syntax: ERROR
        </p>

        <p>Effekt: Tritt ein Diskettenfehler auf, so wird mit diesem Befehl die Fehlernummer, der Fehlertext, der Sektor und die Spur geholt, in der der Fehler auftrat. Das Ganze wird durch Kommata getrennt ausgegeben.</p>

        <h3>5. Befehle für strukturiertes Programmieren</h3>

        <p><strong>REPEAT&hellip;UNTIL</strong><br />
            Syntax: REPEAT (beliebige Anweisungen) UNTIL(Bedingung)</p>

        <p>Effekt: Die Anweisung(en) zwischen REPEAT und UNTIL werden solange ausgeführt, bis die Bedingung hinter UNTIL erfüllt ist. Die Befehle dürfen in zwei Zeilen stehen.</p>

        <p>Es dürfen maximal 32 REPEAT&hellip;UNTIL-Schleifen geschachtelt werden. Ansonsten erfolgt die Meldung »?TOO MANY REPEAT..UNTIL«. Ein UNTIL ohne vorhergehendes REPEAT führt zu dem Fehler »?UNTIL WITHOUT REPEAT«.<br />
            <strong>JUMP</strong> Syntax: JUMP Label
        </p>

        <p>Effekt: Es erfolgt ein Sprung zum Label (Label). Dieses muß in einer PROCEDURE-Zeile stehen. Ein JUMP ohne nachfolgendes Label verursacht den Fehler ?»?MISSING LABEL«. Wird versucht, zu einem nicht existierenden Label zu verzweigen, wird ?»?PROCEDURE NOT FOUND« gemeldet.<br />
            <strong>PROCEDURE</strong> Syntax: PROCEDURE Label
        </p>

        <p>Effekt: Markiert eine Zeile als Labelzeile. Der Befehl selbst wird wie ein REM behandelt. Deshalb dürfen vor und hinter PROCEDURE keine anderen Statements stehen.<br />
            <strong>CALL&hellip;SUBEND</strong> Syntax: CALL Label&hellip;SUBEND
        </p>

        <p>Effekt: Hierbei handelt es sich um eine Art GOSUB&hellip;RETURN. Jedoch wird hier nichtzu einer Zeilennummer, sondern zu der durch Label gekennzeichneten Labelzeile gesprungen. Bei SUBEND springt das Programm dann auf das Statement, das unmittelbar hinter dem entsprechenden CALL steht. Auch hier gilt: maximal 32 CALL..SUBEND-Aufrufe schachteln, sonst gibt’s einen ?TOO MANY CALL&hellip;SUBEND-Fehler.<br />
            Ein SUBEND ohne CALL gibt »7SUBEND WITHOUT CALL«.<br />
            <strong>EXIT</strong> Syntax: EXIT Zeilennummer
        </p>

        <p>Effekt: Mit diesem Befehl kann beliebig oftaus einem Unterprogramm ohne RETURN herausgesprungen werden. Das Programm verzweigt zu der hinter EXIT angegebenen Zeilennummer. Fehlt sie, so wird ein ?MISSING LINENUMBER-Fehler ausgegeben.<br />
            <strong>BRANCH</strong> Syntax: BRANCH Zeilennummer
        </p>

        <p>Effekt: Ermöglicht ein Verlassen eines Unterprogrammes ohne SUBEND. Ansonsten gilt das bei EXIT Gesagte.</p>

        <p>xBasic 64 ermöglicht außerdem das Setzen des DATA-Zeigers auf eine bestimmte Zeilennummer mit RESTORE. Auch Variable sind als Ausdruck zugelassen. Das gleiche gilt auch für GOTO und GOSUB.</p>

        <p>Ein Nachteil von xBasic 64 ist, daß ein xBasic 64-Befehl bei einer IF&hellip;THEN-Anweisung durch einen Doppelpunkt vom THEN getrennt werden muß.<br />
            Beispiel:</p>

        <p>100 IF A=SIN(45) THEN:EXIT 500</p>

        <h3>Zur Beachtung:</h3>

        <p>Verwechseln Sie bei den Spritebefehlen nicht Spritenummer und Spritedatenblocknummer. Die Spritenummer bezieht sich auf die auf dem Schirm darstellbaren Sprites, während sich die Spritedatenblocknummer auf den Datenblock bezieht, aus welchem die Sprites ihre Bitmuster beziehen können. Die Spritenummer darf im Bereich von 0 bis 7 liegen, während die Datenblocknummer Werte von 0 bis 511 annehmen kann. Achten Sie jedoch darauf, daß die im freien RAM liegenden Blöcke vor dem Überschreiben geschützt werden. Die Blöcke 0 bis 10 bitte nicht benutzen!</p>

        <p>Der Spritepointer kann natürlich nur die Blöcke 0 bis 255 adressieren. Um auf die anderen Blöcke zugreifen zu können, müssen diese erst mit MOVE in den entsprechenden Bereich geschoben werden.</p>

        <p>xBasic 64 arbeitet mit drei verschiedenen Video-RAMs. Das »normale« Video-RAM ab $0400, das HRG-Video-RAM, das als Farb-RAM dient, ab $C000 und das Video-RAM bei Gebrauch der UDG ab $C400.</p>

        <p>Weiter belegt xBasic 64 die Bereiche $8E00-8E7F als REPEAT&hellip;UNTIL-Stack und $8E80-8EFF als CALL&hellip;SUBEND-Stack.</p>

        <h2>Programmtechnische Details</h2>

        <p>Zur Initialisierung bedient sich xBasic 64 eines weitverbreiteten Verfahrens: Damit der Commodore 64 ein ROM-Modul beim Einschalten erkennt, muß dieses ab Adresse $8004 das Kennwort »CBM80« enthalten. Die beim Einschalten angesprungene RESET-Routine ruft ihrerseits eine Routine auf, die den erwähnten Speicherbereich nach dem Wort durchsucht. Wird es gefunden, so springt der Computer in der Programmausführung an eine Adresse, die in den Speicherstellen $8000 und $8001 abgelegt ist. Durch Einstecken einer ROM-Kassette am Expansionsport wird der Eingang EXROM auf 0 gesetzt. Dadurch wird der 64er auf ROM umgestellt. Ist EXROM gleich 1, so wird bei einem RESET einfach der RAM-Bereich ab $8004 auf das Kennwort untersucht. Und genau hier setzt xBasic 64 ein. Es enthält nämlich an dieser Stelle das geforderte Kennwort. Der Computer springt also nicht auf den im ROM stehenden Vektor ($A000), sondern auf den von xBasic 64 bereitgestellten ($8000). Dieser zeigt auf eine eigene RESET-Routine. Diese kopiert zum Beispiel das Basic-ROM in das darunterliegende RAM. Nun werden die Veränderungen an den Routinen GOTO, GOSUB und RESTORE vorgenommen. Also Maschinenprogrammierer Vorsicht! In Verbindung mit xBasic 64 ist der Bereich von $A000 bis $BFFF tabu!</p>

        <p>Oberhalb von xBasic 64 ist der für Maschinenprogramme freie Teil nur der Bereich von $9000 bis $9FFF.</p>

        <p>xBasic 64 besitzt einige neue Fehlermeldungen. Die entsprechende Routine liegt ab $8184. Sie wird mit der Nummer der Fehlermeldung im Akku angesprungen. Sie holt sich dann die Adresse der Fehlermeldung aus einer Tabelle ($8DE0).</p>

        <p>Geben Sie einmal folgendes ein:<br />
            POKE 780,2:SYS 33156</p>

        <p>Sie müßten die Meldung »7ILLEGAL LINENUMBER ERROR« erhalten. Das ist die Fehlermeldung mit der Nummer 2. Die Nummern 0 bis 12 werden von xBasic 64 belegt, die restlichen sind jedoch für eigene Fehlermeldungen frei.</p>

        <p>Für die Befehle REPEAT&hellip;UNTIL und CALL&hellip;SUBEND benutzt xBasic 64 zwei Stacks. Auf diesen Stacks wird beim Aufruf von REPEAT oder CALL die momentane Zeilennummer und der Programmzeiger abgelegt.</p>

        <p>Die Befehle UNTIL und SUBEND holen diese Werte wieder zurück. Jeder Stack hat seinen Pointer, der auf die Elemente im Stack zeigt. Die beiden Pointer liegen bei $07E8 (RU-Stack) und $07E9 (CS-Stack). Die beiden Stacks liegen ab $8E00 (RU) und 8E80 (CS).</p>

        <p>Mit den von xBasic 64 zur Verfügung gestellten Routinen sollte es keine Schwierigkeit sein, eigene Befehle einzubauen. Mit dem entsprechenden Algorithmus und den Routinen Koordinaten holen und Punkt setzen, ist es bestimmt nicht sehr kompliziert, eine LINE-Routine oder andere Grafikbefehle zu implementieren (siehe auch Tabelle 1).</p>

        <address class="author">(Stephan Blietz/gk)</address>

        <p>TODO ASIDE</p>

        <p>Die Eingabe von xBasic 64<br />
            xBasic 64 muß mit dem MSE eingegeben werden, den Sie ebenfalls in diesem Heft finden oder bereits aus den vorhergehenden 64’er-Ausgaben kennen. Nach dem Abtippen speichern Sie das Programm auf jeden Fall vor dem ersten Test.<br />
            xBasic 64 läßt sich mit LOAD &ldquo;Name&rdquo;,8,1 von der Diskette (oder LOAD von der Kassette) laden und mit SYS 64738 (!) starten.</p>

        <p>/TODO ASIDE</p>
    </article>
</body>

</html>