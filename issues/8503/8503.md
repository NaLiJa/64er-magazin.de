# Weiter mit 8 Bit

Commodores Position bei den 8-Bit-Heimcomputern erscheint vorerst unangefochten: Der 64, zu dem es immer mehr Software und Peripherie gibt, rennt weiter und dürfte nach dem derzeitigen Stand auch noch zwei bis drei Jahre »leben«. Mit dem PC128 gibt es für anspruchsvollere Benutzer und Aufsteiger einen Computer, der preislich noch ins Heim paßt, von der Leistung für viele professionelle Anwendungen reicht, und vom Preis-/Leistungsverhaltnis sowie von der Größe des Software-Angebotes vielen anderen Computern weit überlegen ist — darunter dem Plus/4 aus dem eigenen Haus oder (um bei den Heimcomputern zu bleiben) den MSX-Systemen mit ihren bisherigen Preisen.

Atari hatte einen etwa gleich großen und ähnlich gut besuchten Stand wie Commodore — die Ambitionen von J ack Tramiel gehen aber in die Richtung Personal Computer. Nach seinen Vorstellungen sollen 80 Prozent von Ataris Computerproduktion im ersten Halbjahr '85 noch auf den 800-Nachfolger 65 entfallen, der von Preis und Leistung direkt mit dem 64 konkurriert — im zweiten Halbjahr sollen aber schon die neuen 16-Bit-Systeme 130/520 ST rund 80 Prozent der Produktion ausmachen. Diese Computer konkurrieren mit anderen auf 68000-Prozessoren basierenden Systemen wie Apples Macintosh, dem QL von Sinclair oder dem bislang nur angekündigten von Commodore. Hier zeichnet sich ein Konkurrenzkampf ab, der allerdings im Herbst ’85 starten und ab '86 ausgetragen werden dürfte. Da ein größeres Software-Angebot für diese 68 000-Systeme erst noch produziert werden muß, dürfte sich nicht vor Ende ’86 die Frage stellen ob die 8-Bit-Technik ausstirbt oder noch in Billig-Computern weiterlebt.

Michael Pauly, Chefredakteur

# Heiße Messe in der Wüste

> Die Consumer Electronics Show (CES) in Las Vegas gift als »die Messe« für UnterhaHungselektronik und Heimcomputer schlechthin. Und Überraschungen gab es auf der diesjährigen CES tatsächlich: Commodore hat mit einer aften Tradition gebrochen. Der neue Computer PC128 ist ergonomisch, extrem vielseitig und hundertprozentig kompatibel mit dem C 64.

In Las Vegas, der Stadt der Unterhaltung, der Shows, der Spielhallen mit den einarmigen Banditen und des großen Geldes findet alljährlich im Januar die Winter Consumer Electronics Show statt. Hier werden die Trends in der Unterhaltungselektronik für das kommende Jahr gesetzt. Einen Großteil der Ausstellungsfläche belegten dabei die Anbieter für Heimcomputer und Software. Zwei Hersteller aus diesem Bereich sorgten für den Gesprächsstoff auf der Messe: Commodore und Atari. Commodore stellte offiziell zwei neue Personal Computer vor: den PC128 und den tragbaren Commodore LCD. Der Amiga-Computer, dem sagenhafte Eigenschaften angedichtet werden, war leider noch nicht zu sehen. Atari wartete mit den Nachfolgermodellen 65XE, 65XEM, 65XEP und 130XE für den Atari 800XL auf. Des weiteren wurden mit den Atari 130ST und 520ST zwei 16/32-Bit-Personal-Computer präsentiert, die dem Macintosh von Apple Konkurrenz machen sollen. Ausführliche Informationen über die Atari-Computer finden Sie in unserer Schwesterzeitschrift Happy-Computer, Ausgabe 4/85. Uns soll hier naturgemäß das Geschehen bei Commodore interessieren.

Der PC128 wurde vorhin mit Absicht als Personal Computer bezeichnet, denn seine Leistungsmerkmale lassen diese Betitelung durchaus als gerechtfertigt erscheinen. Eine plastische Anschauung über die Möglichkeiten der vergleichenden Werbung in den USA liefert Bild 1. Das Äußere des PC128 überzeugt durch funktionelles Design und ergonomisches Styling sowie durch eine klaren Giederung des Tastenfeldes. Die flache Bauweise gewährleistet ermüdungsfreies Arbeiten (entsprechend der DIN-Norm: 3 cm Höhe der mittleren Tastenreihe gegenüber der Auflagefläche). Die abgesetzte Zehnertastatur und die Anordnung der Cursor-Funktions- und Sondertasten, die technischen Details und die abzusehenden Marktchancen tragen zu einem positiven Gesamteindruck bei. Im PC128 sind zudem drei verschiedene Computer integriert.

Da wäre zunächst der C 64-Computer. So unwahrscheinlich es auch klingen mag, der neue PC128 ist tatsächlich 100 Prozent kompatibel mit dem »alten« C 64. Ein Faktum, mit dem sich die Commodore-Fans erst einmal anfreunden müssen. War es doch bisher Commodore-Philosophie, alle neuen Systeme absolut inkompatibel zu den Vorgängermodellen zu gestalten. Verständlich war daher die Reaktion vieler Messebesucher, Programme, die für den C 64 geschrieben worden waren und die sie zufällig dabei hatten, mit Skepsis in den PC128 zu laden. Um so größer das Staunen, als wirklich jedes Softwareprodukt, sei es nun auf Kassette, Diskette oder Modul, ohne Probleme lief. Es ist also Commodore gelungen, eine vollständige Anpassung des C 64 auf dem PC128 zu realisieren. Die logische Konsequenz: Mit dem PC128 erhält man also einen vollwertigen C 64 mit all seinen Grafik-, Sprite-, RAM- und ROM-, Sound-, Schnittstellen- und Prozessorfähigkeiten. Demgemäß sind alle Anschlüsse wie Expansion-Seriell- und User-Port, Kassetten-, Video- und Audio-Port sowie sogar der Joystick-Port (im Gegensatz zum C 16 und Plus/4) absolut identisch mit dem C 64. Hat man sich eine komplette Anlage um seinen C 64 mit Drucker, Floppy, Erweiterungskarten und umfangreicher Software-Bibliothek aufgebaut, so wird diese Peripherie bei einem eventuellen Wechsel zum PC128 weiterhin vollständig verwendbar sein.

Der eigentliche Aufstieg wird aber durch die beiden nächsten Computer-Modi erreicht: zunächst der PC128-Computer. Als Mikroprozessor wird der 8502 verwendet (6502- und 6510- kompatibel). Die Taktfrequenz beträgt entweder 1 MHz (für den C 64- und PC128-Modus in 40-Zeichen-Darstellung) oder 2 MHz (für den PC128-Modus in 80-Zeichen-Darstellung). Durch einen neuen Chip, der Custom Memory Management Unit (MMU), lassen sich mit dem 8-Bit-Mikroprozessor 8502 mehr als 64 KByte durch Bankswitching adressieren. Für Basic stehen im PC128-Modus daher exakt 122365 Byte zur Verfügung. Dieses Bankswitching erlaubt auch den Ausbau der RAM-Kapazität auf bis zu 512 KByte. Diese zusätzliche externe RAM-Erweiterung, die in 128-KByte-Schritten erfolgen kann, läßt sich als sogenannte RAM-Floppy einsetzen. Das Betriebssystem ist in 48 KByte ROM plus 16 KByte ROM für das DOS (Disk Operating System) untergebracht. Enthalten ist darin das neue Basic 7.0 — das mächtigste Basic, das Commodore jemals vorgestellt hat. Es enthält insgesamt über 140 Befehle, welche alle Merkmale der Versionen 2.0 (C 64 und VC 20), 3.5 (C 16/C 116) und 4.0 (CBM 8032 etc.) vereinigt und darüber hinaus einige zusätzliche Befehle bietet. Beispielsweise die Definition von Fenstern von Basic aus oder strukturiertes Programmieren mit DO.. .LOOP.. WHILE.. .UNTIL...NEXT, IF...THEN ...ELSE oder FOR...TO...STEP ...NEXT. Im PC128-Modus kann man zwischen 40 x 25 Zeilen (320 x 200 Punkte) oder 80 x 25 Zeilen (640 x 200 Punkte) mitjeweils 16 Farben wählen. Ein Maschinensprache-Monitor ist ebenfalls eingebaut. Programme für den C 64 wie etwa Vizastar (8 KByte für Daten beim C 64) werden, sobald sie umgeschrieben worden sind, im PC128-Modus ihre volle Leistungfähigkeit unter Beweis stellen können. Die C 64-Software für den PC128 umzuschreiben soll nach Angaben von Commodore keine großen Mühen bereiten.

Der »dritte« Computer-Modus stellt die Verbindung zur CP/M-Welt dar. Im PC128 ist ein Z80A-Mikroprozessor mit 4 MHz Taktfrequenz fest eingebaut. Dadurch lassen sich fast alle unter CP/M Plus 3.0 erstellten Programme verarbeiten. Professionelle Software unter CP/M wie etwa Wordstar oder dBase II sollen daher auf dem PC128 lauffähig sein. Ein Handikap dürfte lediglich der doch noch recht hohe Preis für diese CP/M-Software sein. Hier sind jedoch die Software-Hersteller aufgerufen, mittels einer attraktiven Preisgestaltung (wünschenswert wäre zum Beispiel dBase II für zirka 250 bis 350 Mark) dem, durch die Vorherrschaft von MS-DOS, etwas ins Hintertreffen geratenen CP/M über die dominante Marktstellung von Commodore wieder auf die Beine zu helfen. Die RAM-Speicherkapazität von 128 KByte, mit der Erweiterung auf 512 KByte RAM-Floppy, dürfte durchaus ausreichen, mußten doch die ersten CP/M-Programme mit 64 KByte und weniger auskommen.

Um 80 Zeichen lesbar auf einem Bildschirm darzustellen, wurde mit dem 1902 ein neuer RGB/Composite-Farbmonitor, der durch einen Schiebeschalter in den verschiedenen Modi arbeiten kann, sowie mit dem 1901 ein neuer monochromer Monitor vorgestellt. Man kann diese Monitore auch gleichzeitig mit dem 1701-Monitor betreiben (Bild 2), um beispielsweise Grafik auf dem einen und Text auf dem anderen darzustellen.

Das wichtigste Peripheriegerät dürfte aber das neue 5¼-Zoll-Diskettenlaufwerk 1571 in Slim-Line-Ausführung sein (Bild 3). Dieses Laufwerk hat, wie das 1541, einen eingebauten 6502-Mikroprozessor, 2 KByte RAM, eingebautes DOS, aber 32 KByte ROM. Die Übertragungsgeschwindigkeit des seriellen Busses hängt von der Betriebsart ab: 300 cps (characters per second; Zeichen pro Sekunde) unter C 64-Kontrolle, 1500 cps unter PC128-Kontrolle und 3500 cps unter CP/M-Kontrolle. Die Speicherkapazität variiert wieder mit der Betriebsart. Im Commodore-Aufzeichnungsformat (GCR) lassen sich 350 KByte formatiert, doppelseitig in einfacher Dichte (Double Sided/Single Density) abspeichern. Das 1571-Laufwerk ist kompatibel zum 1541 (170 KByte, einseitig) und 2031, unterstützt also Programm-, User-, sequentielle und relative Dateien. Im CP/M-Modus (MFM) findet die Aufzeichnung der Daten doppelseitig in doppelter Dichte (Double Sided/Double Density) mit bis zu 410 KByte formatiert statt. Nach Aussagen von Commodore dürften die meisten CP/M-Dateien im Kaypro- und Osborne-Foramt gelesen werden können.

Die wichtigste Frage, nämlich was dieses gesamte System, bestehend aus PC128, Monitor und Diskettenlaufwerk (Bild 2) kosten würde, beantwortete man bei Commodore mit: »Deutlich unter 1000 Dollar«. Für Deutschland wurde für den PC128 ein Preis von zirka 1400 Mark genannt. Es wird aber auch eine Version PC128D mit eingebautem Diskettenlaufwerk und abgesetzter Tastatur (Bild 4) für etwa 2000 Mark geben. Lieferbar soll der PC128 im zweiten Quartal ’85 sein, es kann also durchaus noch Juni werden. Der PC128D soll zwei bis drei Monate später folgen.

In Bild 5 sind die Anschlüsse auf der Rückseite des PC128D zu erkennen.

Erste Software-Entwicklungen für den PC128 sind bereits im Gange und wurden auf der Messe auch in der Rohfassung demonstriert (Bild 6). Bild 7 zeigt ein schönes Beispiellisting, wie man mit dem PC128 in Basic 7.0 Grafik programmiert.

Obwohl der Plus/4 (siehe Testbericht 64’er, 2/85) auf der CES mit einer Vielzahl neuer Software sehr präsent war, dürften dessen Tage gezählt sein. Gibt es doch keinen einsehbaren Grund, sich statt des wirklich hervorragenden PC128 den etwas eigenwilligen Plus/4 anzuschaffen. Der C16/C116 dürfte hingegen als Nachfolger des VC20 und damit als typischer Einsteigercomputer mit sehr gutem Basic seine Chancen zumindest auf dem deutschen Markt haben.

## Commodore wird tragbar

Mit dem Commodore LCD (Bild 8) wurde ein tragbarer Computer mit Flüssigkeitskristallanzeige auf der CES vorgestellt, der sich nahtlos in die Reihe der Portablen von Tandy, Epson oder NEC einreiht. Überrascht hat die äußerst kontrastreiche LCD-Anzeige (Bild 9) mit 80 Zeichen pro Zeile auf insgesamt 16 Zeilen (480 x 128 Punkte Grafikauflösung), die zugleich als Abdeckung für die Tastatur beim Transport dient. In den 96 KByte CMOS ROM sind die wichtigsten Anwendungsprogramme wie Textverarbeitung, Tabellenkalkulation, Adreß- und Terminverwaltung, Taschenrechner, Dateimanager, Notizzettel, Basic 3.6, Monitor und Terminalprogramm fest eingebaut. Ebenfalls eingebaut ist ein 300-Baud-Modem. Für den deutschen Markt muß die FTZ-Zulassung noch abgewartet werden. Die Tastatur besteht aus 72 Tasten in schreibmaschinenähnlicher Anordnung mit acht programmierbaren Funktions- und vier Cursortasten. Die Stromversorgung erfolgt entweder über das Netz oder übervier 1,5 Volt Nickel-Kadmium-Batterien.

An Schnittstellen sind der serielle Commodore-Bus (damit läßt sich die gesamte Commodore-Peripherie vom Drucker bis zum Diskettenlaufwerk betreiben), eine serielle RS232C- und Centronics-Schittstelle (für alle gängigen Drucker), der vom C 64 bekannte Expansion-Port sowie ein Bar-Code-Anschluß (HP-kompatibel) und eine Modem-Telefon-Schnittstelle (Bild 10) vorhanden. Der Commodore LCD ist also beispielsweise für Reisende gedacht, die Nachrichten schnell an die Heimatadresse senden müssen oder wollen und zugleich ein Heim-/ Bürosystem, basierend auf dem C 64/PC128, besitzen. Der Preis soll um die 2000 Mark betragen.

Speziell für den Commodore LCD wird es auch ein 3½-Zoll-Diskettenlaufwerk mit Batteriebetrieb und serieller Schnittstelle geben. Über technische Daten, Preise und Lieferzeiten konnte man sich bei Commodore noch nicht äußern, da es sich bei den Laufwerken auf dem Stand (Bild 11) um Prototypen handelte.

Offiziell nicht gezeigt wurde der IBM-PC-kompatible CommodorePC 10. Dennoch war er hinter verschlossenen Türen und auf einer Pressekonferenz bereits zu bewundern (Bilder 12 und 13). Dieser Commodore PC 10 wurde in Braunschweig entwickelt und soll dort auch hergestellt werden. Bei dem Commodore PC 10 will man über den Preis am Boom der IBM-Kompatiblen teilhaben. So soll der PC 10 mit zwei eingebauten Diskettenlaufwerken, 256 KByte RAM, eingebauter RS232- und Centronics-Schnittstelle, vier freien Steckplätzen und DOS 2.11, das dem MS-DOS-Standard entspricht, deutlich unter 6000 Mark kosten. Vergleichbare Systeme sind 2000 bis 3000 Mark teuerer. Um hundertprozentige Kompatibilität mit dem doch etwas langsamen IBM-Original zu gewährleisten, wurde auf eine Geschwindigkeitserhöhung bewußt verzichtet.

Überhaupt nicht zu sehen war, entgegen aller Erwartungen, auch auf unserem Titel, der Amiga. Dieser Wundercomputer soll folgende Eigenschaften besitzen: 68000 Prozessor von Motorola mit 10 MHz getaktet, 512 KByte RAM, drei Coprozessoren für Grafik, Mathematik und I/O-Controlling, hochauflösende Grafik mit 256 Farben für CAD/CAM-Anwendungen und eingebautes 3½-Zoll-Laufwerk. Es wurde eigentlich erwartet, zumindest einen Prototyp des Amigas auf dem Stand zu sehen, doch nach Aussagen von Commodore will man den Amiga erst dann vorstellen, wenn er produktionsreif ist. Sicher eine sehr löbliche Absicht, wenn man die früheren Zeitdifferenzen zwischen Ankündigung und Verkauf betrachtet. Auf der anderen Seite wollte man wohl dem PC128 auf der CES auch nicht die Schau stehlen.

Was gab es sonst noch auf der Consumer Electronics Show in Las Vegas? Ein Trend: Die programmierbaren Roboter sind im Kommen. Heath bot den Hero Jr. (Bild 14) für unter 1000 Dollar an. Was kann man mit einem solchen Roboter anfangen? Zum Beispiel sichert der Roboter das Haus gegen Einbrecher ab. Durch sein »Infrarot-Auge« ortet er Lebewesen (und kann auch Hindernissen ausweichen), verlangt von ihnen ein Codewort etc. Hat das der Dieb nicht parat, gibt Hero Jr. Alarm. Falls Sie sich einsam fühlen, bleibt Hero ständig in Ihrer Nähe, singt Lieder vor, sagt Gedichte auf, spielt Cowboy und Robots mit Ihnen, erinnert Sie an den Geburtstag Ihrer Mutter oder an einen wichtigen Telefonanruf. Auf Wunsch können Sie sich von Hero Jr. morgens wecken und abends auf eine wichtige Fernsehsendung aufmerksam machen lassen. Mit einigem Zubehör wird der Hero zur Lichtorgel oder durch ein drahtloses Mikrofon zum Partyrenner, Verkaufsförderer und Kindermagnet. Nicht ganz so universell wie der Hero, dafür aber mit Greifarm und Fernsteuerung, ist die Roboterfamilie von Tomy. Mit dem Verbot (Bild 16) kann man sich beispielsweise den Salzstreuer von der anderen Seite des Tisches holen lassen. Omnibot (Bild 16) kann sogar ganze Menüs servieren. Mit einem eingebauten Kassettenrecorder (oder via Mikrofon) und der eingebauten Timerfunktion läßt sich eine Nachricht zu einer bestimmten Zeit an einem bestimmten Ort übermitteln. Spezialisiert hat sich Computer Magic auf die Programmierung von Robotern anderer Anbieter. In Bild 17 ist gerade der perfekte Alarmroboter bei der Einbrechersuche zu sehen. Aber auch einfachere Mittel reichen dazu schon aus. Mit einem Sensorland (Bild 18) genannten Sonargerät für 99 Dollar, das am C 64 angeschlossen wird, lassen sich Fenster auf geöffnet oder geschlossen prüfen, der genaue Abstand zu einem Gegenstand abmessen oder Musikstücke durch Unterbrechen des Sonarstrahls in definierten Abständen, spielen. Eine interessante und nicht alltägliche Erweiterung für den C 64.

Roboterähnliche Zusätze sind auch die beiden unkonventionellen Plotter von Fischer Technik und Penman Products. Der Plotter von Fischer Technik (Bild 19) besteht aus den Standardbauteilen des bekannten Fischerbausatzes, ist aber beim Papierformat natürlich etwas eingeschränkt. Nahezu beliebige Papiergrößen kann hingegen der Penman (Bild 20) von Penman Products mit Grafiken, Tabellen und Diagrammen bemalen. Die Zeichenunterlage ist nicht wie bei herkömmlichen Plottern auf die Papierauflagefläche begrenzt, sondern jede freie, ebene Fläche kann als Unterlage für das Papier herhalten. Der Zeichenkopf mit drei verschiedenfarbigen Stiften bewegt sich mittels kleiner Schrittmotoren und Rädern über die Papierebene. Die Verbindung des Penman (Preis zirka 300 Dollar) zum C 64 erfolgt über eine RS232-Schnittstelle.

Neues gab es auch von renommierten Druckerherstellern. Epson stellte den Homewriter 10 vor (Bild 21), der durch leicht austauschbare Printer Interface Cartridges (PICs) speziell für die Heimcomputerszene entwickelt wurde. PICs gibt es bereits für C 64, Atari 800XL, IBM-PCjr und Apple IIc. Mit dem Homewriter 10 erhält man einen 80-Zeichen-Drucker mit einer Druckgeschwindigkeit von 100 Zeichen pro Sekunde im Normalmodus und 16 cps (Characters per second) im Schönschreibmodus. Durch einfaches Berühren von Bedienungselementen auf der Instrumententafel läßt sich leicht zwischen den einzelnen Druckmodi wie fett, komprimiert, elite, italic oder unterstrichen hin- und her schalten. Der Drucker mit Friktionseinzug soll 269 Dollar, jedes PIC 60 Dollar, der Traktoreinzug 40 Dollar und der Einzelblatteinzug 100 Dollar kosten. Dieselbe Version mit Centronics-Schnittstelle, dann LX-80 genannt, ist für 349 Dollar zu haben.

Mit dem Riteman C + offeriert Riteman einen direkt an den C 64 anschließbaren 9 x 9 Matrixdrucker mit 105 cps für 299 Dollar. Ungewöhnlich ist beim Riteman C + (Bild 22) die Papierzuführung über die Frontseite, die aber durch die Standfüße eine erhebliche Platzeinsparung mit sich bringt. Bemerkenswert ist auch hier der standardmäßige Friktionsantrieb (durch Andruck der Walze auf das Papier findet der Vorschub statt), der sich bei neuen Druckern immer mehr durchsetzt. Der Traktoreinschub für gelochtes Endlospapier wird jedoch mitgeliefert. Selbstverständlich sind der Commodore- und ASCII-Zeichensatz sowie vier internationale Zeichensätze verfügbar. Noch um einiges besser ist der Riteman R64 mit 120 cps für 449 Dollar, der über einen speziellen Listingsmodus verfügt, in dem die Steuerzeichen des C 64 automatisch in alphanumerische Zeichen (zum Beispiel (F1), (RED)) umgesetzt werden.

Star wartete mit einer vollständig neuen Produkt-Linie der SG-, SD- und SR-Sene auf. Die neuen Einheiten sollen folgende Preise haben:
SG-10: $299; SG-15: $499
SD-10: $449; SD-15: $599
SR-10: $649; SR-15: $799

Die Drucker sollen sowohl für Commodore-, Apple- als auch IBM-Computer einsetzbar sein. In jeder Serie gibt eseine 10- und 15-Zoll-Variante. Der Schönschreibmodus gehört zur standardmäßigen Ausrüstung jeden Druckers. Die Star SG-Serie druckt mit 120 cps (im Schönschreibmodus mit 30 cps); die SD-Serie mit 160 cps (40 cps) und die SR-Serie mit 200 cps (50 cps). Der Pufferspeicher beträgt bei den 10-Zoll-Varianten jeweils 2 KByte, bei den 15-Zoll-Varianten 16 KByte. Ein Trend, der sich bei den Matrixdruckern abzeichnet, ist bei Star mit dieser neuen Produkt-Linie besonders deutlich zu erkennen: Die Matrixdrucker sollen den Typenraddruckern durch den wesentlich verbesserten Schönschreibmodus Konkurrenz machen. Der Matrixdrucker der Zukunft wird also mindestens zwei Aufgaben im besonderen Maße zu erfüllen haben: Er muß möglichst viele Schriftarten bereitstellen und diese sehr schnell ausdrucken können und zweitens die Möglichkeit bieten, den geschäftlichen oder privaten Schriftverkehr über denselben Drucker mit einem sauberen Schriftbild zu gewährleisten. Es ist also abzusehen, daß in zwei oder drei Jahren preiswerte Matrixdrucker angeboten werden, die sowohl die Bedürfnisse eines sehr schnellen Ausdrucks des Listings, der Tabelle oder sonstiger Dokumente für den persönlichen Gebrauch gewährleisten, als auch für den geschäftlichen oder privaten Briefverkehr eine Qualität liefern, die der einer Typenradschreibmaschine in nichts nachsteht (Bild 23).

Blue Chip ist eine relativ junge Firma in den USA, die sowohl Typenraddrucker als auch Matrixdrucker »Made in Germany« vertreibt. Der M120/10 (Bild 25) ist em 9 x 8 Matrixdrucker mit 120 cps und zwölf internationalen Zeichensätzen für 299 Dollar.

Damit soll’s für diese Ausgabe genug sein. Was sich auf den Gebieten der alternativen Floppylaufwerke, der Grafikeingabemedien, der Musik, der Spiele, und der Software im allgemeinen getan hat, erfahren Sie in der nächsten Ausgabe. (aa)

# Neu: stabileres 1541-Laufwerk

Endlich gibt es das neue 1541-Laufwerk zu kaufen, das zum erstenmal auf der Hannover-Messe '84 vorgestelltwurde. Wir haben das neue Modell für Sie getestet und waren begeistert. Dieses Laufwerk unterscheidet sich äußerlich von der alten 1541 nur durch einen Knebelverschluß. Das Innere wurde verbessert: Anstelle des Laufwerks von Alps-Elektronik wird nun eines von Mitsumi verwendet. Wesentliches Merkmal ist der enorm solide Eindruck, den die gesamte Mechanik, im Gegensatz zur alten, macht. Zusätzlich wurde die Controller-Platine überarbeitet: Alle ICs sind gesockelt, und es befinden sich keine Kabelbrücken, wie bei manchen Zwischenversionen, auf der Platine. Am Betriebssystem des Laufwerks wurden keine feststellbaren Veränderungen vorgenommen. Eine volle Kompatibilität zu den bisherigen Laufwerken scheint deshalb gewährleistet. Die neue 1541 braucht sich nicht hinter den Laufwerken anderer Hersteller zu verstecken. Ein altes Manko der 1541 bleibt aber bestehen: Das neue Laufwerk ist ebenso langsam wie das alte.

Arnd Wängler

# Internationaler Chaos Communication Congress in Hamburg

> Der Chaos Computer Club rief, und alle, alle kamen: Zum ersten internationalen Chaos Communication Congress ’84 im Bürgerhaus von Hamburgs Randbezirk Eidelstedt.

Schlagzeilen in allen Medien hatte dieser Club schon Ende November verursacht, als er durch spektakuläre Aktionen einige Systemschwächen des BTX-Dienstes der Post aufdeckte. Zu diesem »Treffen für Datenreisende« kamen deshalb in Erwartung weiterer sensationeller Enthüllungen auch über 30 Journalisten. Unter den zirka 300 Gästen aus Europa und den USA fielen sie allerdings kaum auf, ebensowenig wie Angehörige des Hamburger Amtes für Datenschutz und Postbedienstete (denen 10 Prozent Nachlaß auf die Eintrittspreise gewährt wurde).

Die Sicherheitsmaßnahmen konnten schon beeindrucken: Teilnehmerausweis mit Lichtbild, strenge Kontrolle auf Fotoapparate, die ebenso verboten waren wie Tonaufzeichnungsgeräte; Abtasten mit Metalldetektoren, was manchen überraschenden Fund erbrachte: So manches Taschenmesser und sogar eine Tränengaspistole wurden sichergestellt.

Für die ziemlich hohen Eintrittspreise (»Kids 20 Mark, Girls 10 Mark, Sonstiges 30 Mark« und Presse übrigens 50 Mark) wurde so einiges geboten: Neben einem Cafe und dem Archiv, wo nach Herzenslust aus dem CCC-Bestand kopiert wurde, bis das Gerät glühte, gab es Vorführungen von Bildschirmtext und Datenfunkeinrichtungen und ein Hackcenter, wo von morgens bis morgens das Hackerleben blühte.

Die größte Anziehungskraft allerdings hatten die Workshops, in denen jeder seinen Informationshunger stillen konnte. Da ging es neben der Vermittlung von grundlegenden Kenntnissen um »Datex und ähnliche Netzwerke«, Mailboxen, Bildschirmtext, Modems, »Jura für Hacker«. Einer wollte wissen, wie groß die Gefahr der Entdeckung von Hakkern durch Fangschaltungen sei und erhielt fachmännische Auskunft: Die Post sei sehr veraltet, wodurch der größte Teil der Schaltungen über Relais liefe, die visuell überprüft werden müßten. Bei Verbindungen übers Ortsnetz hinaus sei ohnehin keine Rückverfolgung möglich. Lediglich das moderne elektronische W ählsystem (erkennbar am anderen Besetzt-Zeichen und der Tatsache, daß sofort nach dem Eintippen der letzten Nummer die Verbindung vorhanden ist) erlaube ein schnelles Feststellen des Anrufers.

Datex-Dienste, insbesondere das Datex-P-Angebot, fanden eifrige Zuhörer. Für Hacker ohne eigene Teilnehmerkennung ( = NUI) ist die neue Datex-Software recht hilfreich. Beim sogenannten NUI-Scannen (Ausprobieren verschiedener Teilnehmerkennungen per Programm) meldet die Post schon vor dem Paßwort, ob eine NUI fehlerhaft ist. So muß man nicht mehr eine sehr lange Kombination (NUI + Paßwort) durchprobieren, sondern nur zwei kurze. Für Mailbox-Freunde ist Datex-P ohnehin das falsche Netz: Interessante Mailboxen laufen über das normale Telefon-Netz.

Wo Datex-P aber hilfreich sein kann, zeigte eine Demonstration: Über Gateway-Rechner der Post ist problemlos internationaler Datenverkehr möglich, zum Beispiel auch mittels des kleinen Commodore 64. Chris (Großbritannien), Dana und Robert (North American Green Network) stellten eine Leitung ins amerikanische Delphi-Netz her. Eine völlig neue Dimension der Datenkommunikation, die über das Hackertreiben und einige Mailbox-Spielereien hinausreicht, stellte Dana vor: »Es gibt keinen Grund, daß grüne Bewegungen sich der Technik des 18. Jahrhunderts bedienen.« North American Green Network arbeitet an einem internationalen Nachrichten-Netzwerk per Datenfernübertragung, das sowohl als Datenbank, als auch zur schnellen Informationsübermittlung und zu Computerkonferenzen dienen soll. Mittels der Delphi-Verbindung war dann auch bald eine solche Konferenz im Gange mit Partnern in Washington, Boston, Philadelphiaund New Mexico. Der System Operator von Delphi freut sich über europäische Benutzer. Hier die Adresse von Delphi: 377 Putnam Avenue, Cambridge, MA.02139, USA.

Zurück zum Chaos Computer Club mit einem kurzen Interview.

**Frage**: Welche Ziele hat der CCC und inwieweit dient dazu dieser Kongreß?

**Wau (CCC)**: Wir wollen weltweit offene Netze für die Kommunikation erreichen. Außerdem ist die effektivste Form der Kommunikation der direkte Austausch, wofür wir hier Gelegenheit schaffen. 1985 ist von den Vereinten Nationen zum Jahr der Jugend gekürt worden. Wir meinen, daß die Jugend der Welt internationale Netze zur Kommunikation verwenden können sollte und nicht durch Monopole — wie das der Bundespost — daran gehindert werden darf.

**Frage**: Was kostet den Homecomputer-Benutzer die Teilnahme an Datenkommunikation? Nehmen wir an, er besäße einen Commodore 64.

**Alex(CCC)**: Wenn er Bastler ist, kommt er wohl mit zirka 200 Mark aus für Koppler und RS232C-Schnittstelle, sonst muß er etwa 300 bis 400 Mark anlegen. Dafür hat er dann aber ein Gerät mit FTZ-Nummer. Außerdem kommen noch die Telefonkosten dazu.

**Frage**: Wenn man Eure Arbeit so verfolgt, drängt sich der Eindruck auf, daß da etwas Subversives passiert. Weshalb hüllt Ihr Euch in Geheimnisse?

**Alex**: Das machen wir nur aus Gründen des Personenschutzes. Bei einigen von uns klingelt ständig das Telefon: Dauernd wird man von der Presse belagert...

**Frage**: Das ist wohl der Preis Eures Bekanntheitsgrades, den Eure Aktionen — wie die BTX-Sache — so mit sich bringen. Was macht Ihr außerhalb dieser Sternstunden? Ihr könnt ja nicht ständig Kongresse vorbereiten oder das BTX knacken.

**Alex**: Jeder hat so seine eigenen Themen. Wau beispielsweise arbeitet gerade daran, eine neue Mailbox auf die Beine zu stellen. Dann treffen wir uns natürlich, tauschen Erfahrungen aus, trinken was zusammen...

**Frage**: Wie sind Eurer Meinung nach die Mailboxen zu beurteilen?

**Alex**: Etwa 90 Prozent der Mailboxen sind ganz in Ordnung, wie MCS, USC, TAB-SOFT, RAM, WANG-INFO und so weiter. Sauer sind wir auf NCS, das überhaupt nichts taugt.

Nur die Mailbox der Uni-Hamburg ist noch schlimmer. Die haben da seit Jahren nicht mehr aufgeräumt. Man findet seitenweise uralte Mitteilungen drin.

**Buko**: Übel sind Mailboxen, die ganz gemütlich einen Haufen Sternchen auf den Bildschirm zaubern, Häuschen oder sowas malen und nicht daran denken, daß wir dafür Telefonkosten berappen müssen.

**Frage**: Eine Presseagentur hat verbreitet, einige Leute vom Kongreß hätten sich in die Frankfurter Citybank eingeloggt. Stimmt das?

**Alex**: Das ist eine dicke Ente!

**64’er**: Wir danken für das Gespräch.

(Heimo Ponnath/gk)

# Leserforum

## TA Gabriele 8008 am C 64?

Ich möchte eine Typenradschreibmaschine TA Gabriele 8008 an meinen C 64 anschließen und suche dazu einen Bausatz/Bauanleitung oder besser noch eine fertige Schnittstelle. Wer kann helfen?

Oskar Greifenberger jun.

## Einschaltprüfung für Floppy und Drucker?

Welche POKE-Adressen können in einem Basic-Programm zur Abfrage dienen, ob der Drucker oder die Floppy eingeschaltet ist? Damit könnte ein Programmabbruch durch »Device not present« verhindert werden.

Oskar Greifenberger jun.

Die etwas umfangreichere Lösung dieses Problems finden Sie auf Seite 77 in der Ausgabe 8/84 des 64’er Magazins.

## Altes oder neues Betriebssystem?

Ich besitze seit dem September 1983 einen Commodore-Drucker 1526. Wie kann ich feststellen, ob er noch mit dem alten Betriebssystem ausgerüstet ist, oder ob er bereits über das neue verfügt? Wie teuer wäre gegebenenfalls eine Umrüstung auf das neue Betriebssystem?

Günter Reuter

## Fragen Sie doch!

Selbst bei sorgfältiger Lektüre von Handbüchern und Programmbeschreibungen bleiben beim Anwender immer wieder Fragen offen. Viel mehr Fragen ergeben sich bei Computer-Interessenten, die noch keine festen Kontakte zu Händlern, Herstellern oder Computerclubs haben. Sie können der Redaktion Ihre Fragen schreiben oder Probleme schildern (am einfachsten auf der Karte »Lesermeinung«). Wirveranlassen, daß sie von einem Fachmann beantwortet werden. Allgemein interessierende Fragen und Antworten werden im Rahmen des Leserforums veröffentlicht.

## Chemie per User-Port?

Wie kann man mit dem C 64 mittels User-Port Messungen für chemische Experimente durchführen? Werhat Erfahrungen zu diesem Thema gemacht und kann praktische Beispiele angeben?

Joachim von Neuenkirchen

## Probleme mit der Speichererweiterung

Ich besitze einen VC 20 mit einer schaltbaren 32/27 KByte Erweiterung der Firma Klaus Jeschke. Leider ist der Bereich ab $4000 (dezimal 16384 - 24575) immer eingeschaltet. Wie kann ich diesen Bereich nun abschalten oder umadressieren?

Frank Heynig

Es gibt noch mehr Leser, die uns das gleiche Problem geschildert haben. Offenbar hat sich in einigen Exemplaren der Erweiterung ein Produktionsfehler eingeschlichen. Am besten ist es, wenn Sie sich direkt mit der Firma Jeschke in Verbindung setzen.

## Probleme mit »Exbasic Level II«?

Nach dem Motto »viele Module und kein Steckplatz« habe ich bereits vor einiger Zeit mein »Exbasic Level II« für den VC 20 vom Modul auf Kassette kopiert, um Exbasic und 27 KByte Erweiterung zusammen nutzen zu können. So läßt sich zwargut arbeiten, aberich kann jetzt keine älteren Programme mehr verwenden. Exbasic hat nämlich die fünffache LOAD-/SAVE-Geschwindigkeit und kann mit normaler Geschwindigkeit aufgezeichnete Programme nicht lesen. VerlasseichaberExbasic mit dem Befehl »BASIC«, dann kann ich zwar ein Programm laden, kann dann aber Exbasic nicht wiedermit »PRINT USR(0)« aktivieren, da ich ja nicht das Modul eingesteckt habe. Mit dem Kaltstart »SYS 64802« gelange ich zwar wiederum ins Exbasic, allerdings ist dann mein soeben geladenes Programm verschwunden.

Wie kann ich trotzdem mit normaler Geschwindigkeit gespeicherte Programme unter Exbasic laden?

Werner Flaig

In Exbasic läßt sich ein Programm mit »LOAD*« beziehungsweise »SAVE*« mit normaler Geschwindigkeit laden beziehungsweise abspeichern.

## Compiler für den C 64

Gibt es für den Commodore 64 einen Fortran-, PL/1- oder Ada-Compiler? Auch die Programmiersprache Logo würde mich interessieren.

Bernhard Pöttinger

Fortran und PL/1 sind mit Hilfe des CP/M-Moduls verfügbar. Leider ist uns noch keine Firma bekannt, die diese Sprachen in Deutschland für den C 64 vertreibt; sie lassen sich jedoch mit etwas Geschick vom Apple mit CP/M-Karte auf den C 64 übernehmen (siehe den entsprechenden Beitrag in der Ausgabe 7/84, Seite 36).

Ada auf kleinen Heimcomputern wie dem C 64 zu verwirklichen ist praktisch unmöglich. Ein kleines Subset der Sprache ist bei Data Becker als »ADA-Trainingskurs« erhältlich (siehe Anzeigenteil).

Die Sprache Logo wird von Commodore selbst vertrieben und sollte demzufolge beijedem Commodore-Fachhändler erhältlich sein.

## Maschinenprogramme kopieren?

Wie kopiert man beim VC 20 ein Maschinenprogramm (Steckmodulbereich $A000) von einer Disk auf eine andere?

Walter Lehrke

1. Speichererweiterung auf $A000 umadressieren.
2. Maschinenprogramm laden, aber nicht starten.
3. NEW.
4. POKE 43,0 : POKE 44,160 : POKE 45,0 : POKE 46,192 : SAVE »Name«,8 : REM vorher Diskette wechseln

## Negative Bytes?

Auf die Eingabe »PRINT FRE(0)« antwortet mein C 64 stets mit einer negativen Zahl. Wie erhalte ich den tatsächlich freien Speicherplatz angezeigt?

Klaus Krögler

Die FRE-Funktion liefert beim C 64 stets eine Integer-Zahl (16 Bit) zurück. Der größte so korrekt darstellbare Wert ist 32768 ( = 215). Überschreitet der zur Verfügung stehende Speicherplatz diesen Wert, dann wird auch noch das Vorzeichenbit herangezogen, und es ergeben sich negative Zahlen. Das korrekte Ergebnis erhält man in diesen Fällen, indem man 65535 ( = 2↑16) zum Ergebnis der FRE-Funktion addiert, also mit »? FRE(0) + 2↑16«.

## Pascal-Compiler gesucht

Existiert ein Pascal-Compiler für den C 64, der den im Pascal-Report @L Wirth) definierten Standard erfüllt? Ist USCD-Pascal schon fürden C 64 erhältlich?

Ulf Bartelt

Obwohl ich bereits seit längerer Zeit nach einem Pascal-Compiler für den VC 20 suche, habe ich bis jetzt keinen finden können. Können Sie mir einen Lieferanten nennen?

Reinhard Häring

Unseres Wissens erfüllt derzeit »Oxford-Pascal« als einzige Pascal-Version für den C 64 voll und ganz den Wirth-Standard. USCD-Pascal ist für den C 64 derzeit noch nicht erhältlich, erlaubt aber bislang in der Apple-Version (entgegen dem Standard) auch nicht die Übergabe von Funktionen als Parameter.

Eine Pascal-Implementierung für den VC 20 ist uns nicht bekannt.

Info: Oxford-Pascal ist erhältlich bei ComputerPlus Soft, Bahnstraße 20-26,4220 Dinslaken.

## Mikrofon am C 64?

Ich besitze einen C 64 und habe erfahren, daß es möglich ist, ein Mikrofon anzuschließen und das hereinkommende Signal zu verändern. Ich weiß jedoch weder, wie ein Mikrofon an den C 64 anzuschließen ist, noch wie das Signal zu beeinflussen wäre.

Roland Feichtinger

## Floppy-DOS ändern?

Ist es möglich, sich (mit einem entsprechenden Monitorprogramm) das eingebaute DOS 2.6 der Floppy 1541 anzusehen und auch abzuändern ?

Bernd Heiler, Jürgen Hamberger

Die Antwort lautet: Im Prinzip ja. Das DOS des 1541-Laufwerks läßt sich relativ einfach über den »M-R«-Befehl und das allgemein bekannte POKE in den Speicher holen. Dann geht die Analyse mit jedem Monitor, zum Beispiel unserem SMON. Ändern kann man es freilich nur auf die harte Methode, das heißt mit einem EPROM-Brenner. Kleine Veränderungen oder Zusatzroutinen können aber auch im RAM des Floppy-Laufwerks abgelegt werden. Hier verweise ich Sie auf unseren Floppykurs. Ein analysiertes DOS-Listing wird sich übrigens demnächst in einem Markt & Technik Buch, das sich ausführlich mit der 1541 befaßt, finden.

## Kassetten-Probleme

Kassettenprogramme, die mit einem VC 20 abgespeichert wurden, kann ich mit dem C 64 nicht mehr einlesen. Es erscheint ständig die Fehlermeldung »Out of Memory«. Wie ist hiereineAbhilfemöglich ? Welche POKE-Befehle sind einzugeben?

Hartmut Schalk

Der VC 20 hat zwar das gleiche Speicherformat für die Aufzeichnung auf Kassette wie der C 64, speichert aber leider mit einer etwas höheren Aufzeichnungsdichte, da seine Taktfrequenz etwas höher ist. Leider gibt es bis heute noch keinen POKE, um die Taktfrequenz eines Computers zu ändern, so daß Ihnen prinzipiell nur drei Möglichkeiten bleiben: Die Programme nochmals eintippen, sich ein Diskettenlaufwerk zulegen und die Programme damit übertragen (das funktioniert nämlich), oder einfach zu verzweifeln.

## Reset abschalten ?

Wie kann ein am User-Port des C 64 eingebauter Reset-Schalter softwaremäßig außer Betrieb gesetzt werden? Bei einigen Spielen ist der Schalter einfach wirkunglos, nur ausschalten hilft.

Gerd Fischer

Natürlich kann ein Reset-Schalter nicht so einfach softwaremäßig außer Funktion gesetzt werden. Was Ihnen bei einigen Spielen passiert, ist ein völlig normaler Vorgang. Die Reset-Routine des Betriebssystems fragt nämlich gleich zu Anfang die Speicheradressen 32772 bis 32777 ($8000-$8005) ab. Enthalten diese Speicherzellen die Werte 195, 194, 205, 56, 48 (entsprechend dem Text »CBM80«), was in der Regel bei einem eingesteckten Modul der Fall ist, dann wird nicht ins Basic gesprungen, sondern zu der Adresse, die in den Speicherzellen 32768/32769 steht. Nun hindert Sie (und die Spielehersteller) allerdings niemand daran, die Codefolge »CBM80« und die Startadresse per Programm in die entsprechenden Speicherstellen zu POKEn. Beim Betätigen des Reset-Tasters wird dann automatisch zur vorgesehenen Adresse gesprungen, und wenn es sich bei dieser Adresse gerade um die Startadresse des Spiel- oder sonstigen Programms handelt, dann startet es bei jedem Reset von vorn und kann somit tatsächlich nur durch Ausschalten wieder verlassen werden.

## EPROM-Speicher beim C 64 vergrößern?

Ist es möglich, durch einstecken eines EPROMs den ROM-Bereich des C 64 zu vergrößern?

Arndt Steffen

Der C 64 hat auf seiner Hauptplatine keine freien Steckplätze für EPROMs vorgesehen. Dafür verfügt er über den Steckmodul-Port, in den Sie beliebige ROM-Erweiterungen einstecken können. Sobald Sie ein Modul einstecken, ist der ROM-Bereich Ihres C 64 um die Kapazität des Moduls (8 oder 16 KByte) erweitert.

## Beschädigte Tastatur

Die Tastatur meines C 64 ist durch einen Sturz mechanisch beschädigt worden. Wo bekomme ich Ersatz?

Peter Koegler

An sich müßte jeder Commodore-Fachhändler in der Lage sein, Ihnen jedes beliebige Ersatzteil zu besorgen. Der Kaufhof, Data Becker und Quelle bieten einen Schnell-Reparatur-Service, der Quelle TKD versendet auch Ersatzteile. Computer-Ersatzteile sind aber generell sehr teuer, so daß es sich im Falle einer Tastatur möglicherweise lohnen würde, per Kleinanzeige einen gebrauchten VC 20 zum Ausschlachten zu erstehen (die Tastatur ist die gleiche wie beim C 64, aber der VC 20 wird erheblich billiger angeboten).

## Forth real & hires

Wo gibt es Forth-Erweiterungen, um mit Real-Zahlen und in hochauflösender Grafik arbeiten zu können?
Ausgabe 1/85

Alois Schneider

Entsprechende Forth-Erweiterungen können Sie über »Forth Systeme Angelika Flesch« oder über die deutsche Sektion der Forth Interest Group (FIG), die Forth-Gesellschaft »Common Interface Alpha« beziehen, wo Sie auch nähere Informationen über die verschiedenen Forth-Versionen erhalten.

Info: Forth Systeme Angelika Flesch, Schützenstr. 3, 7820 Titisee-Neustadt, Tel. 07651/1665.
Forth Gesellschaft FIG Deutschland, Common Interface Alpha, Holstenstr. 191, 2000 Hamburg 50, Tel. 040/435070

## Disketten doppelt beschreiben?

Bei uns geht das Gerücht um, daß esbei der Floppy 1541 eine Andruckrolle oder ähnliches gibt, die direkt auf die Oberfläche der B-Seite einer Diskette drückt. Die Anwendung von doppelbeschreibbaren Disketten ist somit schädlich für den Schreib-Lesekopf, da Schmutz übertragen wird. Stimmt das?

Arndt Böhme

Leider ja. Der Schreib-Lesekopf der Diskette, der die Unterseite der Diskette »abtastet« kann die Diskette nicht ohne mechanische Unterstützung lesen. Ein Andruckfilz drückt die Diskette deswegen von oben auf den Schreib/Lesekopf. Wenn der Filz arg verschmutzt ist, kann es zu physikalischer Beschädigung sowohl von Diskette als auch vom Laufwerk kommen. Disketten, die auch nur minimal verschmutzt sind, sollten ersetzt werden. Bewährt haben sich auch Sicherheitskopien für den Fall des Falles. Ein Öffnen des Gerätes, um den Zustand des Kopfes zu überprüfen, beziehungsweise das gelegentliche Reinigen mit einer Reinigungsdiskette wären wohl sinnvoll.

## »Strubs« mit Datasette

Kann der Precompiler »Strubs« (64’er Ausgabe 4-7/84) auch mit Datasette statt Floppy arbeiten ?
Ausgabe 8/84

Sebastian Obermayr

Ich habe »Strubs« für den Betrieb mit der Datasette umgeschrieben. Alle Befehle der Disketten-Version sind erhalten geblieben, auch die Syntax wurde vollständig übernommen. Interessenten können sich direkt an mich wenden.

Ing. (fh) Wolfram Dech, Maybachstr. 34, 6607 Quierschied.

## Zwei Datasetten am C 64?

Als ich vor einiger Zeit meine Datasette aufschraubte, um einem Klappern beim Bandtransport auf die Spur zu kommen, entdeckte ich auf der Platine eine Steckerleiste, auf die haargenau der computerseitige SteckerderDatasette paßt. Hat diese Anschlußleiste einen bestimmten Zweck? Fast sieht es ja so aus, als wenn hiereine zweite Datasette angeschlossen werden könnte. Ist das tatsächlich möglich (etwa mit unterschiedlichen Sekundäradressen)? Wer hat Erfahrungen damit?

Uwe Bilo

## Interface für Brother CE-60

Ich suche ein Interface zum Anschluß eines Brother CE-60 an meinen C 64.
Ausgabe 8/84

Manfred Mattern

Da ich das gleiche plane, habe ich mich über solche Interfaces informiert.

Brother selbst bietet ein Interface an, die Angaben dazu sind jedoch mehr als dürftig. Der Preis liegt um die 600 Mark. Witte-Bürotechnik bietet das Interface WI-60 für 548 Mark komplett mit Steuersoftware auf Disk oder Kassette an. Es verfügt über einen deutschen Zeichensatz, Steuerbefehle für alle Sonderfunktionen der Schreibmaschine und einen 6-KByte-Pufferspeicher. Das Interface arbeitet bidirektional, das heißt alle Texteingaben und (fast alle) Befehle für die Textverarbeitung können auch auf der Schreibmaschinentastatur erfolgen und werden automatisch in den C 64 übernommen. Dieses Interface wurde übrigens in der Zeitschrift RUN, Ausgabe 8/84, getestet.

Von einem dritten Anbieter, der Firma WDT, habe ich bislang noch keine Antwort erhalten.

Heinz-Günther Fischer

Info: Brother International, Im Rosengarten 14, Postfach 1320, 6368 Bad Vilbel.

Witte-Bürotechnik, Bäckerstr. 22, 3250 Hameln 1.

Wicher Digital Technik WDT, Im Untertal 5, 6487 Flörsbachtal-Kempfenbrunn.

## Wollen Sie antworten?

Wir veröffentlichen auf dieser Seite auch Fragen, die sich nicht ohne weiteres anhand eines guten Archivs oder aufgrund der Sachkunde eines Herstellers beziehungsweise Programmierers beantworten lassen. Das ist vor allem der Fall, wenn es um bestimmte Erfahrungen geht oder um die Suche nach speziellen Programmen. Wenn Sie eine Antwort auf eine hier veröffentlichte Frage wissen — oder eine andere, bessere Antwort als die hier gelesene, dann schreiben Sie uns. Antworten publizieren wir in einer der nächsten Ausgaben. Bei Bedarf stellen wir auch den Kontakt zwischen Lesern her.

# Das Interface mit Weitblick

> Das WW-92000/G von Wiesemann ist eine sehr universelle Centronics-Schnittstelle. Fast alle Drucker mit Centronics-Eingang können damit am C 64 angeschlossen werden. Grafik- und Steuerzeichen lassen sich auch im Breitschrift-Modus drucken.

Als Besitzer eines C 64 möchte man seinen Briefverkehr natürlich mit dem Computer und einem Drucker erledigen. Hat man sich für einen Drucker mit Centronics-Anschluß entschieden, weil dieser vielleicht mehr gegenüber einem Commodore-Drucker bietet, braucht man eine passende Schnittstelle. Das Centronics-Interface WW-92000/G erlaubt es, nahezu alle Centronics-Drucker am C 64 oder VC 20 zu betreiben. Da jeder Drucker über eine andere Befehlssyntax verfügt, muß der Druckertyp eingestellt werden. Dies geschieht mit sechs DIP-Schaltern, die nach dem Öffnen des Gehäuses zugänglich sind. Die Schalterstellungen werden im 20seitigen Begleitheft angegeben. Mit diesen Schaltern kann auch die Geräteadresse des Druckers gewählt werden (4 oder 5). Die Elektronik befindet sich in einem kleinen Gehäuse, an das ein Centronics-Stecker angeflanscht ist. Die Betriebsspannung von 5 Volt für das Interface wird dem Computer am Kassetten-Port entnommen. Das Interface kann deshalb nicht am SX 64 angeschlossen werden. Computer-Fans, die mit einer Datasette arbeiten, können diese weiterbenutzen. Der Stecker für den Kassetten-Port hat nämlich einen entsprechenden Anschluß.

Eine andere Version des WW 92000/G bezieht den Strom vom Centronics-Anschluß des Druckers. Nicht alle Drucker haben jedoch den entsprechenden Pin ab Werk angeschlossen. Epson-Drucker beispielsweise.

### Zu kurze Kabel

Bei den Kabellängen wurde gespart. Das 30 cm lange Kabel zwischen Kassetten- und dem seriellen Stecker reicht höchstens zum Anschluß am C 64 selbst aus. Steht das Diskettenlaufwerk nicht in unmittelbarer Nähe des Computers, so muß das Kabel notgedrungen verlängert werden. Das Interface kann nur als letztes der Peripheriegeräte angeschlossen werden, da eine serielle Weiterführungsbuchse fehlt. Das WW-92000/G simuliert auf den meisten Druckern mit Centronics-Eingang einen VC 1515-Drucker.

Die vielfältigen Möglichkeiten dieser Drucker, wie zum Beispiel Schönschriftmodus und verschiedene Zeichensätze, können auch in Verbindung mit Textverarbeitungsprogrammen verwendet werden. Zu diesem Zweck muß vor dem Laden des Programms die Betriebsart des Druckers angewählt und fixiert werden.

Sobald ein Zeichen unter der Sekundäradresse 3 an den Drucker gesandt wird, ist die zuletzt benutzte Betriebsart »fest« eingestellt; der Drucker ist danach unabhängig von folgenden OPEN-Befehlen auf die eingestellte Betriebsart fixiert. Diese kann nur durch Ausschalten des Interfaces gelöscht werden.

### Verträglichkeit mit Textverarbeitungsprogrammen

Im Betrieb mit Vizawrite muß im Druckermenü lediglich ein Centronics-Drucker angewählt werden, und schon arbeitet das Textsystem einwandfrei. Arbeitet man mit Textomat, müssen die Codes für die Umlaute in der Druckertabelle geändert werden. In dieser Tabelle steht, welcher Code für einen bestimmten Buchstaben an den Drucker geschickt wird. Die benötigten Werte dazu finden Sie im Druckerhandbuch. Auch die Codes für die Drucker-Steuerung können mit Textomat angepaßt werden. Die Textverarbeitungsprogramme Wordpro 3 + und Blitztext sind nicht mit dem deutschen Zeichensatz lauffähig, da keine Druckertabelle definiert werden kann und die Drucker-Codes für manche Umlaute im Programm eine andere Funktion haben.

### Grafik und Schriftarten

Das Interface ist grafikfähig. Hardcopies auf Centronics-kompatiblen Druckern sind kein Problem. Der Grafik-Modus wird durch CHR$(8) eingeschaltet. Mit der Eingabe CHR$(10) im PRINT#-Befehl wird in doppelter Breite gedruckt. Reverse Schrift ist mit CHR$(18) einzustellen. Zwischen 6-Punkt- und 8-Punkt-Modus läßt sich mit CHR$(22) und CHR$(23) umschalten.

### Fazit

Das 298 Mark teure WW 92000/ G-Centronics-Interface ist sehr universell. Es hat dadurch einen großen Vorteil: Man muß sich kein neues Interface kaufen, wenn man von einem einfachen Drucker mit Centronics-Schnittstelle auf einen anspruchsvolleren umsteigt.

(Christian Q. Spitzner/hm)

Bezugsquelle: Reinhard Wiesemann, Winchenbachstr. 3a, 5600 Wuppertal 2

# »Card/Print+G« - Das Allround-Interface

> Eines der vielseitigsten Centronics-Interfaces, das wir bisher in Händen hatten, kommt aus den USA und heißt »Card/Print+G«

Das »Card/Print + G« ist ein Produkt der amerikanischen Firma Cardco. Viele Programme amerikanischer Softwarehäuser sind darauf angepaßt. Ein Beispiel hierfür ist der »Koalaprinter« von Koala Technologies oder einige Textverarbeitungsprogramme, die später noch genauer benannt werden.

## Umständlich aber universell

Der Anschluß des Interfaces selbst geht problemlos vor sich: Drei Stecker sind anzuschließen; der erste am seriellen Port, der zweite am Kassetten-Port und der dritte am Centronics-Eingang des Druckers. Der Kassettenport liefert die notwendige Betriebsspannung von + 5 V für das Cardco-Interface. Eine Datasette kann weiterhin zur Datenspeicherung angeschlossen werden, da der Kassettenstecker wieder einen entsprechenden Anschluß hat.

Vor dem Anschluß muß jedoch eine Prozedur ausgeführt werden, die nicht gerade einfach ist. Das Interface muß auf den vorhandenen Druckertyp eingestellt werden, was über 8 DIP-Schalter im Inneren des Interfaces geschieht. Das hört sich zwar einfach an, entartet aber leicht in »Arbeit«. Um die besagten acht Schalterchen umzustellen, müssen Sie erst einmal einen passenden Schraubenzieher finden, um das ziemlich fest verschraubte Gehäuse öffnen zu können. Sind die DIPs eingestellt, kann es sein, daß Sie gleich auch Ihren Drucker aufschrauben dürfen. Denn einige Druckertypen müssen, ebenfalls durch DIP-Schalter, auf das Interface eingestellt werden.

Diese Prozedur muß, zum Trost, nur ein einziges Mal vorgenommen werden. Danach hat man eine Druckerschnittstelle, die kaum Wünsche offen läßt. Es können alle vorhandenen Druckermöglichkeiten genutzt werden. Außerdem hat man mit dem »Card/Print + G« dann ein Interface, mit dem man problemlos von beispielsweise einem alten Epson MX-80 auf einen FX-80 umsteigen kann.

Der größte Pluspunkt des Cardco-Interfaces: Es läuft mit fast allen Centronics-Druckern. Darunter sind zum Beispiel alle Epson MX-, RX- und FX-Drucker, Star Gemini 10X/15X, Delta 10, Itoh 8510, der NEC 8023, alle Okidata 82, 83, 84, 92, 93 und 94, der Spirit und MT 160 von Mannesmann-Tally, der BMC BX80 und einige Panasonic-Drucker. Aber auch bei anderen Druckern mit Centronics-Schnittstelle dürfte der Anschluß den C 64 mit diesem Interface problemlos sein.

## Angepaßte Software

Das Interface zeichnet sich dadurch aus, daß viele für Commodore-Drucker konzipierte Programme auch mit Druckern laufen, die eine Centronics-Schnittstelle haben. Natürlich können sämtliche Commodore-Grafikzeichen dargestellt werden, was in dieser Preisklasse Standard sein sollte. Commodore-Steuerzeichen für Breitschrift, Groß/ Klein- und Groß/Grafik-Modus, »Character-Tab-Mode« und andere werden so umgesetzt, daß der eingestellte Drucker sie »versteht«. Für diese Steuerzeichenwandlung ist keine Software nötig. Wegen dieser Steuerzeichenanpassung laufen viele Textverarbeitungsprogramme mit Centronics-kompatiblen Druckern, zum Beispiel Wordpro 3+, Script 64, Easyscript, Vizawrite und Paperclip.

Verschiedene in den USA erhältliche Programme sind, wegen der Vielseitigkeit des »Card/Print + G« speziell für dieses Drucker-Interface vorgesehen. Von diesen Programmen ist in Deutschland bisher nur eines erhältlich: der »Koalaprinter«, ein mit dem »Koalapad« bedienbares Programm zur Erstellung von Hardcopies von »Koalapainter«-Bildern in verschiedenen Größen und mit selbst wählbaren Farbschattierungen.

Über das »Card/Print + G« werden Programmlistings übrigens in sehr übersichtlicher Form ausgegeben. Anstatt der vielen unübersichtlichen Cursor-Steuerzeichen erhält man als Ausdruck zum Beispiel »C/DN« für Cursor down, »Fl« für die Fl-Taste, »DEL« für Delete und so weiter. Diese Ausdrücke sind in geschweifte Klammern gesetzt, die von Commodore-Computern nicht benutzt werden. Aus diesem Grund ist dann auch keine Verwechslung von Text mit Cursorsteuerzeichen möglich.

In einem Punkt ist das Interface nicht ganz so perfekt: Hardcopies zum Beispiel von Simons Basic (COPY-Befehl) funktionieren nur an etwa einem Viertel der ansprechbaren Druckertypen (Seikosha und. Kompatible), weil das Ansprechen der Grafikfähigkeiten druckerspezifisch bleibt. Eine feine Sache wäre es, wenn Hardcopy-Befehle (COPY, HDCOPY) für den MPS 801 auch vom Interface übersetzt würden, damit diese Befehle mit Druckern funktionieren, die einen Centronics-Eingang haben. Um dies zu erreichen, müßte nach einem Hardcopy-Befehl automatisch die entsprechende Codesequenz für Grafikmodus an den Drucker geschickt werden. Die Mehrkosten dürften wohl der Grund dafür sein, daß diese Funktion fehlt.

## Die Dokumentation

Das englischsprachige Handbuch, das mitgeliefert wird, darf nicht nur als einfaches Handbuch verstanden werden, sondern ist ein vollständiger Druckerkurs. Das heißt, der Anfänger bekommt nicht nur die speziellen Möglichkeiten des Interfaces ausführlich erklärt, sondern er erhält zusätzlich eine vollständige und sehr leicht verständliche Einführung in die Programmierung eines Druckers.

Wer das Handbuch ganz durchliest, ist also sehr gut informiert. Wer es aber nur als Nachschlagewerk benutzen will, der wird sich schwer tun, da die Informationen ziemlich durcheinandergewürfelt im Buch verteilt sind.

## Gesamteindruck positiv

Das Cardco-Interface ist ein sehr universell einsetzbares Centronics-Interface. Ideal ist es für denjenigen, der weiß, daß er im Lauf der Zeit seinen Drucker wechseln wird, weil seine Ansprüche steigen. Zum Beispiel von einem Seikosha GP-80 auf einen Epson FX-80.

Angenehm ist auch die Kompatibilität zur bestehenden Software und die Möglichkeit sämtliche Fähigkeiten der einzelnen Drucker ohne jede Einschränkung ausnutzen zu können.

Leider können wir Ihnen keine Vertriebsadresse in Deutschland nennen, da uns bei Redaktionsschluß kein Händler bekannt war. Der US-Preis liegt bei 99,95 Dollar.

(M. Kohlen/hm)

Info: Cardco Inc., 300 S. Topeka, Wichita, Ks 67202, USA

# Gute Connections

> Mit drei verschiedenen Schnittstellen kann mit dem C 64 fast die gesamte Peripherie, die es gibt, erschlossen werden.

Diese drei Schnittstellen sind: Centronics, RS232/V.24 und IEEE-488. In Europa wird die IEEE-488 meist als paralleler IEC bezeichnet. Centronics findet man neben IEEE-488-Schnittstellen hauptsächlich bei Druckern und Plottern. Die RS232-Schnittstelle wird seit vielen Jahren zur Textübertragung von Fernschreibern eingesetzt und hat sich bei Computern, zumindest in der Datenfernübertragung, durchgesetzt. Dabei wird nicht mehr die ursprüngliche Art, die TTY-, sondern fast ausschließlich die V.24-Version verwendet. Diese codiert logische Zustände in Form von Spannungspotentialen im Bereich von ± 3 bis ± 15 Volt, im Gegensatz zur alten TTYVersion, bei der logisch »1« mit einem Strom von 20 mA dargestellt wurde.

Die IEEE-488-Schnittstellen findet man häufig dann, wenn es um Messen, Steuern, Regeln geht, oder in Floppy-Disk-Laufwerken. Eine Übersicht über die bekanntesten IEEE-488-Schnittstellen finden Sie in einem gesonderten Testbericht.

(hm)

TODO 3x TABLE

# Erst ein IEC-Bus öffnet Tür und Tor

> IEC ist die Bezeichnung einer weitverbreiteten Bus-Norm. Auch am Commodore 64 erlaubt sie eine enorme Vietfalt an Peripheriegeräten bis hin zur Festplatte.

Stellen Sie sich vor: Speicherkapazitäten von 7,5 MByte auf Harddisk oder bis zu 1 MByte auf einer einzigen Diskette und dazu eine bis zu fünf mal schnellere Datenübertragungsgeschwindigkeit .

Diese Leistungsmerkmale sind keine Zukunftsmusik, sondern Realität für die Besitzer eines IEEE-488-Interfaces und der entsprechenden Peripherie. Anschließbar sind damit beispielsweise die Commodore-Doppellaufwerke 4040/8050/8250, die Harddisks 9060/9090, die Single Floppy 2031/SFD 1001 und verschiedene Drucker/Plotter und Meßgeräte.

Zunächst aber etwas zum IEC-Bus allgemein. Mit dem IEC-Bus wurde für den Datenaustausch Computer/Peripherie erstmals eine international akzeptierte Norm (DIN DKE 66.22, IEC 625-1, IEEE-488-1978 und ANSIMC 1.1)entwickelt. Die zugrundeliegende Zielsetzung lag damals darin, verschiedene Meß- und Steuergeräte ohne zusätzliche Interfaces zusammenzuschließen. Ebenso sind viele typische Computer-Peripheriegeräte wie Drucker und Disketten-Laufwerke im IEC-Standard ansprechbar. Bis auf das Steckersystem und den Namen sind die amerikanische und die europäische Version des IEC-Bus identisch. Die amerikanischen Bezeichnungen lauten IEEE-488 beziehungsweise HP-IB (Hewlett-Packard Interface Bus) oder GPIB (General Purpose Interface Bus). In Europa wird er allgemein als IEC-625 bezeichnet. In Bild 1 sind die beiden gebräuchlichen Steckversionen abgebildet. Links im Bild ist der 25polige Canon-Stecker und rechts der 24polige Amphenol-Stecker mit den jeweiligen Pinbelegungen abgebildet. An Commodore-Geräten findet in der Regel der Amphenol-Stecker Verwendung.

### Die Arbeitsweise des IEC-Bus

Der IEC-Bus arbeitet nach dem Prinzip der parallelen Datenübertragung. Es wird immer ein Byte, also acht Bits, auf einmal übertragen. Da acht Datenleitungen (DIO 1 bis 8) zur Verfügung stehen, ermöglicht diese Methode eine hohe Übertragungsgeschwindigkeit. Das, dem Centronics-Verfahren ähnliche, Datenübertragungsprotokoll arbeitet mit dem Dreidraht-Handshake-Verfahren. Dadurch wird sichergestellt, daß der Computer nur dann Daten sendet, wenn das angesprochene Peripheriegerät auch in der Lage ist, sie zu empfangen.

Die an einem IEC-Bus angeschlossenen Geräte werden in drei Kategorien eingeteilt:

- Talker (Geber): Sie schicken Daten an den Bus, können aber keine empfangen; zum Beispiel ein Meßgerät.
- Listener (Empfänger): Sie empfangen Daten vom Bus und verarbeiten sie; zum Beispiel ein Drucker.
- Controller (Steuergerät): Sie überwachen und steuern den Datenverkehr auf dem Bus. Controller können sowohl Listener als auch Talker sein. Der Computer ist ein Controller.

Jedes Gerät hat seine feste Adresse, über die es angesprochen wird. Dabei sind insgesamt bis zu 15 Geräte auf einmal anschließbar. Alle Signale sind TTL-kompatibel und arbeiten mit negativer Logik, das heißt: + 5 Volt ist logisch »Null« (inaktiv) und 0 Volt ist logisch »Eins« (aktiv). Der IEC-Bus hat 16 Signalleitungen zur Übertragung von Daten, zur Steuerung des Datenverkehrs und zur Festlegung des Betriebsmodus der Peripheriegeräte. Die Leitungen haben die folgenden Aufgaben:

- **Data Bus** (DIO 1 bis DIO 8) sind die Datenleitungen, die gemäß dem Zustand des ATN-Signals Kommandos (ATN = 1) oder Daten (ATN = 0) transportieren.
- **Handshake Bus** (DAV, NRFD, NDAC)
**DAV** (Data valid) gibt Auskunft über die Gültigkeit der Daten auf dem Data Bus.
**NRFD** (Not ready for data) wird von einem Gerät gesendet und zeigt dem Controller, daß es nicht bereit ist, Daten zu empfangen.
**NDAC** (No data accepted) wird ebenfalls von einem Gerät gesendet, um dem Controller zu sagen, daß es die Daten noch nicht übernommen hat.
- Interface Management Bus (REN, ATN, IFC, SRQ, EOI).
**REN** (Remote enable) dient der Einstellung auf Fernsteuerbetrieb.
**ATN** (Attention) kennzeichnet, ob auf dem Bus Kommandos oder Daten transportiert werden.
**IFC** (Interface clear) dient zur Normierung aller Geräte.
**SRO** (Service Request). Mit diesem Signal meldet ein Gerät der Steuereinheit, wenn es Daten will.
**EOI** (End or Identify) hat eine Doppelfunktion. Talker können das Ende der Datenübertragung anzeigen, der Controller leitet mit EOI die Parallelabfrage ein.

## Verschiedene Kategorien

Leider verfügt der C 64 im Gegensatz zu anderen Commodore-Computern über keinen IEC-Bus. Er muß beim C 64 nachgerüstet werden. Bild 2 zeigt eine Auswahl entsprechende Schnittstellen. Bei den getesteten Interfaces wurden dabei überraschenderweise drei verschiedene Wege beschritten. Einfach zu installieren sind alle Schnittstellen der ersten Kategorie; sie werden in den Expansion-Port gesteckt (Tewi, Commodore, C 64 plus, Luda, Siren). Bei diesen Modellen sind außer dem Anstecken des Verbindungskabels auf das Interface, keine weiteren Arbeiten notwendig. Ähnlich problemlos ist der Anschluß des Interpod (zweite Kategorie). Es wird, wie ein 1541 Diskettenlaufwerk, am seriellen Ausgang installiert. Neben dem Verbindungskabel zum Peripheriegerät muß hier noch ein Stromversorgungskabel angeschlossen sein. Etwas aufwendiger gestalten sich die Arbeiten bei Geräten der dritten Kategorie, namentlich dem Kfc, dem Maier und einer Version des Luda-Interfaces. Eine Verbindungskarte wird in den Expansion-Port gesteckt und das Kernal-ROM (Steckplatz U4 im Computer) muß ausgetauscht werden.

Welches Interface für welche Anwendung am besten geeignet ist, hängt im wesentlichen von zwei Kriterien ab: Erstens der Art der gewünschten Anwendung und zweitens von der zum Anschluß vorgesehenen Peripheriegeräte. Neben der reinen Hardware gehört zu jedem Interface ein Softwarepaket zur Anpassung der Datenübertragung. Für diese Software gilt das gleiche wie beispielsweise für eine Beschleunigung des Floppy-Disk-Laufwerkes per Programm: Sie kann entweder im Basic-Speicher, im $C000-Bereich oder, an Stelle der Kassetten- oder RS232-Routinen im Betriebssystem stehen. Alle Interfaces der ersten Kategorie legen ihre Software in diesen Bereichen ab, die danach natürlich nicht mehr von anderen Programmen genutzt werden können. Der wesentlichste Nachteil dieser Methode ist ein Verlust an Kompatibilität zu kommerzieller Software, da diese leider oft diese Speicherbereiche nutzt.

### Kompatibilität ist Trumpf

Ganz anders die Kernal-Interfaces (dritte Kategorie). Sie sind mit mehr Programmen verträglich, da die notwendige Software im $E000-$FFFF-Bereich liegt und der darunterliegende RAM-Bereich frei bleibt. Nachteilig ist bei dieser Hardwarelösung der Austausch des Kernal-ROMs. Sind die ICs im C 64 nicht gesockelt, kann der Austausch recht arbeitsintensiv werden. Der Betrieb einer Datasette oder der RS232-Schnittstelle wird dadurch unmöglich gemacht.

Ganz aus dem Rahmen fällt das Interpod als Vertreter der zweiten Kategorie. Durch sein Konzept mit eigenem Mikroprozessor entfällt jede Speicherplatzbelegung im Computer. Anschluß und Betrieb sind unproblematisch, die Software-Verträglichkeit liegt bei nahezu 100 Prozent. Der wesentliche Nachteil des Interpod ist seine serielle Datenübertragung. Die Lade- und Speichergeschwindigkeit eines angeschlossenen schnellen Diskettenlaufwerks mit parallelem IEC-Bus sinkt auf die der 1541-Laufwerke.

Sollen Diskettenstationen mit einer größeren Speicherkapazität und einem anderen Diskettenformat als beim 1541-Laufwerk angeschlossen werden, wie zum Beispiel eine SFD 1001, steht die Software-Verträglichkeit zu käuflichen Programmen im Hintergrund. Um mit diesen Laufwerken arbeiten zu können, sind Zusatzfunktionen eines Interfaces, wie etwa die Basic 4.0 Befehle, wichtig. Ein Überspielen der Programme vom 1541- auf das 8050-Format ist wegen des meistens vorhandenen Kopierschutzes nicht möglich, selbst wenn die Programme mit den verschiedenen Interfaces zusammenarbeiten würden. Soll lediglich ein Commodore-Drucker oder ein Meßgerät mit dem Interface betrieben werden, sind die wichtigsten Kriterien die Zuverlässigkeit und der Preis. Die Übertragungsgeschwindigkeit Interface spielt hierbei nur eine untergeordnete Rolle, da Drucker und Plotter von sich aus recht langsam arbeiten.

Alle vergleichbaren Leistungsmerkmale der einzelnen Interfaces sind in Bild 3 zusammengefaßt. Deshalb wird hier nur noch auf die jeweiligen Besonderheiten der einzelnen Schnittstellen eingegangen.

### Alle Vorteile kombiniert

Wohl am vielseitigsten ist das Luda-Interface, denn es gehört sowohl zur ersten als auch zur dritten Kategorie. Seine Betriebssoftware kann entweder im RAM unter dem Kernal-ROM (für gelegentliche Mischbenutzung) oder im Kernal-ROM liegen. Da sich auf der Platine zwei Steckplätze für 8KByte-EPROMs befinden, kann hier zusätzlich Betriebssoftware oder ein anderes Programm stehen. Auf der Platine befinden sich außerdem ein Reset-Knopf und mehrere Dual-In-Line Schalter, um den Speicherbereich der EPROMs zu selektieren. Auf der mitgelieferten Diskette befinden sich zwei Kopierprogramme, zum wechselseitigen Datenaustausch zwischen 1541- und 8250-Laufwerk.

### Für jeden etwas

Das Kfc-Interface wird in drei Versionen geliefert. Wesentlich unterscheiden sich allerdings nur die MK I- und die MK III-Versionen. Die MK I-Version gehört zur ersten Kategorie, die MK III-Version zur dritten. Beim MK I-Interface wurden einige, dem DOS 5.1 ähnliche, Befehle eingebaut, die dem MK III nicht zur Verfügung stehen. Als Kernal-Version ist das MK III aber wesentlich universeller als das MK I.

### Das Universelle

Das IEC-Interface 3-S von Maier ist ein weiterer Vertreter der Kernal-Schnittstellen. Ein zusätzlicher 8-KByte-EPROM-Steckplatz ist das Kennzeichen dieses Interfaces. Für diesen Steckplatz werden auf EPROM ein Monitor und der Basic 4.0-Befehlssatz angeboten Qe 80 Mark). Höchste Software-Verträglichkeit wird erreicht, wenn der EPROM-Steckplatz per Schalter abgeschaltet wird. Ein zweiter Schalter dient zur Umschaltung zwischen serieller und paralleler Datenübertragung. Der beigefügte Softwareteil auf Diskette enthält ein Seriell/Parallel-Kopierprogramm.

### Das professionelle Interface

Obwohl es mit den Nachteilen einer Schnittstelle der ersten Kategorie behaftet ist, können dem Tewi-Interface gute Noten bescheinigt werden. Es ist als einziges der getesteten Geräte mit einem sehr guten Handbuch ausgestattet. Es erleichtert auch dem Anfänger den Umgang mit der gesamten Peripherie von Commodore. Sehr nützlich ist die Turnkey-Funktion, die ein beliebiges Programm beim Einschalten von einer speziell vorbereiteten Diskette lädt und startet. Eine Version des Tewi-Interfaces, das keinen Speicherplatz mehr belegt und mit der meisten Software für den C 64 verträglich ist, wurde angekündigt.

### Komfortabel contra kompatibel

Den größten Komfort aller Interfaces bietet das C 64 plus von Köhler. Es verfügt über einen kompletten Basic 4.0-Befehlssatz und einige interessante Zusatzfunktionen:
IOSEL bestimmt, ob parallel oder seriell geladen wird
SCREEN bestimmt, mit welcher Geschwindigkeit auf dem Bildschirm gescrollt wird
KEY belegt die Funktionstasten KEYLIST zeigt die Belegung APPEND hängt Programme an RENUMBER numeriert ein Programm neu
DELETE löscht Programmteile FIND findet Strings im Programm SCREEN schaltet Hires-Grafik ein MOVE positioniert den Cursor COLOR wählt die Zeichenfarbe aus ERASE löscht den Bildschirm TEXT gibt bestimmte Strings aus HCOPY Hardcopy einfache Größe HCOPY 2 Hardcopy doppelte Größe

Zusätzlich ist der User-Port als Centronics-Schnittstelle programmiert. Mit SYS 33000 wird das ebenfalls vorhandene, umfangreiche Monitorprogramm aufgerufen.

### Einfach aber funktionell

Das Siren-Interface gehört zur ersten Kategorie, belegt aber wenig Basic-Speicherplatz. Die verschiebbare Betriebssoftware steht im $9C00 bis $9F00-Bereich. Zusätzliche Funktionen oder Hilfsprogramme sind nicht eingebaut.

### Das doppelte Interface

Das Interpod hat neben dem IEC-Bus eine vollständige RS232-Schnittstelle eingebaut, die aber im Rahmen dieses Tests nicht berücksichtigt wurde. Durch seine Konzeption als serieller Konverter ist das Interpod für alle Anwendungen bestens geeignet, die nicht zeitkritisch sind. Auch alle jene Anwender, die keinen Wert auf einen Geschwindigkeitsvorteil beim Umgang mit dem Diskettenlaufwerk legen, sind mit dem Interpod bestens bedient.

### Commodore für Commodore

Auch Commodore selbst bietet ein IEC-Interface an. Es funktioniert ähnlich wie das Siren-Gerät. Sofort nach dem Einschalten ist der IEC-Bus aktiv. Es wird nur wenig Speicherplatz belegt, wobei der Basic-Speicher frei bleibt. Als einziges Interface hat es den Expansion-Port durchgeschleift. Allerdings funktionierte die getestete Vorabversion mit verschiedenen Modulen nicht einwandfrei. Die endgültig ausgelieferten Geräte sollen diesen Fehler aber nicht mehr haben.

### Erst abwägen, dann kaufen

Der Test hat gezeigt, daß es von der jeweiligen Zielsetzung und der zur Verfügung stehenden Peripherie abhängt, welches Interface das richtige ist. Einige Eindrücke lassen sich allerdings doch festhalten: In der ersten Kategorie gefiel das C 64 plus Interface am besten, da es gleichzeitig eine leistungsfähige Programmierhilfe ist. Nebenbei spart man sich die Kosten für eine Centronics-Schnittstelle und ein Monitorprogramm. Die größte Flexibilität bietet das Luda-Interface. Es kann der ersten und der dritten Kategorie zugeordnet werden. Die Steckplätze fassen zwei 8-KByte-EPROMs.

Eines wurde beim Testen der Geräte klar: Es ist eine tolle Sache, mit der »großen« Peripherie zu arbeiten, auch wenn diese den Preis des Commodore 64 bei weitem übersteigt.

(Arnd Wängler/hm)

# Das 30-Mark-Interface

> Mit 30 bis 40 Mark, je nach Ausstattung, und etwas Arbeitszeit können Sie ein V.24/RS232-Interface selbst bauen und damit beispielsweise ein Modem oder einen Akustikkoppler an den C 64 anschließen.

In den wenigsten Computern ist eine V.24/RS232-Schnittstelle bereits ab Werk eingebaut, obwohl Sie Zugang zu vielen Peripheriegeräten, wie Modems und Drucker, eröffnet, die mit Spannungspegeln zwischen +3 Volt und +15 Volt für High- und zwischen -15 Volt und -3 Volt + für Low-Zustand angesteuert werden.

Viele Computer haben jedoch die für eine RS232-Schnittstelle notwendige Software bereits im Betriebssystem implementiert. Der C 64 und VC 20 sind solche Computer, bei denen am User-Port eine RS232-Schnittstelle simuliert werden kann, bei der allerdings TTL-Pegel ( + 5 V) anstelle der geforderten ± 3 bis +15 V anliegen.

Mit dieser Bauanleitung bieten wir Ihnen ein Selbstbauinterface an, das den TTL-Spannungspegel Ihres C 64/VC 20 auf die geforderten V.24/RS232-Schnittstellenpegel konvertiert. Wie das fertige Interface aussehen kann, sehen Sie in Bild 1. Zum Anschluß wurden zwei D-Sub-Buchsenleisten verwendet.

## Einfache Elektronik

Der Aufbau der Schaltung ist, dank der Verwendung von integrierten Bausteinen, sehr einfach und stellt deshalb keine allzu hohen Anforderungen an das handwerkliche Geschick des »Heimwerkers«. Die Bauteile sind in jedem Elektronikgeschäft zu bekommen. Die Kernstücke des Interfaces sind die integrierten Schaltkreise SN75188 und SN75189. Der erste enthält vier Treiber, der zweite vier Empfänger für V.24/RS232-Schnittstellen. Die ICs konvertieren die computerseitig vorhandenen TTL-Pegel von + 5 V in die V.24/RS232C-Pegel von +3 bis ± 15 V. In Bild 2 sehen Sie schematisch die Ausgangsspannung des Interfaces in Abhängigkeit des TTL-Pegels am Eingang. Bild 3 zeigt das Schaltbild des Interfaces. Die RS232-seitig (links im Platinenlayout, Bild 4) bezeichneten Anschlüsse 2 bis 8 und 20 entsprechen der V.24/RS232C-Norm und können an eine 25-polige RS232-Buchse geführt werden, wenn Sie kein fest installiertes Kabel verwenden wollen. Die Pinnummern der Buchse sind identisch mit den Punkten auf der Platine und dem Schaltbild. Die computerseitigen Anschlüsse (rechts im Platinenlayout) beziehen sich auf den User-Port des C 64 und VC 20. Zum Anschluß an den User-Port eignet sich die Steckerleiste TRW 251-12-90-160.

Bild 4 und 5 zeigt das Layout und den Bestückungsplan einer Platine, die alle Teile des Interfaces aufnimmt. Die Stückliste dazu finden Sie in Bild 6. Es reicht aber auch eine 2.54-mm-Lochrasterplatine, wenn Ihnen das Ätzen und Bohren zu viel Arbeit ist. Das Interface kann nach Belieben in ein extra Gehäuse oder in ein genügend großes User-Port-Steckergehäuse eingebaut werden.

## Platine selbstgemacht

Die Versorgungsspannungen für das Interface werden dem Computer entnommen. Zur Versorgung der ICs ist eine Spannung von 5 V/100 mA und zudem eine symmetrische Spannung von ± 9 V nötig. Die 5 V können am User-Port (Anschluß 2) abgegriffen werden. Durch Einweggleichrichtung der 9 V Wechselspannung, die an Pin 11 am User-Port zur Verfügung steht, erhält man eine symmetrische Spannung von ± 9 V. Diese Spannung liegt auch am RS232-Ausgang des Intefaces an. Sie ist innerhalb des Bereichs von ±3 bis ± 15 V den die RS232C-Norm fordert.

## Das Null-Modem

Ein Tip am Rande: Sollen zwei Computer in unmittelbarer Nähe betrieben werden, zum Beispiel innerhalb des Hauses oder der Wohnung, so kann auf ein Modem verzichtet werden. Dazu werden zwei RS232-Interfaces einfach über eine 5-adrige Leitung, wie in Bild 7 gezeigt, miteinander verbunden. Das Kabel kann dabei bis zu 50 m lang sein.

(Dipl.-Ing. R. Kurzhals/hm)

# Joystick im Selbstbau

> Nicht immer findet man im großen Joystick-Angebot »seinen« Joystick. Dann hilft nur Marke Eigenbau.

Vielleicht habt Ihr Euch über die Handhabung von verschiedenen Spielprogrammen mit den herkömmlichen Joysticks geärgert. Die Spielprofis unter Euch glauben sicher schon, den richtigen »Spielknüppel« gefunden zu haben. Auch ich war davon überzeugt. Bis ich mir das Spiel »Summer Games« zugelegt hatte. Viele von Euch, die dieses Spiel besitzen, wunderten sich bestimmt über das Herumrühren und Hin- und Herschütteln des Joysticks, wenn man gute Ergebnisse erzielen wollte. Die Folge: Nach mehreren Tagen »Olympiade« gab der Joystick seinen Geist auf. Deshalb baute ich mir selbst einen Joystick. Meine Grundidee war, für die Steuerung Taster und Schalter zu verwenden. Diese weisen eine längere Lebensdauer auf, als das Plastikinnenleben der herkömmlichen Joysticks.

So bin ich losgezogen, habe mir die nötigen Teile besorgt und anschließend munter drauflos gebastellt. Ich war angenehm überrascht. Durch die Drucktaster für zwei Stromkreise — Position 5 der Bauteilliste — kam zum Beispiel der Weitspringer auf ungeahnte Sprungweiten.

Wenn Ihr Lust habt, diesen Joystick zu bauen, müßt Ihr Euch natürlich erst die Bauteile besorgen (zirka 35 Mark). Ferner benötigt Ihr einen Lötkolben und zirka einen Meter dünnen, isolierten Draht. Der Zusammenbau ist sehr einfach. Mit Reißnadel und Lineal werden die Positionen für die Taster und Schalter in das Plastikgehäuse eingeritzt. Dann werden die Löcher oben und seitlich gebohrt sowie für die Schalter und das Anschlußkabel an der Rückwand ausgesägt. Anschließend werden die Bauteile zusammengesetzt und nach dem Schaltplan verdrahtet.

Wenn Ihr alles richtig gemacht habt, steht Euch nichts mehr im Wege, Goldmedaillengewinner zu werden.

(Johann Ferstl/rg)

# Vielleicht habt Ihr Euch über die Handhabung von verschiedenen Spielprogrammen mit den herkömmlichen Joysticks geärgert. Die Spielprofis unter Euch glauben sicher schon, den richtigen »Spielknüppel« gefunden zu haben. Auch ich war davon überzeugt. Bis ich mir das Spiel »Summer Games« zugelegt hatte. Viele von Euch, die dieses Spiel besitzen, wunderten sich bestimmt über das Herumrühren und Hin- und Herschütteln des Joysticks, wenn man gute Ergebnisse erzielen wollte. Die Folge: Nach mehreren Tagen »Olympiade« gab der Joystick seinen Geist auf. Deshalb baute ich mir selbst einen Joystick. Meine Grundidee war, für die Steuerung Taster und Schalter zu verwenden. Diese weisen eine längere Lebensdauer auf, als das Plastikinnenleben der herkömmlichen Joysticks.
So bin ich losgezogen, habe mir die nötigen Teile besorgt und anschließend munter drauflos gebastellt. Ich war angenehm überrascht. Durch die Drucktaster für zwei Stromkreise — Position 5 der Bauteilliste — kam zum Beispiel der Weitspringer auf ungeahnte Sprungweiten.
Wenn Ihr Lust habt, diesen Joystick zu bauen, müßt Ihr Euch natürlich erst die Bauteile besorgen (zirka 35 Mark). Ferner benötigt Ihr einen Lötkolben und zirka einen Meter dünnen, isolierten Draht. Der Zusammenbau ist sehr einfach. Mit Reißnadel und Lineal werden die Positionen für die Taster und Schalter in das Plastikgehäuse eingeritzt. Dann werden die Löcher oben und seitlich gebohrt sowie für die Schalter und das Anschlußkabel an der Rückwand ausgesägt. Anschließend werden die Bauteile zusammengesetzt und nach dem Schaltplan verdrahtet.
Wenn Ihr alles richtig gemacht habt, steht Euch nichts mehr im Wege, Goldmedaillengewinner zu werden.
Johann Ferstl/rg)

# Von der Schreibmaschine zum Textsystem

> Es gibt wohl nur einen Brief, den man auch in hundert Jahren noch von Hand schreiben wird - den Liebesbrief. Für alle anderen Arten von Texten wird sich der Mensch in Zukunft aber wahrscheinlich des Computers bedienen. Wir helfen Ihnen das für Sie richtige Programm zu finden.

Ob beruflich oder privat, das geschriebene Wort läßt sich aus unserer heutigen Informationsgesellschaft nicht mehr wegdenken. Dabei wird der Anteil der im häuslichen Bereich abgewickelten Korrespondenz noch stark ansteigen. In der Industrie werden beispielsweise schon heute eine Vielzahl der Briefe nicht mehr dem nächsten Briefkasten anvertraut, sondern in Form von Daten auf elektronischem Weg übertragen. Transportzeiten von zwei oder mehr Tagen für eine Nachricht erscheinen im Vergleich zu wenigen Sekunden bei der Datenfernübertragung nahezu mittelalterlich. Diesen Vorteilen wird sich der private Anwender kaum verschließen können. Doch noch hat sich das häusliche Terminal, von dem aus jeder Post empfangen und senden kann, nicht allgemein durchgesetzt. Der Grund dafür liegt einerseits darin, daß die Post die geforderten Leistungen nicht zu einem akzeptablen Preis anbietet und andererseits darin, daß noch eine allgemeine Skepsis gegenüber diesem neuen Medium vorherrscht.

### Welches Programm ist das richtige?

Die gerade in den letzten zwei Jahren sprunghaft angestiegene Verbreitung der Heimcomputer, insbesonders die des C 64, hat Signale für diese Entwicklung gesetzt. Und der eingeschlagene Weg scheint, wenn auch mit gewissen Einschränkungen, richtig. Bestes Beispiel hierfür ist die Textverarbeitung. Kaum ein Heimcomputer, für den es nicht mindestens ein Textverarbeitungsprogramm gibt. Sogar für den Sinclair ZX81 gibt es ein solches Programm. Dem Besitzer eines C 64 stellt sich das Problem aber in einer ganz anderen Form:

Welches der vielen angebotenen Programme ist für mich das richtige? Die Unsicherheit ist groß, denn bei Preisen bis zu 400 Mark für ein gutes Textverarbeitungsprogramm ist eine Fehlinvestition doch recht schmerzlich. Die vielen in der Redaktion eingehenden Anfragen zeigen, daß der Kauf eines Textverarbeitungsprogramms nur nach gründlicher Information erfolgreich sein kann.

Wie vielschichtig die Problematik ist, wird deutlich, wenn man einmal die Grundvoraussetzungen des Commodore 64 betrachtet:

* Um auch dem Besitzer eines Fernsehers ein leserliches Schriftbild anzubieten, arbeitet der C 64 mit 40 Zeichen pro Zeile. Für eine Textverarbeitung sind aber in der Regel mindestens 80 Zeichen pro Zeile notwendig, denn eine Druckzeile auf dem Papier hat meistens auch bis zu 80 Spalten.
* Der C 64 ist mit einer Vielzahl von Schnittstellen ausgestattet, allerdings mit keiner einzigen genormten (im Gegensatz zum Urvater, dem PET 2001). Der Anschluß eines nicht von Commodore hergestellten Druckers ist deshalb immer mit zusätzlichem Aufwand und Problemen verbunden:
* Die von Commodore zum C 64 angebotenen Drucker verfügen nicht über den wichtigen deutschen Zeichensatz.
* Der C 64 wurde für den amerikanischen Markt entworfen und verfügt deshalb über keine deutsche DIN-Tastatur. Hiermit verbunden ist das Fehlen der deutschen Umlaute, die für einen ordentlichen Brief unverzichtbar sind.

Andererseits ist die Tastatur des C 64 für einen Heimcomputer relativ gut und durchaus auch für längere Schreibarbeiten geeignet.

* Die Charakter-Codes des C 64 entsprechen nicht der Standard ASCII-Norm, wie sie von den meisten Druckern verwendet wird.

## Erfindungsreichtum ist gefragt

Alle diese Probleme versuchen die Entwickler von Textverarbeitungsprogrammen zu überwinden — leider nicht immer mit Erfolg. Andererseits wurden aber auch Lösungen gefunden, die schon fast als genial bezeichnet werden können. Eine dieser Ideen ist das horizontale Verschieben des Textes beim Schreiben (Vizawrite, Textomat, SM-Text und andere). Auf diese Weise bleibt eine »lesbare« Zeichengröße erhalten, der Text kann aber schon beim Schreiben formatiert werden.

Ein anderes Programm zeigt den geschriebenen Text auf Wunsch in seiner späteren Form. Dazu wird die Zeichenbreite halbiert, so daß achtzig Buchstaben nebeneinander Platz finden (Homeword).

Die Programmierung eines neuen Zeichensatzes mit deutschen Umlauten und eine Neubelegung der Tastatur nach DIN, gehört bei den Spitzenreitern dagegen schon zum Standard. Um mit möglichst vielen Druckern zusammenarbeiten zu können, haben einige Programme Auswahlmenüs zur Einstellung der Druckerparameter. Andere wiederum bedienen sich intelligenter Tricks um auch aus den Commodore-Druckern deutsche Umlaute herauszulocken (im Grafikmodus).

### Einkauf mit Checkliste

Ginge es nur nach den anpreisenden Werbetexten auf den Verpackungen der verschiedenen Programme, dann wäre jedes das richtige. Doch leider treten Probleme grundsätzlich nie beim Kauf, sondern erst viel später, zu Hause bei der Arbeit, auf. Dann aber ist ein Umtausch oft nicht mehr möglich (Aufschrift: Nach dem Öffnen des Siegels ist jeder Umtausch ausgeschlossen). Deshalb hier eine Checkliste, die zusammen mit einer guten Fachberatung das Risiko vermindern hilft:

Regel 1: Werden Sie sich klar, was Sie eigentlich wollen. Stellen Sie sich dazu das Leistungsprofil der für Sie wichtigen Punkte an Hand der Tabelle 1 (Hardware) und Tabelle 2 (Software) zusammen.
Regel 2: Planen Sie weitsichtig. Auch wenn Sie heute die eine oder andere Funktion nicht brauchen; morgen ist es vielleicht anders.
Regel 3: Planen Sie Hardware und Software gemeinsam. Oft kann die Leistungsfähigkeit einiger guter Textverarbeitungsprogramme nicht ausgenutzt werden, weil die entsprechenden Voraussetzungen von Seiten der Ausstattung nicht gegeben sind. (Tip: Kaufen Sie Peripheriegeräte lieber eine Nummer größer, denn mit steigenden Fähigkeiten wachsen die Ansprüche).
Regel 4: Informieren Sie sich, ob die gewünschte Hardwarekombination auch mit dem geplanten Programm einwandrei funktioniert. Dieser Punkt ist besonders wichtig, wenn Geräte eines anderen Herstellers am Commodore 64 betrieben werden sollen. Man braucht dazu in der Regel ein spezielles Interface, das alle Anpassungen vornimmt. Nun gibt es für jeden Zweck leider die verschiedensten Arten von Schnittstellen. Dabei ist die teuerste nicht immer die beste. Gerade die Vielzahl der Funktionen, die manche Schnittstellen anbieten, behindern die einfache Anwendung.
Regel 5: Achten Sie auf gute Programmdokumentation. Ganz entscheidend dafür, was Sie später aus einem Programm herausholen, ist die Qualität der Anleitung. Lassen Sie sich nicht dazu verführen, ein möglicherweise preiswertes Programm mit englischer Anleitung zu erstehen, wenn Sie nur etwas Schulenglisch beherrschen. Gerade bei Bedienungsanleitungen erschweren häufige Fachausdrücke das Verständnis. Aber auch deutschsprachige Anleitungen haben ihre Tücken. Drei oder vier windige Blättchen, mit einer Heftklammer zusammengehalten, sind kein Ersatz für eine umfangreiche Dokumentation.
Regel 6: Entscheiden Sie selbst. Das Programm, das für Ihren Freund richtig ist, muß nicht unbedingt für Sie passen. Oft sind auch, seitdem Ihr Freund sein Programm erstanden hat, wesentlich bessere Programme erschienen.
Regel 7: Probieren Sie so viel wie möglich aus. Auch wenn Sie glauben, das richtige Programm gefunden zu haben, probieren Sie es bei Ihrem Fachhändler selbst aus. Nur dann können Sie merken, ob nicht doch die eine oder andere Eigenheit des Programms nicht in Ihr Konzept paßt. Zwischen Funktionsqualität und Bedienungskomfort besteht leider häufig ein großer Unterschied.

Einige der nun folgenden generellen Punkte sollten Sie aber auf jeden Fall berücksichtigen.

* Menüstruktur
Es gibt Textverarbeitungsprogramme, bei denen Sie sich jedesmal durch eine Unzahl von Menüs kämpfen müssen, bevor Sie zum eigentlichen Schreiben kommen. Ein gutes Programm kommt mit einem Menü aus, bei dem Sie entscheiden, welche generelle Funktion Sie wünschen. Farbeinstellungen, Datumsausgabe, Parametereinstellungen (Floppy, Drucker) sollten nur dann vom Programm abgefragt werden, wenn Sie das wünschen.
* Manche Programme werden mit zunehmender Textmenge immer langsamer (hauptsächlich Basic- und compilierte Basic-Programme). Füllen Sie mit der Copy-Funktion (falls vorhanden) einmal probeweise den Speicher. Wenn dann ein problemloses Schreiben noch möglich ist, können Sie diesen Punkt Ihrer Liste streichen.
* Achten Sie auf eine Erweiterungsfähigkeit des Programms. Sinnvolle Ergänzungen sind beispielsweise eine Datenverwaltung (für Serienbriefe) oder eine Rechtschreibhilfe.
* Vergleichen Sie die Textspeicherkapazität verschiedener Programme. Sie schwankt zwischen 17000 und 34000 Zeichen.
* Ein professionelles Programm sollte frei von unsinnigem Ballast sein. Ständig verfügbare Hilfsanweisungen kann sich ein relativ kleiner Computer wie der C 64 kaum leisten, denn sie verbrauchen nur unnötig Speicherplatz, wenn Sie das Programm erst einmal beherrschen gelernt haben. Nur für die Einarbeitungszeit ist es sinnvoll diese Hilfskommentare als Textfiles auf Wunsch von der Diskette laden zu können.
* Das Aufrufen einzelner Funktionen darf nur wenige Tastendrücke erfordern. Es gibt Programme, bei denen vor jedem Ausdruck bis zu zehn Tasten gedrückt werden müssen. Gute Programme kommen mit drei bis vier Tastenbetätigungen aus.

Damit wären eigentlich die wichtigsten Punkte gesagt. Eine Entscheidung muß letztendlich jeder selbst treffen, denn nicht jeder stellt die gleichen Ansprüche oder kann 300 Mark für ein Programm ausgeben. Beherzigen Sie die hier gegebenen Ratschläge, dann kann eigentlich einer produktiven Textverarbeitung nichts mehr im Wege stehen. Sie werden sehen, wie angenehm es ist, mit Wörtern und Buchstaben zu jonglieren, ohne dabei ganze Papierberge in Abfall zu verwandeln.

(Arnd Wängler/gk)

# Homeword - Textverarbeitung zu Hause

> Nicht nur im Büro, auch zu Hause, für die ganz persönliche Korrespondenz, ist die Texterstellung mit dem Computer im Vormarsch. Homeword ist das Textverarbeitungsprogramm für den privaten Anwender.

Homecomputer sind mehr als nur Spielzeuge, sie sjnd bereits heute in vielen Bereichen des Haushalts einzusetzen. Dabei ist neben der Datenverwaltung die Textverarbeitung ohne Zweifel das sinnvollste, was man mit einem Homecomputer machen kann. Texte schnell erstellen, korrigieren und auch archivieren sind unbestreitbare Vorteile. Doch die Einarbeitung in die Bedienung eines Textverarbeitungsprogramms ist nicht unbedingt jedermanns Sache. Erschwert wird der Umgang mit vielen Programmen durch die Tatsache, daß sie aus dem englischsprachigen Ausland kommen und lediglich eingedeutscht wurden. Der Spaß am Arbeiten bleibt dabei leider allzu oft auf der Strecke.

## Handbücher ohne gleichen

Homeword ist zwar auch ein ehemals englisches Programm, bei ihm wurden aber diese Fehler nicht begangen. Sowohl den Handbüchern als auch dem Programm selbst wurde bei der Übersetzung größte Sorgfalt gewidmet. Kein Wunder, wenn man den Herausgeber von Homeword kennt — es ist der Langenscheidt Verlag, bekannt durch Wörterbücher, fremdsprachliche Fachbücher und das erste elektronische Wörterbuch. Zum Lieferumfang des nur auf Diskette erhältlichen Programms gehören insgesamt drei Handbücher: Ein klar gegliedertes Anleitungsbuch, ein Trainingsbuch und eine Kurzanleitung. Das Anleitungsbuch ist mit vielen Darstellungen und Beispielen illustriert und führt zu schnellen Erfolgen bei der Einarbeitung. Natürlich werden in einer solchen Anleitung alle Themen nur in so weit angesprochen, daß eine sichere Bedienung möglich ist. Das Programm beherrschen lernt der Anwender aber spätestens mit Hilfe des Trainingsbuches. Auf über achzig Seiten wird jedes Detail erläutert und sinnvolle Beispiele gegeben. Alle drei Handbücher setzen absolut keine Kenntnisse des Computers oder einer Programmiersprache voraus. Sie richten sich an den absoluten Anfänger, denn der Fortgeschrittene braucht für Homeword kaum mehr als die Kurzanleitung, so leicht verständlich ist das Programm.

## Hoher Komfort, aber langsam

Homeword ist ein symbol- und bildschirmorientiertes Textverarbeitungsprogramm. Schon kurz nach dem Laden wird deutlich, was sich die Münchener Wörterbuch-Spezialisten unter Bedienungskomfort vorstellen. Am unteren Bildschirmrand erscheint, größer als bei früher getesteten Programmen, die Menüzeile (Bild 1). Sie enthält allerdings nicht nur Texte, sondern deutliche Symbole der einzelnen Funktionen. Dasjeweils aktuelle Untermenü ist mit einem deutlichen Rahmen gekennzeichnet, ausgewählt wird mit den Cursortasten. Kein langweiliger Marsch durch Textmenüs, sondern viele ansprechende Symbole stehen für das jeweilige Leistungsmerkmal. Leider benötigt Homeword immer wieder die Systemdiskette, um einzelne Programmteile nachzuladen. Bei der Geschwindigkeit des VC-1541-Laufwerkes ist das ein auf die Dauer doch sehr störender Umstand. Erschwerend kommt hinzu, daß immer zwischen Daten- und Systemdiskette gewechselt werden muß — die Diskjockey-Fähigkeiten des Anwenders sind gefordert.

## Deutsche Tastatur ist Standard

Der eigentliche Text wird in dem über dem Menüfeld liegenden, relativ schmalen Editierbereich eingegeben. Glücklicherweise wurde bei der Umsetzung des Programms aus dem englischen nicht versäumt, das Programm mit deutschen Umlauten zu versehen. Die Tastaturbelegung stimmt allerdings mit der deutschen Norm nicht überein. Wer es gewöhnt ist, im Büro mit einer genormten Tastatur zu arbeiten, wird mit täglichen Umstellungsproblemen rechnen müssen. Wer allerdings nur mit Homeword arbeitet, hat sich schnell an die neue Tastenbelegung gewöhnt. Wie die Konkurrenzprodukte, hat auch Homeword sich den Grundvoraussetzungen des C 64 anzupassen. Die Tatsache, daß viele Anwender lediglich einen Fernseher angeschlossen haben, hat die Autoren von Homeword zu einem Kompromiß zwischen einer 40- und 80-Zeichendarstellung gezwungen: Beim Schreiben werden nie mehr als vierzig Zeichen pro Zeile abgebildet. Wörter, die dabei nicht mehr in die aktuelle Zeile passen, werden automatisch in die nächste Zeile übernommen. Vor dem Ausdruck des Textes hat der Schreiber aber Gelegenheit, den gesamten Text im 80-Zeichen-Format an sich vorüberrollen zu lassen. Wie beim Abspann eines Kinofilmes ziehen auf diese Weise Zeile für Zeile über den Bildschirm. Das Aussehen des Textes gleicht dabei, bis auf die Steuerzeichen, dem späteren Drucktext. Eine Veränderung des Textes ist zu diesem Zeitpunkt leider nicht möglich, es muß in den Editiermodus zurückgekehrt werden. Damit war der Einfallsreichtum der Programmierer aber bei weitem noch nicht erschöpft.

## Einmalige Sonderfunktionen

Vier weitere Besonderheiten trennen Homeword von einem Standard-Programm. Bereits während des Schreibens erhält der Anwender laufend Informationen über das spätere Aussehen seines Briefes. In der linken unteren Ecke des Bildschirms zeigt ein kleines Fenster in Seitenform die jeweilige Zeile und die Cursorposition an. Die Darstellung mußte aus Platzgründen zwar stark vereinfacht werden (für jeden Buchstaben ein Pixel), schmälert aber den Informationsgehalt nur unwesentlich. Diezweite Besonderheit ist die kontinuierliche Anzeige des verbleibenden Speicherplatzes in Form eines abnehmenden Balkens im Informationsfenster (Bild 2). Ganz neu ist auch die Art, wie Homeword bestimmte Druckerfunktionen anzeigt: Das Unterstreichen eines Textes oder der Fettdruck wird auf dem Bildschirm in Klarschrift vermerkt. Die letzte der besonderen Funktionen ist eine absolute Novität. Im Schreibmaschinenmodus wird jeder Text sofort auf dem Drucker ausgegeben. Der linke Rand kann dabei einfach eingestellt werden. Erstmals wird es dadurch möglich, kleinere Texte, Notizen oder Beschriftungen ohne großen Aufwand mit einem Matrixdrucker herzustellen. Von besonderen Reiz ist, daß die deutschen Umlaute sogar auf dem Commodore MPS 802 ausgegeben werden.

## Kaum Wünsche offen

Daß Homeword alle »klassischen« Funktionen eines Textverarbeitungsprogramms beherrscht, erscheint, angesichts des bisher gezeigten, schon fast selbstverständlich. Der Text kann in jeder beliebigen Form verändert werden. Linksoder rechtsbündiges Schreiben, ja sogar Blocksatz ist möglich. Verschieben, Einfügen, Kopieren, Suchen und Ersetzen sind nur einige Beispiele der Editierfunktionen. Das Arbeiten mit der Diskette wird ebenso unterstützt, wie die Einstellung auf den jeweiligen Druckertyp (Bild 3). In Zusammenarbeit mit den verschiedensten Druckertypen wird die Flexibilität Homewords besonders deutlich. Die ASCII-Funktion, deren Bedienung schnell erlernt ist, gestattet es, beliebige Steuerzeichen zum Einstellen der Sonderfunktionen an den Drucker zu senden.

Auf das Einfügen, Verschieben oder Kopieren einzelner Textteile muß ebensowenig verzichtet werden, wie auf das Aneinanderketten oder Mischen einzelner Texte von Diskette. Verschiedene Sonderfunktionen, alle durch die CTRL-Taste eingeleitet, helfen bei schnellen Sprüngen durch den Text. Erfreulicherweise wird Homeword auch bei längeren Texten nur wenig langsamer.

Homeword ist zweifelsfrei eines der leistungsfähigsten Textverarbeitungsprogramme, die derzeit erhältlich sind. Bis auf die oben erwähnten langwierigen Diskettenzugriffe und den dadurch verursachten häufigen Diskettenwechsel ist Homeword bei einem Preis von 129 Mark ein echter Geheimtip. Besonders empfehlenswert ist es aber für den Anfänger, der mit den ausgezeichneten Handbüchern und der einfachen Bedienung sicherlich schon recht schnell erfolgreich Texte erstellen wird.

(Arnd Wängler/rg)

Info: Langenscheidt Verlag, Fachhandel
Preis 129 Mark

# Totl.Text – Flexibilität ist Trumpf

> Totl.Text unterscheidet sich von vielen anderen Textverarbeitungsprogrammen. So ist es in Basic geschrieben und läßt eigene Änderungen wie die Druckerparameter-Einstellung oder die Definition eigener Zeichen zu.

Textverarbeitungsprogramme werden in der Regel wegen des Geschwindigkeitsvorteils in Maschinensprache programmiert. Dadurch verwehren sie aber jeden schnellen und einfachen Eingriff in das Programm. Das ist besonders bitter, wenn ein sonst ausgezeichnetes Programm nur deshalb nicht verwendet werden kann, weil zum Beispiel der eigene Drucker durch die Parametereinstellung nicht richtig angesprochen wird.

## Neues Konzept

Totl.Text ist in Basic geschrieben und kann jederzeit an die besonderen Bedürfnisse des Anwenders angepaßt werden. Die Kenntnis der Programmiersprache Basic ist hierfür allerdings Voraussetzung.

Das gesamte Programm weist dadurch eine hohe Kompatibilität zu Erweiterungen für den C 64/VC 20 auf. So belegt zum Beispiel die Software einer 80-Zeichen-Karte meist denselben Speicherbereich wie ein in Maschinensprache geschriebenes Textverarbeitungsprogramm. Totl.Text belegt dagegen nur Speicherplatz im Basic-Bereich. Zu Überschneidungen mit Erweiterungen, die Maschinensprache-Software benötigen, kommt es hier also nicht.

## Deutsches Handbuch vorhanden

Ausgeliefert wird das Programm sowohl für den VC 20 als auch für den C 64. Zum Lieferumfang gehören ein deutsches Handbuch, eine englische Referenzkarte und eine Kassette/Diskette. Das Handbuch geht auf alle wesentlichen Teile des Programms, der Bedienungund der Umprogrammierung ein. Für den deutschen Anwender dürfte wahrscheinlich eine der ersten Arbeiten das Erstellen eines deutschen Zeichensatzes sein. Die Änderung erfolgt genau wie bei jedem anderen Basic-Programm. Leider hat diese Konzeption auch ihre Schattenseiten.

Als Basic-Programm kann es keine so hohe Verarbeitungsgeschwindigkeit wie ein Maschinenspracheprogramm erreichen. Auch ist der freie Textspeicher stark eingeschränkt. Er hat mit knapp 18000 Zeichen nur etwa die Hälfte des Textspeichers von zum Beispiel Vizawrite 64. Den Textspeicher sollte man aber nicht zu sehr füllen, denn durch seine Stringverwaltung verliert das Programm an Geschwindigkeit.

Eine Zusammenfassung der wichtigsten Funktionen zeigt die Tabelle. So können zum Beispiel grafische Zeichen verwendet oder mit verschiedener Farbe editiert werden. Ein Ausdruck kann entweder aus dem Hauptspeicher oder über die Tastatur erfolgen. Sogar eine Schnittstelle zum Datenverwaltungsprogramm der gleichen Reihe ist vorhanden. Adressen oder sonstige Daten aus der Datenbank werden so reibungslos in den Text übernommen.

Wegen der Preis/Leistungs-Relation wird Totl.Text wohl nur bei den Besitzern einer 80-Zeichen-Karte auf Interesse stoßen. Totl.Text kostet 189 Mark für den C 64 (nur Diskette) und 109 Mark für den VC 20 (nur Kassette).

(Arnd Wängler/rg)

# Vokabeltraining mit dem Computer

> Sprachtrainer sind reine Übungsprogramme. Einem Anfänger nutzen sie deshalb recht wenig. Sie sind mehr darauf angelegt, vorhandene Fremdsprachenkenntnisse zu vertiefen.

Vokabeln pauken ist bei Schülern eine gefürchtete Angelegenheit. Verzichtet man großzügig auf diese Fleißarbeit, bleibt man ziemlich sprachlos. Pädagogen bemühen sich deshalb seit langer Zeit, den Wortschatz auf spielerische Weise zu vermitteln. Der neueste Versuch ist das Lernen mit dem Computer. Doch manchmal weiß man gar nicht genau, ob das Spielen mit dem Computer zum Büffeln motiviert oder das ausgefeilte Trainingsprogramm. Etliche der Programme sind auf den Sprachunterricht in Schulen zugeschnitten. Sie kennen nur den Wortschatz, der in den entsprechenden Lehrbüchern vermittelt werden soll. Doch viele Lehrer fordern voh ihren Schülern ein erweitertes Vokabular. Deshalb sind Trainingsprogramme besser geeignet, deren Wortschatz man selbst erweitern kann.

### Wörter Rennen mit System

»Spielend« lernen soll man mit dem Programm »Wörter Rennen mit System« vom Lanaenscheidt Verlag. Vom Computer werden Themen aus dem Alltag, der Medizin oder dem Finanzbereich und eine Buchstabenanzahl zwischen drei und sieben vorgegeben. Zu diesem Themenbereich muß der Spieler englische Begriffe eingeben, wozu aber nur eine begrenzte Zeit zur Verfügung steht. Trifft man mit dem Begriff den Themenbereich und die vorgegebene Buchstabenanzahl, wird dem Spieler ein Punkt gutgeschrieben, und die Zeit wird verlängert. Trifft man nur den Themenbereich, so wird nur ein Punkt gezählt. Dieses Spiel kann mit bis zu vier Personen gespielt werden, wobei nach jeder Runde der Spieler wechselt.

Das Spiel »Wörter Rennen mit System« wird vielen Schülern Spaß machen. Ein großer Vorteil ist, daß man bei mehreren Spielern auch aus dem Wortschatz der Mitspieler lernt.

### Vokabeln greifen an

Dieses Spiel vom Langenscheidt Verlag zeichnet sich durch eine simple Spielidee und einfache Grafik aus (Bild 1). Unter Zeitdruck muß der Spieler aus vier vorgegebenen Übersetzungen die richtige heraussuchen. Hierbei bewegt sich die Vokabel vom linken Bildschirmrand auf den rechten zu, wo der vorher eingegebene Name des Spielers steht. Am Ende bekommt man eine Punktewertung entsprechend der Anzahl der gewußten Vokabeln.

Bei diesem Spiel kann man wohl kaum von einem Vokabel-Trainingsprogramm sprechen, denn der Lernerfolg kann bei dieser Form der Abfrage doch sehr stark bezweifelt werden.

### Englische Grammatik<br>Französische Grammatik

Diese beiden Programme sind vom Aufbau identisch. Die Vokabeln sind nach Kategorien, wie zum Beispiel den Artikeln oder Substantiven, aufgeteilt und werden immer im Satzzusammenhang abgefragt. Besonders hervorzuheben ist bei diesem Programm, daß der Schüler einen Fehler einmal ohne Punktverlust verbessern darf. Erst beim zweiten Fehlversuch wird der Fehler angerechnet.

Wie auch in den anderen Lernsoftware-Programmen des Westermann Verlages taucht auch hier der Löwe auf dem Bildschirm auf (Bild 2). Falsch übersetzte Vokabeln quittiert er mit einem Knurren, richtige Antworten werden durch ihn belohnt. Besonders jüngere Schüler dürften hierdurch angespornt werden.

### Vokabel-Trainer

Dieses Programm von Hagemann (Bild 3) kennt den Wortschatz des Englisch-Lehrbuches »G2«. Auch hier handelt es sich um ein reines Abfrage-Programm, bei dem einzelne Vokabeln und kleine Redewendungen geübt werden. Die Abfrage erfolgt von Deutsch nach Englisch und umgekehrt.

### Wortschatz-Trainer Roma 1 und 2

Das lateinische Vokabular des »Wortschatz-Trainers« (Bild 4) ist auf die Lehrbücher »Roma 1« und »Roma 2« ausgelegt. Der Wortschatz darf jedoch mit eigenen Vokabeln erweitert werden. Hierbei kann die Übersetzung mit den deutschen Umlauten eingegeben werden, da die Tastaturbelegung des C 64 geändert wurde. Werden eigene Vokabeln eingegeben, zeigt der Computer den jeweils noch zur Verfügung stehenden Speicherplatz an.

Bei der Abfrage von Vokabeln benutzt das Programm das »Zettelkasten-System«. Das bedeutet, daß bekannte Vokabeln weniger häufig abgefragt werden, als Vokabeln, bei denen man Fehler gemacht hat.

Nach Beendigung einer Übung vergibt das Programm Noten von eins bis sechs, die in etwa den Schulnoten entsprechen sollen.

Der »Wortschatz-Trainer« von Markt&Technik kann als gelungenes Beispiel für ein unterrichtsbegleitendes Werkzeug gelten.

### Take it easy

Dieses Lernprogramm vom Max Hueber Verlag soll nach der Beschreibung den Lernenden in die Lage versetzen, sich an einfachen Gesprächen in Englisch zu beteiligen. Doch auch bei diesem Programm handelt es sich nur um ein Vokabel-Training.

Das Programm verfügt über einen fest vorgegebenen Wortschatz von 2500 Vokabeln. Die Übersetzung kann von Deutsch nach Englisch oder umgekehrt verlaufen. Nach jeder Übung bekommt man eine in Prozent angegebene Wertung. Das Programm »Take it easy« verfügt über die deutschen Umlaute, die über die Commodore-Taste und die Vokale zu erreichen sind.

### In Europa unterwegs

Von demselben Hersteller wie »Take it easy« ist auch dieses Programm. »In Europa unterwegs« behandelt gleich vier Sprachen. Es soll den Reiselustigen einen Grundwortschatz in Englisch, Französisch, Italienisch und Spanisch vermitteln. Diese Zielsetzung erfüllt das Programm auf keinen Fall. Denn wie soll man eine Sprache erlernen, wenn man wie hier nur das Schriftbild vor sich hat und nichts über die Aussprache mitgeteilt bekommt? »In Europa unterwegs« dürfte sich nur für diejenigen lohnen, die in diesen Sprachen Grundkenntnisse besitzen und sie für eine Reise wieder auffrischen wollen.

Als Fazit ist generell wohl eine gehörige Portion Skepsis gegenüber diesen Vokabel-Lernprogrammen angebracht. Jeder mäßige Basic-Programmierer ist in der Lage, ein Vokabel-Abfrageprogramm selbst zu schreiben, und sei’s auch ohne brüllenden Löwen. Mit Preisen bis zu 89 Mark ist die angebotene Software daher um einiges zu teuer.

(rg)

# 22 ReadError - Theorie und Praxis

> Ein Programm läßt sich wirkungsvoll vor dem Kopieren schützen, indem man einen Sektor zerstört und in diesem Bereich wichtige Daten unterbringt.

Bei Software, die auf Diskette gespeichert wird, dominiert eine Methode des Programmschutzes mit folgendem Prinzip:

Auf der Diskette mit diesem Programm ist ein Block mit Absicht zerstört worden. Wird jetzt dieses Programm geladen und gestartet, so wird vom Programm dieser fehlerhafte Block mit einem Direktzugriffsbefehl auf die Diskette abgefragt. Ist der Fehler vorhanden (was sich meist durch Blinken der Floppy-LED und Rattern des Schrittmotors äußert), so wird dies vom Programm erkannt. Es »merkt« dadurch sozusagen, daß »es« ein Original ist. Diese Methode funktioniert natürlich nur so lange, wie es nicht möglich ist, diesen fehlerhaften Block mitzukopieren. Bei älteren Kopierprogrammen ist dies nicht möglich. In letzter Zeit jedoch gibt es Kopierprogramme, die auf das Kopieren solcher Blöcke vorbereitet sind, indem sie die zerstörten Blöcke (in Form von Lesefehlern) erkennen und auf die Kopie »raufzaubern«. Bei dieser Prozedur wird aber in den meisten Fällen der Inhalt dieser Blöcke zerstört (auch zerstörte Blöcke können einen Inhalt haben).

Und hier zeigt sich ein Ansatzpunkt: Man müßte in diesen zerstörten Blöcken Daten unterbringen, die vom Originalprogramm gelesen werden können, von einer Kopie jedoch nicht. Das heißt, man macht sich den Effekt zunutze, daß diese zerstörten Blöcke durch das DOS nicht korrekt kopiert werden können. Wie aber kann man das DOS trotzdem dazu bringen, einen zerstörten Block kurzzeitig wieder lesbar zu machen?

Diese Frage läßt sich nur nach intensivem Studium des DOS der C 1541 beantworten. Nur wenn die Zusammenhänge und der Aufbau dieses Operations-Systems klar sind, kann auf eine solche Frage eine befriedigende Antwort gefunden werden. Der Autor fand folgende Lösung: In dem Bild ist der interne Aufbau eines Diskettenblocks dargestellt. Für uns ist die Konstante zum Beginn des Datenblocks ($07) wichtig. Das DOS braucht diese Konstante zur Erkennung des Anfangs eines Datenblocks. Sollte diese Konstante einen anderen Wert erhalten, so kann das DOS diesen Block nicht mehr lesen, das heißt er ist zerstört. Der Vergleichswert für diese Konstante liegt in der Zero-Page der Floppy (das heißt im RAM) und kann also geändert werden.

Man hat also durch Manipulation dieses Vergleichswertes die Möglichkeit, einen Block zu zerstören oder zu reparieren. Stellen Sie sich einmal folgendes vor:

1. Sie lesen einen Diskettenblock ein mit dem »U1: ...«-Befehl der Floppy.
2. Sie ändern den Vergleichswert für die Konstante $07 in der Zero-Page in irgend eine Zahl zwischen 0 und 255 außer 7.
3. Sie schreiben den Block auf die Diskette zurück, mit dem USR-Befehl »U2: ...«und
4. Sie setzen den Vergleichswert in der Zero-Page auf 7 zurück.

Sie haben jetzt folgendes gemacht: In dem Diskettenblock, den Sie eingelesen haben, stand bisher die Konstante $07. Dann haben Sie den Vergleichswert für die Konstante geändert, den Block wieder auf die Diskette geschrieben (wobei die geänderte Konstante auf die Diskette geschrieben wurde) und den Vergleichswert wieder auf den Normalwert gesetzt. Im Endeffekt haben Sie also auf der Diskette eine andere Konstante stehen, als in der Vergleichs-Speicherzelle der Floppy-Zero-Page. Versuchen Sie jetzt, diesen Block zu lesen, so werden Sie merken, daß das Laufwerk nur Spot- und Blinkeffekte hervorbringt. Mit anderen Worten: Sie haben diesen Block zerstört, und zwar mit dem Fehler Nummer 22, der das Fehlen eines Datenblockheaders anzeigt.

Dieser Diskettenfehler könnte jetzt wie oben beschrieben von dem zu schützenden Programm abgefragt werden.

Einigen Lesern wird wahrscheinlich jetzt schon klar sein, was passiert, wenn wir nun den Vergleichswert in der Floppy-Zero-Page auf den Wert setzen, den wir vorhin auf die Diskette geschrieben haben. Wir gehen also jetzt wie folgt vor:

1. Vergleichswert in der Floppy-Zero-Page auf den Wert setzen, mit dem der Block vorhin auf die Diskette zurückgeschrieben wurde.
2. Den Block mit dem »U1: ...«-Befehl einlesen und eventuell auch mittels »GET #« in den Computer holen.
3. Den Vergleichswert wieder auf den Standard-Wert $07 setzen.

Wir haben den zerstörten Block kurzfristig lesbar gemacht, indem wir der Floppy einen anderen Vergleichswert untergejubelt haben, als der Standard-Wert. Somit »denkt« die Floppy beim Einlesen des Blocks, es sei alles in Ordnung. Nachdem der Block dann weiterverarbeitet wurde, haben wir den Vergleichswert für die Konstante wieder auf den normalen Wert gesetzt. Der fragliche Block gilt jetzt also wieder als zerstört.

Wichtig dabei ist, daß nach wie vor die 256 Bytes Inhalt des Blocks unverändert vorliegen, das heißt durch die »Zerstörung« des Blocks wurde an seinem Inhalt nichts geändert.

Das ist der Grundgedanke dieser Erweiterung bekannter Methoden zum Schützen von Software. Dieses Prinzip läßt sich jetzt vielfach variieren:

- Das zu schützende Programm könnte beispielsweise (das heißt ohne Verkettungsadressen auf den nächsten Block) abgespeichert und die davon belegten Blöcke zerstört werden. Von einem Vorprogramm aus werden dann die Blöcke einzeln restauriert, eingelesen und wieder zerstört (aus Sicherheitsgründen).
- Man könnte für jeden Block verschiedene Konstanten benutzen, die sich nach einem Algorithmus errechnen lassen (zum Beispiel Spur, EXOR, Sektor).

Eines muß hier ganz deutlich gesagt werden: Es hängt nur von der Programmierfähigkeit des »Schützers« ab, wie wirksam der Schutz ist. Die hier vorgestellte Methode liefert eben doch nur das Prinzip.

Noch ein Hinweis: Ein Programmschutz kann nur dann wirksam sein, wenn es keine Möglichkeit gibt, das Programm nach dem Ladevorgang einfach abzubrechen und abzuspeichern. Versuchen Sie daher, Ihre Lade- beziehungsweise Vorprogramme so zu schützen, daß sie möglichst keine Art der Einsicht erlauben. Bewährt hat sich in diesem Zusammenhang compiliertes Basic. Schreiben Sie also Ihre Ladeprogramme ruhig m Basic und compilieren Sie sie dann oder lassen sie compilieren.

Das Programm »Son of Destroyer« soll den Einstieg in diese Technik des Programmschutzes erleichtern und dessen Arbeitsweise verdeutlichen. Es ist gewissermaßen ein Programm zum Experimentieren und Sammeln von Erfahrungen. Es bietet folgendes: Man kann eine Diskette zerstören und wieder restaurieren, wobei die Bereiche der Diskette, die behandelt werden sollen, grafisch auf dem Bildschirm dargestellt werden können. Dazu bietet »Son of Destroyer« folgende Kommandos:
F1: Block als belegt kennzeichnen
F3: Block als frei kennzeichnen
F5: Spur als belegt kennzeichnen
F7: Spur als frei kennzeichnen
F2: Die als belegt gekennzeichneten Blöcke einer Diskette zerstören
F4: Die als belegt gekennzeichneten Blöcke einer Diskette restaurieren
»*«: Bricht die Funktionen F2 und F4 vorzeitig ab.
»h«: Zeigt die Befehlsliste an. Die Belegung einzelner Blöcke auf dem Bildschirm geht dabei verloren!
»s«: Speichert das Arbeitsfeld auf die Diskette, die sich momentan im aktuellen Laufwerk befindet.
»l«: Lädt das Arbeitsfeld.
F8: Beendet das Programm.

Das Programm fragt Sie nach der Gerätenummer der aktuellen Floppy und nach der Konstante, die Sie als neuen Wert auf dem Header der Blöcke stehen haben wollen, die Sie zerstören. Danach sehen Sie das Arbeitsfeld vor sich und links unten blinkt ein Cursor. Diesen Cursor können Sie jetzt wie gewohnt mit den Cursor-Steuertasten bewegen. Wenn Sie auf dem Block oder der Spur angelangt sind, die zerstört (oder restauriert) werden sollen, dann drücken Sie Fl zum Belegen dieses Blockes oder F5 zum Belegen der ganzen Spur. Das Rücksetzen geschieht analog dazu mit F3 beziehungsweise F7.

Danach können Sie mit F2 beziehungsweise F4 die als belegt gekennzeichneten Blöcke der im Laufwerk befindlichen Diskette zerstören beziehungsweise restaurieren.

Die beiden letztgenannten Funktionen können durch Druck auf die »*«-Taste vorzeitig beendet werden.

Mit »s« oder »l« kann das momentane Arbeitsfeld auf Diskette gespeichert beziehungsweise von Diskette geladen werden.

Mit »h« ist es Ihnen jederzeit möglich, sich eine Kommandoübersicht zu verschaffen, wobei allerdings das Arbeitsfeld gelöscht wird. Mit F8 schließlich beenden Sie das Programm.

Sie müssen beim Zerstören beziehungsweise Restaurieren der Diskette nur auf zwei Dinge achten:

1. Die Konstante, die Sie eingeben, muß beim Zerstören dieselbe sein wie beim Restaurieren und
2. Sie müssen beim Zerstören und Restaurieren immer dieselben Blöcke als belegt kennzeichnen.

Bleibt noch, Ihnen beim Erproben dieser Methode viel Spaß und Erfolg zu wünschen. Auch wenn’s beim ersten Mal nicht klappt: Bleiben Sie am Ball. Es lohnt sich!

(Andreas Wurf/rg)

# Guncho Krill – Enchanter ist gelöst!

> Ein spannender Moment Ich stehe gerade dem bösen Krill gegenüber. Bin ich ihm überiegen?

Doch keine Zeit zum Nachdenken, denn schon ruft er einen U Drachen herbei, dessen Feuer ich gerade noch mit einem Zauberspruch in harmloses Wasser verwandeln kann. Noch ein gemeiner Zauberspruch von Krill folgt, doch ich war schneller! Bevor ich vor Erschöpfung zusammenbreche, versetze ich den Bösen in eine andere Dimension des Daseins. Zerschlagen lehne ich mich zurück: Enchanter ist gelöst.

Enchanter ist ein Abenteuerspiel aus der Serie der Infocom-Adventures, die wohl zu den besten Textabenteuer-Spielen zählen, die es derzeit gibt (Wortschatz: zirka 800 Wörter, Eingabe: ganze englische Sätze, Umfang sehr groß, Lösung: sehr logisch, besonders für intelligente und ausdauernde Spieler geeignet).

Wie schon bei »Blade of Blackpool« (Ausgabe 10/84) gesagt, liegt die eigentliche Spannung eines Abenteuerspiels darin, die Lösung selbst zu erarbeiten. Im Gegensatz zu Blade of Blackpool ist jedoch bei Enchanter jeder Lösungsschritt völlig logisch — man muß nur erstmal darauf kommen. Außerdem ist noch zu erwähnen, daß Enchanter sehr umfangreich ist. Das ist auch der Grund, warum wir drei Monate zur Lösung des Rätsels benötigten. Auf eine Hilfsliste mit Lösungstips haben wir diesmal ganz bewußt verzichtet, die Liste der Zaubersprüche dürfte ausreichen.

Bevor Sie jedoch nach der Schritt-für-Schritt-Lösung vorgehen und sich selbst dadurch den Spiel-Spaß verderben, sollten Sie erst versuchen, das Spiel selbst zu lösen. Schaffen Sie es nicht, dann sehen Sie erstmal nur auf die Landkarte und die Liste mit den Zaubersprüchen — vielleicht lichtet sich dann das Enchanter-Dunkel in den kleinen grauen Zellen. Benützen Sie Ihre Zaubersprüche, wo immer es logisch erscheint. Ein weiterer wichtiger Hinweis: Gehen Sie sparsam mit Ihren Getränken und Nahrungsmitteln um. Erst dann, wenn der Satz »Your are beginning to feel faint from lack ofwater/sustenance« erscheint, sollten Sie etwas trinken oder essen.

(Tom Pither/H. u. M. Kohlen/rg)

SE, SE, NE, S, READ SCROLL, GNUSTO REZROV, LEARN REZROV, SW, NW, NW, NE, N ,OPEN OVEN, GET BREAD, GET JUG, S, NE ,SE, NE, FILL JUG, SW, SE, E, E, REZROV GATE, E, FROTZ BOOK, N, N, E, E, E, E, E, LEARN REZROV, REZROV GATE, N, (GET SCROLL, READ IT), GNUSTO KREBF, E, LOOK UNDER LILY PAD, READ SCROLL, GNUSTO CLEESH, W, S, W, W, W, W, W, S, S, S, S, E, D, OPEN DOOR, N, PULL BLOCK, E, (GET SCROLL, READ IT), GNUSTO EXEX, W, S, U, DROP BOOK, E, GET LIGHTED PORTRAIT, GET SCROLL, W, GET BOOK, READ SCROLL, GNUSTO OZMOO, EAT BREAD, N, GET BOX, S, W, U, GET IN BED, SLEEP, GET UP, EXAMINE BEDPOST, PUSH BUTTON, (GET SCROLL, READ IT), GNUSTO VAXUM, D, N, N, N, N, U, GET EGG, LEARN REZROV, LEARN KREBF, REZROV EGG, GET SCROLL, KREBF SCROLL, READ SCROLL, GNUSTO ZIFMIA, D S, S, S, S, E, E, E, S, LEARN NITFOL, LEARN EXEX, EXEX TURTLE, NITFOL TURTLE, (TURTLE, FOLLOW ME), NW, N, E, U, (TURTLE, SE GET SCROLL, NW, DROP SCROLL, (TURTLE, THANKS), GET SCROLL, D, W, W, W, N, N, E, LEARN OZMOO, OZMOO ME, DROP ALL, E, WAIT, D, W, GET ALL, CUT ROPE, OPEN BOX, GET VELLUM SCROLL, READ VELLUM SCROLL, GNUSTO MELBOR, DROP BOX, LEARN MELBOR, MELBOR ME, E, E, E, N, EXAMINE TRACKS, READ FRAYED SCROLL, GNUSTO GONDAR, N, SLEEP, LEARN ZIFMIA, LEARN VAXUM, UETZT IN DEN SPIEGELSÄLEN AUF UND AB GEHEN BIS DER ADVENTURER ERSCHEINT, DANN...), ZIFMIA ADVENTURER, VAXUM ADVENTURER, UETZT NACH OSTEN BIS ZUR GUARDED DOOR), POINT AT DOOR, LEARN CLEESH, CLEESH ADVENTURER, N, DROP DAGGER, GET PENCIL, GET PURPLE SCROLL, S, W, W, W, W, W, W, S, S, S, S, E, D, D, READ MAP, D, S, E, NE, SE, LEARN MELBOR, MELBOR ME, DRAW FROM F TO P, SW, SW, RUB FROM V TO M, RUB FROM B TO R, DRAW FROM J TO B, DROP PENCIL, DROP MAP, GET SCROLL, NE, NW, NW, W, DRINK WATER, DROP JUG, U, U, E, E, E, W, N, N, LEARN MELBOR, MELBOR ME, N, E, LEARN GONDAR, LEARN CLEESH, DROP BREAD, DROP, PURPLE SCROLL, E, KULCAD STAIR, IZYUK ME, E, GONDAR DRAGON, CLEESH MONSTER, GUNCHO KRILL !!!!!!
TODO Bild 2. Die Schritt-für-Schritt-Lösung

# Taktik- und Strategiespiele

> Strategie- und Taktikspiele sind in Deutschland nur wenig verbreitet.

Teilweise sind die Kriegsschauplätze und die Voraussetzungen recht makaber, denn die Amerikaner arbeiten immer noch den Zweiten Weltkrieg auf oder entfesseln wenigstens einen neuen Krieg in Europa.

Strategie- oder auch Taktikspiel ist ein sehr umfassender Begriff. Wir behandeln hier die Spiele, die sich auf die Diplomatie und den Streit zwischen verschiedenen Mächten beziehen. Für viele sind das einfach »Kriegsspiele«. Das sind sie auch. Doch nicht nur. Denn viele fördern stärker diplomatisches Geschick als Lust am Kampfgetümmel (zum Beispiel »Geopolitique 1990«),

Hier soll auch nicht über das Für und Wider von solchen Kriegsspielen diskutiert werden; Strategiespiele sind so lange gut, wie sie nicht wirklich ernstgenommen werden. Sie sollten auf alle Fälle nicht zur Verherrlichung von Kriegen beitragen. Denn der Ernstfall hat mit dem, was sich im Computer abspielt, wirklich nichts zu tun.

Strategiespiele — und im strengen Sinne gehört dazu auch das klassische Schachspiel — haben durchaus positive Ansätze. Sie fördern das logische Denken, und in gewissem Maße die Kreativität.

## Entwicklung und Formen der Strategiespiele

Viele von Ihnen werden sich schon gefragt haben, woher überhaupt die Computer-Strategiespiele wie »Nato Commander« oder »Operation Whirlwind« kommen. Das ganze fing — wie soU’s auch anders sein — ohne Computer an. Bereits im frühen 15Jahrhundert planten die Feldherren ihre Schlachten auf miniaturisierten Landschaftsmodellen vor. Bei diesen »Sandkastenspielen« wurden Zinnfiguren und kleine Modelle von Kanonen und Burgen gesetzt, um Schlachten zu planen oder nachzuvollziehen.

Aus solchen Miniaturisierungen entwickelten sich die ersten Taktikspiele, die damals allerdings zuerst den Fürstenhöfen vorbehalten waren. Schließlich konnte sich nicht jeder Zinnfiguren und ganze Landschaftsmodelle leisten. Im Lauf der Zeit entwickelten sich billigere Formen (zum Beispiel mit Holzfiguren), die vielleicht auch schon unsere Ururgroßväter im 19. Jahrhundert begeistert spielten.

Die Begeisterung nahm durch den Ersten und Zweiten Weltkrieg ab — kein Wunder, denn Krieg ist genug Grund, keine Kriegsspiele zu spielen.

Erst in den 50er Jahren kam die Spielart des Taktikspiels wieder auf. In den USA entwickelte sich das zu einem Boom, der ein paar Jahre später auch nach England überschwappte. Die restliche Welt hatte an dieser Entwicklung auf dem Spielemarkt nur sehr geringen Anteil. Die Spiele, die damals groß in Mode kamen, unterschieden sich teilweise grundlegend von der Art der Strategiespiele, die noch 50 bis 100 Jahre vorher gespielt wurden. Aus den kunstvollen Schlachtenminiaturen entwickelten sich verschiedene Formen, von denen sich die sogenannten Tabletops durchsetzten. Diese Version erforderte bei weitem weniger Aufwand als die klassischen Taktikspiele, da man die nötigen Materialien selbst herstellen konnte: ein bißchen Karton, etwas Begabung und ein einigermaßen gut durchdachtes Regelwerk. Auf den Karton wurden Landschaften, Gebirge, Städte etc. gemalt. Die so gemalten Kriegsschauplätze wurden in Hexagons (Sechsecke) unterteilt. Diese Spiele wurden dann schließlich auch verkauft, mit »Scenarios« (vorgefertigten Aufgaben), fertigen Spielbrettern mit aufgedruckten Landschaftszügen und mit sogenannten »Counters«. Counters sind quadratische Pappkartons mit ungefähr einem Quadratzentimeter Fläche, auf die Symbole für Soldaten, Panzer, Artillerie und andere Kriegsgefährte aufgedruckt sind. Die typischen Kampfeigenschaften der dargestellten Kampfeinheiten muß man dann dem Regelwerk entnehmen. Für den professionellen Vertrieb wurden also die Landschaftsmodelle durch Karton-Landschaften, die Zinnfiguren durch Counters ersetzt. Diese Tatsache machte das Taktikspiel billig und für die breite Öffentlichkeit zugänglich.

Eine luxuriösere Art der Tabletops ersetzt die Counters durch Zinnquadrate (Größe etwa zwei mal zwei Zentimeter) mit eingravierten und bemalten Formen.

Obwohl sich die Tabletops durchsetzten, wird die klassische Form des Strategiespiels noch immer gespielt: ganze Burgen und Landschaften werden als Modelle aufgebaut und Zinnfiguren entsprechend den Spielregeln hineingesetzt.

Doch nun zu den Computern: Populär wurde diese Computerspielart in den späten 70erJahren, als die Heimcomputer auf den Markt kamen. Einzelne Firmen spezialisierten sich auf die Programmierung von Taktikspielen auf Home- und Personal Computern. Wie es nach dem Durchbruch der Tabletops auch nicht anders zu erwarten war, sind die meisten Computerumsetzungen der Taktikspiele direkte Nachfahren der Tabletops.

## Arten der Strategiespiele

Taktikspiele unterteilt man allgemein in drei große Gruppen: Historische, Science-Fiction- und Fantasy-Strategiespiele.

### Historische Strategiespiele:

Die geschichtlich orientierten Taktikspiele werden am meisten gespielt. Die Themengebiete reichen von Caesars Gallischem Krieg, Alexander dem Großen und seinen Eroberungen bis hin zu Napoleons Feldzügen. Im Vordergrund stehen jedoch der Erste und Zweite Weltkrieg. Zum Beispiel das Spiel »Battle for Normandy«, das in Computerform und als Tabletop-Spiel angeboten wird. »Squadleader« behandelt gleich den gesamten Zweiten Weltkrieg, es liegt jedoch nicht als Computerspiel vor. Squadleader ist das komplexeste Spiel seiner Art und wird auf Taktik-Ebene gespielt (Unterschied zwischen Taktik- und Strategie-Ebene siehe später). Das Spiel gibt es in einem mehrteiligen Set zu kaufen. In den USA werden sogar schon große Squadleader-Turniere ausgetragen.

### Science-Fiction-Strategiespiele:

In diesen Spielen geht es um diplomatische Verhandlungen und Kriege, wie sie in Science-Fiction-Romanen beschrieben werden. So basiert beispielsweise das Spiel »Forever-War« auf dem Roman »Der ewige Krieg« von Joe Haldeman (eine Satire auf den Krieg im Weltall). Andere Beispiele sind: Dune (Der Wüstenplanet) und Titan. Beispiel auf Computer: The Cosmic Balance (dieses Spiel gibt es bisher nur für Apple und Atari, soll aber im Herbst in einer C 64-Version auf den Markt kommen).

### Fantasy-Strategiespiele:

Diese Art des Taktikspiels ist die am wenigsten verbreitete, aber zugleich die interessanteste. Hier geht es beispielsweise um eine Schlacht zwischen 1000 Centauren und 200 Einhörnern. Bei diesem Streit kommt auch eine kräftige Portion Magie mit ins Spiel. Beispiel: Armageddon ist das in Deutschland bekannteste Fantasy-Strategiespiel und enthält Elemente aus Fantasy-Rollenspielen. Auf diesem Spiel beruht sogar eine ganze Romanreihe von Hugh Walker, die in der Fantasiewelt Magira spielt, und nach Regeln und möglichen Ereignissen des Strategiespiels Armageddon aufgebaut wurde. Ein weiteres Beispiel für Fantasy-Strategie wäre Warhammer von der Zinnfigurenfirma Citadel. Auf Computern (Commodore, Apple, Atari, IBM etc.) konnten wir bisher leider keine Fantasy-Strategiespiele ausfindig machen.

## Wie man Strategiespiele spieft

Viele von Ihnen werden sich schon gefragt haben, wie man Taktikspiele spielt. Natürlich können wir nicht auf die Spielregeln und Möglichkeiten aller Taktikspiele eingehen. Grundsätzlich besteht ein großer Unterschied zwischen den Spielen auf Taktik- und Strategie-Ebene. Taktik-Ebene bedeutet, daß man detaillierter arbeiten muß, das heißt, fastjeder einzelne Soldat muß kommandiert werden. Auf der Strategie-Ebene werden ganze Armeen geführt, um beispielsweise den Feind einzukreisen. Das Strategiespiel zieht sich also über einen längeren Zeitraum hinweg, das Taktikspiel dagegen pickt sich einen bestimmten Teil heraus, der dafür um so genauer behandelt wird.

Allgemein gibt es in Taktikspielen eine Angriffsphase und eine Bewegungsphase, die man auch noch in Zwischen- und Unterphasen einteilen kann.

In der Bewegungsphase werden die Counters (am Computer die den Counters entsprechenden Grafiksymbole) nach ihren entsprechenden Fähigkeiten bewegt. Ganze Stoßtrupps sind natürlich langsam und können nur ein Feld weiterbewegt werden, motorisierte Späher dagegen können bis zu fünf Hexagons pro Runde vorwärtsbewegt werden. Ebenso zur Bewegungsphase gehören der Bau einer Brücke oder die Kommunikation zwischen Einheiten.

Ist die Bewegungsphase abgeschlossen, folgt die Angriffsphase. Die Treffgenauigkeit wird dabei ausgewürfelt oder (am Computer-Äquivalent) per Zufallszahl ermittelt. Den entsprechenden Schaden eines Treffers durch eine bestimmte Waffe holen sich dann die Spieler beziehungsweise der Computer aus Tabellen. Die Treffer wirken sich nicht nur auf die Geschwindigkeit und Kampfkraft der Truppen, sondern auch auf die Moral der Soldaten aus. Sehen wir uns nun zum besseren Verständnis der Spielgattung des Strategiespiels ein Beispiel an: Armageddon, das schon seit 1968 in einem deutschen Fantasyclub gespielt wird. Armageddon spielt in einer mittelalterlichen Welt mit magischen Kräften. Die in verhältnismäßig große Hexagons aufgeteilte Landschaft besteht aus verschiedenen Landschaftszügen: Gebirge, Hochland, Tiefland, Wälder, Steppe, Wüste, Dschungel, Wasser etc., die mit unterschiedlichen Geschwindigkeiten überwunden werden. Das Spiel wird sowohl mit 15mm-Zinnfiguren als auch mit Counters gespielt. Die Zinnfiguren beziehungsweise Counters stellen bestimmte Spielfigurentypen dar: Axtträger, Bogenschützen, Lanzenträger, Schwertträger, Zauberer, Helden sowie Belagerungstürme, Wehrtürme, Onager (= Rammbock) und so weiter. Jede dieser Spielfiguren hat Stärken und Schwächen. Unter den Spielern werden verschiedene Königreiche aufgeteilt, die dann diplomatisch miteinander verkehren oder das Kriegsbeil ausgraben.

Der Ausgang der Kämpfe richtet sich nach der Intelligenz des Spielers und nach bestimmten Regeln. Die »Politik« bleibt den Spielern selbst überlassen.

## Taktikspiele auf dem Computer

Strategiespiele auf dem Computer sind direkte Nachfahren der Tabletopspiele und werden auch m etwa so gespielt. Der Unterschied besteht darin, daß das Strategiespiel auf dem Computer wesentlich weniger Platz kostet und billiger ist.

Die meisten Strategiespiele auf dem Computer arbeiten ebenfalls mit dem Hexagon-System, nur wenige weichen von dieser klassischen Form ab. Wie bei den Taktikspielen ohne Computer wird auch hier nach dem Muster der Bewegungs- und Angriffsphase gearbeitet.

Den Markt für Heimcomputer-Strategiespiele beherrschen derzeit die amerikanischen Firmen SSI (Strategie Simulations Inc.) und die Avalon Hill Game Company, die sich bereits mit Strategiespielen auf dem Brett einen Namen machte. Auch so bekannte Firmen wie Broderbund und Microprose brachten schon Taktikspiele für den C 64 heraus.

Für diejenigen, die sich einmal mit Strategiespielen beschäftigen wollen, haben wir hier eine Liste von Taktikspielen für den C 64 zusammengestellt. Diese Liste erhebt keinerlei Anspruch auf Vollständigkeit und soll nur einen kurzen Überblick über das bestehende Angebot geben.

### Nato Commander

Die Story eines Krieges, wie ihn sich zumindest die Amerikaner vorstellen. Arbeiter in Wittenberg streiken und viele Menschen flüchten über die Grenze in den Westen. Die DDR-Regierung in Ost-Berlin beschuldigt die Bundesregierung, die streikenden Arbeiter mit Nahrungsmitteln und Waffen zu versorgen. Daraufhin droht die UdSSR, die Arbeiterrevolte mit Waffengewalt niederzuschlagen - und schon haben wir den Dritten Weltkrieg. Sie, der »Nato Commander«, müssen nun Ihre Streitkräfte gegen den Warschauer Pakt führen. Solidaritätsstreik der polnischen Arbeiter oder Nachrichtensendungen über die Verurteilung des Einmarsches der UdSSR in die DDR durch die westlichen kommunistischen Parteien sind im Spiel eingeplant. Ein interessantes und zugleich erschreckendes Spiel.

### Geopolitique 1990

Ein Spiel, bei dem die Diplomatie wichtiger ist als der Krieg: Sie müssen versuchen, als US-Regierung wirtschaftliche, politische und ökonomische Vormacht zu gewinnen. Der Computer übernimmt dabei die Rolle der UdSSR. Erst, wenn alle Verhandlungen scheitern oder Sie die »falschen« Gebiete als Interessenzonen erklären, wird Geopolitique zu einem kriegerischen Strategiespiel. Die Anleitung ist allerdings sehr unübersichtlich.

### Knights of the Desert

In diesem Strategiespiel geht es um den Wüstenkrieg 1941-42. Als »Wüstenfuchs« Rommel können Sie die Geschichte verändern.

### Battle for Normandy

Es ist »D-Day«. Sie leiten die Alliierten- ^^^^ Invasion in der Normandie.

### Combat Leader

Eines der besten Taktikspiele, die es für den C 64 gibt. Die Bewegungsabläufe werden nicht durch Vorrücken von Symbolen auf Hexagons dargestellt, sondern man sieht, wie die Panzer durch die Landschaft fahren. Der einzige Nachteil: Durch die schlechte Farbwahl wird der Bildschirmaufbau etwas unübersichtlich.

### Operation Whirlwind

Sie sollen eine feindliche Stadt erobern, dann den Gegenangriff abwehren und schließlich gewinnen. Bemerkenswert an diesem Spiel ist die relativ einfache Bedienung.

### Tigers in the Snow

Die Machart dieses Spiels entspricht Knights of the Desert und Battle for Normandy. Hier handelt es sich allerdings um die Ardennenoffensive.

### Tac

Hier haben die Spieler direkten Feindkontakt. Jeder einzelne Panzer (in ziemlich großem Maßstab dargestellt) muß wie bei Combat Leader kommandiert werden.

### Computer Ambush

Ein Taktikspiel, bei dem fast ausschließlich Mann gegen Mann gekämpft wird. Jeder der Soldaten hat seinen eigenen Namen und wird einzeln mit verschiedenen Waffen ausgestattet, die er auch während des Kampfes wechseln darf. Das Spiel kommt voraussichtlich Ende 1985 in einer C 64-Version auf den Markt.

### The Cosmic Balance

Dieses Spiel besteht aus zwei Teilen, die sich zwar einzeln spielen lassen, aber untereinander kompatibel sind. In Cosmic Balance müssen einzelne Galaxiezonen besetzt werden. CB I ist ein Spiel auf Taktik-Ebene, der zweite Teil wird auf Strategie-Ebene gespielt. Man kann also seine Strategie mit CB II ausführen und die einzelnen Schlachten darin mit dem ersten Teil entscheiden. Dieses Science-Fiction-Strategiespiel wird voraussichtlich im Herbst 85 für den C 64 vorgestellt.

Weitere Taktik- und Strategiespiele sind beispielsweise Germany 1985, RDF 85 und Baltic 85 aus der »When Superpowers collide«-Serie, das Actionspiel mit Strategie-Elementen Combat-Lynx und einige andere.

## Strategie- und Taktikspiel — noch ein Fremdwort

Taktikspiele sind in Deutschland recht selten zu finden, und das trotz des Trends von dummen Schießspielen hin zu Denkspielen.

In den USA und England gibt es mittlerweile große Turniere für Strategie-Spiele und sogar eigene Zeitschriften, zum Beispiel Strategics&Tactics.

Wer Interesse für Strategiespiele ohne Computer hat, sollte einmal die alljährlich stattfindenden Essener Spielertage besuchen.

Nachdem wir nun über Fantasy-Rollenspiele (64'er/9/84) und über Taktikspiele berichtet haben, werden wir natürlich auch weiterhin über interessante Spielarten schreiben. Wenn Sie noch mehr Ideen und Anregungen haben, dann senden Sie diese doch an die Redaktion.

(F. Wlodarczyk/T. Weidemann/ M. Kohlen/T. Pither/rg)

# Ohne Organisation kein Tor

> Ohne entsprechenden Verwaltungsaufwand findet auch in der untersten Liga kein Fußballspiel statt. Dieses Programm ist vor allem für die vielen ehrenamtlichen Hefier geschrieben, aber auch jeder Sportfan kann es sinnvoll einsetzen um zu sehen, wo »seine« Mannschaft steht.

In der ersten oder zweiten Bundesliga macht eigentlich nur das Wetter den Kickern zu schaffen. Entweder spielen sie im Regen, Schnee oder Nebel .. oder das Match wird nachgeholt. In diesen Klassen eine Tabelle aufzustellen ist einfach. Schwieriger wird es schon in den unteren Ligen und im Jugendbereich: Mannschaften werden plötzlich nachgemeldet oder zurückgezogen. Nachholspiele sind an der Tagesordnung. Mit Papier und Bleistift oder einem simplen Tabellenprogramm ist es hier nicht getan. Der ehrenamtliche Fußball-Funktionär Franz-Josef Heuser aus Aachen-Haaren schrieb schließlich das Programm »Ligatab«, das genau auf diese Problematik zugeschnitten ist. »Ich habe bewußt kein Programm geschrieben, um mit dem C 64 schneller zu sein, als die EDV-Anlagen der Fernsehanstalten. Mir ging es darum, den vielen ehrenamtlichen Helfern Zeit einzusparen«, erklärt der 34jährige Fußballfan. Eine Übertragung der Ligaverwaltung auf andere Sportarten ist nur dann sinnvoll, wenn die Tabellenplätze nach den gleichen Kriterien bewertet werden. Also: Pluspunkte, Minuspunkte, Tordifferenz, geschossene Tore, Gegentore. Auf alle Fälle sollten Sie die Anleitung beachten. Sie sparen später mit Sicherheit viel Zeit.

(rg)

TODO ASIDE
Franz-Josef Heuser ist 34 Jahre alt, verheiratet und hat zwei Kinder. Nach seiner Lehre als Technischer Zeichner im Heizungsbau, besuchte er die Fachschule für Technik in Essen. Heute arbeitet Franz-Josef Heuser als Technischer Sachbearbeiter in der projektbegleitenden Planung.
Bis Dezember 1984 war er als ehrenamtlicher Jugendleiter mit dem Trainerschein A bei dem Deutschen Jugend Kraft-Sportverein (DJK) der katholischen Kirche in seiner Freizeit tätig. Seit Beginn des Jahres betreut er die Jugend des Vereins als Geschäftsführer.

Sein Interesse an Computern erwachte 1983, als er erkannte, daß man nur mit entsprechenden Kenntnissen seinen Arbeitsplatz sichern kann. Der C 64 wurde dann im Januar 1984 angeschafft. Das Familienleben mußte unter dieser Anschaffung jedoch nicht leiden.

Die Idee zu dem Programm kam ihm bei seiner Arbeit im Verein. Spielpläne und Tabellen aufstellen und auswerten nimmt sehr viel Zeit in Anspruch, deshalb ist dies eine ideale Aufgabe für Computer. So entstand in einem halben Jahr Programmierarbeit das Programm »Ligatab«.

Als nächstes Projekt nimmt Franz-Josef Heuser die Vereinsverwaltung in Angriff. In Zukunft werden dann auch Bereiche wie die Mitgliederverwaltung mit dem Computer erledigt.

## »Ligatab«, die besondere Sportliga-Verwaltung

> Zu einem guten Programm benötigt man eine gute Beschreibung. Fast ein Handbuch ist es bei dem Programm »Ligatab«.

Im nachfolgenden wird nur auf die compilierte und mit Autostart versehene Form eingegangen. Die Original-Version in Standard-Basic des C 64 ist für die Anwendung zu langsam und aus Speicherplatzgründen nur mit bis zu 6 Ligen einsetzbar. Auf der Diskette zu dieser Ausgabe der 64’er ist sowohl die Basic-Version, als auch die compilierte Version des Programms »Ligatab« enthalten. Floppy und Drucker müssen während der Arbeit mit »Ligatab« eingeschaltet bleiben. Das Programm wird von Diskette geladen mit: LOAD "c/ligatab b1/a” ,8,1.

Nach kurzer Zeit wird der Bildschirm gelöscht und nach dem Ladevorgang sehen Sie das Titelbild. Hier geben Sie das Datum ein, das in erster Linie für die Druckerausgabe benötigt wird. Eingabeform: TT.MM.JJJJ (08.08.1985).

Nach korrekter Eingabe mit abschließendem RETURN erklingt, falls Sie die Lautstärke richtig eingestellt haben, ein Ton. Dieser Ton erklingt immer dann, wenn das Programm eine Eingabe von Ihnen erwartet, ohne daß der blinkende Cursor auf dem Bildschirm zu sehen ist.

Im unteren Balken verlangt das Programm eine Eingabebestätigung. Antworten Sie mit »N« für Nein, wird der Bildschirm gelöscht und das Titelbild erscheint erneut. Antworten Sie mit »J« für Ja, erscheint nach kurzer Zeit das Hauptmenü. Das Hauptmenü ist in vier Auswahlgruppen unterteilt.

Bildschirmausgabe	Auswahl	1,2,3
Druckerausgabe	Auswahl	4,5,6
Diskettenoperationen	Auswahl	7,8
Neue Liga/Programmende	Auswahl	9
TODO

Wenn Sie das erste Mal mit diesem Programm arbeiten, sollten Sie zuerst »Tips zur Vorbereitung« genau durchlesen. Des weiteren empfiehlt es sich, Ihre erste Liga als »Testliga« anzulegen, um die Möglichkeiten des Programms besser kennenzulernen und auszutesten.

## Erste Sportliga anlegen

Wie bei der Datenverwaltung ist die Ersteingabe auch in diesem Programm der arbeitsintensivste und wichtigste Teil. Deshalb sollten Sie an dieser Stelle ganz besonders sorgfältig arbeiten und auf mögliche Fehler achten.

Die Basis Ihrer Sportliga sind die Mannschaften. Das Programm benötigt zuerst die Namen und Anzahl der Mannschaften. Aus diesem Grunde wählen Sie im Menü »1 = MANNSCHAFTEN EINGEBEN/SICHTEN/KORRIGIEREN«. Nachdem der Bildschirm gelöscht wurde, werden Sie nach dem Namen der Liga gefragt. Dieser darf einschließlich Leerstellen nicht mehr als 16 Zeichen umfassen. Für die Testliga ein Vorschlag: »FVM 7 A-Ju. Nst. 5«. Dies würde bedeuten:
Fußball-Verband-Mittelrhein, Kreis 7 Aachen, A-Junioren, Normalstaffel 5. Die Eingabe muß mit RETURN abgeschlossen werden.

Nun werden Sie nach der Anzahl der Mannschaften gefragt. Sie können wählen zwischen minimal 3 und maximal 20 Mannschaften. Geben Sie eine Zahl >3 oder <20 ein, wird der Bildschirm gelöscht, und Sie müssen die Eingabe einschließlich Liganamen wiederholen. Der Liganame wird später auch Dateiname auf der Datendiskette sein. Haben Sie alles richtig eingegeben, fragt das Programm nach den Mannschaftsnamen. Abschließend müssen Sie die Richtigkeit der Eingaben bestätigen. Verneinen Sie hier mit »N«, werden Sie gefragt, ob ein Name oder die Anzahl der Mannschaften falsch sind. Sie können nun »N« für Name falsch oder »A« für Anzahl falsch eingeben. Bei Eingabe von »N« haben Sie die Möglichkeit zur Korrektur der Namen.

Auf die Möglichkeit nach Eingabe von »A« für Anzahl falsch wird unter »Besonderheiten« eingegangen.

Hatten Sie die Namen richtig eingegeben oder zwischenzeitlich korrigiert, so können Sie die Eingabe mit »J« bestätigen, worauf wieder das Hauptmenü auf dem Bildschirm erscheint.

Nachdem Sie nun die Eingaben bezüglich der Mannschaften abgeschlossen haben, benötigt der Computer weitere Informationen zu den Spieltagen. Hierzu wählen Sie im Hauptmenü »2 = SPIELTAGE -E-S-K-«. Sie sehen nun das Untermenü »SPIELTAGE -E-S-K-«, indem Sie »E« für »SPIELPLAN EINGEBEN« wählen. Auf die anderen Auswahlmöglichkeiten wird im Abschnitt »ARBEITEN MIT BESTEHENDEN SPORTLIGEN« eingegangen. Es kann nun das Datum aller Spieltage eingegeben werden. Stehen einzelne, alle oder von einer Gruppe (zum Beispiel der Rückserie) von Spieltagen noch nicht fest, so müssen Sie das entsprechende Datum einfach mit RETURN überschreiben.

Die Anzahl der Spieltage läßt sich rechnerisch aus der Mannschaftsanzahl wie folgt ableiten:
a) bei gerader Anzahl Mannschaften:
(Anzahl der Mannschaften * 2) — 2
b) bei ungerader Anzahl Mannschaften:
Anzahl der Mannschaften * 2

Diese Rechnung hat Ihr C 64 bereits durchgeführt, und Sie können das Ergebnis auf dem Bildschirm sehen.

Falls Sie die Daten von allen Spieltagen noch nicht kennen, bestätigen Sie die Abfrage »EINGABE OK« einfach mit »J« für Ja. Zum Eingeben verneinen Sie mit »N« für Nein. Sie können dann die Daten in der Form TT.MM.JJJJ eingeben. Nach erfolgter Eingabe und der Bestätigung mit »J« wird der Bildschirm gelöscht und Sie können die Spiele eingeben.

Auf dem neuen Bild auf dem Bildschirm erkennen Sie im oberen Teil die Mannschaftsnamen. Die Zahlen links davon sind die Mannschaftskennzahlen, für die im nachfolgenden die Abkürzung MKZ gebraucht wird. In dem unteren Teil werden die Spiele eingegeben. Sie brauchen hier aber nicht die Namen sondern nur die entsprechenden MKZ einzugeben.

Die Anzahl der Spiele je Spieltag läßt sich ebenfalls wie folgt aus der Anzahl der Mannschaften ableiten:
a) bei gerader Anzahl Mannschaften:
Anzahl der Mannschaften/2
b) bei ungerader Anzahl Mannschaften:
(Anzahl der Mannschaften -1)/2
Für nicht belegte Spiele geben Sie die MKZ »0« ein.

Nachdem Sie den ersten Spieltag eingegeben haben, können Sie die Richtigkeit der Eingaben mit »J« für Ja bestätigen oder mit »N« für Nein verneinen. Mit »N« können sie die Eingaben korrigieren, mit »J« den nächsten Spieltag eingeben. Des weiteren haben sie an dieser Stelle die Möglichkeit, mit »M« wieder zum Hauptmenü zu gelangen.

Der C 64 benötigt nur die Eingabe der Spieltage der Hinrunde. Die Rückrunde wird in Umkehrung der Hinrunde automatisch gesetzt.

Haben Sie alles richtig gemacht erscheint wieder das Untermenü.

Um sich nicht um den Lohn der Arbeit zu bringen, sollten Sie an dieser Stelle erst einmal ihre Daten in Sicherheit bringen. Dazu überprüfen Sie, ob das Floppy-Disk-Laufwerk eingeschaltet und die richtige Diskette im Laufwerk ist. Danach wählen Sie im Hauptmenü >>8=DATEN SPEICHERN AUF DISKETTE«.

## Arbeiten mit bestehenden Sportligen

Bei der ersten Liga, die Sie verwalten werden, wird davon ausgegangen, daß noch keine Änderungen, mit Ausnahme von Tippfehlern, zu bearbeiten sein werden. Alle möglichen Änderungen und Ergänzungen, die während der laufenden Saison auftreten und vom Programm verarbeitet werden können, sind im Abschnitt »BESONDERHEITEN« beschrieben.

### Programm laden von Diskette

Vor dem Laden sollten Sie NEW und CLR im Direktmodus eingeben, damit alle Speicherplätze im C 64 gelöscht werden. Zum Laden geben Sie
LOAD"c/ligatab b1/a",8,1 ein.

Nach Beendigung des Ladevorgangs erscheint das Titelbild auf dem Bildschirm. Sie geben das Datum in der Form TT.MM.JJJJ ein und bestätigen die Eingabe mit »J« für Ja. Sie sehen nach kurzer Zeit das Hauptmenü.

### Laden einer Liga von Diskette

Nun müssen Sie zuerst die richtige Datendiskette einlegen. Dann wählen Sie im Hauptmenü »7=DATEN LADEN VON DISKETTE« und geben danach den Liganamen ein. Achtung! Jetzt müssen Sie sehr sorgfältig sein, da eine Fehlermeldung wie zum Beispiel »FILE NOT FOUND«, verursacht durch einen nicht richtigen Liganamen, das Programm zum Absturz bringt. Es hilft dann nur noch ein Ausschalten des Computers und ein erneutes Laden vom Programm und Daten.

Haben Sie den Liganamen richtig eingegeben, bestätigen Sie die Abfrage »EINGABE OK« mit »J«. Wenn Sie nun sicher sind, daß die richtige Datendiskette im Laufwerk ist, drücken Sie RETURN. Verneinen Sie die Frage »EINGABE OK« mit »N« für Nein haben Sie die Möglichkeit, den Liganamen zu korrigieren. Des weiteren können Sie mit »M« aus diesem Teil des Programms zum Hauptmenü zurückkehren. Nach Beendigung des Ladevorgangs meldet sich das Programm automatisch wieder mit dem Hauptmenü.

## Bildschirmausgabe

Die ersten drei Auswahlmöglichkeiten im Hauptmenü beziehen sich auf die Bildschirmausgabe.

### 1 = Mannschaften -e-s-k-

Wenn Sie diesen Programmpunkt anwählen, sehen Sie die Mannschaftsnamen auf dem Bildschirm. Da Sie eventuelle Namensfehler bei der Ersteingabe korrigiert haben und alle weiteren Änderungsmöglichkeiten unter Abschnitt »BESONDERHEITEN« behandelt werden, können Sie die Frage »EINGABE OK« mit »J« für Ja beantworten, um zum Hauptmenü zu gelangen.

### 2 = SpieKage -e-s-k-

Nach Eintippen von »2« im Hauptmenü sehen Sie ein Untermenü mit den folgenden Auswahlmöglichkeiten:

e = Spielplan eingeben
s = Spiele sichten
Ergebnisse -e-s-k-
n = Nachholspiele -e-s-k-
m = Menü
TODO

Tippen Sie »s« für Spiele sichten beziehungsweise für Ergebnisse -e-s-k- ein.

Der C 64 fragt nun nach dem Spieltag, mit dem Sie beginnen möchten. Nachdem Sie nun die entsprechende Zahl eingegeben haben, sehen Sie ein neues Bild auf dem Bildschirm.

In der oberen Hälfte erkennen Sie die Mannschaftskennzahl (MKZ) und die Mannschaftsnamen. Dann folgt ein Balken, aus dem Sie die Spieltagsnummer erkennen können.

In der unteren Hälfte sind die Spielpaarungen zu sehen. Der untere Balken ist der Befehlsbalken, aus dem Sie die drei folgenden Eingabemöglichkeiten ableiten können:

1. M = Menü
2. K = Korrigieren
3. CRSR = Blättern

Mit »M« gelangen Sie wieder zum Hauptmenü, über »K« erfolgt die Ergebniseingabe beziehungsweise Korrektur und mit den Cursor-Tasten können Sie in den Spieltagen blättern.

Ergebniseingabe: Hierzu wählen Sie »K« und der Comptuer verlangt nun die Eingabe der Ergebnisse. Sie dürfen nun Zahlen eingeben bis einschließlich 499 sowie den Buchstaben »N« für Nachholspiele.

Auf die Verwaltung der Nachholspiele wird später eingegangen. Steht ein Ergebnis noch nicht fest, drücken Sie RETURN. Haben Sie die letzte Eingabe eines Spieltages mit RETURN abgeschlossen, erscheint der nächste Spieltag. Wollen Sie zu dem Spieltag zurück, bei dem Sie gerade eine Eingabe gemacht haben, drücken Sie CURSOR-RUNTER.

Blättern mit dem Cursor: Das Sichten aller Spieltage ist mi1 den Cursor-Tasten möglich. Sie haben hiermit eine komfortable Möglichkeit zum Blättern.

Mit CURSOR-RUNTER erscheint der vorherige Spieltag.
Mit CURSOR-HOCH erscheint der nächste Spieltag.
Mit CURSOR-RUNTER erscheint beim ersten wieder der letzte Spieltag.
Mit CURSOR-HOCH erscheint beim letzten wieder der erste Spieltag.

### 3 = Tabellen

Wählen Sie diesen Punkt mit »3« im Hauptmenü an, fragt der Computer, bis zu welchem Spieltag er die Tabelle errechnen soll. Sie können nun zwischen 1 und dem höchsten Spieltag, maximal 38, wählen. Die aktuelle Tabelle erhalten Sie bei Eingabe des letzten Spieltages.

Nach kurzer Zeit erscheint die Tabelle auf dem Bildschirm. Sie bleibt so lange erhalten, bis Sie eine beliebige Taste drücken.

Aus Platzgründen konnten bei der Bildschirmausgabe nur der Tabellenplatz, der Mannschaftsname, die Tordifferenz, die Pluspunkte und die Minuspunkte berücksichtigt werden. Die Druckerausgabe der Tabelle ist wesentlich umfangreicher.

## Druckerausgabe

Die Auswahlmöglichkeiten 4, 5 und 6 im Hauptmenü beziehen sich auf die Druckerausgabe.

### 4 = Mannschaftsliste -d-

Nach dem Anwählen dieses Menüpunktes ist auf dem Bildschirm eine Information zu sehen, die aussagt, was der C 64 als nächstes machen wird. Des weiteren werden Sie gefragt, ob der Drucker eingeschaltet ist. Achtung, bestätigen Sie nun mit RETURN und der Drucker ist nicht eingeschaltet, führt dies zum Programmabsturz. Aus diesem Grunde erst überzeugen, dann bestätigen mit RETURN.

Mit der Eingabe von »M« gelangen Sie wieder zum Hauptmenü zurück. Nach Beendigung des Druckvorganges erscheint automatisch wieder das Hauptmenü.

### Spieltage -d-

Nach Eintippen von »5« im Hauptmenü sehen Sie ein Untermenü mit den folgenden Auswahlmöglichkeiten:
A = kompletter Spielplan
B = ein bestimmter Spieltag
C = von/bis zu einem Spieltag
D = Ergebnisse einer Mannschaft
N = Nachholspiele
M = Menü

### A = Kompletter Spielplan

Nachdem Ste »A« eingegeben haben, sehen Sie wieder eine entsprechende Information auf dem Bildschirm. An dieser Stelle sollten Sie überprüfen, ob Ihr Drucker eingeschaltet ist. Wollen Sie den Druckvorgang nicht starten, gelangen Sie mit der Eingabe »M« wieder zum Menü. Haben Siejedoch »D« gewählt, ist der Druckvorgang nicht mehr zu unterbrechen. Nach Beendigung meldet sich das Programm mit dem Menü wieder.

### B = Ein kompletter Spiettag

Wählen Sie »B« im Untermenü fragt der Computer nach dem Spieltag, den Sie ausdrucken möchten. Nach richtiger Eingabe mit abschließendem RETURN sehen Sie wieder die Information und haben nun die Auswahl »M=MENUE« und »D=DRUCKEN«.

### C = Von/bis zu einem Spieltag

Hier können Sie sich nach Eingabe des ersten und des letzten Spieltages, den Sie drucken möchten, eine beliebige Anzahl von Spieltagen ausdrucken lassen.

### D = Ergebnisse einer Mannschaft

Wenn Sie »D« im Untermenü anwählen, können Sie die Spielpläne jeder Mannschaft einzeln ausdrucken lassen.

Das Programm fragt zuerst nach der Mannschaftskennzahl (MKZ) und zeigt Ihnen danach den dazugehörigen Mannschaftsnamen. Verneinen Sie die anschließende Abfrage »EINGABE OK« haben Sie die Möglichkeit, die MKZ zu korrigieren. Beantworten Sie diese Frage jedoch mit »J«, können Sie wieder wählen zwischen »M = Menü« oder »D = Drucken«.

Ist der Druckvorgang zu Ende, fragt das Programm, ob Sie einen weiteren Ausdruck der Spielerergebnisse dieser Mannschaft wünschen. Antworten Sie mit »J« wiederholt sich der Druckvorgang. Antworten Sie mit »N« fragt das Programm, ob Sie einen Ausdruck einer anderen Mannschaft wünschen. Bei Eingabe »J» beginnt wieder die Prozedur mit der Abfrage der MKZ, mit Eingabe von »N« gelangen Sie wieder zum Menü. Hinweis zur Ausdrucksform:

Auf dem Ausdruck wurde eine Spalte ».... Uhr« vorgesehen. Im Programm können Sie diese Uhrzeit nicht eingeben. Nun fragen Sie sicher, wieso dann? Wenn Sie als Staffelleiter ein arbeitssparendes Instrument wie »Ligatab« zur Verfügung haben, sollten auch die Vereine davon profitieren. Stellen Sie diese Liste den Vereinen zurVerfügung, haben diese nach Ergänzung der Listen mit der Uhrzeit einen vernünftigen Spielplan, den Sie für den Aushang und zum Verteilen im Verein verwenden können. Den Vereinen wird somit auch eine Menge Arbeit erspart.

### N = Nachholspiele

Hiermit haben Sie die Möglichkeit, alle noch ausstehenden Nachholspiele ausdrucken zu lassen, wenn Sie als solche in den Spieltagen gekennzeichnet sind.

Hierzu ist jedoch mehr im Abschnitt »Besonderheiten« nachzulessen. Mit der Eingabe von »M« im Untermenü gelangen Sie zum Hauptmenü.

### 6 = Tabelle -d-

Wie bei der Bildschirmausgabe fragt das Programm auch hier, bis zu welchem Spieltag (einschließlich) die Tabelle errechnet werden soll. Nach Beantwortung erscheint nach kurzer Zeit die Tabelle auf dem Bildschirm. Sie haben nun wieder die Wahl zwischen »M=MENUE« und »D=DRUCKEN«. Die Druckerausgaben der Tabellen sind wesentlich umfangreicher als die Bildschirmausgaben und enthalten folgende Informationen:

- Pl.	= Tabellenplatz
- Verein = Mannschaftsname
- Sp.	= Anzahl der Spiele
- G	= Anzahl der gewonnenen Spiele
- U	= Anzahl der unentschiedenen Spiele
- V	= Anzahl der verlorenen Spiele
- +T	= Anzahl der erzielten Tore
- -T	= Anzahl der Gegentore
- TD	= Tordifferenz
- +P	= Anzahl der Pluspunkte
- -P	= Anzahl der Minuspunkte
TODO

## Diskettenoperationen

### 8 = Daten speichern auf Diskette:

Nachdem Sie im Hauptmenü »8« angewählt haben, die richtige Diskette eingelegt ist und dies mit RETURN bestätigt wurde, werden die Daten auf Diskette gespeichert. Ist das Abspeichern abgeschlossen, meldet sich das Programm automatisch mit dem Hauptmenü zurück.

### 9= Neue Liga/Programmende

Diesen Programmteil dürfen oder müssen Sie dann anwählen, wenn Sie entweder die Arbeit mit der zur Zeit im Computer befindlichen Liga beenden und mit einer nächsten Liga weiterarbeiten wollen, oder wenn Sie die Arbeit mit Ligatab ganz beenden wollen. Sie sollten in diesem Programmabschnitt wieder ganz besonders vorsichtig sein, um nicht die eingegebenen Daten durch unüberlegte Eingaben zu verlieren. Dies ist ganz besonders ärgerlich, wenn Sie sich hier bei einer Ersteingabe verschreiben.

Nachdem Sie im Hauptmenü.»9« angewählt haben, erfolgt aus Sicherheit eine doppelte Aubfrage, ob Sie die Daten bereits abgespeichert haben. Sobald Sie eine Abfrage mit »N« für Nein beantworten, sind Sie wieder im Hauptmenü. Bejahen Sie jedoch die Abfragen zweimal mit »J« für Ja, sind die Daten im C 64 unwiderruflich verloren.

Jetzt haben Sie die Möglichkeit, mit Eingabe von »E« die Arbeit ganz zu beenden, oder mit der Eingabe von »N« eine neue Liga zu bearbeiten. Bei der Eingabe von »E« werden nicht nur die Daten, sondern auch das Programm gelöscht.

Der Computer wird in den Einschaltzustand versetzt. Nach Eingabe von »N« werden alle Daten der zur Zeit im Computer befindlichen Liga gelöscht und es wird anschließend wieder das Titelbild auf dem Bildschirm erscheinen.

## Besonderheiten

Mit den bisher beschriebenen Möglichkeiten läßt sich eine Sportliga nur so lange sinnvoll verwalten, wie sie keinerlei Änderungen unterliegt. Wenn damit die Möglichkeiten des Programms erschöpft sind, so ist es vollkommen praxisfremd.

Welcher Staffelleiter kennt nicht den Aufwand zur Verfolgung der Termine von Nachholspielen, oder den Ärger, eine mühsam errechnete Tabelle am zehnten Spieltag vor Saisonende korrigieren zu müssen, weil ein Verein seine Mannschaft zurückgezogen hat, oder den Ärger, einen Spielplan am neunten Spieltag umzuplanen, einschließlich deranfallenden Nachholspiele, weil eine Mannschaft nachgemeldet wurde, oder die entstehen kann, wenn ein Spiel gewertet werden muß, und die Tabelle war schon errechnet, oder...

Jeder, der mit der Verwaltung von Sportligen zu tun hat, weiß, daß all diese Dinge um so häufiger vorkommen, je niedriger die Liga ist, die er zu verwalten hat. Ganz zu schweigen vom Spielbetrieb im Jugendbereich.

Ein Programm, das den Anspruch »praxisnah« für sich stellt, muß mit all diesen Unzulänglichkeiten in einer anwenderfreundlichen Weise fertig werden. Wie Sie nun in solchen Fällen im Detail mit dem Programm arbeiten können, wird in den nachfolgenden Abschnitten beschrieben.

### Wertung von Spielen

Die Wertung von Spielen ist im Programmablauf einer einfachen Ergebniskorrektur gleichzusetzen. Beispiel: Am 12. Spieltag spielt Mannschaft X gegen Y 1:1 unentschieden und Sie erhalten den Spielbericht dienstags. Da keine besonderen Vormerke eingetragen sind, übernehmen Sie das Ergebnis in den Computer. Nun erhebt Y am Samstag berechtigten Einspruch, und die Spruchkammer wertet das Spiel auf ihrer Sitzung zwei Wochen später mit 2:0 für Mannschaft Y.

Was tun?

1. — Sie wählen im Hauptmenü »2 = Spieltage -e-s-k-«
2. — Sie wählen im Untermenü »s = Ergebnis -e-s-k-«.
3. — Sie wählen für den Start den 12. Spieltag.
4. — Sie wählen »K« für korrigieren.
5. — Bei nicht zu korrigierenden Ergebnissen: RETURN
6. — Sie überschreiben die entsprechenden Zahlen.

### Eingabe von Nachholspielen

Beispiel:
Im oben beschriebenen Fall hat die Spruchkammer entschieden, das Spiel ist neu anzusetzen, oder das Spiel ist aufgrund der Witterungsverhältnisse ausgefallen und neu anzusetzen. Was tun:

1. — 5. wie oben (Wertung)
6. — Sie tragen anstelle der geschossenen Tore der Heimmannschaft ein »N« ein.
7. — War bereits ein Ergebnis eingetragen, sind neben dem »N« 2 Punkte und bei den Gegentoren 3 Punkte einzuschreiben.

### Bildschirmausgabe der Nachholspiele und eintragen des Datums

Was tun:
1. — Sie wählen im Hauptmenü »2 = Spieltage -e-s-k-«.
2. — Sie wählen im Untermenü »N = Nachholspiele«.
3. — Sie sehen auf dem Bildschirm die Nachholspiele des 1. Spieltages oder die Meldung »Keine Nachholspiele!«
4. — Sie können nun mit den Cursor-Tasten blättern.
5. — Möchten Sie das Datum eintragen, wählen Sie hierzu »K« und tragen anschließend das entsprechende Datum in der Form TT.MM.JJJJ ein.

### Druckerausgabe Nachholspiele

Hiermit haben Sie die Möglichkeit, alle noch ausstehenden Nachholspiele als Liste über den Drucker auszugeben.

Was tun:
1. — Sie wählen im Hauptmenü »5 = Spieltage -d-«.
2. — Sie wählen im Untermenü »N = Nachholspiele«.
3. — Sie beantworten die Frage von/bis zu welchem Spieltag.
4. - Sie wählen im Informationsbild »D = Drucken«.

Hinweis:
Ein Nachholspiel wird als Nachholspiel automatisch gelöscht, wenn für das entsprechende Spiel ein Ergebnis eingetragen wird.

### Mannschaften zurückziehen

Beispiel:
Sie verwalten eine Liga mit X Mannschaften und am 12. Spieltag zieht ein Verein seine Mannschaft zurück.
Wastun:

1. — Sie wählen im Hauptmenü »1 = Mannschaften -e-s-k-«.
2. — Sie verneinen die Frage »EINGABE OK« mit »N« für Nein.
3. — Sie geben »A« für »ANZAHL FALSCH« ein.
4. — Sie geben »—«für »EINE MANNSCHAFT WENIGER« ein.
5. — Sie geben die MKZ der entsprechenden Mannschaft ein.

Das Programm korrigiert die Daten automatisch. Hatten Sie die falsche MKZ eingegeben, so gehen Sie über das Hauptmenü zu Punkt »9« und beenden die Arbeit so, als ob mit einer neuen Ligaweitergearbeitetwerden soll. Nun laden Sie die Liga erneut und können entsprechend korrigieren.

Alle Spiele, an denen die gelöschte Mannschaft beteiligt war, werden in den Spieltagen (nur Bildschirmausgabe) mit der MKZ »0« belegt.
Beispiel:
Eine Mannschaft wird zurückgezogen und gleichzeitig eine andere nachgemeldet.
Was tun:

1. — 2. — wie im letzten Beispiel.
3. — Sie geben »N« für »NAME FALSCH« ein.
4. — Bei nicht zu ändernden Namen tippen Sie RETURN.
5. — Den Namen der zu löschenden Mannschaft überschreiben Sie mit dem Namen der neuen Mannschaft.
6. — In den Spieltagen müssen Sie nun die Ergebnisse der alten Mannschaft mit drei Punkten belegen, und die Spiele, die laut Spielplan bereits stattgefunden haben müßten, wie Nachholspiele behandeln (das heißt mit »N« belegen).

### Mannschaften nachmelden

Hier müssen Sie drei verschiedene Voraussetzungen unterscheiden.
A) Sie haben eine Liga mit ungerader Anzahl von Mannschaften, und alle Plätze sind bereits besetzt.
B) Sie haben eine Liga mit gerader Anzahl von Mannschaften, und alle Plätze sind bereits besetzt.
C) Sie haben eine Liga, in der noch Plätze frei sind.
Beispiel:
Ihre Liga hat 15 Mannschaften und Sie möchten sie um eine auf 16 erweitern.
Was tun:

1. — Sie wählen im Hauptmenü »1 = Mannschaften -e-s-k-«.
2. — Sie verneinen die Frage »EINGABE OK« mit »N« für Nein.
3. — Sie geben »A« für »ANZAHL FALSCH« ein.
4. — Sie geben »+«für »EINE MANNSCHAFT MEHR« ein.
5. — Sie geben den Mannschaftsnamen ein.
6. — Sie bestätigen »EINGABE OK« mit »J« für Ja.
7. — Sie wählen im Hauptmenü »2 = SPIELTAGE -e-s-k-«.
8. — Sie wählen »E« im Untermenü.
9. — Sie starten mit dem 1. Spieltag.
10. — Sie setzen die Spiele der neuen Mannschaft gegen die, die bisher spielfrei war.
11. — Sie behandeln die Spiele, die eigentlich bereits stattgefunden haben sollten, wie Nachholspiele.

Beispiel:
Ihre Liga hat 14 Mannschaften und soll um eine auf 15 erweitert werden.
Was tun:
1. — 5. — wie im ersten Beispiel.
6. — Sie sehen nun die Meldung »SPIELTAGE UND ERGEBNISSE NEU SETZEN«.

Normalerweise müßten Sie nun den kompletten Spielplan neu setzen. Diese sehr umfangreiche und eigentlich sinnlose Arbeit könnten Sie sich jedoch bei vernünftiger Vorplanung beim Anlegen der Ligen ersparen. Siehe hierzu auch Abschnitt »Tips zur Vorbereitung«. Sie sollten daher nie eine Liga, die eine gerade Anzahl von Mannschaften und keine Plätze mehr frei hat, vergrößern. Das Programm läßt dies zwar zu, jedoch nur in Verbindung mit einem nicht vertretbaren Aufwand.
Beispiel:
Ihre Liga hat 14 Plätze, diese sind aber nur mit 12 Mannschaften belegt, so daß immer 2 Mannschaften spielfrei sind. Sie möchten nun die 13. Mannschaft einordnen.
Was tun:

1. — und 2. — wie im ersten Beispiel.
3. — Sie geben »N« für »NAME FALSCH« ein.
4. — Sie drücken so oft RETURN bis der CURSOR auf den ersten freien Mannschaftsnamen ist.
5. — Sie überschreiben die Punkte mit dem neuen Namen.
6. — Sie drücken so lange »RETURN« bis der Balken njit der Frage »EINGABE OK« erscheint.
7. — Sie bestätigen mit »J« für Ja.
8. — Schritte 7. — 9. — wie im ersten Beispiel.
9. — Sie ersetzen in den Spieltagen die Spiele die bisher mit der MKZ »0« belegt waren mit den richtigen MKZs.
10. — Wie 11. — im ersten Beispiel

## Tips zur Vorbereitung

Wenn Sie das in diesem Abschnitt beschriebene genauestens durchlesen, und bei der Verwaltung ihrer Sportliga anwenden, können Sie sich eventuell sehr viel Arbeit ersparen.

### Anlegen der Ligen vor der Saison

Wir sehen uns nun den Sportteil einer Montagszeitung genauer an. Sie sehen hier fast alle Klassen im Fußballsport. In der mir vorliegenden, einer Aachener Lokalzeitung, stelle ich folgendes fest:

TODO TABELLE

Jeder, der sich normalerweise nicht im Verband um die Organisation des Spielbetriebes kümmert, wird nun erstmal staunen, wieviel Ligen die ehrenamtlichen Staffelleiter, insbesondere im Jugendbereich, zu verwalten haben. Von den insgesamt 66 Ligen werden 58 im Kreisverband, davon 44 im Jegendbereich, organisiert Somit liegt es nahe, sich ein Instrument zu beschaffen, das die Routinearbeiten erledigen kann.

Im nachfolgenden soll nun am Beispiel des Kreises Aachen aufgezeigt werden, welche Grundüberlegungen man anstellen sollte, um die Ligen des Kreises mit »Ligatab« bei möglichst kleinem Aufwand zu verwalten.

Es geht nun darum festzustellen, welche Liga Sie mit welcher Anzahl von Mannschaften anzulegen haben. Das Ergebnis muß natürlich so sein, daß genügend Flexibilität vorhanden ist, um alle Veränderungen, bezogen auf die Mannschaftsanzahl, mit geringst möglichem Arbeitsaufwand erfassen zu können. Hierzu betrachten Sie nur die Ligen, die im Kreisverband verwaltet werden müssen (Nr. 7 bis 20, Nr. 23 bis 66).

Es sind hier zwei Arten zu unterscheiden. Einmal die Ligen, in denen die Anzahl der Mannschaften durch Auf- beziehungsweise Abstieg geregelt wird, zum anderen die Ligen, in denen die Anzahl der Mannschaften nur von der Anzahl der Meldungen der Vereine abhängig ist.

Zur ersten Gruppe gehören die Gruppen der Kreisliga A und Bsowie die Junioren Sondergruppen und Leistungsstaffeln. In diese Ligen wird es in der laufenden Saison nie vorkommen, daß sie durch eine Mannschaft vergrößert werden müssen.

In der zweiten Gruppe, den Kreisligen C und den Juniorenbeziehungsweise Jugendnormalstaffeln, kann es schon öfter vorkommen, daß Mannschaften nachgemeldet werden.

In der ersten Gruppe brauchen Sie nicht lange zu überlegen. Hier kommen Sie mit 16er und 12er Gruppen aus. In der zweiten Gruppe sollten Sie für die Kreisliga C 16er Gruppen anlegen und für die Jugendmannschaften 12er Gruppen. Damit haben Sie zwei Probleme erschlagen. Zum einen haben Sie genügend Reserve für die Nachmeldung, zum andern benötigen Sie nur den 16er und den 12er DFB-Spielplanschlüssel.

Um nun nicht stundenlang in 14 Gruppen mit 16er-Schlüssel und in 44 Gruppen mit 12er-Schlüssel Mannschaftskennzahl und Spieltagsdatum eintragen zu müssen, sollten Sie wie folgt vorgehen:

1. — Sie legen eine Liga mit 16 Mannschaften, einschließlich komplettem Spielplan und Spieltagsdatum an.
2. — Wie vor, jedoch mit 14 Mannschaften.
3. — Sie kopieren die Ligen mit dem auf Ihrer >TEST/DEMO-DISKETTE« befindlichem Programm »DOS 5.1« und benennen sie um.

Die Schreibweise des Befehls im »DOS 5.1« ist: >C:Neuer Name = Alter Name

### Aufteilen der Ligen auf Disketten

Um die Ligen bei Ihrer wöchentlichen Arbeit schnell wiederzufinden, ist es ratsam, nicht mit Disketten zu sparen und die Aufteilung nach rein logischen Gesichtspunkten vorzunehmen. So hat eine F-Jugendliga nichts auf der gleichen Diskette zu suchen wie eine Kreisliga A. Es passen maximal zehn 16er Ligen oder maximal zwanzig 12er Ligen auf eine Diskette. Hierauf aufbauend könnte eine Aufteilung wie folgt aussehen:

TODO TABELLE

### Datensicherung

Die Datensicherung muß sehr ernst genommen werden. Um einen unnötigen Verlust größerer Datenmengen zu vermeiden, sollten Sie mindestens einmal im Monat alle Datendisketten mit einem Diskettenkopierprogramm vollständig kopieren. Dies sollten Sie auch tun, nachdem Sie alle Ligen, die Sie verwalten möchten, zum ersten Mal angelegt haben.

Es wäre natürlich sinnlos, sich die Arbeit des Kopierens zu machen, um die Kopien am gleichen Ort wie die Originale aufzubewahren. Die Kopien sollten mindestens in einem anderen Raum aufbewahrt werden. Es wäre natürlich noch besser, wenn Sie die Kopien in einem anderen Gebäude aufbewahren könnten. Wenn Sie diese Tips befolgen, ersparen Sie sich viel Arbeit.

Das Programm wurde in erster Linie für die ehrenamtlichen Mitarbeiter der Kreisverbände geschreiben, die jede Woche mühsam per Hand die Ergebnisse in Listen eintragen und nach den verschiedensten Schemata in unregelmäßigen Zeitabständen Tabellen errechnen. Aber auch für den privaten Bereich kann Ligatab zweckentfremdet werden.

(Franz-Josef Heuser/rg)

# Neuer Checksummer 64 — blitzschnell und kürzer

> Das Programm Checksummer kennen die meisten unserer Leser bereits aus dem 64’er Sonderheft und den Ausgaben 1 und 2/85. Der Checksummer überprüft jede eingegebene Basic-Zeile und erspart Ihnen deshalb eine langwierige Fehlersuche. Und neu ist der Checksummer, weil die Initialisierung zirka einhundertmal schneller vonstatten geht als bei der alten Version.

Es gab eine riesige Resonanz auf den Checksummer und zwar ausschließlich positiv. Jedoch brauchte das Programm eine ganze Weile, bis es initialisiert war, eine Herausforderung für eine Unmenge von Lesern! Der nebenstehende Leserbrief setzt sich drastisch, aber nicht ganz so ernst gemeint, mit diesem Problem auseinander und gibt eine Lösung, die zirka einhundertmal schneller ist als die bisherige Version. Dieser Brief und der neue, schnelle Checksummer steht übrigens für eine ganze Reihe von Leserzuschriften, die auch entsprechende Verbesserungen eingeschickt haben.

Der Checksummer 64 ist ein kleines Maschinenprogramm, das, wenn es aktiviert ist, Sie sofort davon unterrichtet, ob Sie die jeweilige Programmzeile korrekt eingegeben haben.

1. Tippen Sie den Basic-Ladersorgfältig ein. Es gibtzwei Versionen: Eine für den Commodore 64 und eine für den VC 20.
2. Vergessen Sie nicht das Abspeichern vor dem Start (RUN)!
3. Wenn Sie den Checksummer 64 zwischenzeitlich nicht benutzen, können Sie ihnjederzeit mit »POKE 1,55« desaktivieren. Auch durch Drücken der Run-Stop- und der Restore-Taste wird der Checksummer 64 desaktiviert.

Wollen Sie den Checksummer 64 wieder einschalten, so geben Sie bitte »POKE 1,53« ein.

Das Maschinenporgramm bleibt solange erhalten, bis der Computer ausgeschaltet, oder, wenn von anderen Programmen auf das hinter dem ROM liegende RAM zugegriffen wird.

Alle veröffentlichten Listings sind mit einer Checksumme versehen, die am Ende jeder Programmzeile steht. Diese Checksumme steht zwischen < und >. Sie wird beim Eintippen des Programms nicht mit eingegeben. Die Zahl zwischen den beiden Zeichen stellt lediglich eine Information für Sie dar. Wenn Sie diese Checksumme dennoch mit eintippen, werden Sie schnell bemerken, daß Sie etwas falsch gemacht haben. Bei aktiviertem Checksummer 64 wird nämlich nach Eingabe einer Basic-Zeile, die mit Return beendet wird, in die linke obere Bildschirmecke die Checksumme eingeblendet, die mit der Summe aus dem veröffentlichten Listing übereinstimmen muß. Ist dasnicht der Fall, haben Sie die Zeile anders eingegeben, als sie im Listing dargestellt ist. Vergessen Sie also bitte nicht, daßdieamEndeeinerZeilein < und > stehendePrüfsumme nicht mit eingegeben werden darf.

Der Checksummer 64 ist so ausgelegt, daß er abhängig von der Zeilennummer und dem Text der Zeile eine Checksumme ausgibt. Beim Bilden dieser Checksumme werden Spaces (Leertaste) überlesen, was für Sie bedeutet, daß es egal ist, wieviel Leerzeichen Sie zwischen den Worten lassen, da Sie für den Programmablauf ohnehin keine Bedeutung haben.

### Hinweise zum Lesen von Listings

Die Listings haben sich ein wenig im Ausdruckformat verändert, um Ihnen das Eingeben von Programmen wesentlich zu erleichtern.

- Cursorsteuerzeichen und andere Steuerzeichen, die schwer zu lesen sind, werden von nun an in Klartext in speziellen geschweiften Klammern gesetzt.

Tritt mehrmals hintereinander dasselbe Steuerzeichen auf, so wird diese Steuerzeichen-Sequenz zusammengefaßt, indem zuerst die Anzahl der Wiederholungen dieses Steuerzeichens und dann das Steuerzeichen in Klartext ausgegeben wird.

- Alle Commodore-Grafikzeichen, die über Shift zu erreichen sind, werden nicht mehr als Grafikzeichen, sondern als Klartextzeichen dargestellt. Dabei wird aus dem Zeichen, das Sie auf dem Bildschirm sehen, Wenn Sie die Tastenkombination Shift und »A« ansprechen, wieder ein »A« (nur im abgedruckten Listing). Um dieses »A« vom normalen »A« unterscheiden zu können, ist es etwas kleiner als das gewöhnliche »A« und ist außerdem mit einem Unterstreichungszeichen versehen. Diese Vereinbarung gilt auch für sämtliche andere Commodore-Grafikzeichen, die über Shift zu erreichen sind.
- Entsprechendes gilt für sämtliche Commodore-Grafikzeichen, die über die Commodore-Taste zu erreichen sind. Hier wird jedoch das jeweilige Klartextzeichen nicht unterstrichen, sondern überstrichen.

## Checksummer VC 20

Der Checksummer VC 20 ist im Prinzip genauso aufgebaut wie der Checksummer 64. Da beim VC 20 jedoch nicht die Möglichkeit besteht, das ROM softwaremäßig zu modifizieren, mußte ein anderer Weg als beim Commodore 64 gewählt werden, um die Checksumme zu generieren.

In ihrer Funktionsweise unterscheiden sich der Checksummer VC 20 und der Checksummer 64 nicht. Es gelten folgende Sonderregelungen bei der Benutzung des Checksummer VC20:

- Da der Basic-Bereich nicht belegt werden soll, ist das Programm im Kassettenpuffer abgelegt.
- Angeschaltet wird der Checksummer VC 20 mit »SYS 955« und abgeschaltet mit »SYS 58459«.

**ACHTUNG**: Nehmen Sie keine Kassetten-Operationen vor, wenn der Checksummer VC 20 eingeschaltet ist. Da das Betriebssystem den Kassettenpuffer mit Daten belegt, kann der Checksummer VC 20 überschrieben werden, was zur Folge hat, daß sich der Rechner bei aktiviertem Checksummer VC 20 »aufhängt«. Wollen Sie deshalb ein Programm auf (von) Kassette abspeichern (laden), so müssen Sie erst den Checksummer VC 20 abschalten (SYS 58459).

Daraufhin kann der Kassettenpuffer mit Daten überschrieben werden, ohne daß der Rechner »aussteigt«.

Als Sicherung wird bei der Initialisierung geprüft, ob das zuletzt angesprochene Peripherie-Gerät der Kassettenrecorder war. Ist das der Fall, so werden die Betriebssystemroutinen LOAD und SAVE für die Benutzung gesperrt. Der Rechner meldet bei Aufruf einer dieser beiden Routinen READY, ohne weitere Aktionen durchzuführen. Diese Sicherung kann man nach der Tipparbeit aufheben, wenn man den Checksummer VC 20 mit SYS 58459 abschaltet. Dadurch wird der Kassettenpuffer für andere Daten freigemacht

Weiterhin wird dann durch gleichzeitiges Drücken der Tasten »Run-Stop & Restore« erreicht, daß die Betriebssystemroutinen LOAD und SAVE wieder eingerichtet werden.

- Bei Benutzung einer Diskettenstation brauchen Sie nicht darauf zu achten, daß bei LOAD beziehungsweise SAVE der Checksummer VC 20 überschrieben wird, da der Kassettenpuffer für die Diskettenstation normalerweise nicht genutzt wird. Deshalb können Sie die beiden Routinen weiterhin normal nutzen, sofern der Rechner bei der Initialisierung des Checksummer VC 2Ofeststellt, daß das zuletzt angesprochene Peripherie-Gerät nicht der Kassettenrecorder war.
- Bedingt durch den anderen Aufbau des Checksummer VC 20 wird anders als beim Checksummer 64 nach der LOAD-Routine keine Checksumme ausgegeben.
- Wird eine Zeile gelöscht, also eine Zahl zwischen 0 und 63999 eingegeben, und danach Return gedrückt, so wird eine Checksumme ausgegeben, die aber keine Bedeutung hat.

Viel Spaß beim Eintippen von Programmen mit dem neuen Checksummer!

TODO ASIDE

Herrschaften!

(Nehmen Sie mir den Ton dieses Schreibens bitte nicht übel; ich meine es nicht so ganz ernst!)

...da veröffentlicht Ihr in Eurer Zeitschrift Programme wie HYPRA-LOAD und so weiter, weil die geschätzten Fans, überwiegend wohl Hobbyisten, nicht genug Zeit haben (0 tempora, omores!), aufdielahme, dafüraberbillige 1541 zuwarten, und dann schockt Ihr einen mit einer für den Genuß Eures Magazins lebenswichtigen Utility, nämlich dem Checksummer, während deren Setup man einen ausgedehnten Mittagsschlaf halten kann. Mein C 64-Interpreter (der übrigens Wert darauf legt, auf der 2. Silbe betont zu werden, was einerseits richtig, andererseits wenig bekannt ist) behauptetjedenfalls, er brauche für den Programmlauf 1 Minute 18 Sekunden...

Wenn Ihr Euch jetzt auf die Füße getrampelt fühlt und um konstruktive Kritik bittet, bitte:

Der erste Blick ins Listing entlarvt den ersten Übeltäter in den Zeilen 130 und 140 (wohlgemerkt: die C 64-Version!):

16 KByte in einer Basic-Schleife kopieren! Puh! Warum nicht gleich von Hand ein POKEn?! Dieser Anschlag auf die Geduld des geneigten Lesers und Anwenders ist um so verwerflicher, als daß doch der Interpreter ab Adresse dezimal 41912 ($A3B8) eine Block-Verschiebe-Routine anbietet, mit der man nur umzugehen wissen muß.
Also:

Die ersten 3 Befehle der Routine vergessen wir — die werden nur gebraucht, wenn die Routine in der üblichen Weise verwendet wird. Der richtige Einsprung-Punkt für unsere Zwecke ist also dezimal 41919 ($A3BF).
Die Routine verlangt nun folgende Übergabe-Parameter
(in der üblichen Reihenfolge low — high):
a) Stertadresse des zu verschiebenden (hier bloß in das darunterliegende RAM zu kopierenden) Blocks in dezimal 95/96 ($5F/60),
b) Endadresse+1 des zu verschiebenden Blocks in dezimal 90/91 ($5A/5B),
c) Endadresse+1 des Bereichs, in den verschoben werden soll, in dezimal 88/89 ($58/59).
Getrennt für jeden ROM-Bereich POKEn wir also die Parameter in die angegebenen Adressen, wobei
a) in unserem speziellen Falle die Endadresse des Quell- und Zielbereichs (+1) natürlich identisch ist.
b) wir im 2. Falle anstelle der richtigen, aber leider unmöglichen, Endadresse+1 einfach naßforsch 0 eingeben, getreu dem — in diesem Falle richtigen — Motto: Für den Computer ist dezimal 65535 ($FFFF) + 1 = 0!

Aber... (vor den Ruhm haben die Götter die Schweißfüße gesetzt!) das funktioniert natürlich (von Basic aus) nicht! Der Grund ist für den Kundigen klar: Der Aufruf der SYS-Routine mißhandelt in brutalster Weise die gerade mühsam gePOKEte Startadresse. Das entmutigt unsjedoch in keinster Weise. Wir übergeben die Startadresse in dezimal 780/781 ($030C/030D) an Akku und X-Register und springen zunächst eine selbstgestrickte Mini-Maschinenroutine von insgesamt 7 Byte Länge an, die die Startadresse abliefert und dann die eigentliche Routine anspringt: STA $5F, STX $60, JMP $A3BF. Diese 7 Byte, die wir natürlich im Programm vorher mittels einer READ-Schleife einPOKEn, verstecken wir nichtstörend vor dem Kassetten-Puffer ab dezimal 820 ($0334). Wem dieses stille Örtchen nicht paßt: lm beigefügten Listing (Checksummer für den C 64) habe ich diese Startadresse netterweise parametrisiert.

That’s all! Hört sich komplizierter an, als es ist!

Fragt sich (mit Fug und Recht): Was bringt’s?

Antwort: Das so verunstaltete Programm behelligt den Computer für nur noch 7 Sekunden anstelle von vorher 1 Minute 18 Sekunden.

Das ist natürlich noch viel zu lang!!!

Ein zweiter Blick ins ursprüngliche Listing entlarvt den zweiten Übeltäter. Die Hex-Zahlen in den DATAs samt den dazugehörigen Programmzeilen. Was Ihr Euch dabei gedacht habt, wißt Ihr und die Götter — ich nicht! Jedenfalls sind hier die Nebenwirkungen schlimmer als der Heileffekt.
Also.

Wir ersetzen die Hex-Zahlen durch stinknormale Dezimalzahlen, schmeißen natürlich die dann überflüssige Umwandlungs-Routine weg und entledigen uns letztlich (spätestens, nachdem wir die korrekte Eingabe der Zahlen gecheckt haben) der Prüfsummen-Befehle.

Ich verweise den entsetzten Leser auch insoweit auf das abgedruckte Listing.
Was bringt’s?

Das Programm vergeudet nun nur noch zirka 1 Sekunde!

Und damit wollen wir es genug sein lassen.

(Werner Wenzel)

TODO Tabelle

(F. Lonczewski/gk)

# Elektrotechnisches Zeichnen mit dem VC 20

> Dieses Programm unterstützt den Hobby-Elektroniker beim Entwurf von Schaltplänen. Gezeichnet wird mit dem Joystick, wobei zusätzlich eine Reihe von vordefinierten, elektrotechnischen und alphanumerischen Symbolen eingefügt werden kann.

Das Programm läuft aufjedem VC 20 mit mindestens 8 KByte Erweiterung. Zur Speicherung der Schaltpläne benötigt man eine 1541-Floppy; die Hardcopy-Routine ist für den MPS 801-Drucker geschrieben. Vor dem Abtippen muß der Zeiger fürden Basic-Startverändertwerden, um Platz für die hochauflösende Grafik und das Maschinenprogramm zu schaffen. Das geschieht mit
POKE44,36:POKE36 * 256,0:NEW

Jetzt wird zunächst der Basic-Lader nach Listing 1 eingetippt und vorsichtshalber sofort abgespeichert. Nach einwandfreiem Lauf des Laders kann anschließend der Basic-Teil (Listing 2) abgetippt werden. Sollte jedoch nach dem Start des Basic-Laders ein Fehler aufgetreten sein, so müssen die DATAs noch einmal überprüft werden.

Zu beachten ist, daß das Maschinenprogramm vor dem Start gesichert wird, denn vordem Abtippen des Basic-Teilswird das Ladeprogramm mit »NEW« gelöscht. Nachdem nun auch der Basic-Teil vorhanden ist, kann das Programm endlich mit »RUN« gestartet werden.

Es erscheint auf dem Bildschirm ein Menü (Bild 1). Zunächst muß der Name der zu ladenden Zeichnung eingegeben werden. Wenn eine neue Zeichnung erstellt werden soll, so braucht man an dieser Stelle nur RETURN drücken. Danach wird der Name abgefragt, unter dem die Zeichnung abgespeichert werden soll. Wenn beide Eingaben gemacht wurden, erscheint die Zeichenfläche. Auf ihr kann nun mit dem Joystick gezeichnet werden. Bei gedrücktem Feuerknopf werden bereits gezeichnete Punkte wieder gelöscht. Wird der Bildschirmrand überschritten, springt der Zeichenpunkt immer in die linke obere Ecke.

Die weiteren Funktionen können nur über die Tastatur erreicht werden:

(1)	← Löschen des Bildschirms (komplett)
(2)	↑ Directory (ohne Zerstörung des Programms)
(3)	**RETURN** Menü (Grafik geht verloren)
(4)	**CTRL** Schaltet von Elektrozeichen auf alphanumerische Zeichen
(5)	**SHIFT+CTRL** Macht (4) rückgängig
(6)	**C= + CTRL** Löscht einen bestimmten Ausschnitt der Zeichenfläche.

Im Normalmodus können über die Tasten 1 bis 0 und SHIFT 1 bis 0 elektrotechnische Zeichen abgerufen werden (Bild 2). Nachdem die entsprechende Taste gedrückt ist, wird mit den Funktionstasten die Lage des Zeichens festgelegt:
F1 = Bauteilanschluß oben
F3 = Bauteilanschluß links
F5 = Bauteilanschluß unten
F7 = Bauteilanschluß rechts

Nach dem Drücken der entsprechenden Funktionstaste erscheint das Bauteil auf dem Bildschirm. Mit Hilfe des Joysticks können nun Verbindungslinien gezogen werden. Wenn in den Alphamodus umgeschaltet wurde, stehen die Buchstaben (A bis Z), die Ziffern (0 bis 9) und drei Sonderzeichen zur Verfügung (Bild 2). Die Sonderzeichen sind µ ([), Ω (]) und + (£). Alle Alphazeichen werden nach dem gleichen Verfahren wie die elektrotechnischen Zeichen auf den Bildschirm gebracht undkönnen daher auch in allen vier Lagen (F1, F3, F5, F7) dargestellt werden. Ein fertiger Schaltplan kann über die Funktionstaste F1 auf dem Drucker in einfacher (anschließend 1 drücken) oder in doppelter (anschließend 2 drücken) Größe ausgegeben werden. Durch Betätigen von F6 wird das Bild unter dem zu Anfang angegebenen Namen abgespeichert. Über F4 kann das Bild jederzeit wieder geladen werden.

Da das Löschen größerer Teile einer Zeichnung mit Hilfe des Joysticks normalerweise eine Geduldsaufgabe ist, wurde eine Funktion zum einfachen Löschen von Bildteilen vorgesehen. Das funktioniert wie folgt: Als erstes werden die Tasten C= und CTRL gleichzeitig gedrückt. Daraufhin ertönt ein ständiges Tonsignal. Jetzt kann mit dem Joystick der zu löschende Ausschnitt eingekreist werden (Bild 3). Um die »Löschlinie« von den anderen zu unterscheiden, wird sie gestrichelt dargestellt. Durch Drücken von F8 wird der markierte Ausschnitt schließlich gelöscht. Um das Erkennen der verschiedenen Betriebsarten des Programms zu erleichtern, werden unterschiedliche Rahmenfarben zur Kennzeichnung verwendet:

TODO

Aus Geschwindigkeitsgründen wurden die Routinen für die hochauflösende Grafik, die Joystickabfrage, die Bewegungsberechnung und die Druckerausgabe in einem Maschinenprogramm zusammengefaßt (Listing 1). Diese Routinen liegen von $2000 (8192) bis $24FF (9471) im Speicher des VC 20. Wer auf die alphanumerischen Symbole verzichten will, der kann die Zeilen 30000 bis 35470, 7000 bis 7020, 5165, 5166, 420, 410 weglassen und erspart sich damit einige Tipparbeit. Das Programm läuft dann nur mit den elektrotechnischen Symbolen.

Bild 3 zeigt den Ausdruck eines mit diesem Programm erzeugten Schaltplanes. Bei der praktischen Arbeit werden Sie feststellen, daß es zu Anfang nicht ganz einfach ist, derart komplexe Zeichnungen auf Anhieb korrekt anzufertigen. Der große Vorteil dieses Programms liegt aber in der Änderungsfreundlichkeit und der beliebigen Reproduzierbarkeit der Zeichnungen.

(Elmar Baer/ev)

# MSE — Abtippen sicher und leicht gemacht

> Ähnlich wie der »Checksummer« ist auch der MSE ein Hilfsmittel bei der Eingabe von Listings, diesmal jedoch bei reinen Maschinensprache-Programmen.

Im Gegensatz zum »Checksummer« aber ist die Eingabe nicht ohne den MSE möglich. Der MSE verringert die Tipparbeit um ein Drittel und schließt Fehleingaben vollkommen aus. Außerdem können Sie die DATAs blind eingeben, ohne andauernd auf den Bildschirm schauen zu müssen. Dies wird durch akustische Meldungen realisiert.

Sicher kennen Sie die Situation: Man hat ein langes Listing mit DATA-Zeilen abgetippt, versucht es, das erste Mal zu starten und — nichts läuft. Dann beginnt nach der mühseligen Tipperei die noch mühseligere Fehlersuche. Als letzter Ausweg bleibt dann nur noch der Anruf bei der Redaktion oder dem Verfasser, ob vielleicht doch ein Druckfehler...

Damit ist es jetzt vorbei. Ab dieser Ausgabe werden die Maschinenprogramme im 64’er mit dem MSE abgedruckt. MSE ist ein Maschinenspracheditor, mit dem ein Vertippen ausgeschlossen ist. Eine abgetippte Zeile wird nur angenommen, wenn sie richtig ist. Wie ist das möglich ? Eine Checksumme am Ende jeder Zeile prüft, ob die richtigen Werte in der richtigen Zeile an der richtigen Stelle stehen. Wenn nicht, ertönt ein Warnsignal, und man beseitigt den Fehler.

War die Zeile korrekt, erklingt ein Gong, und die nächste Zeilennummer wird ausgegeben. Damit ist also auch »blindes« Eintippen möglich; Sie können sich voll auf den Text konzentrieren.

MSE verringert die Tipparbeit um ein Drittel. Anstelle von dreistelligen DATAs brauchen Sie nur noch zweistellige Hex-Zahlen einzugeben, die direkt in den Speicher gePOKEt werden.

### So arbeitet man mit MSE

Laden und starten Sie MSE. Zuerst wird der Programmname und die Start- und Endadresse erfragt. Diese Angaben entnehmen Sie dem Kopf des jeweiligen abgedruckten Listings. MSE meldet sich dann mit der Zeilennummer der ersten Zeile. Wenn Sie die Zeile richtig eingegeben haben, erscheint die nächste Zeilennummer und so weiter bis zum Ende. Zum Schluß wird das fertige Programm mit »CTRL-S« auf Diskette oder Kassette abgespeichert. Dazu sind keine weiteren Angaben mehr erforderlich. Das Programm kann dann ganz normal wieder absolut geladen und gestartet werden. Wenn Sie nicht alles auf einmal tippen wollen, können Sie jederzeit unterbrechen und den eingetippten Teil mit »CTRL-S« abspeichern. Wollen Sie weiterarbeiten, laden und starten Sie MSE wieder. Geben Sie auf die Frage nach der Startadresse aber jetzt »L« ein, um Ihr Teilprogramm zu laden. Jetzt können Sie mit »CTRL-N« die Adresse eingeben, an der Sie weitertippen müssen. Wenn Sie sich nicht gemerkt haben, wie weit Sie gekommen sind, geben Sie nach dem Laden »CTRL-M« ein.

Auf die Frage nach der Startadresse antworten Sie mit der Anfangsadresse, die links in der Kopfzeile auf dem Bildschirm steht. Nun wird Ihr Programm aufgelistet. Mit »SPACE« wird das Listen fortgesetzt, mit »STOP« abgebrochen. Das Ende Ihres Programmteils erkennen Sie sehr einfach daran, daß nur noch der Wert »AA« in der Zeile steht. Die Adresse dieser Zeile müssen Sie anschließend mit »CTRL-N« eingeben. Das Programm ist nur mit »STOP/RESTORE« zu verlassen. Speichern Sie aber vorher unbedingt immer Ihren Text ab.

Wollen Sie selbst Programme mit MSE ausdrucken, laden Sie Ihr Programm wie oben beschrieben und geben anschließend »CTRL-P« ein. Die Druckausgabe läßt sich mit »STOP« jederzeit abbrechen.

### Hinweise zum Abtippen

Vor dem Abtippen oder späteren Wiederladen des MSE-Laders müssen Sie unbedingt folgende Zeile eingeben:
**POKE 43,1: POKE 44,32: POKE 8192,0: NEW**

Beachten Sie bei der Eingabe die Hinweise im »Checksummer«. Speichern Sie den »MSE Lader« nach dem Abtippen unbedingt ab. Starten Sie das Programm mit RUN. Fehlerhafte Zeilen werden angezeigt und müssen korrigiert werden, bis der Lader zum »READY« durchläuft. Jetzt müssen Sie das fertige MSE-Programm abspeichern. Dazu brauchen Sie nur »RETURN« zu drücken, weil die erforderlichen Angaben schon auf dem Bildschirm stehen. (Kassettenbesitzer müssen in Zeile 343 die letzte Zahl in »1« abändern). Abjetzt können Sie »MSE V1.0« direkt, also ohne den DATA-Lader benutzen. MSE V1.0 wird ganz normal mit »,8« geladen. Heben Sie das Programm gut auf, Sie werden es noch häufig brauchen.

(N. Mann/D. Weineck/gk)

# Clubs gesucht

Uns erreicht eine Unmenge an Zuschriften von Lesern, die einen Anschluß an einen Club in ihrer Nähe suchen. Soweit Clubs in dieser Stadt oder dem Postleitzahlengebiet bekannt sind, geben wir die Adressen natürlich gerne weiter. Doch es wird sicherlich noch genügend andere Commodore-Besitzer geben, die in einem Club mitmachen wollen.

Deshalb der **Aufruf an alle Commodore-Clubs** sich bei uns zu melden. Wichtig sind dabei neben der Adresse auch die Schwerpunkte, mit denen sich der Club befaßt. Seien dies nun der Erfahrungs- oder Programmaustauch, die . DFÜ, die Hardware oder eine eigene Clubzeitschrift. Um möglichst alle Clubs in der geplanten Übersicht veröffentlichen zu können, sollten sie sich bei Ihren Angaben auf das Notwendigste beschränken. Also Adresse und vier oder fünf Stichpunkte, etwa nach diesem Schema:
C 64 User-Club POKE-Freunde, Basic-Str. 1, 1024 Commodorestadt,
Clubtreffen, monatliche Zeitschrift, Softwarebibliothek, Hardware, Funker, DFÜ, etc.

Diese Infos schicken Sie bitte an: Markt & Technik Verlag AG, Redaktion 64’er, Stichwort: Club, Hans-Pinsel-Str. 2, 8013 Haar bei München.

# Tips & Tricks gesucht

Jeder Computer und jedes Programm hat seine speziellen Schwachstellen und Unzulänglichkeiten. Allerdings ist kaum ein Programmierer oder Anwender auf Dauer bereit, sich damit abzufinden. Wo auch sorgfältigste Lektüre von Handbüchern nicht weiterhilft, da wird so manche Stunde experimentiert, um eine Lösung zu finden (die oft in einer Basic-Zeile Platz hat).

Wir suchen solche Tips und Tricks, um sie unseren Lesern zugänglich zu machen. Schließlich ist es wenig sinnvoll, sich wochenlang mit Problemen herumzuschlagen, die andere bereits gelöst haben.

Wenn Sie also interessante Tips für den Umgang mit Computer, Floppy, Drucker oder sonstiger Hardware haben, wenn Sie bei kommerzieller Software einige Kniffe kennen, die nicht in der Anleitung stehen, oderwenn Sie interessante Problemlö sungen statt in vier Seiten Listing in ein oder zwei Basic-Zeilen untergebracht haben, dann sollten Sie uns auf jeden Fall einmal schreiben.

Bitte geben Sie genau den Computertyp und die Gerätekonfiguration oder die Software an, und senden Sie Ihren Tip oder Trick an die

Redaktion 64'er
Markt& Technik Verlag
Aktiengesellschaft
Hans-Pinsel-Str. 2
8013 Haar bei München

# Floppy-Lister

> Mit einem einfachen SYS-Aufruf können Sie Programme und sequentielle Dateien direkt von Diskette listen. Programme im Speicher bleiben dabei erhalten.

»Floppy-Lister« bietet zwei Möglichkeiten ein Programm von Diskette zu listen. Basic-Programme und sequentielle Dateien können entweder als Klartext oder als Speicherauszug (Dumps) gelistet werden. Im Dumpmodus werden sämtliche Daten als Hexcodes ausgegeben und, soweit möglich, in ASCII-Zeichen übersetzt. Deshalb eignet er sich besonders zum Analysieren von unbekannten Programmdateien. Maschinenprogramme dürfen grundsätzlich nur auf diese Art gelistet werden, will man einen Absturz vermeiden.

Ist das Ladeprogramm mit dem MSE eingetippt, kann das Maschinenprogramm auf Diskette oder Kassette gespeichert werden. Der »Floppy-Lister« kann dann direkt geladen (LOAD ”name”, 8,1, oder LOAD ”name”, 1,1) und mitSYS 49152,"XY:filename” aufgerufen werden. Vergessen Sie nach dem absoluten Laden nicht, den erforderlichen NEU-Befehl im Direktmodus einzugeben, um die Basic-Zeiger in einen vernünftigen Zustand zu bringen. »X« steht für die Fileart: entweder »P« für Programm oder »S« für sequentielle Datei. »Y« steht für den Modus, in dem gelistet werden soll: »L«füreinfaches Listen und »D«für Ausgabe in Form eines Speicherauszugs. Zum Beispiel listet der Befehl SYS 49152,”SL:TESTSEQUENZ” eine sequentielle Datei mit dem Namen »TESTSEQUENZ«. Abkürzungen des Filenamens mit»*« sind erlaubt. Falsche Eingaben werden mit einer Fehlermeldung quittiert.

Mit der CTRL-Taste kann die Ausgabe verlangsamt und mit der RUN/STOP-Taste unterbrochen werden. Eine Fortsetzung erfolgt mit der A-, und vorzeitiger Abbruch des Listens mit der DEL-Taste. Am Ende eines Listings muß immer die SPACE-Taste gedrückt werden.

Das Maschinenprogramm für »Floppy-Lister« liegt im Bereich von $C000 -$C2B2 (49152-49842). An das Programm schließt sich noch ein Pufferbereich an, wo Daten zwischengespeichert werden. ’’Floppy-Lister” läuft mit den gängigen Erweiterungen, wie DOS 5.1, Simons Basic und Exbasic.

(B.Schulzki/hm)

# Durch POKEs zum Erfolg — Die Spiele-Trickkiste

Es gibt mittlerweile schon eine Unzahl von guten Spielen für den C 64. Bei vielen dieser Spiele ist es nicht nur dem »Durchschnittsspieler« fast unmöglich, jemals die höchste Spielstufe, den höchsten Level zu erreichen.

Aber deshalb braucht man noch lange nicht aufzustecken. Für viele Spiele gibt es »Spezial-POKEs«, die dem Spieler beispielsweise 99 statt 3 Leben schenken oder die Anzahl der zur Verfügung stehenden Raumschiffe fast beliebig steigern. Wie wäre es denn zum Beispiel, wenn Sie mit 98 statt mit nur 5 Hubschraubern gegen Fort Apocalypse vorgehen könnten, oder wenn Sie beim Miner 2049’er endlich einmal die letzten Bilder zu Gesicht bekämen ? Alles kein Problem, wenn man die richtigen Tricks (sprich POKEs) kennt.

Die nachfolgenden POKEs erheben jedoch keinen Anspruch auf Funktionsfähigkeit bei jeder Version der angegebenen Spiele. Der Grund dafür ist einfach: In der Regel gibt es von den meisten Spielen mehrere Versionen, nämlich einmal das Orginal, das in der Regel mit einem Autostart ausgestattet ist (und bei dem diese POKEs daher auch gar nicht erst eingegeben werden können), und zum andern eine Reihe sogenannter »Raubkopien«, etwas eleganter auch als »einteilige Versionen« bezeichnet.

Ganz offen gesagt: Unsere POKEs funktionieren in den meisten Fällen nur bei den einteiligen Versionen, und auch dort kann es von Version zu Version noch Unterschiede geben. Wir haben aus diesem Grunde lange gezögert, ob wir eine solche POKE-Liste veröffentlichen sollen. Zwei Gründe sprachen letztlich für eine Veröffentlichung:

Erstens ist es einfach eine Tatsache, daß es eine Unmenge von Raubkopien gibt. Man kann dazu stehen wie man will, durch totschweigen wird man den Software-Schwarzmarkt nicht austrocknen können.

Zweitens findet man in letzter Zeit häufiger Kleinanzeigen mit etwa folgendem Inhalt: »10 Super-Spiele-Pokes für C 64 nur 20 Mark (Schein/Scheck) an...«. Da opfert so mancher Jugendliche sein Taschengeld, um an Informationen zu kommen, die so geheim ja gar nicht sind.

Deshalb nimmt das 64’er-Magazin mal wieder überhaupt kein Blatt vor den Mund. Hier sind sie — die Super-POKEs !

(ev)

## Software statt Joystick

Angeregt durch die Veröffentlichung des »Fort Apocalypse« - POKEs in Ausgabe 9/84 und aufgrund der Tatsache, daß ich mit Sedezimalzahlen und Opcodes weitaus besser umgehen kann als mit Joysticks, habe ich mich entschlossen, mein spielerisches Unvermögen durch gezielten Softwareeinsatz auszugleichen. Hier nun meine bisherigen Ergebnisse:

### Fort Apocalypse

POKE 14697,0 : POKE 14760,0 : POKE 36366,0
Bei dieser Version hat man unendlich viele Hubschrauber, der Treibstoff geht nie aus und der Bonus wird nicht erniedrigt.

### Hunchback

POKE 9521,234 : POKE 9522,234 : POKE 9523,234
Hier hat man unendlich viele Helden !

### Neptune

POKE 7870,60
Damit stehen 60 (!) Taucher zur Verfügung.

### Jungle Hunt

POKE 2242,234 : POKE 2243,234
Der Held hat beliebig viele Leben.

(Frank Bastian)

## Neue POKEs für mehr Leben

Bei vielen Spielen ist es fast unmöglich, alle Bildschirme durchzuspielen, weil man viel zu wenig Leben, Raumschiffe etc. hat. Mit den folgenden POKE-Befehlen kann man die Programme aber so verändern, daß man endlich einmal auch in die höchsten Spielstufen gelangt. Dazu lädt man zunächst die einteilige (!) Version des Spiels, gibt den oder die POKEs ein und startet das Programm anschließend mit »RUN«.

TODO Table

Bei den folgenden Programmen muß man den Hauptteil, also den längsten Teil, mit »LOAD " Programmname ",8,1« laden, den angegebenen POKE eingeben und das Programm dann mit dem entsprechenden SYS-Befehl starten.

TODO Table

(Lukas Bauer)

# Noch mehr POKEs für mehr Spielspaß

Hier sind ein paar POKEs, die den Spaß am Spielen etwas erhöhen könnten:

TODO Table

(Gregor Geister)

## Miner 2049’er

Ärgert es Sie auch, daß Sie beim Miner 2049’er nie die letzten Bilder zu sehen bekommen ? Der Ärger ist unnötig, denn es gibt einen ganz einfachen Weg, um bis in die letzten Spielstufen zu gelangen. Sie brauchen nur die Leertaste oder wahlweise auch den Feuerknopf am Joystick konstant gedrückt halten. Nach einiger Zeit wird die aktuelle Spielstufe übersprungen, und man gelangt von selbst ins folgende Bild.

(Armin Robl)

## HilfsPOKE für »Gangster«

Besitzer des Spieles »Gangster« können aufatmen, denn ab sofort ist es möglich, auch in die letzten der 30 Bilder zu gelangen. Mit »POKE 5989,58« hat man statt der mageren fünf Spielfiguren nun sage und schreibe 128 (!) Gangster zur Verfügung. Sollte auch damit noch jemand Probleme haben, so ist ihm dringend zu raten, das Spiel zu wechseln.

Die merkwürdigen Zeichen, die nach diesem POKE in der Anzeige der verfügbaren Gangster erscheinen, haben auf die Spielbarkeit keinen Einfluß und können ignoriert werden.

Da die Gefahr besteht, daß man die Freude am Spiel verliert, sobald män alle Schwierigkeitsgrade überwunden hat, sollte man ab und zu auch regulär spielen. Es ist dann meist verblüffend, wie weit man auch ohne eine starke Gangster-Truppe kommt.

(Frank Herrmann)

## »Frantic Freddy « als Trainingsversion

Auf sehr einfache Art und Weise kommt man zu einer Trainingsversion von »Frantic Freddy«: Einfach das Spiel laden, dann »POKE 34535,24« eingeben und schließlich mit »RUN« starten. Man kann sich jetzt ohne Gefahr durch das ganze Spiel bewegen.

(Volker Bellendorf)

## Die Lösung von »Aztec-Tomb Part 1«

Ich löse mit Vorliebe Adventures und möchte mit dem Lösungsweg für »Aztec-Tomb Part 1« allen verzweifelten Abenteurern auf die Sprünge helfen, die bei diesem Spiel an irgendeiner Stelle nicht mehr weiterkommen. Hier ist die kürzeste Lösung:

go ladder, take chest, go down, go south, look hall, take jar, go west, look bed, go trapdoor, take cloak, wear cloak, look cellar, take key, open chest, drop chest, drop key, take sword, take rope, go up, open draw, look draw, take key, go east, open door, drop key, go door, climb building, take wood, go down, go south, drop wood, go east, look pool, catch fish, go west, go bridge, go south, take mouse, go north, go west, remove cloak, throw cloak, go gate, take cloak, look fish, fill jar, empty jar, fill jar, emptyjar, climb beanstork, drop mouse, go path, go valley, go south, throw rope, climb rope, give cloak, take box, open box, take map, look map, drop box, go down, go north, go east, go harbour, go boat, look boat, go cabin, take torch, go hatch, cross north, go island, light torch, go hole, take jacket, wear jacket, go up, unlit torch, go boat, cross north, cross east, cross south, jump over, swim, go beach, go forest, go north, climb statue, take diamond, go down, go east, look wall, insert diamond, light torch, go passage.

Damit haben Sie den ersten Teil von Aztek-Tomb erfolgreich hinter sich gebracht. Ich hoffe, daß Ihnen diese Lösung in der einen oder anderen verfahrenen Situation weiterhelfen kann.

(Wolfgang Habich)

# Hexereien: undefinierte Opcodes beim 6502

> Im folgenden Artikel sollen einmal diejenigen Hex-Zahlen unter die Lupe genommen werden, die ein 6502-Disassembler normalerweise nur mit einem höhnischen Fragezeichen quittiert.

Sicherlich ist Ihnen, sofern Sie sich mit Maschinensprache befassen, schon aufgefallen, daß der bekannte Befehlssatz des 6502-Mikroprozessors nicht alle 256 Bitkombinationen eines Bytes ausnutzt. Es existieren neben den bekannten, in jedem Assembler-Handbuch dokumentierten 6502-Befehlen noch eine ganze Reihe undefinierter Opcodes. Der Begriff »undefiniert« bedeutet dabei nur soviel wie »nicht dokumentiert«, denn diese Opcodes haben in vielen Fällen durchaus eine sinnvolle Wirkung.

Da viele Commodore-Systeme mit dem 6502 arbeiten, habe ich mir einmal die Mühe gemacht, die für diese CPU offiziell nicht implementierten Hex-Zahlen, die sich immer wieder vereinzelt zwischen die bekannten 6502-0pcodes einschieben, auf ihre Wirkung hin zu untersuchen. Dabei hat sich manch unscheinbare Hex-Zahl als recht brauchbar entpuppt. Nachfolgende Erkenntnisse habe ich auf meinem C 64 gesammelt, der ja mit einem 6510 bestückt ist, die Ergebnisse sind aber auch auf den 6502 übertragbar.

Die untersuchten Bit-Kombinationen lassen sich in vier Befehlskategorien unterteilen:

**Gruppe 1**: Diese Befehle führen den Prozessor zu einem Systemabsturz, Sie können dann den Computer nur noch mit einem RESET aus seinem Dornröschenschlaf befreien (oder das Gerät ausschalten). Alle »Absturzbefehle« sind dadurch kenntlich, daß ihr niederwertiges Nibble (1 Nibble = 4 Bit) »2« ist (Beispiel: $02,$12). Aber: Nicht alle Hexzahlen mit niederwertigem Nibble »2« führen zum Absturz (Beispiel: $A2 entspricht in Assemblersprache »LDX«),

**Gruppe 2**: Diese Befehlsgruppe bewirkt rein gar nichts, es gibtsie in 3-, 2- und 1-Byte-Ausführungen, zu den letztgenannten gehört ja auch unser gutes altes »NOP«.

Die Befehle der Gruppen 1 und 2 sind in Tabelle 1 zusammengestellt.

**Gruppe 3**: Nun wird’s interessant. Der Prozessor führt zwei »offizielle« Befehle unmittelbar hintereinander aus. Diese verwenden die gleiche Adressierungsart. Ein Beispiel: Die Hex-Zahlenkombination E7 DD führt die beiden Assemblerbefehle »INC DD;SBC DD« (Zeropageadressierung) aus, sie bewerkstelligt dieses in 2 Byte, wozu der »offizielle« Befehlssatz 4 Byte benötigte. Es sind alle vom »STA«-Befehl her bekannten Adressierungsarten auf die Befehlsgruppe 3 anwendbar. Daraus resultiert folgendes Phänomen: Die Hexkombination E3 DD führt die Assemblerbefehle »INC (DD,X)« aus, obwohl es die indirekt-indizierte Adressierung für den »INC«-Befehl eigentlich gar nicht gibt.

Tabelle 2 zeigt alle möglichen Kombinationen. Beispiel: Sie möchten wissen, was geschieht, wenn der 6502 auf die Hex-Zahl C7 trifft. Dazu suchen Sie diese Zahl in der Tabelle 2. Sie steht in der letzten Spalte der Zeile 5. Am linken Zeilenrand finden Sie nun die Befehlskombination, die obersten beiden Zeilen der letzten Spalte geben die Adressierungsart sowie die Befehlslänge in Bytes an. C7 MM würde also dieselbe Wirkung haben, wie die Assemblerbefehle »DEC MM:CMP MM« zusammen.

Die Ausführungszeit der Befehle der dritten Befehlsgruppe ist dieselbe, als wenn nur ein offizieller Opcode der gleichen Adressierungsart ausgeführt würde. E7 DD ist in der Ausführung also genauso schnell wie der Assemblerbefehl »INC DD«.

Als besonders brauchbar würde ich die Befehlskombination »DEC ...: CMP...«(für Schleifenzwecke) und Rotations/Schiebebefehle in den hierfür sonst nicht vorhandenen Adressierungsarten »(..,X)« und »(..),Y« (für hochauflösende Grafik) bezeichnen.

**Gruppe 4**: Diese Befehle sind nur sehr schlecht durch bekannte Opcodes zu ersetzen; sie sind in Tabelle 3 beschrieben.

Zum Abschluß noch eine Warnung. Überlegen Sie sich den Gebrauch dieser neuen Befehle gut, denn sie machen jedes noch so gut strukturierte Programm zunichte. Insbesondere ist zu beachten, daß die hier beschriebenen undefinierten Opcodes nicht bei jeder Prozessorversion die gleiche Wirkung haben müssen. Schließlich handelt es sich dabei ja nur um unbeabsichtigte Nebenprodukte bei der Implementierung des 6502-Standard-Befehlssatzes.

(Jürgen Urban/ev)

# Autoboot beim C 64

> Tippen Sie zwei Zeilen im Direktmodus ein, und Ihr Programm verhält sich wie die meisten professionellen Programme — es startet nach dem Laden der Diskette von selbst.

Es gibt verschiedene Techniken zum automatischen Booten von Programmen. Die hier vorgestellte zeichnet sich dabei durch besondere Einfachheit aus.

Denken Sie sich zunächst einen neuen Namen für das Programm aus, das Sie autobootfähig machen wollen. Laden Sie nun Ihr Programm in den Computer. Tippen Sie sodann den folgenden Text:
PRINT”{CLR}POKE45,”PEEK(45)”:POKE46,”PEEK(46)” :RUN”.

Drücken Sie RETURN. Dies löscht den Bildschirm und schreibt folgendes in die oberste Zeile:
POKE45, n1 :POKE46, n2 :RUN

wobei anstelle von n1 und n2 die Inhalte der Speicherstellen 45 und 46 als Zahlenwerte erscheinen, die von der Länge Ihres Programmes abhängig sind. Zwei Zeilen tiefer steht dann »READY« mit dem blinkenden Cursor darunter.

Gehen Sie mit der CURSOR DOWN-Taste zwei Zeilen tiefer und schreiben Sie:
POKE631,19:POKE632,13:POKE198,2:POKE43,198: POKE44,0:SAVE"0:NEUER NAME",8
und drücken Sie die RETURN-Taste. Natürlich können Sie jeden beliebigen Namen statt »Neuer Name« verwenden.

Ihr Autoboot-Programm wird nun auf Diskette gespeichert. Die »SYNTAX ERROR«-Meldung, die Sie nach dem Speichern erhalten, können Sie ignorieren. Gehen Sie jetzt mit dem Cur- 1 sor auf eine leere Zeile, wo Sie POKE43,1:POKE44,8 tippen und RETURN drücken. Dann ist alles wieder beim alten, und der Computer befindet sich im Ausgangszustand.

Das Programm kann nun jederzeit mit »LOAD”NEUER NAME”,8,1« wieder geladen werden. Vergessen Sie dabei nicht, zuvor NEW zu schreiben und bedenken Sie, daß die Sekundäradresse 1 in »LOAD”NN”,8,1« unbedingt erforderlich ist, um alles an den richtigen Platz zu bringen.

Das eben beschriebene Verfahren funktioniert wie folgt: Durch »POKE 43,198:POKE44,0« wird der Basic-Anfang heruntergesetzt und so das Programm zusammen mit allen Speicherplätzen ab 198 auf Diskette gespeichert, inklusive den Speicherstellen 631 und 632 des Tastaturpuffers, der Speicherstelle 198 für die Anzahl der im Tastaturpuffer gespeicherten Zeichen sowie dem Bildschirmspeicher von 1024 bis 2023. Dies ermöglicht die Benutzung der »Dynamic Keyboard«-Technik, so daß der Computer gleich nach dem Laden die in den Textspeicher geschriebenen Befehle durchführt.

Der Cursor wird durch das POKE631,19 auf die Home-Position geführt, findet dort die Zeile POKE45,n1:POKE46,n2: RUN vor, und das POKE632,13 läßt ihn genau diese Zeile ausführen.

Die POKEs in 45 und 46 sind dabei notwendig, um den Vektor für das Programmende wieder richtig zu setzen. Das vom RUN automatisch mit ausgeführte CLR setzt auch die übrigen Vektoren von 47 bis 52 auf die richtigen Werte. Ein Gratis- | Bonbon, das Sie mit dieser Technik erhalten, ist die Möglichkeit, mit POKE808,234 in der ersten Zeile Ihres Programmes das Anhalten und Listen verhindern zu können, so daß kein Unbefugter Ihr Programm kopieren kann.

(Prof. Hartmut Ginnow-Merkert/ev)

# Fehlerteufelchen

### 3-D Vier gewinnt, Ausgabe 12/84, Seite 99

Der korrekte Befehl für die Zeile 2543 lautet: GOSUB 2900:RX (Y,Z) = H

### Hypra-Load mal vier, Ausgabe 1/85, Seite 83

Da schafft man es doch tatsächlich, runde 1500 DATAs richtig abzudrucken (gemeint ist Hypra-Load in Ausgabe 10/84), und wenn man vier POKE-Befehle angibt, ist die Hälfte davon falsch. Hier sind die korrigierten POKEs für Hypra-Modul:
POKE 3301,130:POKE 3332,128
POKE 3364,133:POKE 3377,132

### Richtig verbunden, Ausgabe 2/85, Seite 22

In Bild 3 muß es bei der Belegung der Pins nicht 18 sondern 8 heißen. Pin 8 führt 12V Schaltspannung, Pin 181iegtaufMasse. Außerdem wurden die Bilder 4 und 5 vertauscht. Ein monochromer Monitor wird also an Pin 1, ein Farbmonitor an Pin 4 der Video/Audio-Buchse des C 64 angeschlossen.

### Grab des Pharao, Ausgabe 2/85, Seite 57

In Zeile 780 muß das GOTO 50000 in GOTO 50211 geändert werden. Zwischen den Zeilen 19129 und 19130 taucht auf Seite 61 wahrscheinlich durch einen Fehler im Betriebssystem die Zeile 19002 mit verändertem Inhalt nochmal auf. An dieser Stelle ist die Zeile 19002 nicht einzutippen.

### MSE, Ausgabe 2/85, Seite 69

Die fehlenden Zeilen im MSE-Lader in der Ausgabe 2/85 sind in dieser Ausgabe beim MSE besonders gekennzeichnet.

## Sonderheft

### SH1, Fileprotect, Seite 62

Die Zeilen 2470 und 2480 müssen, um einen Absturz in der Protect-Ebene zu vermeiden, folgendermaßen geändert werden:
2470 IFP = 1THENFT=(FT{SPACE} OR{SPACE}64)
2480 IFP = 0THENFT=(FT{SPACE} AND{SPACE}255-64)

Wichtig ist dabei, daß die Zwischenräume {SPACE} eingegeben werden. Dieser fehlende Zwischenraum ist leider auch auf der Diskette vorhanden. Die Anwender dieser Diskette müssen also die Blanks in 2470 und 2480 nachträglich noch einfügen.

(Klaus Dieter Kupfermann)

### Leserforum, Hier gibt’s Mailboxnummern, Ausgabe 1/85, Seite 15

Bitte folgende Nummern aus der Liste nicht mehr anrufen, es handelt sich dabei um private oder reprivatisierte Telefonnummern, oder um Mailboxen, die aufgegeben wurden.
0202/448202, 0202/448204, 02366/38536, 040/5246387, 06826/2234, 069/835037
Folgende Mailboxnummern haben sich geändert:
Toelleturm 0202/559350
MCS Karlsruhe 0721/685010
Cyber 809/280310

Wir bitten alle SysOps, diese Änderungen beziehungsweise Streichungen in Ihren Mailboxen vorzunehmen.

# Bücher

## Rombachs C 64-Spieleführer

Schon seit einigen Wochen gibt es den Rombach C 64-Spieleführer, der eine Übersicht über den Spielemarkt geben soll.

Daß gerade die besonders guten Neuerscheinungen der letzten Wochen in diesem Buch kaum erwähnt werden, kann ihm, aufgrund des Redaktionsschlusses Ende September, nicht zur Last gelegt werden.

Aber nun zum tatsächlichen Inhalt des Buches: Auf über 400 Seiten im leider schon üblichen Epson-Matrixdruck werden gut 800 Spiele beschrieben und bewertet. Eine klare Linie ist bei diesen Bewertungen aber nicht zu erkennen. Verkaufsrenner wie »Space Pilot« werden aufgrund ihres »Ballercharakters« mit 5, der schlechtesten Note, ausgezeichnet, während manches andere Kriegsspiel, zum Beispiel »Blue Max«, eine glatte 1 wegen guter Gestaltung erhält. Ähnlich verhält es sich bei vielen anderen Spielen, die im Vergleich entweder stark über- oder unterbewertet werden.

Ein hoher Anteil der beschriebenen Spiele ist im Fach- oder Versandhandel gar nicht erhältlich, da es sich hier meist um Programme handelt, die von Privatpersonen mehr wohl aus Spaß an der Freud’ geschrieben worden sind, als zum späteren Vertrieb. Solche Spiele werden dann auch noch folgendermaßen kommentiert: »Die einzigen, die sich jemals über das Programm gefreut haben dürften, waren wohl die Programmierer, voller Stolz über ihr Erstlingswerk.« Solche boshaften Kommentare sind bei vielen Spielen wegen ihrer oben angesprochenen Herkunft völlig unberechtigt. Da hätte man doch lieber gar nichts über sie geschrieben.

Interessant ist auch, daß bei zirka 10 Prozent der Spiele keine Angaben über Vertriebsquellen, sondern nur ein lapidares »ohne Copyrightangabe« steht.

Dazu fällt noch auf, daß bei sehr vielen, eigentlich kopiergeschützten Spielen sowie Modulprogrammen (!), Angaben über die Länge in Blocks auf einer Diskette gemacht werden.

Sierra On-Line wird sich übrigens wundern, daß, laut Rombachs Spieleführer, das Copyright für Threshold bei den Jedi’s liegt, deren Signatur so manche Raubkopie ziert.

Bei Betrachtung all der angesprochenen Punkte stellt sich dann natürlich die Frage, ob hier die Softwareliste eines Raubkopierers als Arbeitshilfe diente, oder ob gar Raubkopien getestet worden sind.

Meiner Ansicht nach ist dieses Buch nur für denjenigen brauchbar, der seine Softwaresammlung sortieren, oder privat Programme tauschen oder kaufen möchte. Für den ernsthaften Spielekäufer ist der Gang zum Fachhandel, wo man sich Spiele jederzeit vorführen lassen und sich selber ein Urteil bilden kann, durch dieses Buch nicht zu ersetzen, insbesondere, wenn es um Neuerscheinungen geht.

(Boris Schneider)

Info: Oswald Reim/Martin Scholer, Rombachs C 64-Spieleführer, Rombach Verlag 1984, 410 Seiten, 24,80 Mark

## Goldmann Computer Compact

In letzter Zeit drängen verstärkt die etablierten Taschenbuchverlage wie Heyne und Rowohlt auf den Computerbuchmarkt. Auch der Goldmann-Verlag gibt einige Taschenbücher zum Thema Computer in der Reihe »Goldmann Computer« heraus. Mit Preisen zwischen 10 und 15 Mark sollen wohl hauptsächlich die Jüngeren, die mit einem schmalen Taschengeld versehen sind, angesprochen werden.

Für uns besonders interessant sind natürlich die drei C 64-spezifischen Bücher.

Das erste heißt schlicht und einfach »Commodore 64« und trägt den Untertitel »Eine Einführung in Betrieb und System«. Es richtet sich also an die absoluten Computer-Anfänger. Deswegen werden auch sehr genau Begriffe wie Hard- und Software, RAM und ROM und ähnliches erklärt. Darauf wird dann der Umgang mit dem Computer selbst, der Tastatur, Kassettenrecorder, mit Diskettenlaufwerken und ROM-Modulen beschrieben. Natürlich werden auch bald erste Gehversuche in Basic gemacht. Abgerundet wird das ganze mit einem Überblick über die erhältliche Hard- und Software. Insgesamt ein für Anfänger recht empfehlenswertes Buch.

Nicht ganz so positiv fällt das Urteil dagegen bei den beiden anderen Büchern aus.

»Commodore 64 Basic« soll eine Einführung in Basic sein. Um es gleich vorweg zu nehmen: Das Original-Commodorehandbuch bietet gleiches an Informationen zum »Nulltarif«.

Außerdem kann einen schon das zweite Kapitel zur Verzweiflung bringen. Dort wird nämlich erklärt, wie der C 64 in Betrieb gesetzt wird. Bei der Übersetzung ist aber nicht beachtet worden, daß sich die amerikanischen C 64 von den europäischen im TV-Modulator stark unterscheiden. So wird man zum Beispiel am C 64 vergeblich einen Schalter von Kanal 3 auf 4 suchen.

Das einzige, was den Basic-Lehrteil vom Handbuch unterscheidet, sind die eingestreuten Übungsaufgaben, die allerdings nur teilweise mit Lösungsvorschlägen versehen sind. Auch die abschließende Erklärung aller Basic-Befehle unterscheidet sich qualitätsmäßig nicht von der im Handbuch.

Ähnlich verhält es sich mit dem Buch »Commodore 64 Graphics«. Auf 80 Seiten wird folgendes präsentiert:

Anschluß des C 64 mit einem haarsträubenden Funktionstest (»Geben Sie den Namen Ihres Lieblingsmusikers ein, drücken Sie RETURN, kommt SYNTAX ERROR ist der Computer in Ordnung«), Einführung in Basic, einfache Grafiken mit dem PRINT-Befehl.

Auf Seite 62 erfährt man dann schließlich, daß man auch in den Bildschirmspeicher POKEn kann.

Ganze 11 Seiten widmen sich noch den Sprites. Dieser Abschnitt läßt derart viele Fragen offen, daß man sich richtig nach dem Handbuch zurücksehnt, das wenigstens noch eine Registertabelle der Spriteregister im VIC enthält. Die einzige Tabelle im vorliegenden Buch wurde sogar aus dem Handbuch übernommen und zeigt die ASCII- und CHR$-Codes.

Wie Sie sich vielleicht schon denken, wird die hochauflösende Grafik wie bei Commodore nur in der Werbung (sprich Rückseitentext) erwähnt.

Ein recht trauriges Fazit muß man da ziehen. Diese Bücher sind zwar, verglichen mit anderer Computerliteratur sehr preiswert, gegenüber anderen, vom Umfang gleichwertigen Taschenbüchern jedoch wiederum recht teuer. Und leider sind sie, bis auf das erste, ihr Geld wohl nicht wert.

(Boris Schneider)

Info: Michael Boom, Commodore 64, Goldmann 1984, zirka 100 Seiten, 9,80 Mark Richard G Peddicord, Commodore 64 Basic, Goldmann 1984, zirka 100 Seiten, 9,80 Mark

Richard G Peddicord, Commodore 64 Graphics, Goldmann 1984, zirka 80 Seiten, 9,80 Mark

## Das Cassettenbuch

Das Cassettenbuch von Data Becker beschreibt in aller Ausführlichkeit (als Ergänzung zum Commodore-Handbuch) das Zusammenarbeiten zwischen Computer und dem Datenrecorder (Datasette). Da ist zunächst die Beschreibung aller Befehle, die mit dem Zugriff des VC 20 oder C 64 auf die auf Band abgespeicherten Daten und Programme zu tun haben. Dies bezieht sich sowohl auf Basic, als auch auf die entsprechenden Kernalroutinen, die das Arbeiten mit Maschinenprogrammen ermöglichen. Natürlich fehlt es auch nicht an guten' Ratschlägen, die sich aufden Recorder selbst beziehen, wie zum Beispiel die Pflege der Andruckrollen oder das Nachjustieren des Schieib-/Lesekopfes. Auch eine Mithörkontrolle und ein Selbstbau-Kassetteninterface werden, wenn auch etwas kurz, beschrieben.

Der zweite Teil des Buches bezieht sich auf ein Fasttape-Programm (ein ähnliches ist im 64’er, Ausgabe 12 erschienen), mit dem es möglich sein soll, Programme und auch Daten 10- bis 20mal schneller abzuspeichern. Für den VC 20 (und dies betrifft viele Käufer dieses Buches) ist eine Programmversion abgedruckt, die nur bei einem voll ausgebauten (28 KByte) Speicher funktioniert. Um die Routinen in einem andern Speicherbereich laufen zu lassen, müssen sie vom Leser (!) umgeschrieben werden.

Auf diese Routinen aufbauend werden dann einige andere Programme wie beispielsweise ein Kassettenverzeichnis oder ein Backup-Programm entwickelt. Diese Routinen sind alle ausführlich beschrieben und kommentiert. Was den Profi jedoch enttäuschen wird, ist das fast gänzliche Fehlen einer Beschreibung der im Betriebssystem verankerten Kassettenroutinen. Auch eine in diesem Zusammenhang notwendige Beschreibung der Ein-/Ausgabebausteine fehlt in diesem Buch. Dafür findet man einen Hinweis auf andere Data Becker-Bücher — eine sicherlich nicht sehr befriedigende Situation.

Auch bezüglich des Aufzeichnungsformats sind die Ausführungen des Autors sehr knapp gehalten und obendrein scheinbar direkt den »Tips & Tricks«-Handbüchern des gleichen Verlages entnommen.

Wegen der gut lesbaren und informativen Einführung in das Arbeiten mit der Datasette, ist das Cassettenbuch mit seinen zahlreichen Programmen trotz einiger Schwächen eine rentable und empfehlenswerte Anschaffung für den fortgeschrittenen Einsteiger.

(Christoph Sauer)

Info: Dirk Paulissen, Das Cassettenbuch zu C64 und VC 20, Data Becker 1984, ISBN 3-89011-030-4, 192 Seiten, 29 Mark.

# Tips und Erweiterungen zu Hi-Eddi und Simons Basic

> Sie haben sicher schon selbst festgestellt, wie hervorragend das Listing des Monats aus der Ausgabe 1/85 ist, unser »fantastisches Zeichen- und Mal-Programm«. Der Autor des Hi-Eddi hat jedoch noch etwas weitergearbeitet und stellt kleine Programme vor, die es ermöglichen, mit Simons Basic erstellte Bilder in Hi-Eddi zu laden. Außerdem gibt es eine Reihe von Tips, die die Arbeit mit Hi-Eddi erleichtern.

Simons Basic bietet leider keine Möglichkeit, High-Resolution-Bilder auf Diskette zu speichern und zu laden. Dies ist jedoch Voraussetzung, um Bilder, die mit Simons Basic erstelltwurden, auch in Hi-Eddi und andere Programme zu laden.

Ich habe deshalb das Programm »Screensave« (Listing1) geschrieben, das die Simons-Basic-Befehle »SCRSV« und »SCRLD« um die Fähigkeit, Hires-Bilder zu laden und zu speichern, erweitert. Leider funktioniert das nicht für die Modul-Version, da direkt das Simons Basic modifiziert wird. Dafür wird kein Speicherplatz außerhalb des Simons Basic gebraucht. Außerdem ist die modifizierte Version abspeicherbar, nach ihrem Laden stehen die erweiterten Befehle sofort zur Verfügung, ohne ein weiteres Programm nachladen zu müssen.

### Hinweise zum Eintippen:

- Simons Basic starten
- »Screensave« eintippen, sicherheitshalber abspeichern und starten
- Nachdem alle DATA-Fehler beseitigt wurden, stehen die erweiterten Befehle »SCRSV« und »SCRLD« zur Verfügung: Die Syntax ist dieselbe wie bisher, mit der Sekundäradresse wird jetzt der Bildschirm gewählt:
Sekundäradresse = 2: Low-Resolution-Bildschirm,
Sekundäradresse = 3: High-Resolution-Bildschirm

Das Aufzeichnungsformat des Low-Resolution-Bildschirmes ist leider nicht kompatibel mit dem der alten Befehle. Das des High-Resolution-Bildschirmes ist dasselbe wie bei Hi-Eddi, Diashow und anderen Grafikprogrammen. Dazu muß das Bild aber unbedingt als PGM-File, also zum Beispiel mit:
SCRSV1,8,3,»NAME,P,W«
abgespeichert werden, da Hi-Eddi keine SEQ-Files laden kann.

Zum Abspeichern des »neuen« Simons Basic dient das Programm »Saver« (Listing 2). Dieses Programm speichert nicht nur das komplette Simons Basic, das übrigens auch noch andere Modifikationen, zum Beispiel die aus 64’er Ausgabe 11/84, enthalten kann, sondern auch die Funktionstastenbelegung mit ab. Nach dem Laden der mit »Saver« erstellten Simons-Basic-Version stehen somit nicht nur die neuen Befehle, sondern auch die individuelle Funktionstastenbelegung sofort zur Verfügung.

### Hinweise zum Eintippen:

- Funktionstasten nach eigenen Wünschen belegen
- »Saver« eintippen, abspeichern, eine Diskette mit mindestens 66 freien Blocks einlegen und Programm starten. Nun fragt der »Saver« nach dem Namen, unter dem er die neue Version ablegen soll. Diese neue Version ist um einen Block länger als die alte (66 statt 65), da die Funktionstastenbelegung hinzugekommen ist.

## Tips zu Hi-Eddi

Erfreulicherweise ging das Druckfehlerteufelchen bei den Listings offensichtlich leer aus, denn schon einige Tage nach Erscheinen des Heftes meldete sich der erste, der nicht nur das komplette Programm abgetippt, sondern auch gleich das Beispiel-Menü abgepinselt hatte und alles lief einwandfrei. Im folgenden möchte ich auf die Fragen der Anrufer eingehen.

### Druckeranpassung

Die Anleitung in den REM-Zeilen des Programms»Hi-PRINT.DATA« ist zugegebenermaßen etwas dürftig ausgefallen, so daß eine ausführlichere Erklärung dringend nötig ist:

Wie schon in der Bedienungsanleitung erwähnt, beschränkt sich die Anpaßbarkeit dieses Programms auf 8-Nadel-Drucker mit »vernünftiger« Einzelnadelansteuerung, wie zum Beispiel Drucker von Epson oder Mannesmann (im Gegensatz zum 1526/MPS 802). Mit dem Datum in Zeile 420 wird zwischen dem seriellen Bus (also Hardware-Interface) oder dem User-Port gewählt. Im ersten Fall muß mit den Daten in Zeile 440 (Primäradresse) und 460 (Sekundäradresse) das Interface auf Direktmodus gestellt werden. Hardwareinterfaces bieten in der Regel verschiedene Betriebsmodi (zum Beispiel Emulation eines Commodore-Druckers, spezielle List- oder Grafikmodi und eben den Direktmodus oder Linearmodus), die meist über die Sekundäradresse angewählt werden. »Hi-PRINT« braucht den Direktmodus, in dem sich das Interface wie ein einfaches Kabel verhält und die Bytes vom Computer unverändert an den Drucker übergibt. Für das Data-Becker-Interface muß zum Beispiel die Sekundäradresse 1 eingegeben werden, für das Görlitz-Interface 4 oder 12 (ohne beziehungsweise mit Auto-Linefeed). Beim Anschluß an den User-Port sind die Daten in Zeile 440 und 460 zwar nicht relevant, man darf sie jedoch nicht weglassen, da sonst die nachfolgenden DATAs verschoben würden.

Aus dem gleichen Grund dürfen auch die Längen der folgenden DATA-Zeilen nichtverändertwerden, sie müssen nach Bedarf mit 255 aufgefüllt werden. Außerdem muß jede dieser Zeilen mit mindestens einem 255 enden, da diese Zahl als Ende-Kennzeichen einer Sequenz dient.

Die Zeile 530 legt die Sequenz für einen Carriage-Return Linefeed fest, sie ist 13,255,255 für Drucker mit Auto-Linefeed und 13,10,255 für Drucker ohne Auto-Linefeed.

Zeile 550 stellt den Drucker auf den für Grafik passenden Zeilenvorschub ein. Für den Epson RX-80 ist dies zum Beispiel ESC »3« 23 oder in Zahlen 27,51,23, aufgefüllt mit 255 auf die erforderliche Länge.

In Zeile 580 wird der Grafikmodus (Bit-Image-Mode) für 640 Punkte/Zeile angesteuert. Beispiele:

Epson RX-80: ESC »*« 4 entspricht 27,42,4 Mannesmann
MT-80: ESC »K« entspricht 27,75
TODO

In Zeile 600 wird wieder der normale Zeilenabstand eingestellt (ESC »2«) und die -2 in Zeile 610 signalisiert für den DATA-Lader das Ende der DATAs.

### Betrieb mit der Datasette

Ich besitze selbst keine Datasette, so daß die hier gegebenen Hinweise nicht getestet sind:

Zunächst muß in den Listings 1 und 2 (Hi-Exe und Hi-PRINT) die »8« in den OPEN-Befehlen durch eine »1« ersetzt werden. Dasgleichegiltfüralle LOAD-Befehleim Listing 3 (Hi-Eddi). An diesem Listing müssen außerdem noch die folgenden Änderungen vorgenommen werden:
Zeile 300: POKE8115,8 durch POKE8115,1 ersetzen
Folgende Zeilen müssen gelöscht werden:
200,210,220,340,400
Folgende Zeilen müssen dafür eingefügt werden:
200 RETURN
400 RETURN

Auf der Programmkassette speichert man die Files dann am besten in folgender Reihenfolge ab:

1. Hi-Eddi (Listing 3)
2. Hi-Exe (Das von Listing 2 erzeugte Maschinenprogramm, nicht den Data-Lader!)
3. Menü
4. Hi-PRINT (Das von Listing 1 erzeugte Maschinenprogramm)

Die Overlay-Technik gestaltet sich mit der Datasette natürlich nicht so komfortabel wie mit der Diskette: Nachdem zu Beginn eines Druckvorganges die Druckerroutine geladen wurde, muß die Kassette wieder zurückgespult werden, damit nach dem Drucken das Maschinenprogramm »Hi-Exe« wieder geladen werden kann.

### Koala- und Paint-Magic-Bilder

In Ausgabe 1/85 wurde schon erwähnt, daß auch die Bilder von Paint Magic und Koalapainter geladen werden können. Das ist richtig, aber man muß einiges dazu wissen:

## Laden von Bildern

Bei Schwarzweiß-Bildern, wie die der Diashow, Supergrafik oder natürlich des erweiterten Simons Basic geht’s problemlos. Bei Grafikprogrammen, die im Multicolour-Modus arbeiten, treten zwei Schwierigkeiten auf:

1. Da Hi-Eddi im High-Resolution-Modus arbeitet, sehen Multicolour-Bilder recht ungewöhnlich aus. Dabei kommt es vor allem auch auf die Farborganisation des betreffenden Programmes an: Die des Koalapainter ist so chaotisch, daß dessen Bilder im »Hi-Eddi« fast unbrauchbar sind (Ein und dieselbe Farbe erhält verschiedene Multicolour-Codes). Paint-Magic-Bilder sind dagegen sofort »druckreif«.
2. Für Multicolour-Bilder gibt es kein einheitliches Format für die Speicherung auf Diskette, so daß viele Bilder nicht direkt von »Hi-Eddi« geladen werden können.

Für den Koalapainter tritt die 2. Schwierigkeit nicht auf, seine Bilder lassen sich sofort laden. Den Filenamen gibt man dabei in der Form »?PIC...« ein, um das Steuerzeichen am Anfang auszutricksen. Dajedoch Koala-Bilder länger sind als die vom »Hi-Eddi«, werden Farbinformationen nicht nur des geladenen, sondern noch eines weiteren Bildes überschrieben. Nach dem Laden eines Koala-Bildes herrscht somit buntes Chaos im Computer, das erst durch Neu-Einfärben beseitigt werden muß.

Etwas komplizierter wird’s bei Paint Magic, dessen Bilder sich nicht direkt laden lassen, da sie in Form eines Basic-Laders abgespeichert werden. Man muß erst ein Bild mit »LOAD”..”,8« laden, dann mit RUN starten, anschließend »Hi-Eddi« laden und in Betriebsart 1 starten. Die 1 ist nötig, damit »Hi-Eddi« das im Speicher befindliche Bild nicht löscht. Außerdem darf »Hi-Eddi« nicht im Farbbetrieb gestartet werden, da das Paint-Magic-Bild im Speicherbereich $4000-$6000 liegt, wo »Hi-Eddi« sonst seine Farbinformationen ablegen würde. Nach dem Start ist das Bild in Speicher Nummer 7 zu finden.

Lädt man übrigens im Schwarzweiß-Betrieb ein Farbbild (36 Blocks), dann wird auch hier durch die Farbinformation ein Teil eines anderen Bildes überschrieben, was sich durch »Gerümpel« in den ersten paar Zeilen dieses Bildes bemerkbar macht.

### Laden von »Hi-Eddi«-Bildern in Basic-Programmen

Will man »Hi-Eddi«-Bilder in normalen Basic-Programmen (oder mit der Simons Basic Modulversion) laden, dann tut’s das Listing »Pic-Lader (Listing 3), das natürlich in eigene Programme eingebaut werden kann. Das Bild wird unter das Betriebssystem-ROM gelegt, der Farbspeicher ab $C000 (=49152, wie bei Simons Basic). Damit wird kein Basic-Speicherplatz belegt. Allerdings dürfen nur Schwarzweiß-Bilder (33 Blocks) geladen werden, bei Farbbildern gibt’s einen Absturz.

### Fehler

Falls Sie erwartet haben, daß ich Ihnen jetzt irgendwelche schwerwiegende Fehler mitteile, muß ich Sie enttäuschen. Lediglich ein paar Kleinigkeiten sind mir aufgefallen:

Auf Seite 51, in der Bildüberschrift zum Ottomotor, steht »sieben Bilder pro Sekunde«. Das gilt jedoch für große Bilder. Die Viertelbilder dagegen werden mit maximal 24 Bilder pro Sekunde abgearbeitet. Und auf Seite 60, rechts oben, vierte Zeile, müßte es natürlich heißen »Felder« und nicht »Fehler«.

Auch am Programm selbst sind mir noch vier Kleinigkeiten aufgefallen:

1. Bei einem STOP/RESTORE schreibt das Betriebssystem ein paar Bytes in den RAM-Bereich über $E000. Diese sind dann in einem der Bilder am unteren Rand als »Gerümpel« zu sehen.
2. Beim Befehl »Paint« kann es bei extrem verwinkelten Flächen vorkommen, daß Teile übersehen werden (Grund dafür ist der begrenzte Stack des 6510). Diese müssen eben extra aufgefüllt werden.
3. Der Sequenzstring sollte nicht länger als zirka 40 Zeichen werden, sonst könnte es bei LOAD oder SAVE zu einem OUT OF MEMORY ERROR kommen. Sollte das passieren, so muß Hi-Eddi mit GOTO 150 gestartet und der Sequenzstring verkürzt werden.
4. Bei gewaltigem »Herumwürgen« am Joystick kann es vorkommen, daß der Computer meint, es wurde eine Taste gedrückt. Ergebnis istdann eine Befehlsausführung, die man gar nicht wollte. Allerdings passiert das äußerst selten, vielleicht liegt’s auch nur an meinem mickrigen Joystick. Wenn ansonsten mal ein Befehl nicht das tut, was er sollte, dann liegt es meistens an einer eingerasteten SHIFT-LOCK-Taste. Bei Befehlen, die die SHIFT-Taste nicht benutzen, fällt es gar nicht auf. Will man jedoch zum Beispiel den Före-Modus anwählen und färbt statt dessen das ganze Bild ein, dann war’s SHIFT-LOCK!

(Hans Haberl/gk)

TODO ASIDE

## Änderungsvörschlag zur Turtle-Grafik

Ich habe Ihnen folgenden Anderungsvorschlag zur Turtle-Grafik (Ausgabe 11/34) zu machen: Diese Änderung bewirkt, daß ein Maschinenprogramm am Anfang des Basic-Speichers erzeugt wird und dieses wie ein Basic-Programm abspeicherbar ist.

Folgendes ist zu beachten: Der Basic-Lader muß vor dem Starten abgespeichert werden und nach POKE 44, 18: POKE 18 256,0: NEW wieder geladen werden. Dann kann gestartet werden.

Folgende Programmzeilen müssen geändert oder hinzugefügt werden:

300 AN=2048
301 ZI=4320
360 S=ANZ=960
580 PRINT "MIT SAVE ABSPEICHERN"
590 PRINT "MIT 'RUN' STARTEN"
600 POKE 45,234: POKE 46,16: POKE 44,8
610 END
960 DATA 0,25,8,192,7.158,50,48,55,53,3,2,84,85,82,84,76,1039
970 DATA 69,45,71,82,65,70,73,75,0,0,0,169,0,168,133,252,1272
980 DATA 169,192,133,253,169,64,133,254,169,8,133,255,162,9,177,254,2534
990 DATA 145,252,136,208,249,230,253,23,0,255,202,208,242,76,0,192,234,3112
1030 DATA 83,190.190,29,29,66,89,32,80,46,77,46,32,38,32,66,1125
1040 DATA 46,82,46,190,190,29,51,56,57,49,49,32 66,65,83,1120

(Burkhart Renk)

# Verbindungsfreundlich

> Es ist allgemein bekannt, daß der VC 20 über eine serielle Schnittstelle verfügt. Weniger bekannt ist, daß er auch mit einem parallelen Interface ausgestattet ist. Beide sollen hier beschrieben werden.

Die Schnittstellen des VC 20 werden von einem 6522-Chip gesteuert. Dieser verfügt über 16 Register, mit deren Hilfe zwei 8-Bit-Datenports, zwei 16-Bit-Timer, ein Schieberegister und verschiedene Steuerleitungen gehandhabt werden können. Für die parallele Schnittstelle benötigen wir nur die Register 0 und 2.

Das Register 0 gibt den Zustand des Datenports B (PB 0 bis PB 7 am User-Port) wieder. Es kann sowohl gelesen als auch geladen werden. Es liegt bei dezimal 37 136 ($ 9110). Die Pin-Belegung des User-Ports geht aus Tabelle 1 hervor. Mit dem Register 2 können die Leitungen des Datenports individuell auf Ein- oder Ausgabe geschaltet werden. Ist zum Beispiel das Bit 0 gesetzt, so ist die korrespondierende Datenleitung (in diesem Fall PB 0) auf Ausgabe programmiert. Die anderen Leitungen stehen auf Eingabe, weil Bit 1 bis Bit 7 nicht gesetzt sind.

Das Ganze sieht in Basic wie in Listing 1 aus. Etwas schwieriger ist es, die serielle Schnittstelle zu programmieren. Sie hat einen Aus- und einen Eingang. Am User-Port ist CB 2 der Aus- und CB 1 der Eingang. Mit dem Basic-Befehl OPEN 2,2,0, CHR$ (Byte 1) + CHR$ (Byte 2) wird die serielle Schnittstelle eröffnet und programmiert. Die Bezeichnungen Byte 1 und Byte 2 stehen für das Kontroll- und das Befehlsregister. Die beiden Register werden nach den Tabellen 2 (Kontrollregister) und 3 (Befehlsregister) programmiert.

Wenn ich zum Beispiel das Kontrollregister auf 300 Baud, 7 Daten- und 2 Stoppbits programmieren möchte, muß ich die Bits 1, 2, 5 und 7 setzen. Man rechnet also 21 + 22 + 25 + 27 = 2 + 4 + 32 4- 128 = 166 und setzt diesen Wert bei Byte 1 ein. Genauso macht man es mit dem Befehlsregister, also: alle Werte zusammenzählen und in Byte 2 einsetzen.

Nun ist die serielle Schnittstelle programmiert. Ausgaben macht man über den Befehl PRINT # 2, CHR$ (x), wobei x der ASCII-Code des zu sendenden Buchstabens ist. Lesen kann man die Schnittstelle mit dem Befehl GET # 2, x$, wobei x$ das zuletzt gelesene Zeichen ist.

Ein Basic-Programm, das den VC 20 mit anderen Computern, zum Beispiel über ein Telefonmodem, kommunizieren läßt, ist als Listing 2 abgedruckt. Bei diesem Programm können falsche Eingaben mit der DEL-Taste gelöscht werden. Nun viel Spaß mit Ihren Schnittstellen.

(Andrej Dvorak/ev)

# Assembler ist keine Alchimie (Teil 7)

> ln diesem Teil werden wir drei Themen besprechen: den Stapel und die indirekte Adressierung. Ferner zeigen wir an einem ausführlichen Beispiel, wie Text auf dem Bildschirm und auf dem Drucker ausgegeben werden kann.

Die Assembler-Folge in der letzten Ausgabe hat einige Fragen offengelassen, die dieses Mal beantwortet werden sollen: Die Sache mit dem Stapel wird geklärt, und Sie werden Befehle zu gebrauchen lernen, die uns Stapeloperationen ermöglichen. In unserem ersten Programmprojekt-Teil gab es für Sie unverständliche Sequenzen, die mit der Speicherstelle 1 zu tun hatten. Auch das werden Sie diesmal verstehen.

Sie beherrschen inzwischen fast alle Arten der Adressierung: Nach dieser Folge fehlt keine mehr. Ich habe Ihnen hoffentlich das Wasser im Munde zusammenlaufen lassen mit der Liste aller Kernal-Routinen: Nun sollen uns die ersten davon munden.

### Wir stapeln

In der vorangegangenen Ausgabe haben wir beim JSR-Befehl schon den Stapel etwas kennengelernt. Aber so ganz genau wissen wir’s ja noch nicht, was das ist. Deswegenjetzt mal im Detail: Der Stapel, auch Prozessorstack genannt, ist der Speicherbereich von dezimal 256 ($100) bis dezimal 511 ($1FF), der direkt von unserer CPU verwaltet wird. Das ist also die gesamte Page 1. Ähnlich wie bei der String-Verwaltung geschieht auch hier das Füllen von oben nach unten. Das erste Byte, welches in den Stack geschoben wird, kommt also nach $1FF, das nächste nach $1FE und so weiter. Voll ist der Stapel, wenn auch $100 besetzt wurde (siehe Bild 1).

Warum heißt das Ding nun eigentlich Stapel? Das erklärt sich aus dem Zugriffs-Prinzip. Man spricht von einer LIFO-Struktur, von »Last In — First Out«, zu deutsch »zuletzt hinein — zuerst heraus«. Das zuerst hineingebrachte Byte befindet sich am Speicherboden ($1FF), das zuletzt eingebrachte an der Speicherspitze. Stellen Sie sich einen Stapel Akten vor (Bild 2).

Offensichtlich wurde der 4. Aktenordner zuletzt auf den Stapel gesteckt. Er kann zuerst heruntergeholt werden. An die Akte 1 kommen wir erst heran, wenn alle anderen heruntergenommen worden sind. Genauso verhält es sich mit dem Prozessorstack: Um an das unterste Byte des Stapels heranzukommen, müssen erst Byte für Byte die darüberliegenden (nach Bild 1 eigentlich die darunterliegenden) weggeschafft werden.

Mit dem Prinzip des Stapelspeichers werden Sie sich auskennen, wenn Sie schon mal andere Programmiersprachen als Basic ausprobiert haben: In Forth beispielweise operieren Sie ständig mit Stapeln.

## Der Stapel: Das Gedächtnis des Prozessors

Damit wir — und der Prozessor — den Überblick über den Stack behalten, gibt es dankenswerterweise noch einen Stapelzeiger (stackpointer), der jeweils auf den nächsten freien Platz des Stapels weist. Da gibt’s nun aber ein kleines Problem: Der Stapel belegt die komplette Seite 1.

Ein Stapelzeiger, der auf zum Beispiel $01FE zeigen soll, müßte das MSB (also 01) und das LSB (also FE) in zwei Bytes lagern. Der Stapelzeiger ist aber nur 8 Bit groß ... Freundlicherweise sorgt unser Mikroprozessor automatisch für das neunte Bit. Der Zeiger zählt also immer von $FF an rückwärts bis $00 und weist dabei von $1FF bis $100.

Der Stack hat in unserem Computer drei Aufgaben zu erfüllen:

1) Organisation von Unterprogramm-Adressen
2) Zwischenspeicherung bei Unterbrechungen (Interrupts)
3) vorübergehende Datenspeicherung

Die Rolle des Stapels bei Unterprogramm-Aufrufen haben wir in der letzten Folge schon ausgiebig behandelt. Die sogenannten Interrupts heben wir uns noch für später auf — dazu fehlen uns noch ein paar Kenntnisse. Mit der vorübergehenden Speicherung von Daten befassen wir uns gleich, wenn wir an die Befehle zur Stackbehandlung herangehen.

Zuvor — weil das hier gerade ganz gut paßt — noch ein paar Gedanken zur rekursiven Programmierung. Gemeint ist damit eine Programmstruktur, in der sich ein Unterprogramm selbst aufruft. Auch GOSUB-Befehle in Basic bewirken Einträge der Rücksprungadressen im Stapel. Auf diese Weise ergibt sich für unseren Computer eine begrenzte Verschachtelungstiefe bei Unterprogrammaufrufen. Diese wird bei Rekursion besonders schnell erreicht, und das bewirkt die Ausgabe einer OUT OF MEMORY-Fehlermeldung.

### Aktives Stapeln mit PHA, PLA, PHP, PLP, TSX und TXS

Mit dem Stapel haben wir 256 Speicherplätze für eine schnelle Zwischenspeicherung aller möglichen Daten zur Verfügung. Weil der 6510 (und natürlich auch der 6502) diesen Speicherbereich wie die Zeropage behandelt, geht das Speichern sehr schnell. Man muß nur immer die spezielle LIFO-Struktur berücksichtigen.

Im Grunde braucht man eigentlich nur zwei Befehle: Etwas auf den Stapel schieben (in der Literatur oft als Push-Befehl bezeichnet) und etwas herunterziehen, das nennt man dann Pulloder auch Pop-Befehl.

Unser Prozessor kennt insgesamt sechs auf den Stapel wirkende Anweisungen:

**PHA** Damit schreibt man den Akku-Inhalt in den Stapel (»push-accumulator«). Der Stapelzeiger wird automatisch eine Position heruntergezählt (er rechnet ja von $FF an abwärts!). Der Inhalt des Akku wird dabei nicht verändert. Deswegen bleibt auch das Status-Register (also die ganzen Flaggen: N V B D I Z C) unbeeinflußt.

**PLA** »Pull accumulator«. Das ist der umgekehrte Weg: Das, was zuoberst auf dem Stapel liegt, wird in den Akku geschrieben. Dadurch wird ein Stapelplatz frei, was den Stapelzeiger veranlaßt, um 1 zu wachsen. Weil das, was da in den Akku geladen wird, 0 sein kann oder auch negativ (also mit gesetztem Bit 7), wird unter Umständen auch die N- oder die Z-Flagge verändert.

Weniger mit Datenzwischenspeicherung haben die anderen Befehle zur Stapel-Manipulation zu tun:

**PHP** Das steht für »push processor status«, also »schiebe das Prozessor-Status-Register auf den Stapel«. Der aktuelle Flaggenstand kann damit aufbewahrt werden. Das Status-Byte ändert seinen Inhalt dabei ebensowenig wie der Akku bei PHA. Auch hier wird der Stapelzeiger freundlicherweise um 1 herabgezählt.

**PLP** »Pull processor status«, »hole den Prozessor-Status vom Stapel«, ist der umgekehrte Befehl, der (wie bei PLA in den Akku) den Wert, der zuoberst im Stapel liegt, in das Flaggen-Register schreibt. Da sollte man höllisch aufpassen, was man damit einlädt: Das ist eine feine Gelegenheit für den Computer abzustürzen. Der Stapelzeiger wird — wie gehabt — um 1 erhöht.

Nicht direkt mit dem Stapel, sondern mit dem Stapelzeiger befassen sich die beiden folgenden Befehle:

**TSX** »Transfer stackpointer into X«, zu deutsch, »schiebe den Stapelzeiger ins X-Register« eröffnet die Möglichkeit, den Stapelzeiger zu lesen. Dabei bleibt er selbst unverändert erhalten. Weil nun im X-Register alle Werte zwischen $FF und 0 auftreten können, werden auch die Flaggen beeinflußt (N- und Z-Flagge).

**TXS** Den umgekehrten Weg geht »transfer X into stackpointer« = »übertrage X-Register-Inhalt in den Stapelzeiger«. Das ist der einzige Befehl, der es erlaubt, den Stapelzeiger mit einem von uns kontrollierten Wert zu laden. Der Inhalt des X-Registers bleibt dabei unverändert, demzufolge interessieren sich auch die Flaggen nicht dafür.

Alle sechs Anweisungen bestehen nur aus einem Byte und sind implizit adressiert. Die Stapelzeiger-Befehle TXS und TSX benötigen zwei Taktzyklen, die Push-Befehle je drei und die Pull-Befehle vier Taktzyklen zur Bearbeitung.

Es ist etwas schwierig, Stapel-Operationen direkt zu verfolgen. Die meisten Assembler — so anscheinend auch der SMON — gebrauchen ebenfalls diesen Speicherbereich. Verlangt man beispielsweise mit dem SMON-Kommando M 0100 01FF eine Darstellung des Stapelinhaltes, dann findet man eine ganze Menge Spuren der Arbeit des Assemblers. Versucht man die zu löschen oder zu überschreiben, zum Beispiel mit dem nachfolgenden kleinen Programm, dann hat der Assembler die Mühe schon wieder zunichte gemacht, wie man durch erneutes M 0100 01FF schnell sehen kann. Dieses kleine Programm soll unterhalb des durch den Stapelzeiger bezeichneten Bereichs 32 Nullen in den Stapel schreiben:

8000	LDA #00
8002	TSX

Der Stapelzeiger wird ins X-Register gerettet.

8003	LDY #20
8005	PHA

Wir schieben eine Null auf den Stapel.

8006	DEY
8007	BNE 8005
8009	TXS

Nach 32 Eintragungen von Nullen stellen wir den alten Stapelzeiger wieder her.

800A BRK

Erneutes Kommando M 0100 01FF zeigt keine Nullen. Erst wenn wir anstelle des TXS in Zeile 8009 ein BRK schreiben, den Stapelzeiger also nicht zurückschreiben, erscheinen unsere Nullen. Sieht man genau hin, dann stellt man fest, daß unterhalb des durch den Stapelzeiger bezeichneten Bereichs genau der gleiche Inhalt zu finden ist wie vorher, nur eben mit dem Stapelzeiger verschoben.

Ganz konnte ich dies Rätsel noch nicht lösen, muß ich gestehen, aber für den Gebrauch des Stapels ändert sich dadurch für uns nichts. Worauf muß man achten bei Stapeloperationen? Ganz einfach: Zwischen dem Ablagern eines Wertes auf dem Stapel und dem Zurückholen muß für jeden Push-Befehl ein Pull-Befehl vorhanden sein, für jedes weitere PHA ein PLA, für jedes JSR ein RTS. Nur wenn wir auf diese Symmetrie der Push- und der Pull-Befehle achten (und wie Sie noch aus der vorhergegangenen Ausgabe wissen, sind ja JSR und RTS ebenfalls dazuzurechnen), können wir sicher sein, daß der Stapelzeiger zum Zeitpunkt des Rückholens eines Wertes vom Stapel auch wirklich darauf deutet. Wenn man also nicht ganz genau weiß, wie der verwendete Assembler den Stapel nutzt, sollte man auf Operationen mit den Befehlen TSX und TXS verzichten.

Nun können Sie schon einen Teil der bislang unbekannten Programmsequenz aus der letzten Folge verstehen. Im zweiten Programmteil hatten wir mit

02CE LDA 01
02D0 PHA

den Inhalt der Speicherstelle 01 in den Akku geladen und auf den Stapel geschoben. Später — nach einigen weiteren Operationen — wurde dann dieser Speicherinhalt wiederhergestellt durch

02E7 PLA
02E8 STA 01

Was aber hat es mit dieser Speicherstelle 01 auf sich? Das soll nun als nächstes erklärt werden.

### Sein oder Nichtsein: Das Rätsel des Prozessorports

Der Commodore 64 hat 64 KByte an RAM zu bieten. Außerdem aber verfügen wir beim normalen Programmieren über weitere 24 KByte, in denen das Betriebssystem, der Basic-Interpreter, Ein- und Ausgabebausteine und der Zeichenspeicher stecken. Wie Sie aus der ersten Assemblerfolge wissen, umfaßt der Adreßbus aber nur 16 Bits, was uns lediglich 65536 Speicherzellen, also 64 KByte adressieren läßt/Des Rätsels Lösung liegt darin, daß einige Adressenbereiche mehrfach belegt sind. Man kann das vergleichen mit dem Trick des Kastens mit dem doppelten Boden. Welcher Kasteninhalt gerade dem Prozessorzugriff offensteht, wird durch den Prozessorport, das sind die Speicherstellen 00 und 01, gesteuert.

Dr. Helmuth Hauck hat in seiner Serie »Memory Map mit Wandervorschlägen« (64'er, Ausgabe 11 (1984), Seite 135 ff.) die genaue Funktion jedes Bits dieser beiden Speicherstellen erklärt. Wer noch mehr wissen möchte — auch über die Wirkungsweise der beiden Leitungen »Game« und »Exrom« — sollte das nachlesen im »Commodore 64 Programmers Reference Guide« ab Seite 260. Für uns als angehende Assembler-Alchimisten ist die Speicherstelle 1 aber so wichtig, daß wir ganz kurz hier nochmal darauf eingehen.

Die Speichersteuerfunktionen haben die Bits 0 bis 2 der Speicherstelle 1. Je nach Belegung dieser Bits gestaltet sich die 64-KByte-Landschaft unseres Computers wie in Tabelle 1 gezeigt.

Was können wir als Maschinen-Programmierer mit dieser Kenntnis anfangen? Theoretisch stehen uns für unsere Programme damit 64 KByte offen. Praktisch werden wir nur in den seltensten Fällen auf die Ein- und Ausgabe-Bausteine verzichten können. Lassen wir ein reines Maschinenprogramm laufen, ohne jeglichen Rückgriff auf Interpreter oder Betriebssystem, dann haben wir immerhin noch zirka 60 KByte zur freien Verfügung. Benutzen wir Routinen aus diesen beiden ROM-Bausteinen, dann müssen wir sie allerdings — zumindest für den Zeitpunkt des Routineaufrufs — wieder einschalten. Wenn wir — was wohl meistens der Fall sein wird — Kombinationen von Basic- und Assemblersprache verwenden, können wir den gesamten Basic-Speicher bis $A000 frei halten, können auch den bei allen Beispielprogrammen so beliebten Bereich $C000 bis $D000 leer lassen und packen unsere Routinen weitgehend unter die ROMs, die dann jeweils beim Aufruf abgeschaltet werden. So haben wir eine Menge zusätzlichen Speicherplatz ergattert.

Nun können wir auch den letzten Rest des bislang unklaren Programms aus der letzten Folge verstehen. Nachdem wir den Inhalt der Speicherstelle 1 auf den Stapel gerettet haben (Zeilen $02CE und $02D0), schreiben wir $35 in den Prozessorport:

02D1 LDA #35
02D3 STA 01

$35 ist binär 0011 0101. Die Bits 0 bis 2, auf die es uns in diesem Zusammenhang ankommt, bewirken nun das Ausschalten des Interpreters und des Betriebssystems. Die Ein- und Ausgabe-Bausteine bleiben aktiv. Im weiteren Programmverlauf lesen wir die Speicherinhalte ab $E000, wobei wir nun den RAM-Inhalt erfassen. Das sollte vielleicht nochmal klargestellt werden: Jedes Hineinschreiben in die mehrfach belegten Speicherbereiche (dabei sind die Ein- und Ausgabe-Bausteine aber ausgenommen) wird automatisch in den RAM-Bereich umgelenkt. Das ist ja auch klar: In ein ROM kann eben nicht geschrieben werden. Deshalb braucht man dabei die ROMs nicht auszuschalten. Jeder Lesevorgang greift aber auf die ROMs zu, weshalb man sie in unserem Fall ausschalten muß. Wie schon oben beim Stapel erklärt, schalten wir durch das Zurückholen des vorher dorthin geretteten alten Inhalts der Speicherstelle 1 in den Prozessorport wieder den Normalzustand ein.

## Die wandernden toten Briefkästen der Assembler-Alchimisten

Wir werden nun die beiden letzten noch ausstehenden Arten der Adressierung kennenlernen. Beides sind sogenannte indirekte Adressierungsarten. Mit dem indirekten JMP-Befehl (zum Beispiel JMP(0300)) sind wir in der letzten Folge schon vertraut geworden. Wir hatten auch gelernt, daß es sich hierbei um einen absoluten Einzelgänger handelt, der nur für so einen Sprung erlaubt ist. Ebenso haben wir die indizierte Adressierung zu beherrschen gelernt: Das war die Sache mit den Indexregistern X oder Y. Eine Kombination aus beiden (also der indirekten und der indizierten) Adressierungsarten sind die indiziert-indirekte und die indirekt-indizierte Adressierung.

### Die indirekt-indizierte Adressierung

Fangen wir mit der sehr häufig benutzten indirekt-indizierten Adressierung an: Man nennt sie auch »indirekt Y« oder »nachindizierte indirekte« Adressierung. Am besten sehen wir uns mal so einen Befehl an:

LDA (FA),Y

Die Klammer erinnert uns an den indirekten JMP-Befehl. Tatsächlich hat sie hier auch dieselbe Funktion: In FA und FB steht ein Zeiger auf eine Adresse. Nehmen wir mal an, die Belegung der Speicher wäre:

FA 01
FB 80

und im Y-Register stünde eine 5. Der Zeiger FA/FB weist also auf die Speicherstelle 8001. Da haben wir also wieder das Prinzip des toten Briefkastens. Der Computer guckt in den hohlen Baum FA/FB (LSB in FA, MSB in FB) und findet dort die Treffpunktadresse. Nun sind diese toten Briefkästen aber auch den gegnerischen Alchimisten-Agenten bekannt. Es kommt also noch ein Trick dazu: Zur dort aufgefundenen Adresse wird der Inhalt des Y-Registers addiert. In unserem Fall fanden wir also in FA/FB die Adresse 8001, im Y-Register steht eine 5, somit ist die endgültige Adresse 8001 + 5 = 8006. Unser Beispiel »LDA(FA),Y« bewirkt daher, daß in den Akku der Inhalt der Speicherstelle 8006 geladen wird. Nachindiziert nennen manche die Adressierung deswegen, weil zunächst dem Zeiger nachgegangen wird, der in unserem Beispiel auf 8001 weist, und erst danach durch Addition des Inhalts des Y-Registers die endgültige Speicherstelle (hier also 8006) berechnet wird.

Als Zeiger (also die Adresse in der Klammer) sind nur Zeropagespeicherstellen verwendbar, als Indexregister darf man hier nur das Y-Register gebrauchen. Von den bisher behandelten Befehlen können ADC, CMP, LDA, SBC und STA mit dieser Adressierungsart verwendet werden. Genaueres finden Sie wieder in der Tabelle mit der Befehlsübersicht (Tabelle 2).

Bevor wir uns dem anderen indirekten Adreß-Modus zuwenden, wollen wir uns überlegen, wozu man die indirekt-indizierte Adressierung verwendet. Wie Sie sich natürlich erinnern können, konnte man mit der normalen indizierten Adressierung, zum Beispiel mit

LDA 8000,Y

durch Variation des Indexregisters (hier das Y-Register) 256 Speicherstellen erfassen (Y von FF herunter bis 00). Will man mehr als diese 256 berücksichtigen, dann muß eine neue Basis (im Beispiel also anstelle der 8000) gewählt werden. Um das zu illustrieren, sehen wir uns mal den Anfang eines Programms an, welches den gesamten Bildschirminhalt ausliest und nach E000 schreibt:

1000	LDY #00
1002	LDA 0400,Y
1005	STA E000,Y
1008	LDA 0500,Y
100B	STA E100,Y
100E	LDA 0600,Y
1011	STA E200,Y
1014	LDA 0700,Y
1017	STA E300,Y
101A	DEY
101B	BNE 1002
...

Wie Sie sehen, erfordert das durch die Tatsache, daß vier Blöcke zu je 256 Bytes übertragen werden müssen, immerhin schon 28 Bytes Programmtext. Nun soll die indirekt-indizierte Adressierung verwendet werden, um dieselbe Aufgabe zu lösen. Wir legen zunächst zwei Zeiger auf der Zeropage fest:
FA/FB sollen die Bildschirmadresse enthalten
FC/FD die Zieladresse ab E000.

1000	LDA #00
1002	STA FA
1004	STA FC

Das waren die LSBs der Zeiger, es folgen die MSBs:

1006	LDA #04
1008	STA FB
100A	LDA #E0
100C	STA FD

Damit sind die Zeiger festgelegt. Es sind vier Blöcke zuje 256 Bytes zu übertragen. Diese Blockanzahl legen wir ins X-Register als Zähler:

100E LDX #04

Dann laden wir ins Y-Register ebenfalls einen Zähler (den Index):

1010 LDY #00

Jetzt kann die eigentliche Übertragungsschleife starten:

1012	LDA (FA),Y
1014	STA (FC),Y
1016	DEY
1017	BNE 1012

Wenn das Y-Register wieder bei 0 angekommen ist (von der ersten 0 nach einem Unterlauf— siehe dazu Folge 3 — über FF, FE und so weiter bis 0), ist der erste Block übertragen. Wir erhöhen nun das MSB beider Zeiger um 1:

1019	INC FB
101B	INC FD

Außerdem zählen wir den Blockzähler um 1 herunter:

101D	DEX
101E	BNE 1012

Wenn das Programm auf diese Weise auch drei Bytes mehr Speicherplatz braucht, ist doch leicht der Vorteil zu sehen: Müssen wir nämlich (statt nur vier) mehr Blöcke übertragen (bis zu 255), dann verändert sich unser zweites Programm um keinen Deut (außer dem Zähler im X-Register, der nun mit der jeweils anderen Block-Anzahl geladen wird), während die erste Programmtechnik für jeden weiteren Block um sechs Bytes erweitert werden muß.

Es gibt noch eine ganze Reihe von Anwendungsmöglichkeiten, die die indirekt-indizierte Adressierung so attraktiv machen. Für Geschwindigkeitsfanatiker (ich selbst bin bei Grafik-Fragen auch einer!) muß aber gesagt werden, daß dem Speicherplatzvorteil ein Geschwindigkeitsnachteil gegenübersteht. Jeder indirekt-indiziert adressierte Befehl braucht einen Taktzyklus länger als der vergleichbare absolut-indizierte Befehl. Zu diesen Feinheiten werden wir aber in späteren Folgen noch kommen.

### Die indiziert-indirekte Adressierung

Wenden wir uns nun der letzten noch fehlenden Adressierungsart zu, der indiziertindirekten. Man nennt sie auch »vorindizierte indirekte« oder »indirekt X« Adressierung. Sehen wir auch hier zunächst ein Beispiel an:

STA (FA,X)

Auch hier drückt die Klammer wieder aus, daß der Klammerinhalt ein Zeiger ist. Das ist jetzt aber nicht das Bytepaar FA/FB, sondern zur angegebenen Adresse FA soll noch der Inhalt des X-Registers addiert werden. Nehmen wir mal an, dort stünde eine 2, dann wird der Zeiger FC/FD mit diesem Befehl angesprochen, denn FA + 2 = FC und entsprechend FB + 2 = FD. Wenn in den Speicherstellen FA bis FF folgender Inhalt zu finden ist:

00FA 00
00FB 04 FA/FB = 0400
00FC 00
00FD E0 FC/FD = E000
00FE 10
00FF 80 FE/FF = 8010

dann könnte das eine ganze Tabelle von Zeigern sein, die jeweils durch den X-Registerinhalt angesprochen werden. Der Akkuinhalt wird in unserem Beispiel nach 0400 geschrieben, wenn im X-Register 0 steht, nach E000, wenn das X-Register eine 1 enthält und nach 8010, wenn statt dessen eine 2 im X-Register zu finden ist.

Sie werden sich vielleicht auch bei diesem Beispiel gefragt haben, was passiert, wenn im X-Register unseres Beispiels eine 3 steht. Nun, unser 8-Bit-Prozessor läuft über, und wir finden einen Zeiger 00/01.

Rein theoretisch ist diese Adressierungsweise ganz interessant. Aber auf der Zeropage ist’s reichlich eng, und nur selten kommt man daher in die Lage, dort eine Zeigertabelle einzurichten, die man mittels des X-Registerinhalts und der indiziert-indirekten Adressierung abgreifen kann. Die Bedeutung dieser Adressierungsart ist also nur recht gering. Außerdem erfordert sie sechs Taktzyklen zur Bearbeitung und ist somit auch noch recht langsam. Von den bisher bekannten Befehlen sind die folgenden damit verwendbar: ADC, CMP, LDA und STA.

Bevor wir die Adressierung zu den Akten legen, sei noch erwähnt, daß manche Lehrbücher noch eine weitere Art, die Akkumulator-Adressierung, unterscheiden. Betroffen sind davon vier l-Byte-Befehle, die wir noch kennenlernen werden und die man ebensogut als implizit adressiert ansehen kann.

### Die ersten Kernal-Routinen

Sicher werden Sie alle schon von der Kernal-Routine FFD2 gehört haben und sie vielleicht auch schon verwenden. Wenn nicht, um so besser, denn dann sind Sie noch nicht vom einseitigen Gebrauch dieses Instruments verdorben. Die meisten Kernal-Adressen sind nämlich sehr vielseitig verwendbar, je nach den Vorgaben. Das ist wie mit einem Haushaltsgerät, das immer nur zum Rühren von Kuchenteig eingesetzt wird. Dabei kann man damit auch noch Saft machen, Gurken schnitzeln, Getränke mixen ... Genauso wie man in diesem etwas schiefen Vergleich die Gebrauchsanleitung kennen sollte, um die ganzen anderen Funktionen ausnutzen zu können, muß man hier noch einige Dinge über die Kernal-Aufrufe beherzigen.

Für jede Verwendung der Kernal-Sprungtabelle sollte man sich angewöhnen, dies in drei Schritten zu tun:

1) die nötigen Vorbereitungen treffen
2) Routineaufruf
3) Fehlerabfrage und -behandlung

Fangen wir mit dem Punkt »Vorbereitungen« an. Einige Routinen brauchen Informationen, die ihnen erst durch andere Kernal-Routmen beschafft werden. Ruft man diese anderen Routinen vorher nicht auf, dann funktioniert auch der erwünschte Aufruf nicht richtig. Wenn die Routine einen bestimmten Wert im Y-Register erwartet, dann muß der dort auch stehen. Wenn nicht, dann geht das Programm in die Hose. Bei jeder Kernal-Routine, die hier beschrieben wird, gebe ich alle nötigen Vorbereitungen an.

Der Routinenaufruf sollte immer mittels ]SR erfolgen. Alle auf diese Weise aus der Kernal-Sprungtabelle abzurufenden Programme enden nämlich mit einem RTS. Damit keine wichtigen Werte aus dem Aufrufprogramm überschrieben werden, man sie also vor dem Aufruf der Kernal-Routine irgendwohin retten kann, gebe ich auch noch an, welche Register durch die Routine verändert werden und wieviel Stapelspeicherplatz bereitgehalten werden muß.

Die Routinen sind so konstruiert, daß beim Auftreten eines Fehlers nach der Rückkehr das Carry-Bit gesetzt ist. Durch Untersuchen des Carry können so Fehler rechtzeitig erkannt und behandelt werden. Im Akku findet man in dem Fall dann eine Fehlernummer. Die Ausgabe der Fehlermeldung erfolgt also nicht — wie im Basic — in Klarschrift. In Tabelle 3 sind die Fehlernummern und ihre Bedeutung aufgelistet.

Welche Fehlernummern eine Routine ausgeben kann, wird ebenfalls von mir bei jeder Routinen-Besprechung angegeben.

Nun aber zur ersten Routine FFD2, die wie einen Rattenschwanz eine Reihe weiterer nach sich zieht:

Name CHROUT
Zweck Ausgabe eines Zeichens
Adresse $FFD2
dez. 65490
Vorbe- (CHKOUT,OPEN) reitungenZeichen im Akku
Fehler 0
Stapel- 8 bedarf
Register Akku
TODO

Falls Sie diese Routine schon einmal benutzt haben, dann geschah es vermutlich ohne die Vorbereitungen CHKOUT und OPEN. Freundlicherweise hat unser Computer einige Voreinstellungen schon für uns getroffen. Denn normalerweise sendet CHROUT ein Zeichen über einen schon geöffneten Ausgabekanal, und der ist zum Bildschirm geschaltet. Ein kleines Beispielprogramm soll das illustrieren. Zunächst laden Sie bitte den SMON ein und starten Sie ihn. Nun soll eine Texttabelle angelegt werden. Das funktioniert beim SMON am bequemsten über das K-Kommando. Geben Sie ein K 6000. Der SMON antwortet mit:

'6000 .......................

Wenn Sie nun die RUN/STOP-Taste drücken, können Sie mit dem Cursor in diese Punktzeile fahren und einen Text schreiben:

'6000 HALLO ASSEMBLER-ALCHIMIST ................

Sinnvoll — vor allem für die weitere Verwendung dieses Textes — ist es, ein (RETURN), also dezimal 13 oder $0D anzuschließen. Dazu gibt es natürlich den Weg über den Assemblerbefehl. Zur Übung wollen wir aber das M-Kommando verwenden. Geben Sie ein (zuerst die »RETURN«-Taste betätigen) M6018, dann wieder RUN/STOP, und fahren Sie mit dem Cursor auf Speicherstelle 601A (falls Sie in 6019 kein Leerzeichen $20 stehen haben, dann fügen Sie’s jetzt noch ein). Geben Sie nun anstelle des dort stehenden Bytes 0D ein, und drücken Sie die RETURN-Taste. Der Monitor sollte jetzt zeigen:

:6018 54 20 0D etc.

Unser Text soll mit einem BRK enden. Deshalb gehen wir jetzt in den Assembler-Modus mit dem SMON-Kommando A 601B und schreiben:

601B BRK

Nun folgt das eigentliche Progrämmchen, das Byte für Byte bis zur Null (BRK) den Text aus der gerade erstellten Texttabelle liest und mittels FFD2 auf den Bildschirm bringt:

601C	LDY	#00
601E	LDA	6000,Y
6021	BEQ	602C

Das Y-Register wird als Index initialisiert, dann die Texttabelle in den Akku geladen. Wenn das Programm dabei auf die Null stößt, verzweigt es zum Ende. Jetzt folgt die Routine zur Bildschirmausgabe:

6023	JSR FFD2
6026	BCS 602D

Falls bei der Kernal-Routine etwas schiefgelaufen ist, wird das Carry-Bit gesetzt, was wir überprüfen und zu einem BRK-Kommando verzweigen (das ist natürlich nur sinnvoll, solange ein Monitor oder Assembler wie der SMON aktiv ist). Nun erhöhen wir das Index-Register und das ganze beginnt von vorne:

6028	INY
6029	JMP 601E
602C	RTS
602D	BRK

Wenn wir nun aus dem SMON mit F und anschließendem X aussteigen und ein kleines Basic-Aufrufprogramm machen (Bei OUT OF MEMORY ERROR bitte NEW eingeben):

10 PRINTCHR$(147)
20 SYS 24604 :REM = $601C
30 END

dann können wir uns die Wirkung unseres Programms ansehen: Nach RUN wird der Bildschirm gelöscht und unser Text ausgedruckt.

FFD2 nimmt uns also eine Menge Arbeit ab: Automatisch legt diese Routine in den Bildschirmspeicher den Bildschirmcode (sie rechnet also auch gleich ASCII, das wir ja eingegeben haben, in den POKE-Code um) und in die dazugehörige Bildschirmfarbspeicherstelle den aktuellen Farbcode. Sie setzt außerdem noch den Cursor weiter.

Mit FFD2 kann man aber noch viel mehr machen! Schließlich ist ja der Bildschirm (Gerätenummer 3) nicht der einzige mögliche Empfänger. Wir wollen als nächstes mal eine Ausgabe mittels FFD2 auf den Drucker erzielen. Hier sind die Vorbereitungen allerdings nötig. Zunächst mal müssen wir uns noch zwei weitere Kernal-Routinen ansehen, nämlich CHKOUT und OPEN.

Name CHKOUT
Zweck Kanal zum Ausgang definieren
Adresse $FFC9 dez. 65481 Vorberei- OPEN tungen log. Filenummer
ins X-Register
Fehler 0,3,5,7
Stapel- 4 bedarf
Register Akku, X-Register
TODO

Mit aieser Routine kann jedes File, der zuvor durch OPEN spezifiziert worden ist, zum Ausgabefile erklärt werden. Natürlich muß dann das derart angesprochene Gerät auch ein Ausgabegerät sein. Andernfalls ergibt sich ein Fehler. Bevor man Daten über einen Kanal senden will, muß CHKOUT durchgeführt werden. Wenn die mittels OPEN übergebene Geräteadresse größer als 3 ist, sendet diese Routine automatisch auch ein LISTEN-Kommando an das Ausgabegerät. LISTEN setzt dann zum Beispiel den Drucker in Empfangsbereitschaft. Die Durchführung von CHKOUT ist einfach (vorausgesetzt, man hat vorher OPEN aufgerufen): In das X-Register wird die logische Filenummer geschrieben und dann perJSR FFC3 CHKOUT angesteuert.

Nun zur anderen Vorbereitung von FFD2, zu OPEN:

Name OPEN
Zweck Öffnen eines logischen Files
Adresse $FFC0 dez. 65472 Vorberel SETLFS,SETNAM tungen
Fehler 1,2,4,5,6
Register Akku, X- und Y-Register
TODO

Die Routine OPEN an sich anzusprechen, ist relativ einfach. Es genügt ein JSR FFC0. Zuvor allerdings — der Rattenschwanz wird länger — muß mit SETNAM der Filename und mit SETLFS die logische Filenummer, die Geräteadresse und eventuell eine Sekundäradresse festgelegt sein. Erst danach kann das File geöffnet werden durch OPEN. Also sehen wir uns noch SETLFS und SETNAM an:

Name	SETLFS
Zweck	Spezifikationen eines logischen Files
Adresse	$FFBA dez. 65466
Vorbe-	logische Filenum-
reitun-	mer in Akku
gen	Gerätenummer ins X-Register Sekundäradresse ins Y-Register
Fehler	keine
Stapelbedarf 2
Register keine
TODO

SETLFS legt für die anderen Kernal-Routinen logische Filenummer, Gerätenummer und Sekundäradresse fest. Die logische Filenummer ist dabei eine Schlüsselzahl, die in eine durch OPEN angelegte File-Tabelle weist. Die Gerätenummer kann zwischen 0 und 31 liegen, dabei sind folgende Zuordnungen vorgesehen:

0 Tastatur
1 Datasette
2 RS232C-Kanal
3 Bildschirm

Gerätenummern ab 4 beziehen sich automatisch auf Geräte am seriellen Bus. Dabei gilt im allgemeinen:

4	Drucker
8	Diskettenstation

Die Sekundäradresse ist eine Kommandonummer, die für das jeweils angesproche Gerät spezifisch ist, zum Beispiel 10 bewirkt beim Drucker Commodore 1526, daß das Gerät in die Grundstellung geht (siehe jeweiliges Handbuch). Will man keine Sekundäradresse verwenden, dann muß FF ins Y-Register geschrieben werden. Der Aufruf von SETLFS geschieht also in folgender Weise: In den Akku lädt man die gewünschte logische Filenummer, ins X-Register die Geräteadresse und ins Y-Register FF oder aber die Sekundäradresse. Danach erfolgt der Sprung mit JSR FFBA.

Schließlich noch zu SETNAM:

Name	SETNAM
Zweck	Filenamen festlegen
Adresse	FFBD dez. 65469
Vorbe-	Namenslänge in
reitun-	den Akku
gen	LSB des Namenstextes in X-Register MSB des Namenstextes in Y-Register
Fehler	keine
Stapel- 2
bedarf
Register Akku, X- und Y-Register
TODO

Vor der Eröffnung eines Files mittels OPEN muß diese Routine den Filenamen festlegen. Dazu schreibt man in den Akku die Länge des Namens und in die Register X, Y die Startadresse (LSB ins X-Register, MSB ins Y-Register) der Namenstext-Tabelle. Der Ort dieser Tabelle ist frei wählbar. Wird kein Filename gewünscht, dann gibt man dem Akku die Länge 0 an. X- und Y-Register sind in dem Fall ohne Bedeutung.

Damit — sollte man meinen — hätten wir nun alle Bedingungen erfüllt, FFD2 zur Ausgabe auf den Drucker zu bewegen. Leider ist das noch nicht der Fall: FFD2 schließt nämlich das File und den Ausgabekanal nicht. Das kann — wenn man’s nicht beachtet — zu Fehlern oder zur weiteren Ansprache des Druckers führen, auch wenn die gar nicht mehr erwünscht ist. Deswegen sollten noch zwei KernalRoutinen angehängt werden, von denen die eine (CLRCHN) alle Ein- und Ausgabekanäle wieder in den Ausgangszustand zurückführt, und die andere (CLOSE) das File ordnungsgemäß schließt:

Name CLRCHN
Zweck Ein- und Ausgabekanäle in Ausgangsstellung bringen
Adresse $FFCC dez. 65484
Vorberei- keine
tung
Fehler keine
Stapel- 9 bedarf
Register Akku, X-Register
TODO

Der Aufruf von CLRCHN erfolgt einfach durch JSR FFCC. Die Wirkung ist enorm: Mit einem Schlag werden alle Kanäle freigeräumt. Eingangskanälen wird ein UNTALK (dem Gerät wird gesagt: Halt den Mund), Ausgangskanälen ein UNLISTEN (das bedeutet soviel wie: Hör nicht mehr zu) übermittelt. Der Ausgangszustand stellt sich wieder her: Tastatur als Eingabe-Bildschirm als Ausgabegerät.

Die endgültig letzte Routine für diesmal ist CLOSE:

Name CLOSE
Zweck Schließen logischer Files
Adresse $FFC3dez.65475 Vorbe- logische Filenum-reitun- mer in Akku
gen
Fehler 0
Stapel- 2 bedarf
Register Akku, X- und Y-Register
TODO

Wenn für ein File alle Ein- und Ausgabeoperationen beendet sind, kann es — nach Einschreiben der Filenummer in den Akku — mittels CLOSE ordnungsgemäß geschlossen werden. Der Eintrag in der Filetabelle wird auf diese Weise gelöscht.

So, jetzt sind wir soweit, daß wir die Textausgabe auf dem Drucker programmieren können. Bild 3 faßt die einzelnen Schritte nochmal zusammen.

Und hier das Programm dazu. Wir verwenden die im anderen Beispiel schon aufgebaute Texttabelle weiter. Zunächst also SETNAM:

601C LDA #00
601E JSR FFBD
6021 BCS 6053

Wenn ein Fehler aufgetreten ist, findet man ein gesetztes Carry-Bit. In dem Fall wird verzweigt zu einem BRK-Kommando (was die Anwesenheit eines Monitors erforderlich macht, solange man sich noch nicht sicher ist, ob Fehlermeldungen auftauchen). Die Null im Akku besagt, daß kein Filename gewünscht ist. Dann kommt SETLFS:

6023	LDA	#04
6025	LDX	#04
6027	LDY	#FF
6029	JSR	FFBA
602C	BCS	6053

Es wurde ein File festgelegt mit der logischen Filenummer 4, der Geräteadresse 4 und ohne Sekundäradresse. Jetzt geben wir das OPEN-Kommando:

602E	JSR	FFC0
6031	BCS 6053

Der Ausgabekanal wird definiert mit CHKOUT:

6033	LDX	#04
6035	JSR	FFC9
6038	BCS	6053

Damit sind alle Vorbereitungen erledigt, und die Zeichenausgabe kann wie im ersten Programm durchgeführt werden mit CHROUT:

603A	LDY	#00
603C	LDA	6000,Y
603F	BEQ	604A
6041	JSR	FFD2
6044	BCS	6053
6046	INY	
6047	JMP	603C

Alle Zeichen sind nun ausgedruckt. Wir rufen CLRCHN auf:

604A JSR FFCC

Als letzte Routine folgt nun noch CLOSE:

604D	LDA # 04
604F	JSR FFC3
6052 RTS

Damit wurde das File Nummer 4 geschlossen. Anschließend erfolgte der Rücksprung aus dem Programm. Für die Fehlerbehandlung habe ich nur einen BRK vorgesehen, der sofortigen Registerüberblick erlaubt, wenn zum Beispiel der SMON im Speicher enthalten ist.

6053 BRK

Ohne Monitor im Speicher kann der Computer allerdings abstürzen oder im besten Fall einen Basic-Warmstart durchführen. Wenn Sie sowas also für Ihre Zwecke programmieren möchten, sollten Sie einen anderen Weg suchen, die Fehler aufzufangen. Man hat ja nicht immer einen Monitor eingeladen.

Mit diesen sieben Kernal-Routinen soll’s für diesmal genug sein. In der Dezember-Ausgabe des 64’er haben B. Schneider und K. Schramm in ihrer Serie »In die Geheimnisse der Floppy eingetaucht« gezeigt, wie man mittels der besprochenen Routinen, und einiger anderer, auch die Diskettenstation ansprechen oder sogar Floppy und Drucker zum »Spooling« veranlassen kann. Das habe ich zwar schon öfter gesagt, muß es aber trotzdem immer wieder tun: Durch das Nachvollziehen fremder Programme kann man sehr viel lernen.

Oje, mein Versprechen, diesmal mit den Fließkommazahlen weiterzumachen, kann ich nicht halten. Auch unser Programmprojekt kommt nicht mehr dran. Beides hätte den Umfang dieser Folge mit Sicherheit gesprengt. Ich gebe Ihnen aber mein großes Ehrenwort, daß wir in der nächsten Ausgabe beide Themen weiterbehandeln.

(Heimo Ponnath/gk)

# In die Geheimnisse der Floppy eingetaucht (Teil 5)

> Wie funktioniert ein Kopierschutz, und wie kann man eigene Programme selbst schützen? Warum »rattert« die Floppy bei manchen Programmen? Und wissen Sie, was »Killertracks« sind? Die Antworten finden Sie im folgenden Artikel.

Die fortgeschrittenen Programmierer unter Ihnen werden sicher schon mit Ungeduld auf den Beginn des folgenden Abschnitts gewartet haben. Jetzt wird unser Kurs seinem Titel nämlich endlich voll gerecht werden, und wir wollen einmal sehen, was sich so alles mit einer Diskette anstellen läßt. Selbstverständlich sollen dabei Errors (Diskettenfehler) und »Killertracks« auch nicht zu kurz kommen.

Damit wir uns aber wieder an wichtige Tatsachen erinnern, noch einmal eine kurze Zusammenfassung einiger wichtiger Einzelheiten.

Wie im letzten Teil, unseres Kurses ausführlich beschrieben, besteht ein Sektor auf Diskette aus zwei Teilen, nämlich dem Header und dem eigentlichen Datenblock. Beide Teile des Sektors werden auf Diskette durch eine SYNC-Markierung angekündigt, der dann das Kennzeichen (ob Header oder Datenblock) zur Identifikation folgt.

Der Blockheader enthält Track- und Sektornummer*des Blocks, die beiden Bytes der Diskettenidentifikation (ID) und schließlich noch eine Prüfsumme, die dem Disk-Controller (DC) mitteilt, ob alle Daten einwandfrei gelesen wurden. Wurde der Blockheader richtig eingelesen, so wartet der DC auf den nachfolgenden Datenblock, der die Zeiger auf den nächsten Block im File, die Datenbytes und schließlich ebenfalls eine Prüfsumme enthält.

Zwischen Blockheader und Datenblock und zwischen Datenblock und Header des darauffolgenden Sektors befindet sich jeweils eine Lücke, die dem DC Zeit zum Umschalten seiner Modi (Lesen und Schreiben) läßt und außerdem für eine symmetrische Verteilung der Sektoren auf Diskette sorgt.

So, und jetzt genug der Wiederholung. Wir werden uns auf ein paar grundsätzliche Programmbeispiele stürzen, die Sie später in eigene Anwendungen einbauen können.

Wie wir schon wissen, werden alle Schreib-/Lesevorgänge des Disk-Controllers interruptgesteuert vorgenommen. Es ist also zum direkten Eingriff auf Diskette notwendig, daß wir uns die Regeln der Interruptsteuerung genau einprägen, da uns die Floppy bei unseren Experimenten sonst rnit Sicherheit »abstürzt«.

Da wir in unserem Kurs verständlicherweise kein DOS-Listing abdrucken können, habe ich die wichtigsten Adressen, die wir benötigen, in Tabelle 1 zusammengefaßt und mit einer kurzen Erläuterung versehen, damit Sie sich mit der Anwendung der DOS-Routinen vertraut machen können.

Ein weiteres »Werkzeug« ist die RAM-Belegung der wichtigsten Speicherstellen, die in der letzten Folge 3 (64’er Ausgabe 1/1985) abgedruckt worden ist.

Um den Einstieg zu finden, fangen wir gleich einmal mit der Übergabe der Kommandos an den DC an. Wie bewerkstelligt es das Hauptprogramm, die unterschiedlichsten Befehle wie Lesen, Schreiben, Suchen, Kopf bewegen, Laufwerksmotor an, Formatieren und so weiter an den Disk-Controller zu übergeben?

Um eine Antwort auf diese Frage zu finden, betrachten Sie sich bitte die Tabelle 2. Sie enthält eine Aufstellung aller Jobcodes der Floppy 1541. Mit Jobcodes sind hierbei die Kommandos gemeint, die dafür sorgen, daß ein bestimmter Job zur Ausführung kommt.

Nehmen Sie jetzt einmal die Belegung der Zeropage zur Hand. Wenn Sie sich die Speicherstellen $0000 bis $0005 betrachten, so merken Sie schon am Namen, daß diese Adressen etwas mit unserer Sache zu tun haben. Es handelt sich hierbei um die Jobspeicher, die die Aufgabe haben, für den Dialog zwischen Hauptprogramm und DC zu sorgen.

Habe ich eben etwas von Dialog (nicht etwa Monolog) gesagt? Genau! Die Jobspeicher dienen nicht nur der Übergabe der Kommandos vom Hauptprogramm an den Disk-Controller; sie enthalten nach der Ausführung des Jobs auch die Rückmeldung des DC, an der das Hauptprogramm erkennen kann, ob der Job erfolgreich, das heißt fehlerlos durchgeführt worden ist.

Die Rückmeldungen des Disk-Controllers sind komplett in Tabelle 3 aufgeführt. Wenn Sie sich einmal die Bitmuster der Jobcodes und der Rückmeldungen ansehen und beide Typen miteinander vergleichen, so werden Sie sehr schnell einen Unterschied feststellen, der von entscheidender Bedeutung ist:

Die Befehlscodes sind ausschließlich negative Werte, das heißt Werte, die größer als $80 (128) sind. Das Kennzeichen solcher Zahlen ist das gesetzte Bit 7 im Byte, das deshalb auch als »negative bit« bezeichnet wird und bei jeder Befehlsausführung in Maschinensprache direkt in das Prozessorstatusregister übernommen wird (N-Flag).

Die Rückmeldungen sind fast ausschließlich Zahlen, die kleiner als $0F (16) sind (bis auf eine Ausnahme). Diese Größe spielt zwar nicht direkt eine Rolle; das Wichtigste ist jedoch, daß bei diesen Werten keiner größer als $7F (127) ist. Zu der Begründung für diese Einteilung werde ich im folgenden noch kommen.

Wie Sie aus der Belegung der Zeropage ersehen, existiert für jeden Puffer der Floppy ein eigener Jobspeicher. Das ermöglicht einen sehr dynamischen Einsatz der Floppystation, der es zum Beispiel erlaubt, mit mehreren Puffern gleichzeitig zu arbeiten.

Eine wichtige Regel sollten Sie sich gleich einprägen, damit später keine Pannen passieren: Wenn Sie einen Jobcode an den DC übergeben, sollten Sie darauf achten, daß der DC für die Ausführung dieses Jobs meistens einen Puffer benötigt. Den Puffer, der dabei zum Beispiel beschrieben wird, wählen Sie durch die Übergabe des Jobcodes in der entsprechenden Speicherstelle aus.

Achtung: Verwenden Sie dabei niemals den Puffer, in dem Sie Ihr Programm abgelegt haben, da dieses sonst unter Umständen gelöscht wird und sich die Floppy auf »mysteriöse« Weise verabschiedet.

Haben Sie also beispielsweise ein Programm ab $0300 (Puffer 0) abgelegt, so sollten Sie sich davor hüten, die Zeropageadresse $0000 als Jobspeicher zu benutzen. Auch als Zwischenspeicher sind die Adressen $0000 bis $0005 nicht unbedingt zu empfehlen, da es sonst zu einer kleinen Katastrophe kommen kann.

## Die Kommandos an den Disk-Controller

Haben Sie sich die Speicherbelegung der Floppy schon etwas genauer betrachtet, so werden Ihnen auch die Speicherstellen $0006 bis $0011 nicht entgangen sein.

Wie wir wissen, gibt es verschiedene Jobcodes, die bestimmte Aktionen hervorrufen (die ausführliche Erläuterung der Jobcodes folgt gleich). Nun ist es aber in der Regel notwendig, einem Befehl auch ein paar Parameter mitzugeben, die dann in entsprechender Weise abgearbeitet werden.

In unserem Fall sind das sicherlich die Track- und Sektornummern, auf die sich unser jeweiliger Befehl beziehen soll. Wie Sie aus der Tabelle 2 nämlich ersehen können, existiert zum Beispiel ein Jobcode, der das Lesen eines Blocks veranlaßt. Hier ist es natürlich nötig, die Blockparameter mit anzugeben.

Wollen Sie also ein Kommando $80 an den DC für Puffer 1 übergeben, so schreiben Sie zunächst in die Speicherstelle $0008 die Tracknummer und in Speicherstelle $0009 die Sektornummer des Blocks, der in Puffer 1 gelesen werden soll. Anschließend erhält die Speicherstelle $0001 den Jobcode und auf geht’s... Das klingt alles recht einfach. Stimmt, recht viel komplizierter wird es auch nicht mehr.

Unser einziges Problem besteht jetzt nur noch in der Tatsache, daß der DC für die Ausführung der Befehle eine gewisse Zeit benötigt, die je nach Kommando mehrere Interruptaufrufe erforderlich macht. Woher wissen wir also jetzt, wann ein Block vollständig in den Puffer gelesen ist und wir dessen Inhalt übernehmen können?

Die Lösung dieses Problems liegt in der unterschiedlichen Wertigkeit der Befehlsbytes und der Rückmeldungen des DC, die ich vorhin schon angesprochen habe. Sie können sich noch erinnern: Alle Jobcodes bestehen aus Werten größer als $80 und alle Rückmeldungen aus Werten kleiner als $80.

Da der DC aber nach **jedem** Job seine Rückmeldung in der gleichen Speicherstelle hinterläßt, in die wir vorher das Kommando geschrieben hatten, ist es uns nun ein leichtes, diese Speicherstelle zu überprüfen und das Ende des Jobs anhand der Rückmeldung abzufragen. Anhand der noch folgenden Beispiele wird diese Technik gründlich erläutert.

Jetzt wollen wir uns aber mit den eigentlichen Jobcodes und deren Aufgaben beschäftigen.

### 1) Lesen eines Sektors in einen Puffer:

Wenn wir einen Sektor in einen Puffer lesen wollen, so stellen wir fest, daß diese Aktion auf der Ebene der Jobschleife fast genauso einfach ist, wie von Basic aus mit dem »B-R«- beziehungsweise »Ul«-Befehl. Zum Lesen eines Sektors geben Sie dessen Track- und Sektornummer in den entsprechenden Speicherstellen für den gewünschten Puffer an. Anschließend senden Sie den Code $80 an den DC, und das Laufwerk startet sofort und liest den Sektor ein.

Diese Befehlsübergabe können Sie sogar von Basic aus, mit den MEMORY- und BLOCK-Befehlen, realisieren und dann den Pufferinhalt auslesen, um sich zu überzeugen, daß der Block auch wirklich eingelesen wurde.

Achtung: Die Diskette muß beim Arbeiten in der Jobschleife von Hand initialisiert werden, da wir uns auf dieser unteren Programmierebene im Rücken der automatischen Initialisierung befinden, die hier deshalb nicht mehr von alleine erfolgt. Merken Sie, daß der Inhalt im Puffer nicht mit dem auf der Diskette übereinstimmt, so kann das mit großer Wahrscheinlichkeit an der fehlenden Initialisierung liegen; doch auch dazu später noch mehr.

Jetzt wollen wir die Jobcodes anhand kleiner Beispiele genauer kennenlernen; dabei wollen wir uns auch gleichzeitig mit den Rückmeldungen des DC vertraut machen, anhand derer sich Fehler in der Ausführung des Jobs erkennen lassen.

Wir werden jetzt den Jobcode für Lesen des Blocks 18,1 in Puffer 0 übergeben und uns dann die Rückmeldung und den Inhalt des Blocks ansehen. Mit dem POKE-Befehl im Programm schreiben wir den Inhalt des Puffers direkt in den Bildschirmspeicher, was für unsere Kontrolle langen soll:

Dieses kleine Programm initialisiert die Diskette im Laufwerk. Anschließend werden Track und Sektor (18,1) übergeben und schließlich der Jobcode in Adresse $0000 geschrieben, der dafür sorgt, daß unser Block in Puffer 0 geladen wird. Nach einer kleinen Warteschleife, in der die Floppy Zeit zur Befehlsausführung hat, wird der Jobspeicher wieder ausgelesen. Anhand von Tabelle 2 können Sie erkennen, daß der Job ordnungsgemäß ausgeführt wurde, wenn Sie als Rückmeldung eine »1« bekommen.

Auf dem Bildschirm erscheint der Inhalt des Puffers, wobei unter anderem auch Teile des Directory der Diskette zum Vorschein kommen sollten.

### 2) Schreiben eines Blocks auf Diskette:

Analog zum Lesen eines Blocks erfolgt das Schreiben. Hier übergeben Sie die gleichen Parameter; nur muß sich der zu schreibende Block schon im Puffer der Floppy befinden. Durch die Auswahl des Jobspeichers können Sie jeden x-beliebigen Puffer der Floppy (0 bis 4) in jeden Block der Diskette schreiben.

### 3) Verifizieren eines Blocks von Diskette:

Dieser Vorgang erfolgt in der Floppy bei einem SAVE normalerweise automatisch. Aus diesem Grund dauert das Speichern eines Programms auch um einiges länger als das Wiedereinladen in den Computer. Mit Hilfe des entsprechenden Jobcodes ($A0) können wir ein VERIFY aber nach unserem Belieben starten, um den Inhalt in einem Pufferspeicher mit einem Block auf Diskette zu vergleichen.

Entspricht der Inhalt des Puffers nicht dem Inhalt auf Diskette, so erhalten wir als Rückmeldung die Nummer 7. Beim LOAD-Befehl entspräche das einem »VERIFY ERROR«.

Übrigens: Ich habe ja schon auf die Notwendigkeit des Initialisierens hingewiesen. Unterbleibt dieser Vorgang, so können Sie anhand der Tabelle 3 schon erkennen, was für eine Meldung Sie bekommen werden. Richtig! Die Nummer 11 wird auf Ihrem Bildschirm erscheinen.

### 4) Suchen eines Sektors:

Dieses Kommando dient nicht dem Lesen eines Blocks von Diskette. Hier wird lediglich untersucht, ob sich der von Ihnen angegebene Block überhaupt auf Diskette befindet. Ist das nicht der Fall, so erhalten Sie eine »2« als Antwort.

Ihnen ist vielleicht auch schon ein weiterer Vorteil der Jobschleife aufgefallen: Es erfolgt keine Kontrolle auf »legale« Angaben mehr; das heißt, wenn Sie an den Disk-Controller das Kommando geben, daß er Block 2 auf Track 38 lesen soll, dann tut er dies auch.

Versuchen Sie das einmal mit dem Ul-Befehl; hier bekommen Sie als Antwort: »ILLEGAL TRACK OR SEKTOR«, da Track 38 gar nicht existiert.

So groß der Vorteil dieser Nichtkontrolle auch sein mag; sie sollten sich dessen immer bewußt sein, daß der DC auch versuchen würde, auf Track 100 zuzugreifen, wenn dies verlangt werden sollte.

Die Folge wäre hierbei ein Anschlagen des Kopfes an die vordere Laufschienenbegrenzung der Mechanik; eine sicherlich nicht sehr schonende Angelegenheit.

### 5. Kopf neu positionieren (BUMP):

Dieser Befehl hat eine nützliche Funktion, die jedoch auch für eine sicher nicht unerhebliche Menge an verstellten Tonköpfen verantwortlich ist. Kann der DC einen Track nicht identifizieren, so besteht die Möglichkeit, daß der Kopf sich auf einer illegalen Spur befindet. In diesem Fall kann der DC die Position des Kopfes nicht mehr anhand der Blockheader auf jedem Track bestimmen.

Aus diesem Grund passiert folgendes: Der DC fährt den Kopf zurück an den Anschlag, und nach einem »Rattern« erfolgt eine neue Ansteuerung des gewünschten Tracks.

Mit dem Kommando $C0 können Sie ein solches Bump ausführen lassen. Nach dem BUMP können Sie den Kopf neu positionieren lassen; der Tonkopf steht ansonsten immer auf Track 1.

### 6) Maschinenprogramm im Puffer starten:

Mit dem Jobcode $D0 machen Sie intern genau das, was extern mit dem M-E-Befehl funktioniert. Der Unterschied zum M-E-Befehl besteht nur in der Tatsache, daß das Programm, das durch $D0 aufgerufen wird, als Interruptprogramm arbeitet, das heißt es wird in die Jobschleife mit eingebaut und darf deshalb nicht mit einem RTS enden, da ein JMP zurück in die Jobschleife erfolgen muß.

Wie Sie aus einem solchen Programm zurückspringen, wird später noch erläutert.

### 7) Programm im Puffer starten, nachdem das Laufwerk hochgefahren ist:

Den letzten Befehl werden wir kaum benutzen, da ihm eine Eigenschaft fehlt, die wir dringend benötigen. Wollen wir nämlich ein Programm in der Jobschleife starten, so werden wir meistens Schreib- oder Lesezugriffe auf die Diskette ausführen. Dies ist jedoch mit $D0 nicht möglich, da das Laufwerk stillsteht.

Der Befehl $E0 hat nun folgende Auswirkungen: Erkennt der DC den Jobcode, so wird das Laufwerk angefahren und die Hardware auf Diskettenzugriff vorbereitet. Mit Hilfe dieses Befehls ist es also möglich, direkt auf die Diskette zuzugreifen, was in einem eigenen Maschinenprogramm erfolgt.

Auch hier muß das Programm mit einem JMP-Befehl beendet werden, da ein Rücksprung in die Jobschleife erfolgen soll.

Wichtig ist noch, daß das Programm, das mit $D0 oder $E0 gestartet werden soll, immer am Anfang des entsprechenden Puffers stehen muß. Sollen also Programmteile aufgerufen werden, die an höheren Adressen, als $xx00 (xx = 03 bis 07) stehen, so müssen diese über Sprungbefehle aufgerufen werden.

Mit $E0 werden wir uns in unserem Kurs noch öfters beschäftigen, da er die Grundlage der Diskettenzugriffe darstellt (er wird auch vom DOS für das Formatieren angewendet).

Eine Sache dürfen Sie aber auch beim Jobcode $E0 nicht vergessen, nämlich Track- und Sektornummer anzugeben. Es wird, wie schon erwähnt, das Laufwerk betriebsbereit gemacht. Dazu gehört aber auch das Positionieren des Tonkopfes auf die richtige Spur.

## Wie schreibt das DOS auf Diskette?

Wir haben jetzt die Möglichkeit, ein Maschinenprogramm im Pufferspeicher der Floppy abzulegen und dort zu starten. Unsere Jobcodes erlauben es uns außerdem, direkt in den Ablauf der Jobschleife einzugreifen und die Diskette sozusagen »von Hand« zu manipulieren.

Als letztes fehlen uns jetzt nur noch die Kenntnisse über den direkten Zugriff auf den Schreib-/ Lesekopf der Floppy, so daß wir einzelne Bits ohne Umwege und ohne irgendeine Einschränkung durch die Blockstruktur der Diskette direkt auf die Magnetschicht schreiben können. Mit diesem Problem, das eigentlich gar keines ist, wollen wir uns jetzt beschäftigen. Dazu ein paar Bemerkungen zur Organisation der Schreib-/Leseelektronik der 1541.

Die Bytes werden zwar auf Diskette in serieller Bitfolge abgelegt; dieses Problem braucht uns jedoch gar nicht weiter zu beschäftigen. Der VIA 6522, der für uns die Elektronik steuert, kann nämlich von uns wie eine Speicherstelle behandelt werden. Senden wir also ein Byte an den VIA 6522, so geschieht das Schreiben auf Diskette vollautomatisch, so daß uns diese Sache nicht weiter beschäftigen soll.

Das einzige Problem, das sich bei der ganzen Angelegenheit stellt, ist die Frage des Timing. Immerhin benötigt der Schreiboder Lesevorgang eine gewisse Zeit, das heißt, wenn wir beispielsweise Daten vom Tonkopf lesen wollen, muß uns der DC erst mitteilen, wann das nächste Byte fertig eingelesen ist und zur Ausgabe bereitsteht.

Zur Steuerung dieses Timings wird in der 1541 das V-(Overflow-)Flag des Prozessorstatusregisters benutzt. Der Mikroprozessor 6502 hat nämlich den Vorteil, daß dieses Flag extern beeinflußt werden kann.

Die Regel sieht also folgendermaßen aus: Hat die Lese-Elektronik ein Byte vollständig eingelesen, so wird das V-Flag auf »1« gesetzt. Genauso verhält es sich mit dem Schreiben: Wurde das gegebene Byte komplett auf Diskette geschrieben, so erfolgt ebenfalls ein Setzen des V-Flags.

Das einzige, das der Programmierer nie vergessen darf, ist, daß das V-Flag nach dem Erkennen »von Hand« wieder auf »0« gesetzt werden muß, damit keine Fehlinformation erfolgen kann.

Die Speicherstelle, die für Schreib- und Lesebetrieb zuständig ist, ist Port A des Disk-Controllers mit der Adresse $lC01.

### Endlich kommt die Praxis

So, nachdem wir nun so ziemlich alle Voraussetzungen zum Programmieren haben, soll es jetzt endlich mit der praktischen Anwendung unseres Wissens losgehen. Das Werkzeug, das wir jetzt benötigen, besteht aus einem komfortablen Monitor mit »Miniassembler«. Da die Floppyprogramme, die zum Beispiel Fehler auf Diskette bringen, relativ kurz sind, ist es am besten, wenn wir einen Monitor in den Bereich ab $C000 laden und uns anschließend den Bereich ab $8000 für unsere Anwendungen sichern:

POKE 56,127: POKE 52,127: NEW (oder CLR)

Wir legen also unsere kleinen Maschinenprogramme ab $8000 ab und senden diese jeweils mit einem Basic-Programm zur Floppy, wo wir sie dann ausführen.

Achtung: Bei einem RESET wird der Speicher der Floppy gelöscht. Es ist also empfehlenswert, die Programme vor jedem Neustart wieder in den Pufferspeicher der 1541 zu schreiben.

### Error Nummer 21 auf Diskette

Ein früher beliebter Programmschutz war das Aufbringen von Errors auf Diskette. Diese konnten von den »alten« Kopierprogrammen nicht übernommen werden. Das geschützte Programm brauchte also nur einen definierten Fehler auf Diskette abzufragen und bei Nichtvorhandensein »auszusteigen«. Wenn Sie sich die Tabelle der Fehlermeldungen im Commodore-Handbuch zur 1541 ansehen, werden Sie sehr schnell erkennen, daß es für jeden kleinen Defekt eine eigene Fehlernummer gibt. Betrachten Sie jetzt Tabelle 3 dieser Folge, so können Sie dort ablesen, welche Rückmeldung des DC welche Fehlermeldung an den Computer zur Folge hat.

Wir wollen uns einmal den Fehler mit der Nummer 21 ansehen. Er tritt dann auf, wenn die Floppy versucht, einen Track zu lesen, auf diesem jedoch keine SYNC-Markierungen findet. Das ist zum Beispiel bei einer unformatierten oder beschädigten Diskette der Fall.

Unser kleines Programm in Listing 1 werden Sie vom Prinzip sehr schnell durchschauen. Es macht nichts weiter, als einen bestimmten Track auf Diskette mit lauter $55 (binär: 01010101) zu überschreiben. Das hat zur Folge, das alle SYNC-Markierungen gelöscht werden und ein Fehler »21« ist die Folge, wenn ein Zugriff stattfinden soll.

Für unsere Versuche sollten Sie eine leere, neuformatierte Diskette verwenden, die Sie sich speziell für unsere Experimente aufheben. Geben Sie also einmal das Programm in Listing 1 ein und starten Sie es anschließend (leere Diskette einlegen!).

Versuchen Sie nun den Track 5 Ihrer Diskette später einmal zu lesen, so wird sich die Floppy mit einem »21, READ ERROR« dafür bedanken.

Wie Sie sehen, ist ein Fehler 21 recht einfach zu erzeugen, da sich dieser über einen gesamten Track erstreckt (alle Informationen werden gelöscht).

Schwieriger wird es bei anderen Fehlern, die beispielsweise nur in einzelnen Blöcken vorkommen, wobei einige davon (20, 22) auch auf einen gesamten Track geschrieben werden können. Es sind dies die Fehler mit den Nummern 23, 24, 27, 28 und 29.

Um solche Fehler zu erzeugen, muß jeweils der zu zerstörende Sektor abgetastet werden, bis die richtige Stelle für den Eingriff gefunden wird. Damit Sie die wichtigen Routinen zur Arbeit innerhalb der Jobschleife ebenfalls aufrufen können, sind in Tabelle 1 ein paar wichtige Unterprogramme des DOS mit den geforderten Parametern aufgeführt.

Einen Error 22 beispielsweise würden Sie dadurch herstellen, daß Sie die Routine zum Finden des Datenblocks aufrufen. Diese kehrt bei gefundenem Datenblock mit RTS zurück. Jetzt schalten Sie auf Schreiben um (in Bild 1 dargestellt) und bringen ein paar Bytes ohne Konzept auf die Diskette. Versucht der DC diesen Datenblock später einmal zu lesen, so erfolgt ein Fehler 22, da sie die Datenblockkennung, die direkt hinter der SYNC-Markierung steht, zerstört haben.

Wollen Sie einen Fehler mit der Nummer 23, dann ist es erforderlich, daß Sie den Vorspann des Datenblocks überspringen und erst inmitten der gespeicherten Daten einen Schreibzugriff durchführen. Durch diesen Zugriff, der in der Prüfsumme am Blockende natürlich nicht verzeichnet wird, folgt die Meldung »23, READ ERROR«, als Zeichen eines Prüfsummenfehlers.

Listing 2a und 3a zeigen Ihnen Programme, die einen Error 22 und einen Error 23 erzeugen (Listing 2 b und 3 b sind die zugehörigen Quellprogramme).

Der Vorteil eines Fehlers mit der Nummer 23 ist, daß die Daten in der Regel schon im Puffer stehen, bevor der Fehler erkanntwird, dasheißt, Sie können einen Datenblock auf Diskette gezielt mit einem Fehler versehen, obwohl dieser noch lesbare Inhalte enthält.

Die eben besprochenen Fehler auf Diskette eignen sich hervorragend für einen Kopierschutz. Am wirkungsvollsten sind dabei mit Sicherheit solche Fehler, die zusätzlich noch Daten enthalten. Es gibt nämlich schon eine ganze Menge von Programmen, die Fehler übernehmen und auf der Kopie wieder simulieren.

Soweit zu Fehlern. Haben Sie schon einmal etwas von »Killertracks« gehört? Dieses anschauliche Wort steht für die Manipulation eines Tracks, der sämtliche Sicherheitseinrichtungen des DOS durcheinanderbringt.

Vielleicht hatten Sie schon einmal eine Diskette in Ihren Händen, die folgendes »Phänomen« aufzeigte: Wenn Sie versuchten, einen Block auf einer bestimmten Spur zu lesen, ist der Schreib/Lesekopf der Floppy ordnungsgemäß auf den Track positioniert worden. Danach hat der DC mit dem Lesen des Blocks angefangen und — nicht mehr aufgehört. Anders ausgedrückt: Die 1541 las und las ...

Die Spur, die Sie da versucht haben zu lesen, hat grundsätzlich dafür gesorgt, daß sich die Floppy »aufhängte«. Das es sich hier um schon angesprochenen »Killertrack« handelte, brauche ich kaum noch zu erwähnen. Aber, wie stellt man eine solche »Falle« her? Was ist mit dem Track passiert, daß der DC völlig »aus dem Häuschen« gerät? Die Antwort sehen Sie in Listing 4. Dieses kleine Programm stellt einen solchen »Killertrack« her. Des Rätsels Lösung ist eigentlich ganz einfach: Die gesamte Spur besteht aus einer einzigen SYNC-Markierung. Da die SYNC-Markierung von der Lese/Schreibelektronik speziell verarbeitet wird, verzögert sich die Arbeit des DC gewaltig, wenn eine solche »Dauer-SYNC-Markierung« auftritt.

Da die Floppy bei Fehlern bis zu über 200 mal versucht, einen Block zu lesen, dehnt sich der Zeitraum, den sie bei Verzögerungen benötigt, stark aus. Bei »Killertracks« braucht die Floppy pro Leseversuch eine Unmenge an Zeit, was sich auch im langsamen Blinkrhythmus der LED am Laufwerk zeigt.

Allein schon an den kleinen Anwendungen können Sie erkennen, wie vielseitig und vielfältig die Möglichkeiten sind, die einem in der Programmierung offenstehen. Wenn Sie intensiv mit der Floppy arbeiten, werden Sie bald schon neue Anwendungsmöglichkeiten kennenlernen. Aus der 1541 läßt sich noch eine Menge herausholen, wie wir noch feststellen werden, wobei der Kopierschutz von Disketten sicher nur einen kleinen Teil der vielfältigen Möglichkeiten darstellt.

(Karsten Schramm/gk)

# Hires-3 – 15 neue Basic-Befehle (Teil 2)

> Hier ist er, der 2. Teil von Hires-3, dem grafikunterstützenden Maschinenprogramm. Mit den diesmal gezeigten 15 neuen Basic-Befehlen kann Dornröschen (die hochauflösende Grafik) schnell und leicht ihr ganzes Können entfalten.

Mit einigen der neu vorgestellten Funktionen werden vor allem diejenigen viel anfangen können, die ihren Computer für mathematische, technische oder naturwissenschaftliche Zwecke gebrauchen. Das sollte aber die künstlerisch Interessierten nicht vom Experimentieren abhalten. Es gibt eine unbegrenzte Anzahl von Möglichkeiten, Hires-3 zu nutzen.

Wieder ist das Programm (Listing 1) mit dem MSE, den Sie an anderer Stelle in diesem Heft finden, einzugeben. Danach sollten Sie alles zunächst auf Kassette oder Diskette speichern.

Sie werden sofort bemerkt haben, daß Sie damit auch den Bereich zwischen $89B7 und $9000 abspeichern, in dem kein Maschinenprogramm enthalten ist. Das ist ein Manko, das sich aus der Entstehungsgeschichte von Hires-3 erklärt. Andererseits kannjede Erweiterung in diesen Bereich gelegt werden, ohne daß man sich immer wieder neue Start- oder Endadressen merken muß.

Jedesmal, wenn Sie jetzt Hires-3 benötigen, laden Sie es (mit Sekundäradresse 1); stellen Sie danach die Basic-Zeiger mittels NEW zurück, schützen Sie Hires-3 durch POKE52, 128:POKE56, 128, und starten Sie es dann mit SYS 36864. (Das wurde schon in der vorangegangenen Ausgabe beschrieben.)

Nun sollen die neuen Befehle erklärt werden:

### Einrichten eines frei wählbaren Koordinatensystems TRS, XU, X0, YU, Y0

Für alle nachfolgenden Befehle mit T oder LT am Anfang muß dieser TRS-Befehl vorher gegeben worden sein. TRS baut den Bildschirm nach unseren eigenen Wünschen um. Das normale Bildschirmkoordinatensystem, in dem X von 0 bis 319, Y von 0 bis 199 (abwärts) läuft, wird durch ein uns genehmes ersetzt. XU und XO sind dabei die kleinste und größte X-Koordinate, YU und YO entsprechend die kleinste und die größte Y-Koordinate, die wir wünschen.

Beispiel: Wir wollen eine Sinus-Funktion zeichnen lassen. Uns interessiert der Verlauf von XU = -10 bis XO = 6. Wir wissen, daß die Y-Werte zwischen +1 und —1 hin- und herpendeln, wählen daher YU = -1.5 und YO = 1.5: Wir geben ein TRS, -10, 6, -1.5, 1.5. Unser Bildschirm istjetzt so organisiert, wie es Bild 1 zeigt.

Dieser Befehl ist wohl der stärkste, der in Hires-3 enthalten ist. Innerhalb von Programmen kann er mehrmals verwendet werden, was zum Beispiel die Erstellung von 3D-Grafik erleichtert. Als Argumente dürfen beliebige Zahlen, arithmetische Ausdrücke oder mathematische Basic-Funktionen verwendet werden.

Nehmen Sie mal an, Sie untersuchten eine Funktion, bei der Sie ein Maximum im X-Bereich —200 bis —300 vermuten, und wo der YWert irgendwo zwischen 1000 000 und 10 000 000 sein könnte. Dann benutzen Sie unseren Bildschirm wie ein Kameraobjektiv: Fahren Sie ihn auf diesen interessanten Ausschnitt mit TRS, -300, -200, 1E6, 1E7! Grenzen sind Ihnen nur insofern gesetzt, als unser Computer keine größere Zahl als 1.701411 83E38 und keine dem Betrag nach kleinere als 2.93873588E-39 kennt.

Dazu noch eine Bemerkung. Alle Eingaben werden als Gleitkommazahlen verarbeitet. Der Prozessor 6510 unseres C 64 ist mit nicht ganz 1 MHz getaktet. Gleitkomma-Arithmetik ist eine recht aufwendige Angelegenheit. Je komplizierter die Ausdrücke werden, die als Argumente auftreten, desto längere Interpreterteile werden durchlaufen, und desto langsamer erfolgt die Befehlsausführung. Beispielsweise kann ein Argument 2.234 sofort verarbeitet werden, wohingegen bei einem Argument SIN(SQR(AtCOS(B))) ein erheblich längerer Rechengang erforderlich ist. Das sind eben die Grenzen unseres Systems, die wir hier spüren. Trotzdem geht alles noch erheblich schneller als in Basic.

Auch nachdem Sie mittels des TRS-Befehls den Bildschirm neu organisiert haben, können Sie die Befehle benutzen, die sich auf den alten Bildschirm beziehen. Sie haben somit zwei Koordinatensysteme gleichzeitig zur Verfügung: Das normale (X von 0 bis 319, Y von 0 bis 199) und Ihr selbstdefiniertes.

Die Abkürzung TRS kommt von dem Wort Transformation. Hier soll nicht näher erklärt werden, was das ist und wie das funktioniert. Wenn Sie mehr darüber wissen möchten, dann schlagen Sie mal die vergangenen Ausgaben des 64’er nach. In den Teilen 6 und 7 der Reise durch das Wunderland der Grafik ist der Begriff näher erläutert. Mehr dazu werden spätere Ausgaben bringen. Nur soviel soll dazu gesagt werden: Mittels geeigneter Transformationen können Sie wahre Wunderdinge auf dem Bildschirm vollbringen.

### Zeichnen im selbstdefinierten System

Zu allen folgenden Befehlen sollte beachtet werden, daß vorher mit TRS das neue System definiert worden ist. Alle X und Y-Werte sollten möglichst innerhalb der damit festgelegten Grenzen XU-XO und YU-YO liegen. Überschreiten oder Unterschreiten der Grenzen führt im allgemeinen jedoch nicht zu Fehlermeldungen. Es können sich aber unter Umständen falsche Bildschirmdarstellungen ergeben. Im allgemeinen kann man diese dann deutlich erkennen und durch geeignete Neuwahl der TRS-Argumente beheben.

### TPK, X, Y

zeichnet einen Punkt mit den Koordinaten X und Y in das vorher definierte System.

Beispiel:

TRS, -1,5, -2,6:TPK, 1,1 zeichnet in der in Bild 2 gezeigten Weise einen Punkt auf den Bildschirm.

### TLN, XA, YA, XB, YB

zeichnet eine Linie in das vorher selbstdefinierte Koordinatensystem ein, die vom Punkt A (XA,YA) bis zum Punkt B (XB,YB) verläuft. Mit TLN läßt sich nun recht einfach das Achsenkreuz des selbstgewählten Systems zeichnen: TLN, XU, 0, XO, 0 zeichnet die X-Achse und TLN, O, YU, 0, YO die Y-Achse.

### TRE, XA, YA, XB, YB

zeichnet in das selbstgewählte System ein Rechteck. Der Punkt A (XA, YA) ist der linke obere, B (XB, YB) der rechte untere Eckpunkt.

### TBK, XA, YA, XB, YB

zeichnet in das durch TRS definierte System ein ausgefülltes Rechteck. Die Bezeichungen sind dieselben wie bei TRE.

### TKR, XM, YM, RX, RY, W

zeichnet in das neue Koordinatensystem eine Ellipse oder einen Kreis (dann ist RX = RY). Für die Bezeichnungen gelten die Regeln des GIR-Befehls (siehe letzte Ausgabe).

### TRA, XM, YM, RX,RY, W

zeichnet ins TRS-System einen Radius ein. Es gelten dieselben Bezeichnungen wie beim RAD-Befehl (siehe vorangegangene Ausgabe).

### FUNKT, Name, XA, XB

zeichnet in das mittels TRS definierte Koordinatensystem die Funktion »Name« ein. Gezeichnet wird dabei der Bereich von XA bis XB. Im Gegensatz zu den sonstigen Basic-Regeln für Funktionsnamen ist hier nur ein Buchstabe als Name erlaubt. Mehr als 26 (Buchstaben A bis Z) Funktionen gleichzeitig wird aber vermutlich kaum jemand auf dem Bildschirm darstellen wollen, oder?
Beispiel:
DEFFNA(X) = SIN(X)
TRS, -10, 10, -2, 2
FUNKT, A, 0, 3.14
zeichnet die definierte Sinus-Funktion in das durch TRS festgelegte System. Das Ergebnis zeigt Bild 3.

Auch für diesen Befehl gilt das für TRS Gesagte (nur deutlicher). Die Ausführungszeit steigt stark an, je komplexer die Funktion ist. Trotzdem geht alles noch schneller als in einer FOR... NEXT-Schleife, die Punkt für Punkt die Funktion zeichnet.

### Löschen im selbstdefinierten System LTP, X, Y

löscht einen Punkt im TRS-System.

### LTL, XA, YA, XB, YB

löscht eine Linie im neuen System.

### LTR, XA, YA, XB, YB

löscht das Rechteck im neudefinierten Koordinatensystem.

### LTB, XA, YA, XB, YB

löscht ein ausgefülltes Rechteck im selbstdefinierten System.

### LTK, XM, YM, RX, RY, W

löscht eine Ellipse (einen Kreis) im TRS-System.

### LTV, XM, YM, RX, RY, W

löscht einen Radius im neuen System.

### LFUNK, Name, XA, XB

löscht die Funktion Name im Bereich XA bis XB im selbstgebauten Koordinatensystem.

### Noch zwei Kleinigkeiten

Zwei Programmteile gibt es noch, die über SYS-Befehle anzuspringen sind.

### SYS34647

zeichnet auf den Normalbildschirm einen schwarzen Rahmen mit einer Kopfzeile. Den Inhalt dieser Zeile können Sie verändern, indem Sie den neuen Inhalt in die Tabelle ($87FE bis '$8830) einschreiben, durch Ein-POKEn des Commodore-ASCII-Codes ihres Textes. Nach dem Aufruf dieses Programmes ist die Zeichenfarbe Schwarz. Durch POKE 646, gewünschter Farbcode können Sie das schnell ändern.

### SYS34865, Bit-Map-Start

Damit können Sie jede gewünschte Bit-Map per Drucker zu Papier bringen. Die Startadresse der Bit-Map ist in Hires-3 dez. 40960. Wenn dieser Befehl gegeben wird, während sich am Bildschirm die Hochauflösung tummelt, dann braucht die Bit-Map-Startadresse nicht angegeben werden.

Zwei Wermutstropfen mischten sich in die freudige Anwendung dieser Hardcopy-Routine:

Erstens muß sich irgendwo im Programm eine besonders gut versteckte Wanze (bug) befinden. Ich bin mir nicht einmal sicher, ob die Ursache nicht etwa im Druckerbetriebssystem versteckt liegt. Wenn man vor jedem Aufruf dieser Hardcopy-Routine den Drucker in die Ausgangsstellung bringt, durch OPENl,4,10:PRINT # 1:CLOSE1, dann funktioniert der Ausdruck fast fehlerfrei. Lediglich dann, wenn ganz links oben auf dem Bildschirm schon eine Information zu übermitteln ist, gibt der Drucker dort das Pi-Zeichen aus. Der Rest des Bildes ist einwandfrei.

## Hardcopy für den Drucker 1526

Zweitens aber ist dieses Programm für den Commodore-Drucker 1526 erstellt worden. Jeder, der dieses Gerät besitzt, wird den Ärger mit den vielen verschiedenen Betriebssystemen des 1526 kennen. Vermutlich werden Sie gar nicht wissen, welches Sie nun in Ihrem Drucker haben. Da hilft nur eines: Probieren Sie mal den Aufruf der Hardcopy-Routine aus. Wenn’s funktioniert, dann haben Sie das richtige Betriebssystem, wenn nicht, dann wenden Sie sich doch mal vertrauensvoll an Manfred Böhmel, Am Töbele 2 in 7923 Königsbronn. Der hat meinen nicht grafikfähigen 1526 in ein mich zufriedenstellendes Gerät verwandelt. In Tabelle 5 sind die Startadressen aller Hires-3 Programmteile angegeben. In vielen Zeitschriften finden sich Maschinenprogramme für Hardcopies auf diversen Druckern. Sollten Sie solch ein Programm für Ihren Drucker finden, können Sie es leicht gegen das hier vorgestellte austauschen.

Damit kennen Sie Hires-3 von der Anwendung her. In Listing 2 finden Sie wieder ein kleines Testprogramm, das alle neuen Funktionen überprüft (Bild 4 bis 7). Profis der Programmierung in Maschinensprache wird nun natürlich noch einiges interessieren: Welche Zeropage-Adressen benötigt Hires-3 und welche Adressen aus den Seiten 1-3? Welche Routinen werden aufgerufen? Wo findet man welche Programmteile? Um all diese Fragen zu klären, sind die Tabellen 1 bis 5 angefügt.

Tabelle 1 gibt alle durch Hires-3 ausdrücklich verwendeten Zeropage-Adressen an. Ausdrücklich deshalb, weil im Rahmen von Interpreter- oder Betriebssystem-Routinen ebenfalls Zeropage-Adressen angesprochen werden, die aber hier nicht benannt sind (es handelt sich dann ja um die normale Ansprache dieser Speicherstellen, wie sie ständig auch vom herkömmlichen Basic aus geschieht). Die meisten Zeropage-Speicherplätze werden in derselben Weise benutzt, wie es Interpreter und Betriebssystem vorgeben. Nur dort, wo Hires-3 eine andere Bedeutung eingeführt, ist das dann angegeben. Die Seiten 1 bis 3 unseres Speichers bergen ebenfalls wichtige Parameter unseres Computers. Deshalb ist die Tabelle 2 angefügt, die Auskunft gibt über Aktivitäten von Hires-3 in diesem Bereich.

Einige Zeiger werden verbogen und durch Hires-3 auch wieder gerade gerückt. Das geschieht zum Beispiel mittels AUS oder aber spätestens bei RUN/ STOP und RESTORE.

Tabelle 3 gibt einen Überblick über alle durch Hires-3 angesteuerten Interpreter-Routinen. Es wird jeweils die verwendete Einsprung-Adresse und die Bedeutung dieser Programmsegmente angegeben.

Aus zwei Gründen ist diese Tabelle interessant: Zum einen gibt sie Assembler-Programmierern eine kleine Orientierungshilfe für eigene Programme. Das kann in diesem Zusammenhang aber nur in relativ kurzer Form geschehen. Ausführlich wird zu einem späteren Zeitpunkt in der Serie »Assembler ist keine Alchimie« uns dieser ganze Komplex noch beschäftigen. Sie sind herzlich eingeladen, daran teilzunehmen.

Zum anderen haben mich verschiedene Gerüchte erreicht, daß Commodore klammheimlich mehrere Änderungen des Betriebssystems und eventuell auch des Interpreters durchgeführt habe. Ich habe gerade ein neueres Betriebssystem untersucht, um die Unterschiede benennen zu können (siehe »Hokus-Pokus...« in dieser Ausgabe). Es könnte deswegen sein, daß im Falle eines Falles auch Routinen geändert wurden, die Hires-3 verwendet. Ob dadurch Fehlfunktionen auftreten und wenn ja, welche, kann man kaum vorhersagen — es kommt eben sehr auf die Art der Veränderungen an. Testläufe auf verschiedenen C 64 gaben keinen Hinweis darauf: Alles lief — wie bei mir — einwandfrei.

Routinen aus dem oberen ROM-Bereich $E000 bis $FFFF, die Hires-3 anwendet, zeigt die Tabelle 4.

## ROM-Anderungen bei Commodore

Der untere Teil dieser Tabelle enthält die sogenannten Kernal-Sprungadressen. Für diesen Bereich garantiert Commodore, keine Änderungen durchzuführen. Leider — wie man aus dem vorangegangenen schnell ersehen kann — ist die Aufgabenvielfalt dieser Kernal-Adressen recht begrenzt. Man kommt ohne die anderen Routinen kaum aus.

Es wäre ja mal etwas völlig Neues, wenn Commodore etwas Vergleichbares wie die Kernal-Adressen auch für Gleitkomma- und auch andere Operationen einrichten würde. Dem steht aber die allgemein bekannte Publikationsfreundlichkeit des Hauses Commodore entgegen.

Im Gegensatz dazu sollen Sie Hires-3 geradezu durchleuchten können. Daher ist als Tabelle 5 noch eine Liste aller Teile von Hires-3 angegeben.

Sollten Sie bei der Gelegenheit noch Bugs (Programmfehler) finden, dann würde ich mich über Information darüber freu-’ en. Außerdem sollen Sie durch einige schwächere Programmteile animiert werden, sich bessere Lösungen auszudenken. Da gibt es viele Möglichkeiten. Veröffentlichungen — denke ich — können hervorragend dazu dienen, daß jeder etwas neues lernen kann, Anregungen für seine eigenen Programme erhält, etc.

In Hires-3 sind viele solcher Anregungen verarbeitet. Als besonders hilfreich haben sich erwiesen:

1. Schneider, Ebert »Das Commodore 64-Buch«, Band 1, Markt & Technik Verlag
2. »Computerspiele und Wissenswertes, Commodore 64«, Markt & Technik Verlag
3. Angerhausen, Englisch, Gerits, »64 Tips & Tricks«, Data Becker
4. H.-J. Kutz, mc6 (1984) S. 78f.

Murphys Gesetze gehen natürlich nicht an so einer guten Gelegenheit wie Hires-3 vorbei. Wenn ich also weiter oben sagte, ich würde mich freuen, wenn Sie noch Bugs entdecken, ist das durchaus erst gemeint.

Ich benütze Hires-3 in dieser Form seit mehreren Monaten ausgiebig. Dasselbe tun einige meiner Freunde. Einer hat festgestellt, daß — aus welchen Gründen auch immer — sich Probleme ergeben können, wenn man direkt nach der Zeilennummer einen Doppelpunkt eingibt. Ich habe bisher noch keine Notwendigkeit gefunden, so etwas zu tun.

Sollten Sie’s vorhaben oder aber gewohnt sein, dann achten Sie auf mögliche Störungen. Ein selten benutztes Programm-Segment hat mir in letzter Minute noch einen Fehler offenbart. Es geht um eine Fehlermeldung bei falscher Eingabe des FUNKT-Befehls. Anstelle einer 8 ist da ein B hineingerutscht. Der Fehler ist schnell behoben durch diesen POKE:
POKE34249,8

Geben Sie diese Anweisung ein, bevor Sie mittels SMON das gesamte Hires-3 abspeichern, dann ist alles in Ordnung.

Nun wünsche ich Ihnen viel Vergnügen mit Hires-3. Testen Sie, probieren sie, verbessern Sie... In den nächsten Ausgaben werden in lockerer Reihenfolge weitere Grafik-Artikel erscheinen, in denen auf die praktische Anwendung von Grafik besonderer Wert gelegt wird. Ich werde dabei dann Hires-3 als Grundlage verwenden. Falls Sie noch besondere Wünsche oder Fragen haben sollten, dann melden Sie sich doch einfach mal.

Ich versuche dann die interessantesten und wichtigsten Fragen im 64’er zu beantworten.

(Heimo Ponnath/gk)

# Memory Map mit Wandervorschlägen – Teil 5

> Auf unserer Reise durch den Speicherdschungel unserer beiden Commodore-Computer treffen wir diesmal auf die Speicherstellen 47 bis 56. Sie teilen uns sehr interessante und wichtige Informationen über Variablen-Felder mit.

TODO ASIDE

Bevor wir unsere Wanderung beginnen, möchte ich Ihnen, lieber Leser, kurz in eigener Sache etwas erklären. Erst nachdem ich diesen fünften Teil des Kurses bereits geschrieben, aber noch nicht abgeliefert hatte, bekam ich die Ausgabe 1/85 des 64'er in die Hände ...und darin fand ich den ausgezeichneten Aufsatz von Boris Schneider über das Thema der »Garbage Collection« (Seite 122 ff). Vieles, was er beschreibt, beschreibe ich im 5. Teil dieser Serie auch. Und einige meiner Erklärungen von heute hätte ich mir auch sparen können, wenn ich den Aufsatz von Boris Schneider gekannt hätte.

Und genau darum geht es mir in meiner Erklärung: Die Autoren im 64’er wissen voneinander nichts, und es ist reiner Zufall, wenn dasselbe Thema von zwei Seiten gleichzeitig aufgegriffen wird. Nun, was soll man da machen? Die Redaktion jedenfalls hat mich ermutigt, dies ruhig geschehen zu lassen, da wichtige Themen, von verschiedenen Seiten betrachtet, sicher an Verständlichkeit gewinnen. Jetzt, wo Sie mir hoffentlich glauben, daß Duplizitäten nicht abgesprochen sind, will ich natürlich auf die hauptsächliche Duplizität zwischen Herrn Schneider und mir hinweisen. Wir stellen beide eine Methode vor, wie man die im Arbeitsspeicher stehenden Variablen und Zeichenketten sichtbar machen kann. Die Grundidee ist bei uns beiden gleich, nicht aber die Ausführung. Da diese Duplizität so schön demonstriert, daß dieselbe Idee in der Computerei oft auf verschiedene Weise gelöst werden kann, lasse ich die Erklärung meiner Methode in ihrer Ausführlichkeit bestehen.

In der letzten Folge haben wir die Bedeutung der Speicherzellen 45-46 für den Speicherbereich der Ganzzahl-, Gleitkomma- und Stringvariablen behandelt.

Zur »Sichtbarmachung« habe ich Ihnen ein Kochrezept gezeigt, mit dem wir die Variablen, so wie sie im Rechner stehen, auf dem Bildschirm anschauen können. Allerdings galt diese Methode nur für den C 64. Heute liefere ich Ihnen das entsprechende Kochrezept für den VC 20 nach (siehe Texteinschub 1).

Alle interessierten VC 20-Besitzer sollten sich jetzt noch einmal den letzten Teil des Kurses vornehmen und sich die normalen Variablen ansehen.

Heute kommen wir zu weiteren Zeigern im Speicherbereich 0 bis 1024, welche ebenfalls den Variablenspeicher beeinflussen.

### Adresse 47-48 ($2F-$30)<br>Zeiger auf die Anfangsadresse des Speicherbereichs für Felder (Arrays)

Dieser Zeiger, in der Low/ High-Byte-Darstellung, gibt dem Basic-Übersetzer (Interpreter) an, ab welcher Speicherzelle die Felder (Arrays) eines Basic-Programms gespeichert sind. Da die Felder direkt nach den normalen Variablen gespeichert werden, zeigt dieser Zeiger natürlich gleichzeitig auf das Ende des Speichers für normale Variablen.

Durch POKEn einer Adresse in die Speicherzellen 47-48 kann der Speicherbereich am Anfang eines Programms beinahe beliebig verschoben werden, beinahe deswegen, weil die Verschiebung im Zusammenhang mit den anderen Bereichen (siehe Bild 1) einen Sinn haben muß. Im übrigen gilt für diesen Zeiger dasselbe, was schon für den Zeiger in 45-46 gesagt worden ist. Die Darstellung der Feld-Variablen selbst kann mit den genannten Methoden angesehen werden, ihre Erklärung finden Sie im Texteinschub 2 und 3.

Wie aus den Erklärungen hervorgeht, wird bei Feldern mit Zeichenketten (Strings) in dem von Zeiger 47-48 bezeichneten Speicherbereich nur die Definition beziehungsweise die Dimensionierung gespeichert. Die eigentlichen Zeichenketten stehen wie bei den normalen Variablen im 4. Block, vom Speicherende rückwärts angeordnet.

### Adresse 49-50 ($31-$32)<br>Zeiger auf die Endadresse (+1) des Speicherbereichs für Felder (Arrays)

Der Inhalt dieser Speicherzellen zeigt auf die Adresse, wo der Speicherbereich für Felder aufhört. Wie aus Bild 1 hervorgeht, werden die Zeichenketten vom Ende des verfügbaren RAM-Speichers rückwärts abgespeichert. Man kann also auch sagen, daß der Zeiger in 49-50 die letzte mögliche Adresse für Zeichenketten angibt. Wenn in einem Programm neue Variablen definiert werden, rutscht diese Adresse weiter nach oben und nähert sich dem Ende der Zeichenketten, die durch den Zeiger in 51-52 angegeben wird.

Wenn sich die Speicherbereiche der Felder und Zeichenketten berühren, bleibt der Computer stehen und führt die »Garbage Collection« (Müllabfuhr) durch — ein Prozeß, in dem nicht mehr gebrauchte Zeichenketten entfernt und der Zeichenketten-Speicher reduziert wird. Ist danach immer noch kein Platz, wird OUT OF MEMORY gegeben.

Der Befehl FRE löst immer eine solche Garbage Collection aus und gibt dann die Differenz zwischen den Adressen in den Zeigern 49-50 und 51-52 als verbleibenden noch verfügbaren Speicherbereich aus.

### Adresse 51-52 ($33-$34)<br>Zeiger auf die untere Grenze des Speicherbereichs für den Text der Zeichenketten-Variablen

Der Inhalt dieser Speicherzellen zeigt in Low/High-Byte-Darstellung auf dasjeweilige untere Ende (siehe Bild 1) des Textspeichers von Zeichenketten, er bezeichnet aber zugleich auch das obere Ende des frei verfügbaren RAM-Bereichs. Das entsteht dadurch, daß der Text der Zeichenketten vom Ende des RAM-Bereichs nach unten abgespeichert wird. In Bild 1 ist das durch den Pfeil dargestellt.

Beim Einschalten des Computers und nach einem RESET wird dieser Zeiger auf das oberste Ende des RAM-Bereichs gesetzt. Beim C 64 ist das 40960 ($A000). Beim VC 20 hängt es von den eingesetzten Speichererweiterungen ab, ohne Erweiterung ist die Adresse 7680 ($1E00).

Der Befehl CLR setzt den Zeiger auf die Adresse, welche durch den Zeiger in den Speicherzellen 55-56 als das Ende des Basic-Speichers angegeben wird. Wozu das dient, erkläre ich Ihnen bei der Beschreibung dieses Zeigers weiter unten.

### Adresse 53-54 ($35-$36)<br>Zeiger auf die Adresse der zuletzt eingegebenen Zeichenkette

In diesen Speicherplätzen steht die Adresse (im 4. Block, siehe Bild 1) der Zeichenkette, die als letzte von Routinen (Programme, Direkteingabe) zur String-Manipulation abgespeichert worden ist. Mit dem folgenden kleinen Programm können Sie das genau sehen:

<code>
10 PRINT PEEK(53) + 256*PEEK (54),
20 PRINT PEEK(51) + 256*PEEK (52)
30 INPUT A$
40 GOTO 10
</code>

Zeile 10 druckt uns zuerst (links) den Zeiger auf die zuletzt eingegebene Zeichenkette aus, Zeile 20 rechts daneben den Zeiger auf die untere Speichergrenze der Zeichenketten. Zeile 30 fordert zur Eingabe einer Zeichenkette auf.

Wenn Sie bei frisch eingeschaltetem Computer das Programm starten, sehen Sie eine 0 (= vorher noch kein String eingeben) und daneben die Adresse dez. 40960 (C 64) beziehungsweise dez. 7680 (VC 20 ohne Erweiterung). Wenn Sie auf das Fragezeichen des INPUT hin zum Beispiel ein A eintippen, erhalten Sie links den vorigen Wert von rechts und rechts jetzt eine um 1 kleinere Zahl. Eine weitere Eingabe von zum Beispiel XXXXX schiebt die alte rechte Zahl nach links und die neue wird um die Anzahl der Zeichen, also 5, verringert.

### Adresse 55-56 ($37-$38)<br>Zeiger auf das Ende des für Basic-Programme verfügbaren Speichers

Dieser Zeiger, in der Low/ High-Byte-Darstellung, gibt dem Basic-Übersetzer an, welches die höchste von Basic verwendbare Speicheradresse ist. Wie aus Bild 1 ersichtlich ist, ist diese Adresse zugleich der Anfang der als Variable abgespeicherten Zeichenkette (Strings).

Normalerweise ist diese Adresse fest vorgegeben. Die folgende Tabelle gibt darüber Auskunft:

TODO TABLE "Ende des Programmspeichers"

Beim Einschalten des Computers überprüft das Betriebssystem den gesamten RAM-Speicher, bis es zur ersten ROM-Speicherzelle kommt, setzt den Zeiger in 55-56 auf diese Adresse und druckt den bekannten Kopf mit der verfügbaren Speicherangabe auf den Bildschirm.

Normalerweise wird dieser Zeiger nicht geändert.

Es gibt aber zwei Gelegenheiten, bei denen eine Änderung dieses Zeigers sinnvoll beziehungsweise notwendig ist.
Anwendung 1:

Es kommt oft vor, daß der gesamte Speicher nicht ausschließlich für Basic benötigt wird, sondern daß ein freier Speicherbereich geschaffen wird, um zum Beispiel Maschinenprogramme, selbst definierte Zeichen oder hochaufgelöste Grafik unterzubringen, die aber nicht vom Basic-Programm überschrieben werden können.

Bei der Besprechung der Zeiger in 43-44 haben wir das auch schon gemacht, allerdings durch »Hochschieben« des Speicheranfangs. Mit dem Zeiger in 55-56 erreichen wir denselben Effekt, diesmal durch »Hinunterdrücken« des Speicherendes. Gegenüber den vier Schritten beim Hochschieben ist das Hinunterdrücken einfacher. Mit dem Befehl:

POKE 56,PEEK(56)-1:CLR schieben wir das Speicherende um 256 Byte nach unten, egal für welchen Computer und welche Speichererweiterung. Mit —2 verschiebt sich das Ende um 512, mit —4 um 1024 Byte (also 1 KByte) nach unten. Wenn Sie eine feinere Verschiebung als Vielfache von 256 benötigen, kommen Sie mit dem High-Byte in 56 allein nicht aus, sondern Sie müssen auch einen entsprechenden Wert in 55 hineinPOKEn.

Der Befehl CLR ist absolut notwendig, denn er setzt den Zeiger der Zellen 51-52 (siehe dort), das heißt das untere Ende des Speicherbereichs für Zeichenketten auf dieselbe Adresse wie Zeiger 55-56. Dadurch wird erzwungen, daß die Zeichenkette sozusagen als Ausgangslage unterhalb des heruntergedrückten Speicherendes abgelegt werden.
Anwendung 2:

Über den User-Port (Steckerleiste an der Rückseite, neben dem Datasetten-Anschluß) können VC 20 und C 64 mit anderen Geräten verbunden werden. Der Datentransfer über diese Verbindung — sie heißt RS232-Schnittstelle — muß allerdings programmiert werden. Diese RS232-Schnittstelle hat die Gerätenummer 2 (so wie der Drucker Nummer 4 und das Diskettengerät die Nummer 8 hat).

Wenn nun ein Gerät Nummer 2 mit einem OPEN-Befehl angewählt wird, wird automatisch der Zeiger in 55-56 und der Zeiger in 643 um 512 Bytes heruntergedrückt, um je einen Eingangsund Ausgangspufferspeicher zu erzeugen. Da der Inhalt dieser Pufferspeicher alle Variable in diesen 512 Bytes überschreiben würde, wird auch der CLR-Befehl automatisch gegeben.

Es gilt daher als Vorschrift, daß bei RS232-Verbindungen zuerst der Datenkanal durch OPEN eröffnet werden muß, bevor Variable, Felder und Zeichenketten definiert werden.

Dieser Zeiger beschließt die Gruppe der Speicherzeiger. Das nächste Mal machen wir ab Adresse 57 weiter.

(Dr. Helmuth Hauck/gk)

---
TODO ASIDE

## Texteinschub 1<br>Darstellung der normalen Variablen beim VC 20

In der letzten Folge habe ich Ihnen gezeigt, wie die drei Typen der normalen Variablen auf dem Bildschirm sichtbar gemacht werden können, auch wenn kein Disassembler oder Monitor-Programm zur Verfügung steht. Die Erklärung galt aber nur für den C 64.

Heute ist die Methode für den VC 20 an der Reihe. Die Grundidee ist natürlich dieselbe wie beim C 64:

Wir legen den Bildschirmspeicher in den Speicherbereich, der für die Variablen reserviert ist, und schon sehen wir alle Variablen in der vom Computer verwendeten internen Darstellung.

Alle Angaben gelten für den VC 20 ohne Speichererweiterung, also ziehen Sie bitte alle Speichermodule heraus. Der Speicherbereich für Programme und deren Variablen beginnt jetzt ab Adresse 4096, das ist Block 1 im Bild 1. Der Bildschirmspeicher beginnt ab 7680. Wir verlegen jetzt den Bildschirmspeicher in den Block 1, so daß er ebenfalls ab Adresse 4096 beginnt. Danach müssen wir noch eine Farbe — am besten Schwarz — in den Farbspeicher POKEn, der in dieser neuen Konfiguration von 37888 bis 38399 liegt. Warum das so ist, erklärt Christoph Sauer in seinem Aufsatz »Der gläserne VC 20« Teil 4 im 64’er 1/85 Seite 131.

Das High-Byte der Adresse, inwelcher der Bildschirmspeicher beginnt, steht in der Speicherzelle 648. Sie können das jederzeit mit PRINT PEEK(648) nachprüfen. Umgekehrt können wir eine Zahl hineinPOKEn, wodurch der Bildschirmspeicher verschoben wird. In unserem Fall erhalten wir das High-Byte für 4096 durch 4096/256 = 16.

Machen Sie jetzt bitte folgende Schritte:

1) direkt emgeben: POKE 648,16 (RETURN),
2) RUN/STOP und RESTORE drücken, bis der Cursor wieder da ist,
3) direkt eingeben:<br>FOR J = 37888 TO 38399: POKE J,0: NEXT J (RETURN),
4) mit der DELETE-Taste (nicht mit CLR !) den ganzen Text des Bildschirms löschen,
5) mit dem Cursor etwa acht Zeilen nach unten gehen,
6) mit der Commodore- und SHIFT-Taste zusammen auf die Groß- und Kleinschrift umstellen,

Schritt 1 und 3 habe ich oben schon erklärt. Schritt 4 ist nicht absolut notwendig, aber ein leerer Bildschirm ist für uns besser. Die CLR-Taste würde Schritt 3 zunichte machen. Schritt 5 erlaubt uns, weiter unten auf dem Bildschirm Variablen einzugeben, ohne den oberen Teil vollzuschreiben. Schritt 6 schließlich erleichtert das Erkennen der Variablen-Darstellung.

Geben Sie jetzt bitte direkt ein:
VARIABLE = 3
und drücken Sie die RETURN-Taste. Was jetzt passiert und alle folgenden Erklärungen sind identisch mit dem Texteinschub für den C 64 in der letzten Folge. Ich verweise deshalb darauf, ohne sie zu wiederholen.

---
TODO ASIDE

## Texteinschub 2<br>Darstellung der Felder-(Array)-Variablen

Die Felder-Variablen kommen in drei Arten vor:

- als ganze Zahlen,
— als Gleitkomma-Zahlen,
— als Zeichenketten,

Sie sind in dem Texteinschub 3 »Felder in Basic« kurz beschrieben.

Wir wollen sie uns hier mit den Methoden anschauen, welche ich das letzte Mal für den C 64 und heute für den VC 20 in den Texteinschüben »Darstellung der normalen Variablen« beschrieben habe.

Beim C 64 ist allerdings ein Zusatz dabei. Sie müssen, ambesten gleich am Anfang, noch eingeben:
POKE 44,4:NEW

Ein eventuell auftretender SYNTAX ERROR soll uns nicht weiter stören.

Wenn Sie also das jeweilige Kochrezept ausgeführt und damit den Bildschirm- und den Variablenspeicher auf dieselbe Adresse gelegt haben, können wir anfangen.

### Gleitkomma-Feld

Geben Sie direkt ein:
DIM AB(1,2,3)

Wir dimensionieren also ein Feld mit dem Namen AB, es hat drei Dimensionen, die erste Dimension hat zwei (0,1) Werte, die zweite hat drei und die dritte hat vier Werte. Sobald Sie die RETURN-Taste drücken, erscheint das Feld auf dem Bildschirm. Wir sehen:
...(plus 120 Klammeraffen @ ...)

Die ersten zwei Stellen sind der Name des Feldes in der Darstellung für Gleitkomma-Variable, wie m der letzten Folge beschrieben wurde. Die dritte und vierte Stelle geben im Bildschirmcode als Low- und High-Byte die Länge des Feldes an (das inverse c = 131, das @ = 0, bitte nachzählen). Die fünfte Stelle zeigt die Anzahl der Dimensionen (c = 3) an. Ab der sechsten Stelle stehen die Anzahl der Elemente der Dimension (diesmal als High- und Low-Byte) und zwar beginnend mit der letzten Dimension. In unserem Falle ist das also in Stelle 6 und 7 ein @ und d (0 — 3 = 4 = d), Stelle 8 und 9 sind dasselbe für die zweite Dimension und schließlich Stelle 10 und 11 für die erste Dimension (0 — 1 ^ 2=b). Danach folgen entsprechend der Anzahl der dimensionierten Elemente (2x3x4 = 24) fünf Bytes pro Element (24x5 -120), die vorerst auf 0 = @ stehen, die aber mit den Werten der Elemente aufgefüllt werden.

Dieses Auffüllen wollen wir nachvollziehen. Geben Sie bitte direkt ein:
AB(0,0,0)=5

Wir weisen damit dem allerersten Element des Feldes den Wert 5 zu.

In der oberen Darstellung des Feldes AB ändern sich dadurch Byte 12 und 13. Das neu erschienene inverse C und die Leerstelle mit den drei nachfolgenden @ ist die Gleitkommadarstellung (Mantisse und Exponent) der Zahl 5, Auf diese Darstellung werde ich später im Verlauf dieses Kurses bei der Besprechung der Speicherzelle 97 noch genauer eingehen.

Wenn wir jetzt (durch Überschreiben der vorigen Anweisung) zusätzlich noch eingeben:
AB(1,0,0) = 6
erreichen wireine entsprechende Änderung der Bytes 17 und 18, also des zweiten Elements des Feldes.

In Bild 2 sind die Stellen eines Gleitkomma-Feldes grafisch dargestellt.

### Ganzzahliges Feld

Im Vergleich zu dem Gleitkomma-Feld dimensionieren wir als nächstes ein ganzzahliges Feld:
DIM AB%(1,2,3)

Jetzt erscheint auf dem Bildschirm gleich anschließend an das erste Feld eine neue Darstellung:
... (plus 48 Klammeraffen @) ...

Die ersten elf Byte haben dieselbe Bedeutung wie beim Gleitkomma-Feld, aber nur deswegen, weil wir dieselben drei Dimensionen mit identischer Elementenzahl dimensioniert haben. Bei mehr Dimensionen wäre dieser Kopf natürlich länger. Die inverse Darstellung des Feldnamens signalisiert ein ganzzahliges Feld. Die dritte Stelle zeigt das »;« — im Bildschirmcode ist das die 59. In der Tat ist das Feld nur 59 Byte lang, also wesentlich weniger als das Gleitkomma-Feld. Die 2x3x4 = 24 Elemente benötigen in der Ganzzahl-Darstellung nur je zwei Byte (24x2 = 48 + 11 = 59). Womit bewiesen ist, daß eine Ganzzahl-Darstellung mit dem Zeichen % erheblich Speicherplatz spart — allerdings nur bei Feldern!

Jetzt wollen wir noch den Inhalt des Feldes füllen, so wie vorher mit:
AB%(0,0,0) = 5
... und prompt ändert sich Byte Nummer 13 in ein e (e = 5).

Eine Eingabe für das zweite Element:
AB%(1,0,0) = 6
verändert das 15. Byte in ein f.

In Bild 3 ist der Inhalt eines Ganzzahl-Feldes grafisch dargestellt.

### Felder mit Zeichenketten

Die Dimensionierung eines Feldes mit Zeichenketten sieht so aus:
DIM AB$(1,2,3)

Auf dem Bildschirm erscheint jetzt ein Feld in folgender Darstellung:
... (plus 72 Klammeraffen @) ...

Auch hier zeigen die ersten elf Stellen dieselbe Information wie bei den anderen Feldern. Zur Kennzeichnung des Zeichenketten-Feldes ist das zweite Zeichen des Feldnamens invers dargestellt. Zeichen 3 und 4 geben wieder die Länge des Feldes an. Das S hat den Bildschirmcode 83. (Vorsicht! Da wir im Groß-/Kleinbuchstaben-Modus sind, müssen wir die jeweils rechte Seite der Spalten in der Code-Tabelle nehmen). Die Länge 83 minus 11 Kopfstellen ergibt 72 Bytes, geteilt durch 24 (2x3x4 = 24 Elemente) erhalten wir 3 Byte zur Darstellung eines Elements.

Das erste Byte gibt die Länge der Zeichenkette an, das zweite und dritte Byte (Low/High-Byte) die Adresse, ab der die Zeichenkette im vierten Block (siehe Bild 1) gespeichert ist.

Die Methode ist also dieselbe wie bei den »normalen« Zeichenketten-Variablen. Das wollen wir uns auch noch ansehen. Geben Sie direkt ein:
AB$(0,0,0)='AAAAAA'

In der Darstellung des Feldes ändern sich dadurch die Stellen 12, 13 und 14, und wir sehen

- beim C 64:
- beim VC 20:

Im Bildschirm steht dafür:

-C 64: 6 250 159 das heißt 6 Zeichen, ab Adresse 250 + 159x256 = 40959
- VC 20: 6 250 29 das heißt 6 Zeichen ab Adresse 250 + 29x256=7674

Jetzt weisen wir dem letzten Element auch noch eine Zeichenkette zu:
AB$(1,2,3)"BB"

Die letzten drei Stellen des Feldes ändern sich ebenfalls, wobei die erste mit dem b eine Zeichenkettenlänge von 2 angibt, dementsprechend muß die Anfangsadresse um 2 niedriger sein als die vorher definierte Kette; Das Low-Byte 250 — 2 = 248, in der Codetabelle finden wir dafür das, was auch im Feld steht. Das High-Byte bleibt unverändert.

Bild 4 zeigt die grafische Darstellung des Zeichenketten-Feldes.

Als letztes zeige ich Ihnen noch die im vierten Block abgespeicherten Zeichenketten. Wir drucken einfach den CHR$-Wert der in den betreffenden Speicherzellen stehenden Codezahlen aus mit:
- VC 20: FORI = 248 TO 255:PRINT CHR$(PEEK(29*256 + I));:NEXT
- C64: FOR 1 = 248 TO 255:PRINTCHR$(PEEK(159*256+I));:NEXT
... und wir erhalten die beiden Zeichenketten in umgekehrter Reihenfolge, also vom Speicherende her eingespeichert. Interessant ist, daß sich vor die Felder — wenn Sie sie noch auf dem Bildschirm hatten — die neu definierte Gleitkomma-Variable I@ geschoben hat. Auch das ist eine Demonstration des Speicherverfahrens der Variablen, genau so wie ich es Ihnen in der letzten Folge erklärt habe.

---
TODO ASIDE

## Texteinschub 3<br>Felder in Basic

Zur Wiederholung: Es gibt zwei Arten von Variablen, normale Variable und Felder. Jede der beiden Arten ihrerseits kann aus Gleitkomma-Zahlen, ganzen Zahlen oder Zeichenketten bestehen.

Eine normale Variable kann immer nur einen Wert haben, ein Feld enthält gleichzeitig viele Werte, alle unter demselben Variablen-Namen.

Wir können uns ein Feld mit dem Namen KARLSTRASSE als eine Liste vorstellen, in der jedes Element zwar auch den Namen Karlstraße hat, sich aber von den anderen Elementen durch eine eigene Hausnummer unterscheidet. Jede Variable in einer Hausnummer hat einen bestimmten Wert.

Während eine normale Variable einfach mit A = 3 einen Wert zugewiesen bekommt, muß ein Feld erst definiert werden, nämlich wie viele Elemente es enthält. Wir machen das mit dem Befehl
DIM KARLSTRASSE (12)

Dieses Feld hat 13 Elemente (von 0 bis 12). Jedem Element kann nun ein Variablenwert zugewiesen werden durch KARLSTRASSE (0) = 25
KARLSTRASSE (1) = 56

Das Feld KARLSTRASSE hat in der Klammer nur eine Zahl, man sagt, es hat nur eine Dimension.

Ein zweidimensionales Feld entspricht einem Schachbrett, mit Zahlen in der einen und Buchstaben in der anderen Dimension. Wir definieren es mit:
DIM AX (7,7)

AX ist der Name, jede Dimension hat acht Elemente, insgesamt kann das Feld 64 Werte enthalten.

Ein dreidimensionales Feld entspricht einem Quader, oder bei gleicher Elementenzahl pro Dimension (Seite) einem Würfel. Dieses wird dimensioniert mit
DIM BY (125,6,2)

Die Anzahl der Dimensionen wird nur begrenzt durch den verfügbaren Speicherplatz. Wieviel Bytes pro Feld gebraucht werden, entnehmen Sie bitte der Erklärung bei der Darstellung der Feld-Variablen (Texteinschub Nummer 2).

Ein Feld, das wie bisher gezeigt dimensioniert wird, enthält Gleitkomma-Zahlen.

Ein Feld mit ganzen Zahlen wird durch das Zeichen % nach dem Namen gekennzeichnet, also:
DIM CZ%(.,.,.)

Ein Feld mit Zeichenketten dagegen hat nach dem Namen das übliche Zeichen $, also:
DIM DT$(..,..,..)

»Wozu brauche ich Felder, wenn ich auch normale Variable verwenden kann?«, werden Sie vielleicht noch fragen.

Felder haben den großen Vorteil, daß immer dann, wenn viele Variable in einem Programm vorkommen, die alle einen gewissen Zusammenhang haben, viel Speicherplatz gespart werden kann.

Eine normale Variable braucht sieben Byte, eine Feld-Variable nur fünf oder bei ganzen Zahlen sogar nur zwei Byte. Zugegeben, vorher steht noch ein längerer Kopf, aber halt nur einmal. Und das zahlt sich bei vielen Variablen sehr rasch aus.

Und schließlich muß ich noch darauf hinweisen, daß die »Hausnummern« oder Indizes der Elemente innerhalb eines Programms durch mathematische Operationen verändert und manipuliert werden können. Aber das ist natürlich höhere Programmierkunst und geht über diese kurze Einführung hinaus.

# Finden mit System - Eine neuartige Suchmethode

<!-- Effektives Programmieren -->

> Nachdem wir uns in den letzten beiden Folgen mit grundlegenden programmiertechnischen Fragen befaßt haben, sollen jetzt konkrete Anwendungen im Mittelpunkt stehen. Diesmal ist es das Suchen von Zeichenketten mit einer erst vor kurzen entwickelten Methode.

Wie versprochen, stelle ich Ihnen diesmal ein Suchprogramm vor, mit dem eine schnelle »intelligente« Suche von Strings möglich wird. Doch bevor wir uns mit der Praxis, sprich dem Programm, beschäftigen können, müssen wir uns ein wenig mit der Theorie des Suchens befassen.

### Wie sucht man eigentlich?

Nun, uns soll hier nicht interessieren, wie der eine oder andere mit seiner häuslichen (Un-) Ordnung fertig wird. Uns geht es hier um das Suchen und möglichst auch Finden von einer Zeichenkette in einer anderen. Einigen wir uns jetzt schon auf zwei Begriffe, damit wir später keine Schwierigkeiten bekommen. Der Suchstring ist der String, nach dem wir suchen. Dies kann eine beliebige Zeichenkette, also ein Wort, eine Zahl, Grafikzeichen oder ein Gemisch aus alledem sein. Der Durchsuchstring ist derjenige, in dem wir suchen.

Das landläufige Suchverfahren sieht folgendermaßen aus: Der Anfang des Suchstring wird an den Anfang des Durchsuchstrings angelegt. Dann werden die beiden ersten Buchstaben verglichen. Sind diese gleich, werden die beiden zweiten Buchstaben verglichen, und so weiter. Dieses Spielchen wiederholt sich so lange, bis sich die beiden Buchstaben nicht gleichen. Dann wird der Suchstring um eine Position am Durchsuchstring verschoben, und somit der erste Buchstabe des Suchstrings mit dem zweiten des Durchsuchstrings und so weiter, verglichen. Wird beim Suchen festgestellt, daß alle Buchstaben übereinstimmen, so hat man den Suchstring im Durchsuchstring gefunden. Stellt man aber fest, daß das Ende des Suchstrings über den Durchsuchstring hinausragt, so muß man die Suche abbrechen, da der Suchstring nicht im Durchsuchstring vorhanden sein kann.

Dieses Suchverfahren war jahrelang das einzige verwendete, da es relativ einfach zu programmieren und relativ schnell war.

### Es geht auch anders

In der November-Ausgabe der Zeitschrift Spektrum der Wissenschaft wurde nun ein völlig neuer Suchalgorithmus vorgestellt. Dieser ist erst vor kurzem von zwei amerikanischen Forschern entwickelt worden, und kann mit noch vertretbarem Aufwand in Maschinensprache formuliert werden. Noch einmal das Prinzip des alten Algorithmus: Man verschiebt den Suchstring am Durchsuchstring immer nur um eine einzige Position, braucht also mindestens so viele Vergleiche, wie Zeichen im Suchstring minus Zeichen im Durchsuchstring (bei Überhang wird ja abgebrochen). Findet man einen Weg, den Suchstring immer gleich um mehrere Positionen zu verschieben, ohne daß dabei ein Auftauchen des Suchstrings im Durchsuchstring übersehen werden kann, läßt sich der Suchvorgang rapide beschleunigen. Einfach um einen größeren konstanten Faktor zu verschieben, etwa um 2, klappt natürlich nicht, weil dann nur alle ungeraden Positionen abgefragt werden. Beginnt der Suchstring aber auf einer geraden Position, wird er nicht gefunden. Dieser Verschiebefaktor muß also variabel sein. Um ihn zu ermitteln, stellen wir mal fest, wie weit in einigen Fällen maximal verschoben werden darf, um den Suchstring nicht zu verpassen.

Im folgenden werden wir immer nach dem Wort »HALLO« suchen. Wenn wir das Wort »HALLO« im String »SCHÖNES WETTER HEUTE« suchen, dann legen wir erstmal »HALLO« ganz normal an der ersten Position an. Nun vergleichen wir von hinten! Die beiden letzten Buchstaben, »N« und »O« stimmen offensichtlich nicht miteinander überein. Also kann »Hallo« nicht am Anfang des Strings stehen, und darf somit gleich um fünf Positionen, dies ist gleich der Länge von »Hallo« verschoben werden.

Hier das Ganze im Bild:

SCHÖNES WETTER HEUTE
HALLO
HALLO
HALLO...
TODO

Doch es ist nicht immer ganz so einfach. Suchen wir mal im String »DU HALLODRI«. Beim Anlegen und Vergleichen trifft das »O« aus »HALLO» auf das »A« von »DU HALLODRI«. Würden wir jetzt, da die beiden ja ungleich sind, »HALLO« um fünf Positionen verschieben, würden wir leider das »HALLO« in »HALLODRI« übersehen, da wir schon zu weit verschoben haben:

DU HALLODRI
HALLO
HALLO
TODO

Wie weit darf man in diesem Fall verschieben? Nun, um maximal drei Positionen, dann liegt das »HALLO« nämlich genau an der richtigen Stelle:

DU HALLODRI
HALLO
HALLO
TODO

Das ist ja ganz schön und gut, daß wir wissen, daß jetzt maximal um drei Positionen verschoben werden darf, aber wie sag ich’s dem Computer? Auf die Lösung zu kommen ist genial und deshalb verblüffend einfach. Zählen wir einmal die Buchstaben von »HALLO« von hinten mit Null beginnend durch.

H A L L O
4 3 2 1 0
TODO

Das A erhält dann die Stellungsnummer 3. Diese stimmt aber nun mit dem maximalen Verschiebefaktor überein. Zufall? Nun machen wir noch ein Beispiel. Suchen wir PUTER in COMPUTER.
Erst einmal durchzählen:

P U T E R
4 3 2 1 0
TODO

Und dann:

C O M P U T E R
P U T E R
P U T E R
TODO

Der letzte Buchstabe in PUTER, das R stößt auf ein U im Computer. Dessen Stellungsnummer ist aber wieder 3, es darf also wieder um drei Positionen verschoben werden. Daß das tatsächlich immer funktioniert, kann man auch mathematisch beweisen, würde jedoch hier den Rahmen sprengen.

Das Verfahren, den maximalen Verschiebefaktor herauszufinden, sieht im groben also so aus: Bevor der Suchvorgang gestartet wird, wird eine Tabelle mit den Stellungsnummern der Buchstaben im Suchstring angelegt. Zwei Sonderfälle haben wir noch nicht betrachtet, die beim Tabellenanlegen aber automatisch mitberücksichtigt werden:

Sollten Buchstaben im Suchstring doppelt auftauchen, so wird für einen Buchstaben immer die kleinste Stellungsnummer gespeichert. Dies läßt sich sehr einfach dadurch erreichen, daß der Suchstring beim Anlegen der Tabelle von vorne nach hinten durchgegangen wird. Taucht dann ein Buchstabe ein zweites Mal auf, so wird automatisch die größere Stellungsnummer von der kleineren überschrieben. Ein Beispiel:

Suchen wir mal »COMMODORE« in » COMMODORE«. TODO

Zuerst einmal durchzählen:

C O M M O D O R E
8 7 6 5 4 3 2 1 0
COMMODORE COMMODORE
TODO

Das »E« stößt nun auf ein »O«. Nun gibt es aber drei »O«. Welche Stellungsnummer darf hier genommen werden? Die des letzten »O«, die »2«. Mit einer Verschiebung von zwei haben wir dann ja auch die Übereinstimmung gefunden. Durch den Tabellen-Algorithmus wird immer automatisch die Stellungsnummer des letzten »O« genommen.

Die zweite Regel befaßt sich mit den Buchstaben. Die erhalten als Stellungsnummer die Länge des Suchstrings, da ja in diesem Fall um die gesamte Suchstringlänge verschoben werden kann. (Siehe auch unser allererstes Beispiel). Somit ist der Algorithmus zur Tabellenbildung schon formulierbar. Er ist in Bild 1 als Flußdiagramm dargestellt.

Bis jetzt habe ich immer von einem maximalen Verschiebefaktor gesprochen. Denn nicht immer darf um den vollen Faktor verschoben werden. Wir haben bisher nämlich noch nicht den Fall betrachtet, daß teilweise oder volle Übereinstimmung von Such- und Durchsuchstring eintritt.

Suchen wir mal »HOHO« in »HIHOHOHI«. Beim ersten Anlegen von »HOHO« stimmen die letzten beiden Buchstaben überein, der zweite aber nicht. Würde jetzt um den Tabellenwert — bei dem »I« ist er 4, verschoben, so würden wir um zwei Buchstaben zu weit verschoben haben!:

H I H O H O H I
H O H O
H O H O
TODO

Um dies zu vermeiden, müssen wir einen weiteren Begriff einführen, die Suchtiefe. Die Suchtiefe bezeichnet nichts anderes, als die Anzahl der positiv ausgefallen Vergleiche. In unserem Beispiel wäre sie 2, da zwei Vergleiche, »O« mit »O« und »H« mit »H«, positiv ausgefallen sind. Der dritte Vergleich »I« mit »O« ist nun negativ, das heißt, daß der Suchbegriff dort nicht auftauchen kann, und nun verschoben werden muß. Um den tatsächlichen Verschiebefaktor zu ermitteln, muß nun noch von dem aus der Tabelle entnommenen Wert die Suchtiefe subtrahiert werden. In unserem Fall wäre das 4 minus 2 = 2. Und das stimmt wieder:

H I H O H O H I
H O H O
H O H O
TODO

Verschieben wir um zwei Positionen, so liegt unser »HOHO« genau an der richtigen Stelle. Die Suchtiefe kann minimal Null werden, wenn schon der erste Vergleich negativ ausfällt, und maximal gleich der Länge des Suchstrings, wenn nämlich völlige Übereinstimmung herrscht, der Begriff also gefunden wurde.

Das wäre an sich schon alles. Theoretisch ließe sich auch schon jetzt der Suchalgorithmus formulieren. Aber eine Kleinigkeit würde unsjetzt noch Schwierigkeiten machen. Gemeint ist das Suchen mit ]oker. Den Floppybesitzern unter Ihnen wird es wahrscheinlich schon bekannt sein.

### Probleme mit dem Joker

Nehmen wir einmal an, Sie führen eine Adressendatei und würden nun gerne die Adresse von einem Herrn Maier haben. Dummerweise wissen Sie nun nicht mehr, ob es Herr Maier oder vielleicht Herr Meier oder gar Herr Mayer war. Beim Durchsuchen wäre also ein Joker sehr praktisch. Dann suchen sie nach Herrn M??er. Die Suchroutine müßte ihnen nun alle nur erdenklichen Formen des Namens Maier heraussuchen. Dummerweise ist ein Joker in unserem Suchalgorithmus gar nicht so einfach zu installieren, und wirft uns auch, wie wir noch sehen werden, geschwindigkeitsmäßig zurück.

Konstruieren wir uns mal wieder ein Beispiel. Wir suchen nach »H?HI« in »HIHXHI«. Beim ersten Anlege- und Vergleichsvorgang wird das »I« mit einem »X« verglichen. Da der Vergleich ungleich ausfällt, und »X«, da nicht im Suchstring enthalten, einen Maximalverschiebefaktor von 4 liefert, und die Suchtiefe hier auch noch 0 ist, würde um vier Zeichen verschoben, und das Auftauchen von »HXHI« an der Position 3 völlig übersehen.

H I H X H I
H ? H I
H ? H I
TODO

Fragen wir uns also wieder einmal, um wieviel hier maximal verschoben werden kann. Die Antwort lautet 2, da ja »HXHI« an der Position 3 steht.

H	I	H	X	H	I
H	?	H	I
H	?	H	I
TODO

Nun ist die Stellungsnummer des Jokers gerade aber auch 2. Ohne näheren Beweis und Erklärung muß der Algorithmus noch folgende Regel zusätzlich enthalten:

Es darf maximal um die Stellungsnummer des Jokers im Suchstring verschoben werden. Damit läßt sich der Suchalgorithmus als Flußdiagramm formulieren. Dies ist in Bild 2 dargestellt. Das Flußdiagramm ist übrigens parallel zur Suchroutine im Suchprogramm zu sehen, da sich beide in der Struktur gleichen. Diese Suchroutine steht in den Speicherzellen $C12B-$0179. Deswegen ist das Flußdiagramm auch nicht ganz so elegant, wie es eigentlich sein könnte.

### Lohnt sich das überhaupt?

Das ist jetzt natürlich die entscheidende Frage. Was haben wir dabei eigentlich gewonnen? Dem Verschieben können um mehrere Positionen, steht ein ungleich hoher Aufwand gegenüber. Dazu sei gleich gesagt, daß es Unsinn wäre, das Ganze in eine normale INSTR-Funktion, wie in Ex-, Simons- und GBasic enthalten, einzubauen. Dann lohnt sich der Aufwand eben nicht. Ich habe einmal überschlagsweise mein Programm (das ich »Intellisearch« = intelligentes Suchen genannt habe) mit diesen Erweiterungen verglichen, indem ich einen String in einem anderen gesucht habe. Fazit: Fast alle sind ungefähr fünfmal so schnell wie Intellisearch.

Aber: Diese INSTR-Funktionen lassen sich nur jeweils auf einen einzigen String anwenden. Will man eine größere Anzahl von Strings durchsuchen, etwa in einem Feld (Array), ist eine FOR-NEXT-Schleife notwendig. Im Gegensatz dazu ist Intellisearch darauf »abgerichtet«, Stringarrays zu durchsuchen. Und dann kommt man auf einmal auf Suchgeschwindigkeiten, die alles andere in den Schatten stellen. Zur Entlastung von Intellisearch muß nämlich folgendes gesagt werden. Die Parameterauswertung bei Intellisearch ist ungleich umfangreicher, als bei den INSTR-Funktionen. Außerdem wird Intellisearch über den SYS-Befehl aufgerufen, was ebenfalls sehr zeitintensiv ist (Zeitintensiver als der Aufruf über einen neuen Basic-Befehl auf jeden Fall).

Am allerwichtigsten aber: Ein Zeitverlust entsteht noch durch das Aufstellen der Tabelle. Der Suchalgorithmus selbst ist nämlich tatsächlich schneller. Aber da ja zuerst die Tabelle der Stellungsnummern aufgestellt werden muß, haben bei kurzen Durchsuchstrings die INSTR-Funktionen einen recht großen Zeitvorsprung, bevor Intellisearch mit dem Suchen anfangen kann. Die Anwendung lohnt sich also nur bei recht großen zu durchsuchenden Strings, oder gleich bei einer großen Anzahl zu durchsuchender Strings, am besten Arrays. Je mehr Strings durchsucht werden müssen, desto eher lohnt sich der Einsatz des Programms. Dann kann der Suchalgorithmus den gegebenen Zeitvorsprung locker wieder wettmachen, und um Faktoren von 2 bis 10, je nach Länge des Suchstrings, schneller sein. Denn je länger der Suchstring, desto weiter kann er bei völliger Nichtübereinstimmung in einem Schub verschoben werden, während der alte Algorithmus immer nur um 1 verschieben kann.

Es ist übrigens noch eine Erweiterung eingebaut, die auch verlangsamend wirken kann:

Das Füllsel.

### Was ist ein Füllsel?

Manchmal hat mich bei der Floppy die Filenamenabkürzung mit »\*« gestört. So organisiere ich meine Artikel meist indem ich ihnen einen Namen und dann Anhängsel wie «.LSTOl« oder »TXT« gebe. Möchte ich nun einen Überblick über sämtliche auf der Diskette befindlichen Texte, ginge das nur, wenn das »TXT« immer die letzten vier Buchstaben eines 16stelligen Filenamens wäre. Dann könnte ich nach »?????????????.TXT« suchen. Und das ist mir zuviel Tipparbeit. Einfacher wäre es da, wenn man nach »*.TXT« suchen könnte. Aber nach dem »*« nimmt die Floppy 1541 keine weiteren Zeichen an.

Nun, in der Floppy 1541 kann ich das natürlich nicht so ohne weiteres ändern, aber immerhin in mein Suchprogramm einbauen. Suchen Sie also nach »HA*LO«, so wird sowohl »HALLO«, wie auch »HALLIHALLO«, und sogar »HALO« gefunden.

Eine Einschränkung muß dabei aber gemacht werden. Es ist nur ein Füllsel im Suchstring erlaubt, da der Speicherplatz in der Zeropage zu klein ist, noch mehr Werte ungefährlich zwischenzuspeichern. Denn Intellisearch zerlegt einen solchen String in zwei Teilstrings. Wird in einem String der erste Teilstring gefunden, so wird nach dem zweiten gesucht. Ist auch dieser vorhanden, so hat man gefunden was man sucht. Sonst muß die Suche beim nächsten Durchsuchstring wieder mit dem ersten Teilstring beginnen. Verständlicherweise benötigt das Zerlegen in zwei Teilstrings, und das ab und zu notwendige Erstellen der Tabelle eine gewisse Zeit, so daß das Suchen mit Füllsel etwas langsamer als das normale Suchen ist.

### So arbeitet man mit Intellisearch

Nach all der grauen Theorie doch nun etwas Praxis. Intellisearch belegt die Speicherbereiche $C000 bis $C2FF. Das Programm selbst belegt dabei nur die Speicherstellen $C000 bis $C17A, um die Tabellenroutinen jedoch einfacher und somit das Programm einigermaßen verschieblich zu halten, liegt die Tabelle von $C200 bis $C2FF. Wer will, kann ja die Tabelle direkt hinter das Programm legen, um Platz zu sparen.

Sollte dieser Speicherbereich von Ihrem eigenen Programm oder einer Basic-Erweiterung anderweitig benötigt werden, so müssen Sie leider selber die Anpassungen an einen anderen Speicherbereich vornehmen. Mit dem dokumentierten Listing und dem SMON dürfte das aber kein Problem sein.

Im Vertrauen auf den MSE ist kein Basic-Lader mehr notwendig, das MSE-Listing ist also Listing 1. Im Programm werden zwei kleine Tricks verwendet, die vielleicht dem einen oder anderen von Ihnen nicht bekannt sind. Es sind dies die Maskierung des SEC-Befehls über den Bit-Befehl gegen Ende des Listings, und der recht brutale Aussprung aus der Zähler-Erhöhen-Routine ($C0E2), wenn die Suche beendet werden soll. Dort wird eine Rücksprungadresse über PLA PLA »vernichtet«, so daß ordnungsgemäß mit JMP »Klammer zu?« ausgesprungen werden kann. Dies entspricht einem POP oder DISPOSE RETURN bei den Basic-Erweiterungen G- und ExBasic, mit denen ein Unterprogramm, das über GOSUB aufgerufen wurde, mit GOTO und nicht mit RETURN verlassen werden kann. So, nun aber zum Aufruf der Routine. Dieser erfolgt über:

### SYS 49152 (A$,B$(O),P,Q,X%,Y%)

Die Variablennamen sind hier ganz willkürlich gewählt, können also von Ihnen verändert werden.

**A$** bezeichnet den zu suchenden String. Hier ist wohl keine besondere Erklärung nötig, außer daß wie schon erwähnt »?« als Joker und »*« als Füllsel gilt.

**B$(0)** bezeichnet das zu durchsuchende Array. Soll, waswenig sinnvoll ist, ein einzelner String durchsucht werden, darf hier auch einfach B$ stehen. Will man die Suche erst beim siebten Arrayelement starten, weil der String zum Beispiel schon im sechsten Element gefunden wurde ( = B$(5), Zählung beginnt bei 0), darf dort auch B$(6) stehen. Dies ist dann der erste durchsuchte String.

**P** gibt die Anzahl der zu durchsuchenden Strings an. Wird beispielsweise bei B$(0) begonnen, und hat P den Wert 100, so wird nach dem Durchsuchen von B$(99) abgebrochen. Bei einem Startwert B$(17) wäre dies dann analog bei B$(116) der Fall. Diese Angabe ist stets sorgfältig zu handhaben, da Intellisearch nicht die Größe des zu durchsuchenden Arrays feststellt, und somit aus Versehen über das Array hinaus gesucht werden kann. Dies kann im ärgsten Fall zum Absturz führen!

**Q** ist die Startposition der Suche. Dies kann bei mehreren Daten in einem String recht nützlich sein. Steht etwa ein Name immer ab der 14ten Stelle im Array, so brauchen die ersten 13 Stellen nicht durchsucht zu werden, wenn nach einem Namen gesucht wird. Dann sollte Q den Wert 14 enthalten.

In **X%** und **Y%** wird am Ende das Ergebnis der Suche festgehalten. In X% steht die Nummer des Strings, in dem der Suchstring gefunden wurde, wenn mit B$(0) gestartet wurde, ansonsten muß zu X% noch P addiert werden, um die Position im Array zu bekommen.

Y% gibt schließlich die Position im String selbst an. Wird die Suche abgebrochen, das heißt Suchstring nicht gefunden, steht in X% -1, in Y% bleibt der alte Wert erhalten.

### Und so geht’s

Im folgenden werden wir uns noch ein wenig mit der Funktionsweise des Programms beschäftigen. Dazu dienen uns Bild 3, das ein Flußdiagramm der Kontrollroutine zeigt, sowie Listing 2, und Tabelle 1, die alle verwendeten Zeropage-Adressen aufschlüsselt. Ich weiß leider nicht, ob nach der Benutzung ein einwandfreier Kassettenbetrieb möglich ist, da einige der Kassetten-Zeropage-Adressen verwendet werden. Hier wäre ich für Hinweise dankbar.

Als erstes wird der Suchstring geholt, und auf Füllsel untersucht. Bei der Verwendung dieser Routine ($AD9A) kann es unter Umständen bei manchen C 64 zu einem FORMULAR TOO COMPLEX ERROR kommen. Ist ein solches Füllsel vorhanden, erfolgt die Teilung in zwei Teilstrings. Die Länge des Teilstrings 2 ist später gleichzeitig das Kennzeichen dafür, ob ein Füllsel vorlag. Ist die Länge gleich 0, ist das nicht der Fall.

Alsdann wird der Pointer auf den Startdurchsuchstring gespeichert. Dies erfolgt auch über die uns schon bekannte Routine $AD9A. Wenn keine direkte Auswertung vorgenommen wird, steht in $64/$65 ein Zeiger auf den Stringdescriptor, oder den Variablendescriptor. Achtung! Hier wird nicht überprüft, ob es sich überhaupt um einen String oder ein Stringarray handelt. Hier kann man also die Routine zum »Ausflippen« bringen.

Später wird zu diesem Pointer einfach 3 addiert, um den nächsten Stringdescriptor zu bekommen. Dies funktioniert bei Arrays einwandfrei, solange nicht die Array-Obergrenze überschritten wird. Theoretisch ließen sich hier auch mehrdimensionale Arrays durchsuchen. Wer dies vor hat, möge sich nochmal den Aufbau von Stringarrays im Artikel über die Carbage Collection zu Gemüte führen (64’er, Ausgabe 1/85).

Als nächstes werden die zwei numerischen Parameter geholt, beide als Bytewert. Deswegen sind hier auch nur Werte kleiner 256 erlaubt. Mehr ist sowieso kaum sinnvoll.

Nun wird der aktuelle Durchsuchstringdescriptor in den Arbeitsspeicher kopiert, die Tabelle angelegt und die Suche nach Teilstring 1 gestartet. Wird Teilstring 1 gefunden, wird nach der zu durchsuchenden Strings erreicht wird. Dann wird die Rücksprungadresse vom Stack entfernt, und nach dem Einkopieren von —1 in die erste der beiden Integervariablen die Routine verlassen.

Die beiden letzten Teile des Programms sind das Tabellenanlegen und die eigentliche Suchroutine. Hier verweise ich auf die beiden Flußdiagramme und die obigen Erklärungen.

So, damit hätten wir uns wohl durch das Programm durchgekämpft.

Noch einige Tips: Das Füllselzeichen kann in der Speicherstelle $C01E geändert werden. Beim Jokerzeichen sind einige Änderungen mehr notwendig. Diese betreffen die Speicherstellen $C14A, $C160 und $C165. Dort muß dann jeweils der ASCII-Code des Jokers stehen.

Das nächste Mal geht’s wieder um Strings, dann allerdings um Sortieren. Karsten Schramm wird dann die gängigsten Sortieralgorithmen vorstellen und vergleichen.

(B. Schneider/gk)

# Der gläserne VC 20 — Teil 6

> Als Abschluß unseres Kurses beschäftigen wir uns mit Interruptmechanismus und Betriebssystem des Volkscomputers. Damit haben wir in den sechs Teilen den VC 20 aus jeder Perspektive durchleuchtet und wirklich zum »gläsernen« Computer gemacht.

Ein Betriebssystem, so sagt ja bereits der Name, ist für die elementaren Funktionen des Computers wie zum Beispiel Bildschirmverwaltung, Tastaturabfrage, laden und speichern von Daten und vielem mehr verantwortlich. Natürlich ist auch im VC 20 solch ein Systemprogramm eingebaut: Es befindet sich im ROM zwischen Adresse $E429 und $FFFF, der restliche ROM-Bereich (von $C000 bis $E428) wird vom Basic-Interpreter beansprucht. Diese zwei Programmblöcke sind bei diesem Computer so miteinander verzahnt, daß kein Teil für sich alleine arbeiten kann.

## Was beim Einschalten alles geschieht

Als erstes möchte ich nun die Vorgänge beschreiben, die sich beim Einschalten des Systems abspielen.

Zunächst wird die Resetleitung der CPU von der Elektronik des Computers auf Low gezogen (genau das Gleiche geschieht übrigens beim Betätigen eines eventuell eingebauten Reset-Tasters), wodurch die wichtigsten Systemkomponenten (CPU, VIC und die Ein-/ Ausgabebausteine) in einen definierten Betriebszustand versetzt werden.

Danach sucht sich die 6502-Zentraleinheit aus den Speicherstellen $FFFC und $FFFD die Startadresse des Betriebssystems heraus und beginnt die Programmausführung an der dort abgespeicherten Stelle (beim VC 20 $FD22). Diese Vektoren sind hardwaremäßig in der CPU festgelegt worden und können daher nicht durch ein Programm geändert werden.

Die Einschaltroutine hat nun die verschiedensten Aufgaben zu bewältigen. Am wichtigsten ist zunächst die Initialisierung des Prozessorstacks, also des Stapelspeichers, der die Rücksprungadressen beim Befehl JSR verwaltet (damit der Computer aus den Unterprogrammen wieder ins Hauptprogramm zurückfindet).

Der nächste Schritt in der Reset-Routine ist die Modulabfrage, in der die Modulidentifikation abgefragt wird. Findet der VC 20 im Bereich $A004 bis $A009 die Zeichenfolge »aOCBM« (die den Bytes 41 30 C3 C2 und CD entspricht), so gibt das Betriebssystem die Kontrolle an das Modulprogramm ab. Auch hierbei spielen wieder Vektoren ein Rolle, denn die Startadresse des Moduls muß in den beiden Speicherstellen $A000 und $A001 abgelegt sein.

Mit Hilfe eines solchen Modulprogramms, das automatisch gestartet wird, kann man nun den Computer ganz nach seinen Wünschen gestalten. Dies kann zum Beispiel in Form einer Basic-Erweiterung geschehen, wie sie an dieser Stelle ja schon besprochen worden ist.

Findet die Einschaltroutine — um wieder zum Reset zurückzukommen — keine Modulmarkierung, so wird die Initialisierung ganz normal fortgesetzt. Diese besteht im wesentlichen aus vier Unterprogrammen, die auch in einem Autostartprogramm nacheinander aufgerufen werden sollten. Da ist als erstes eine Routine ($FD8D), die die Aufgabe hat, in der Zeropage bestimmte Startwerte einzutragen und den verfügbaren Speicher festzustellen. Dieser RAM-Test ist für den VC 20 besonders wichtig, denn auf diese Weise kann er erstens die Funktionsweise des Speichers überprüfen und zweitens die momentane Ausbauversion feststellen. Wird tatsächlich einmal ein Defekt in einer oder mehreren Speicherstellen des Grundversions-RAMs festgestellt, dann »hängt« sich das Betriebssystem in einer Endlosschleife auf, und der Bildschirm bleibt dunkel.

Nach dieser Prüfung, die bei voll ausgebautem Speicher einige Sekunden in Anspruch nimmt, werden in einer weiteren Unterroutine ($FD52) die Kernal-Vektoren im Bereich zwischen $0314 und $0355 installiert (einige dieser Zeiger werden wir später noch genauer kennenlernen). Zum Schluß müssen natürlich auch in den Registern der Peripheriebausteine die benötigten Werte abgespeichert werden. Dafür sind die zwei letzten Unterprogramme der Einschaltroutine zuständig. Das eine ($FDF9) initialisiert die I/O-Register, damit Interrupts und Tastaturoperationen stattfinden können, und das andere ($E518) kümmert sich um die Grundeinstellung des VIC.

Dies waren im wesentlichen die Schritte, die nach dem Einschalten des Computers ablaufen; damit ist nun das Betriebssystem einsatzbereit und gibt nun die Kontrolle an den Basic-Interpreter ($E378) ab. Der wiederum setzt als erstes die in Folge 3 angesprochenen Basic-Vektoren, damit die essentiellen Operationen (wie zum Beispiel die Umwandlung einer Zeile in Interpretertoken) über diese abgewickelt werden können.

Bevor die bekannte Einschaltmeldung (CBM BASIC..) auf dem Bildschirm ausgegeben wird, initialisiert der Interpreter den Basic-Teil der Zeropage und des Speichers nach seinen Bedürfnissen. Dabei werden zum Beispiel verschiedene Zeiger (Adresse 43, 44, 45, ...) gesetzt und der erste Verbindungszeiger im Programmspeicher gelöscht (daher kann ein Basic-Programm nach einem Reset nicht mehr gelistet werden).

## Unterbrechung? Ja, bitte!

Nachdem die Systemmeldung auf dem Bildschirm ausgegeben wurde, verzweigt die Interpreterroutine in die sogenannte Eingabewarteschleife ($C474), die wirja bereits in Folge 3 näher beleuchtet haben. Damit ist der Computer bereit, Anweisungen des Benutzers zu empfangen.

Soweit die Beschreibung der Resetroutine, die durch ein Signal an einem Prozessoreingang gestartet wurde. Auch die Interrupts, auf die ich genauer eingehen möchte, werden über die Hardware ausgelöst. Der Plural bei Interrupts verrät bereits, daß es mehrere — genauer gesagt sogar 3 — Unterbrechungen von dieser Sorte gibt.

Da ist zunächst der Systeminterrupt, der vom VC 20 alle 60steF Sekunde durchlaufen wird (ein Timer in dem 6522-Ausgabebaustein ist für dessen Auslösung verantwortlich). Durch diese Interruptanfrage — sie wird auch IRQ (Interrupt Request) genannt — wird die Zentraleinheit veranlaßt, das gerade laufende Programm zu unterbrechen, um in eine Abarbeitungsroutine zu verzweigen. Auch hierbei besorgt sich die CPU über den Hardwarevektor ($FFFE und $FFFF) die entsprechende Startadresse ($FF72).

Dort werden als erstes alle CPU-Register auf den Stack gerettet, denn die dort gespeicherten Werte werden ja später bei der Wiederaufnahme des regulären Programmablaufs benötigt. Danach verzweigt die Routine über einen eigenen Vektor (Interrupt-Vektor $0314,$0315) in das eigentliche Abarbeitungsunterprogramm (Adresse $EABF).

Hier wird zunächst die interne Uhr (TI) um eins hochgezählt und bei dieser Gelegenheit auch gleich der Zustand der STOP-Taste abgefragt. Ist diese gedrückt, dann setzt die Unterroutine ein Flag in der Zeropage, und der Interpreter unterbricht — nachdem der Interrupt zu Ende bearbeitet worden ist — das laufende Basic-Programm. Durch »verbiegen« des erwähnten Sprungvektors kann dieses Unterprogramm in der Abarbeitungsroutine so übersprungen werden, daß keine Abfrage der STOPTaste mehr stattfindet, womit bewirkt wird, daß man ein Basic-Programm nicht mehr auf normalem Wege anhalten kann (dieses nur als eine Programmschutzvariante).




Nun aber wieder zurück zu unserer Abarbeitungsroutine. Hier wird als nächstes der sogenannte Cursorblinkzähler, der bei jedem Interrupt um eins dekrementiert wird, abgefragt. Ist dieser auf Null, so wird der momentane Zustand des Cursors geändert; das heißt aus revers wird normal oder umgekehrt (auf diese Weise wird ein Blinken des Zeigers erreicht).

Abschließend wird — und das ist das Wichtigste an dem ganzen Interrupt — die Tastatur des Computers abgefragt. Drückt der Benutzer irgendeine Taste, so wandelt die Routine diesen Tastencode in den entsprechenden ASCII-Wert und speichert das Ergebnis im Tastaturpuffer ab. Dieser bleibt solange dort, bis ein Zeichen von der Tastatur angefordert wird. Das ist entweder im Direktmodus der Fall oder bei den Basic-Befehlen INPUT und GET (oder den entsprechenden Unterprogrammen im Betriebssystem).

Damit hat die Interrupt-Routine ihren Zweck erfüllt, und der VC 20 kann die Arbeit an dem eigentlichen (Basic-) Programm wieder aufnehmen. Vorher werden allerdings noch die CPU-Register wiederhergestellt (deren Inhalte befinden sich ja immer noch auf dem Stack) und dann gibt das Interrupt-Unterprogramm über den Befehl RTI (Return From Interrupt) die Kontrolle wieder an das eigentliche Hauptprogramm ab. Diese Einschnitte mittels Interrupt haben für den Benutzer den Vorteil, daß er sich nicht um die, in einem gewissen Zeitabstand immer wiederkehrenden, Tastaturabfragen zu kümmern braucht. Außerdem kann kein noch so kurzer Tastendruck verloren gehen, wie es der Fall wäre, wenn die Tastatur in unregelmäßigen, längeren Abständen abgefragt werden würde.

## Eingriff ins Eingemachte

Wie wir bereits gesehen haben, springt der Computer über einen Vektor ($0314-$0315) in die Bearbeitungsroutine ein. Dadurch können wirjetzt in den Ablauf eingreifen, indem wir dort zusätzliche Unterprogramme einbetten. Als Beispiel für solch einen Eingriff möchte ich nun eine Routine besprechen, die den regelmäßigen Interruptzyklus benützt, um die aktuelle Uhrzeit auf dem Bildschirm anzuzeigen. Dazu bedienen wir uns einer speziellen Eigenschaft des VIC, die es erlaubt, mehr als 23 Zeilen auf dem Bildschirm anzuzeigen. Mit Hilfe des Registers # 4 (Adresse 36867 beziehungsweise $9003) kann man die anzeigbare Zeilenzahl vergrößern oder verkleinern. Für unseren Zweck genügt es, die verfügbaren Zeilen auf 25 zu erhöhen. In diesen Zeilen wird dann später die Uhrzeit angezeigt werden. Mittels POKE 36867,50 wird diese Umschaltung realisiert. Meine Routine kann mit dem Lader (Listing 1) irgendwo im Speicher plaziert werden (das Programm gibt die günstigste Adresse vor). Den wichtigsten Teil der Initialisierungsroutine — also dem Unterprogramm, das den Interrupt-Vektor »verbiegt« — möchte ich kurz anhand von Listing 2 beschreiben. Dort wird gleich als erstes eine Unterroutine aufgerufen, die ein eventuell vorhandenes Basic-Programm im Speicher verschieben soll. Das hat seinen guten Grund, denn die zwei zusätzlichen Bildschirmzeilen nehmen, um ihre Zeichen ablegen zu können, den Anfang des Basic-Speichers in Beschlag, so daß ein dort stehendes Programm teilweise überschrieben werden würde. Diese Verschiebe-Routine ist so universell, daß sie auch für andere Anwendungen nützlich sein kann (um beispielsweise ein Basic-Programm zu verschieben, damit Platz für einen Grafikspeicher ist). Die Anzahl der zu verschiebenden Bytes ist, bei einer anderweitigen Verwendung, in die Additionsroutine in $210E einzusetzen.

Nachdem die 24. und 25. Zeile zugeschaltet worden ist, wird der Interruptvektor auf den Anfang unserer Uhrenroutine gestellt, damit sie beim nächsten Aufruf mit abgearbeitet wird. Bevor man diesen Zeiger jedoch verändert, muß man mittels des Befehls SEI dafür sorgen, daß zeitweise keine Interrupts mehr akzeptiert werden. Sonst könnte es passieren, daß die — zufällig gerade zu dieser Zeit ausgelöste — Interruptroutine ihren Vektor sucht, und wir sind gerade dabei, ihn zu verändern, wodurch der Computer eine falsche Adresse finden und damit abstürzen würde. Das ist auch der Grund, warum man niemals versuchen darf, Interrupt-Vektoren von Basic aus mit POKE-Befehlen zu verändern.

Der Maschinenbefehl SEI (Set Interrupt-disable Flag) setzt das entsprechende Flag im Statusregister der CPU. Wird nun ein IRQ ausgelöst, so testet die Zentraleinheit zuerst dieses Flag; ist es gesetzt, dann wird die Interruptanfrage ignoriert. Das Gegenstück dazu ist der Befehl CLI, der dieses Flag löscht, damit Interrupts wieder möglich werden.

## Interrupt auf Tastendruck

Ich habe ja eingangs bereits erwähnt, daß es auch andere Interrupts gibt — diesen wollen wir uns jetzt zuwenden. Wer wird es glauben, auch die RESTORE-Taste löst einen Interrupt aus. Über den Hardwarevektor in $FFFA und $FFFB bezieht die CPU die Anfangsadresse der NMI-Abarbeitungsroutine (NMI bedeutet »nicht maskierbarer Interrupt«). Dieser Interrupt unterscheidet sich von dem IRQ in der Weise, daß er nicht per Spezialbefehl abschaltbar ist. Die Abarbeitungsroutine ($FEAD), die wiederum über einen Vektor in $0318, $0319 angesprungen wird, prüft nun als erstes, ob sie etwa ein Modulprogramm unterbrochen hat. Ist dies der Fall, so verzweigt die Routine in die NMI-Bearbeitung des Modulprogramms (dazu ist in $A002, $A003 die entsprechende Startadresse anzugeben). Dadurch ist es für den Programmierer eines solchen Moduls möglich, alle Unterbrechungen, die durch das Drücken der RESTORE-Taste entstehen, abzublocken, womit natürlich auch ein gewisser Programmschutz gewährleistet ist.

Sollte ein solches Modulprogramm nicht vorhanden sein, so wird die NMI-Routine normal fortgesetzt. Als erstes wird dann die STOP-Taste des Computers abgefragt, denn ein Programmabbruch soll ja nur durch das Drücken der Tastenkombination RUN/STOP-RESTORE möglich sein. Wenn auch diese Klippe genommen ist, beginnt der eigentliche Warmstart des Computers, der die Vektoren neu setzt und die Zeropage ordnet (daher wird auch unser Uhrenprogramm nach dem Drücken dieser Tastenkombination abgeschaltet).

Natürlich kann auch der NMI für unsere Programme mißbraucht werden. Dazu muß nur wieder (wie soll es auch anders sein) der entsprechende Vektor geändert werden, so daß er auf ein eigenes Maschinenprogramm zeigt. In Folge 3 ist eine sehr kurze und effiziente Anwendung der RESTORE-Taste erläutert worden. Damals ging es darum, sich innerhalb von Hochkommas (") von den lästigen Cursor-Steuerzeichen zu befreien. Durch das Drücken der RESTORE-Taste, die dann quasi als zusätzliche Funktionstaste arbeitet, kann man also auch Aktionen auslösen.

## Aller guten Dinge sind drei

Der Vollständigkeit halber möchte ich jetzt auch noch den dritten Interrupttyp anführen, der allerdings nicht durch irgendwelche Signale in der Hardware ausgelöst wird. Ich spreche von dem Maschinenbefehl BRK. Dieser wird in der CPU wie ein Interrupt-Aufruf (IRQ) behandelt, und deshalb benutzt er auch den gleichen Hardwarevektor, nämlich $FFFE. Das Betriebssystem im VC 20 hingegen trifft eine Unterscheidung zwischen diesen beiden Interrupttypen, denn der Befehl BRK soll beim VC 20 einen Warmstart bewirken. Auch diese Abarbeitung wird (ich traue mich es schon nicht mehr zu sagen) über einen Vektor ($0316, $0317) geleitet. Damit bietet sich die Möglichkeit, dieses Kommando dazu zu benutzen, ein Unterprogramm über einen Ein-Byte-Befehl (!) aufzurufen. Durch die Angabe der Startadresse in diesem Vektor kann man jedes beliebige Unterprogramm adressieren und mit BRK aufrufen.

Soweit zu den Interrupts. Ich möchte Ihnen zum Schluß noch, da wir gerade beim Betriebssystem sind, einige sehr nützliche Unterprogramme aus dem Interpreter vorstellen. Diese Routinen können nämlich sehr gut in eigenen Maschinenprogrammen Verwendung finden, und dies spart enormen Platz- und Programmieraufwand.

## Nützliche Routinen im Betriebssystem

**Verschieberoutine ($C3B8)**: Genau diese wurde in meinem Beispielprogramm verwendet, um das eventuell im Speicher vorhandene Basic-Programm zu verschieben. Die Benutzung dieser Routine ist verhältnismäßig einfach. Die Anfangsadresse des zu verschiebenden Speicherbereichs muß in den beiden Zeropagespeicherstellen $5F und $60 abgelegt werden. Um das Ende zu markieren, vermerkt man die entsprechende Adresse plus 1 (!) in den Speicherstellen $5A und $5B. Schließlich ist auch noch die neue Anfangsadresse in $58 und $59 abzulegen. Auch hierbei ist darauf zu achten, daß eins dazuaddiert wird, denn die Routine ist dementsprechend konzipiert. Der Aufruf der Routine geschieht schließlich mit »JSR $C3B8«.

**Fehlermeldung ausgeben ($C437)**: Oftmals ist es nötig, eine Basic-Fehlermeldung auszugeben (zum Beispiel in einer Befehlserweiterung, in der ein Komma abzufragen ist). Wenn dieses nicht vorhanden ist oder sonst ein Fehler vorliegt, dann soll eine Fehlermeldung ausgedruckt werden. Alles, was man bei dieser Routine zu tun hat, ist die Eingabe der Fehlernummer ins X-Register. Alle möglichen Meldungen und die dazugehörigen Nummern sind in Tabelle 1 zu finden. Dann wird die Abarbeitungsroutine mit JMP $C437 angesprungen. Zu beachten ist, daß ein Maschinenprogramm auf diese Weise beendet wird (der Interpreter springt nämlich in die Eingabewarteschleife zurück). Möchte man nur eine Meldung ausgeben (ohne das Programm anzuhalten), so ist die Nachricht mit einer anderen Routine, die noch besprochen wird, zu erzeugen. Zwei oft benötigte Fehlermeldungen (Syntax- und Illegal Quantity Error) sind noch einfacher zu bekommen. Um den Syntax Error zu erzeugen springt man mit JMP $CF08 in eine Unterroutine ein, die bereits die Fehlernummer enthält (auf diese Weise spart der Interpreter Speicherplatz). Auch für den Illegal Quantity Error gibt es solch ein Unterprogramm: JMP $D248. Für beide Abkürzungen gilt im übrigen — dies noch als Ergänzung — das oben zum Programmabbruch gesagte.

**Programmzeilen neu ordnen ($C533)**: Dies ist eine der praktischsten Routinen, die mir im gesamten Basic-Interpreter untergekommen ist. Das kleine unscheinbare Unterprogramm kann mehr, als zunächst zu vermuten ist. Es ist wahrscheinlich jedem schon einmal passiert, daß plötzlich aus irgendeinem Grund ein verstümmeltes Basic-Programm im Speicher steht. Das kann durch falsches Laden vom Band oder auch durch unvorsichtiges POKEn im Basic-Speicher geschehen. Der Grund für diesen »Zeilensalat« ist eine Veränderung der Verbindungszeiger (Koppeladressen), die am Beginn jeder (Basic-) Programmzeile stehen, und die im Normalfall auf die Adresse der jeweils folgenden Zeile zeigen (siehe auch Folge 1 dieses Kurses). Das Unterprogramm ab $C533 hat nun die nützliche Eigenschaft, fast alle auf diese Weise beschädigten Programme wieder zu restaurieren. Man ruft es einfach von Basic aus mit SYS 53483 auf, und schon ist das Programm zumindest wieder LISTbar (jedenfalls in den meisten Fällen). Damit aber noch nicht genug. Bei dieser Gelegenheit stellt die Routine auch noch die Länge des Programmes fest und übergibt die Endadresse den Speicherstellen $22 und $23. Damit ist es möglich, die durch einen Reset oder durch NEW scheinbar verlorenen Programme völlig wiederherzustellen. Dazu ist lediglich der erste Verbindungszeiger zu rekonstruieren (das macht unsere Unterroutine), und das Programmende muß in den Speicherstellen $2D und $2E vermerkt werden. Die nachfolgende Programmzeile ist das kürzeste Rekonstruktionsprogramm, das mir bekannt ist. Ich habe es bereits in Folge 1 besprochen und möchte es in diesem Zusammenhang noch einmal erwähnen.
SYS 50483:POKE 46,PEEK(35): POKE 45,PEEK(781) + 2:CLR

Bevor diese Zeile eingegeben wird, muß man den Anfang des Basic-Programms im Speicher markieren, denn sonst wird es von der Routine nicht gefunden: POKE (Basic-Anfangsadresse) + 1,1.

Natürlich ist diese Routine auch im C 64 zu finden. Dort ist die Startadresse $A533.

**String ausgeben ($CB1E)**: Mit diesem Unterprogramm ist es in einfacher Weise möglich, Texte in einem Maschinenprogramm auszugeben. Dadurch entfallen die sonst nötigen langwierigen Druckschleifen, mit denen man sich sonst herumschlagen muß. Auch bei dieser Unterroutine ist die Handhabung wieder ganz einfach. Der auszugebende Text, der natürlich auch Sonderund Steuerzeichen enthalten darf, muß im ASCII-Format irgendwo im Speicher stehen. Das Textende muß mit einer Null markiert sein. Ist diese Voraussetzung erfüllt, braucht man nur noch den Akku mit dem Low-Byte, das Y-Register mit dem High-Byte der Anfangsadresse zu laden und das Unterprogramm mit JSR $CBlE aufzurufen: Schon steht der Text auf dem Bildschirm. Auch Fehlermeldungen können auf diese einfache Weise ausgegeben werden (die Möglichkeit hatte ich ja oben schon angekündigt). Die Adressen der einzelnen Fehlernachrichten sind Tabelle 1 zu entnehmen.

Es soll nicht verschwiegen werden, daß es in seltenen Fällen zu einem Problem kommen kann: Weil dieses Unterprogramm auf String-Basis arbeitet, wird der Text als Variable zwischengespeichert. Wurden die Zeiger $37 und $38 (dezimal 55, 56) verändert, so kommt es manchmal dazu, daß irgendwelche unsinnigen Zeichen, aber nicht der gewünschte Text ausgegeben werden. In solch einem Fall müssen die Zeichen konventionell, das heißt über die Kernalroutine $FFD2 ausgegeben werden.

## Nachlese

Zum Schluß möchte ich nochmals ein Thema aufgreifen, das ich schon einmal angesprochen hatte — ich spreche von dem Autostartprogramm aus Folge 1. Damals wurde ein Programm abgedruckt, das mir viele Leserzuschriften eingebracht hat. Einige berichteten mir, daß es bei ihnen nicht möglich gewesen sei, diese Routine ordnungsgemäß laufen zu lassen. Da dieses Programm bei mir tadellos arbeitet, kann ich mir die geschilderten Fehler nicht erklären. Dennoch möchte ich diese Thematik nochmals aufgreifen, denn es gab eine Reihe von Anfragen nach einer Version für andere Commodore-Computer.

Um möglichst allen Wünschen gerechtzu werden, erläutere ich nun eine neuartige, kürzere Methode, in der auf sämtliche Programmschutzmaßnahmen, wie zum Beispiel das Abschalten der RESTORE-Taste, verzichtet wurde.

Für diese selbststartenden Programme nutzen wir eine besondere Eigenschaft des Kassettenpuffers aus. Der ist nämlich in der Lage, einen Programmnamen mit einer Länge von bis zu 187 Zeichen zu speichern. Davon werden allerdings nur die bekannten 16 Zeichen auf dem Bildschirm angezeigt; der Rest bleibt im Verborgenen. Da der gesamte Inhalt des Kassettenpuffers als Vorspann zu jedem Programm abgespeichert wird, kann man aber tatsächlich einen sehr viel längeren Filenamen mit dem Programm übertragen. Der Trick ist nun folgender: Neben dem Programmnamen mit einer Länge von 16 Zeichen wird auch ein kleines Maschinenprogramm im Bandpuffer generiert. Dieses wird nach der Beendigung des Ladevorganges von dem geänderten Kernal INPUT-Vektor angesprungen (siehe dazu auch Folge 1). Die kleine Maschinenroutine macht nun nichts anderes, als diesen Zeiger auf seinen Ursprungswert zurückzustellen und den Tastaturpuffer mit den Zeichen LOAD (CR) und RUN (CR) zu füllen. Das ist im Prinzip nichts anderes, als wenn man über die Tastatur SHIFT RUN/STOP eingeben würde, nur mit dem Unterschied, daß dies hier automatisch geschieht.

Im einzelnen wird also Folgendes gemacht: Man generiert einen kurzen Vorspann (ohne Programm) auf Band. Dieser enthält lediglich den präparierten Filenamen. Nachdem dieser Vorspann geladen worden ist, verzweigt der Computer über den INPUT-Vektor in das sich im Bandpuffer befindliche Maschinenprogramm, das wiederum einen neuen Ladebefehl erzeugt, mit dem das eigentliche Programm nachgeladen und automatisch gestartet wird.

Dazu jetzt die einzelnen Schritte, mit denen man einen solchen Vorspann generieren kann:

1. Eingabe des Ladeprogramms (Listing 3)
2. Programm testen und abspeichern
3. Lader starten
4. Programmnamen eingeben
5. Die auf dem Bildschirm ausgedruckten Zeilen nacheinander mit RETURN ausführen
6. Vorspann abspeichern
7. Wenn auf dem Bildschirm »SEARCHING« erscheint, muß der beginnende Ladevorgang mit der STOP-Taste abgebrochen werden
8. Hauptprogramm nachladen und abspeichern

Listing 4 zeigt das kleine Maschinenprogramm aus den DATA-Zeilen 360 bis 380 des Basic-Laders im Assembler-Format. Wer den C 64 dazu bringen will, das Gleiche zu tun, den möchte ich auf die REM-Zeilen am Ende des Programms aufmerksam machen, in denen die nötigen Änderungen beschrieben sind.

Zwei Anmerkungen wären zu dieser Methode noch zu machen:

Erstens: Die demonstrierte Autostartroutine funktioniert nur im Kassettenbetrieb. Die Floppystation nutzt diesen Puffer nicht, folglich funktioniert auch diese Methode nicht.

Zweitens: Da das Maschinenprogramm an einen festen Speicherplatz im Kassettenpuffer gebunden ist, muß auch der Filename eine feste Länge haben, denn an diesen schließt sich die Maschinenroutine an. Daher ergänzt der Lader den Programmnamen auf 16 Zeichen.

Mit diesem Ausflug in Betriebssystem und Interruptmechanismus ist der VC 20, so meine ich, genug durchleuchtet worden. Ich hoffe, daß Sie in den sechs Folgen dieses Kurses einen Eindruck von den Geschehnissen im Inneren Ihres Computers bekommen haben, so daß dieser Kurs seinen Namen auch wirklich verdient hat.

(Christoph Sauer/ev)

TODO ASIDE

PS. Uns interessiert Ihre Meinung zum Thema VC 20 im 64’er-Magazin im allgemeinen und zu diesem Kurs im besonderen. Wie wär's, schreiben Sie uns eine Mitmachkarte?

# Großer Programmierwettbewerb

Gesucht wird ein Programm Ihrer Wahl. Es kann sich hierbei um Spiele, Anwendungen oder auch Utilities handeln. Nur eines ist zu beachten: Das gesuchte Programm darf beim Listen nicht mehr als eine Bildschirmseite einnehmen. Es darf also nicht länger als 25 Zeilen mit 40 Zeichen sein.

Schicken Sie uns Ihr Programm auf einem Datenträger mit einer ausführlichen Beschreibung. Und vergessen Sie auf keinen Fall Ihre komplette Anschrift anzugeben. Ihren Vorschlag senden Sie an:
Markt & Technik Verlag
Redaktion 64’er
Gesucht wird ...
Hans-Pinsel-Straße 2
8013 Haar bei München

# Vorschau

## Universelles Druckprogramm

Glückwunschkarten, Liebesbriefe und Briefköpfe drucken ist mit »Print Shop« kein Problem. Neben acht Schriftarten kann zwischen zwei Schriftgrößen gewählt werden. Mit einem Grafik-Editor können Sie, zu der Vielzahl der vorhandenen, eigene Bilder und Logos herstellen. Print Shop ist ein universelles Druckprogramm, das mit den meisten Druckern zusammenarbeitet.

## Netzgrafiken leicht gemacht

Wir können Ihnen ein Maschinenprogramm zum Abtippen anbieten, mit dem Sie auf einfache Weise mathematische Funktionen als dreidimensionale Netzgrafiken darstellen können. Das Programm zeichnet sich durch eine hohe Arbeitsgeschwindigkeit und eine elegante Parameterübergabe aus.

## 80-Zeichen-Karten

Welche 80-Zeichen-Karten gibt es, was leisten und kosten sie? Ein Test und eine Marktübersicht sollen Ihnen Klarheit verschaffen.

## Mailboxen durchleuchtet

Mailboxen schießen zur Zeit wie Pilze nach einem warmen Regen aus dem Boden. Man kann aus finanziellen Gründen fast nicht mehr alle selbst ausprobieren. Wir bringen deshalb eine Übersicht, bei welcher Mailbox es sich lohnt einmal reinzuschauen und bei welcher man der Post unnötige Einheiten schenkt.

## Wir sind ein Jahr alt

Mit der nächsten Ausgabe feiern wir unser einjähriges Bestehen. Als Geburtstagsgeschenk wird ein oft geäußerter Wunsch der Leser erfüllt: Wir bringen ein Jahresinhaltsverzeichnis. Auch ältere Ausgaben können beim Verlag noch nachbestellt werden. Was Sie noch alles in unserem zweiten Jahr erwartet, erfahren Sie in der nächsten Ausgabe.

## C 64 als Speicheroszilloskop

Mit einer Platine von Print Technik können Sie Ihren C 64 zu einem Speicheroszilloskop umfunktionieren. Die damit erzielbaren Meßergebnisse dürften für die Hobbyanwendung ausreichend sein. Der Bausatz ermöglicht Meßzeiten von 1 ms bis zu einigen Stunden.

## »Alte« Datasette am neuen C 16

Die am C 16 gegenüber VC 20/ C 64 geänderten Anschlüsse für Datasette und Joysticks sind ein Ärgernis für alle »Aufsteiger«, die vom VC 20 kamen und nun mit ihrem Zubehör nichts mehr anfangen können. Doch kein Problem ohne Lösung. Wir zeigen, wie man mit wenig Aufwand die »alte« Datasette an den C 16 anschließt. Und so ganz nebenbei erfahren Sie noch, wie man Basic-Programme beim C 16 ohne Variablenverlust nachladen kann.

## Textverarbeitung

Von vielen Textverarbeitungsprogrammen ist inzwischen schon die x-te Version am Markt. Ein Grund für uns, Ihnen mit einer Marktübersicht die Kaufentscheidung zu erleichtern. Wir testen Textprogramme für 80-Zeichen-Karten. Lohnt sich die Anschaffung?

## Außerdem...

- lehrreiche Kurse für Anfänger und Profis
- zahlreiche Listings zum Abtippen, zum Beispiel Hypra-Load perfekt, eine Hardcopyroutine als Einzeiler, eine ideale Basic-Erweiterung etc.
- und wieder viele Tips & Tricks für VC 20, C 16 und C 64

